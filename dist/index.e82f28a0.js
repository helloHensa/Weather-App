// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"4FFYD":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "207a8fdfe82f28a0";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws;
    try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        if (e.message) console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"dV6cC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _bootstrap = require("bootstrap");
var _cloudsSunSunnyIconSvg = require("../Icons/clouds_sun_sunny_icon.svg");
var _cloudsSunSunnyIconSvgDefault = parcelHelpers.interopDefault(_cloudsSunSunnyIconSvg);
var _auto = require("chart.js/auto");
var _autoDefault = parcelHelpers.interopDefault(_auto);
var _dateFns = require("date-fns");
var _compromise = require("compromise");
var _compromiseDefault = parcelHelpers.interopDefault(_compromise);
let hoursContainer = document.getElementById("hourly");
let hoursRainContainer = document.getElementById("hourlyRain");
let daysContainer = document.getElementById("daily");
let graph = document.getElementById("mychart");
let currentTemp = document.getElementById("currentTemp");
let currMax = document.getElementById("currMax");
let currMin = document.getElementById("currMin");
let currFeels = document.getElementById("currFeels");
let currDate = document.getElementById("currDate");
let currImg = document.getElementById("currImg");
let locationName = document.getElementById("locationName");
const userLanguage = navigator.language || navigator.userLanguage;
const dateFormatter = new Intl.DateTimeFormat(userLanguage, {
    weekday: "long"
});
const dateFormatterShort = new Intl.DateTimeFormat(userLanguage, {
    weekday: "short"
});
function mapWeatherIcon(iconCode) {
    const iconMapping = {
        "01d": "bi-sun",
        "01n": "bi-moon",
        "02d": "bi-cloud-sun",
        "02n": "bi-cloud-moon",
        "03d": "bi-cloud",
        "03n": "bi-cloud",
        "04d": "bi-cloudy",
        "04n": "bi-cloudy",
        "09d": "bi-cloud-drizzle",
        "09n": "bi-cloud-drizzle",
        "10d": "bi-cloud-rain",
        "10n": "bi-cloud-rain",
        "11d": "bi-cloud-lightning",
        "11n": "bi-cloud-lightning",
        "13d": "bi-snow",
        "13n": "bi-snow",
        "50d": "bi-fog",
        "50n": "bi-fog"
    };
    const iconClass = iconMapping[iconCode];
    return iconClass || "bi-question";
}
const apiKey = "5a43b5303a0107f4cf1ced3ef800b104";
const gApi = "AIzaSyDQpOAjC1-a_uBJtkhoFXHPWum7D1UHUYs";
async function getCityCoordinates2(cityName) {
    const response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?address=${cityName}&key=${gApi}`);
    const city = await response.json();
    console.log(city);
    const lat = city.results[0].geometry.location.lat;
    const lon = city.results[0].geometry.location.lng;
    const address = city.results[0].formatted_address;
    return {
        lat,
        lon,
        address
    };
}
async function getWeatherData(city) {
    const coordinates = await getCityCoordinates2(city);
    const response = await fetch(`https://api.openweathermap.org/data/3.0/onecall?lat=${coordinates.lat}&lon=${coordinates.lon}&appid=${apiKey}&units=metric&lang=pl`);
    const data = await response.json();
    console.log(data);
    return data;
}
async function drawWeatherChart(city) {
    //taking weather data
    const weatherData = await getWeatherData(city);
    const address = await getCityCoordinates2(city);
    //Today and now
    const date = (0, _dateFns.fromUnixTime)(weatherData.current.dt);
    const dayOfWeek = dateFormatter.format(date);
    const hour = (0, _dateFns.format)(date, "HH:mm");
    console.log(`Dzie\u{144} tygodnia: ${dayOfWeek} ${hour}`);
    let degrees = weatherData.current.temp.toFixed(0);
    locationName.innerHTML = address.address + " ";
    currentTemp.innerHTML = degrees + "\xb0";
    currDate.innerHTML = dayOfWeek + ", " + hour;
    currMax.innerHTML = weatherData.daily[0].temp.max.toFixed(0) + "\xb0/";
    currMin.innerHTML = weatherData.daily[0].temp.min.toFixed(0) + "\xb0";
    currFeels.innerHTML = "Odczuwalna " + weatherData.daily[0].temp.min.toFixed(0) + "\xb0";
    //Current weather icon
    const currIconCode = weatherData.current.weather[0].icon;
    const iconClass = mapWeatherIcon(currIconCode);
    currImg.innerHTML = '<i class="' + iconClass + '"></i>';
    //Select all hourly entries
    const allHourEntries = weatherData.hourly;
    // preparing arrays for hourly forecast
    const hoursLabels = [];
    const temperaturesCelsius = [];
    const pop = [];
    const weatherIconCode = [];
    for(let i = 0; i < 25; i++){
        const entry = allHourEntries[i];
        const date = (0, _dateFns.fromUnixTime)(entry.dt);
        const hourLabel = (0, _dateFns.format)(date, "HH:mm");
        let temperature = entry.temp.toFixed(0);
        if (temperature == "-0") temperature = "0";
        hoursLabels.push(hourLabel);
        temperaturesCelsius.push(temperature);
        pop.push((entry.pop * 100).toFixed(0));
        weatherIconCode.push(entry.weather[0].icon);
    }
    //hourly forecast's hours and images
    for(let i = 0; i < temperaturesCelsius.length; i++){
        const iconClass = mapWeatherIcon(weatherIconCode[i]);
        let html = `<div class="col" id="towide">
    <div class="row" id="towideContent">
    <div class="col col-12">${hoursLabels[i]}</div>
    <div class="col col-12"><i class="iconSize bi ${iconClass}"></i></div>
    </div>`;
        hoursContainer.innerHTML += html;
    }
    //temparatue chart
    new (0, _autoDefault.default)(graph, {
        type: "line",
        data: {
            labels: hoursLabels,
            datasets: [
                {
                    label: "Temperature",
                    data: temperaturesCelsius,
                    borderWidth: 1,
                    lineTension: 0.3
                }
            ]
        },
        options: {
            plugins: {
                legend: {
                    display: false
                }
            },
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: "category",
                    labels: temperaturesCelsius.map((temp)=>temp + "\xb0"),
                    ticks: {
                        color: "white",
                        font: {
                            size: 20
                        }
                    },
                    grid: {
                        color: ""
                    },
                    position: "top"
                },
                y: {
                    display: false
                }
            }
        }
    });
    //probability of precipitation
    for(let i = 0; i < temperaturesCelsius.length; i++){
        let html = `<div class="col" id="towide ">
    <div class="row" id="towideContent">
    <div class="col col-12 d-flex flex-column"><i class="bi bi-droplet text-info"></i>${pop[i]}%</div>
    </div>`;
        hoursRainContainer.innerHTML += html;
    }
    //daily forecast
    const dailyDayOfWeek = [];
    const dailyDayOfWeekShort = [];
    const dailyIconCode = [];
    for(let i = 0; i < 7; i++){
        const date = (0, _dateFns.fromUnixTime)(weatherData.daily[i].dt);
        dailyDayOfWeek.push(dateFormatter.format(date));
        dailyDayOfWeek[0] = "Dzisiaj";
        dailyDayOfWeekShort.push(dateFormatterShort.format(date));
        dailyDayOfWeekShort[0] = "Dzi\u015B";
        const dayIconCode = weatherData.daily[i].weather[0].icon;
        const iconClass = mapWeatherIcon(dayIconCode);
        console.log(iconClass);
        dailyIconCode.push(iconClass);
        let maxTemp = weatherData.daily[i].temp.max.toFixed(0);
        let minTemp = weatherData.daily[i].temp.min.toFixed(0);
        if (maxTemp == "-0") maxTemp = "0";
        if (minTemp == "-0") minTemp = "0";
        let html = `
    
      <div class="row d-flex align-items-center d-flex flex-column flex-md-row mx-0 daycontainer">
        <div class="col-3 d-none d-md-flex align-items-start">
            <p class="my-1 ps-2">${dailyDayOfWeek[i]}</p>              
        </div>
        <div class="col-3 d-flex d-md-none align-items-start justify-content-center">
            <p class="my-1 ps-0">${dailyDayOfWeekShort[i]}</p>              
        </div>
        <div class="col-12 col-md-6">
          <div class="row">
            <div class="d-flex align-items-center justify-content-evenly">
              <h1 class="pt-1 ${dailyIconCode[i]}"></h1>                                   
              <p class="my-1 d-md-flex d-none">${weatherData.daily[i].weather[0].main}</p>
            </div>
          </div>           
        </div>
        <div class="col-3  d-flex justify-content-center"><span class="text-nowrap">${maxTemp}\xb0/${minTemp}\xb0</span></div>
      </div>
    `;
        daysContainer.innerHTML += html;
    }
}
drawWeatherChart("orzesze");

},{"bootstrap":"h36JB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","../Icons/clouds_sun_sunny_icon.svg":"b5QA5","chart.js/auto":"d8NN9","date-fns":"dU215","compromise":"iKhKr"}],"h36JB":[function(require,module,exports) {
/*!
  * Bootstrap v5.3.2 (https://getbootstrap.com/)
  * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Alert", ()=>Alert);
parcelHelpers.export(exports, "Button", ()=>Button);
parcelHelpers.export(exports, "Carousel", ()=>Carousel);
parcelHelpers.export(exports, "Collapse", ()=>Collapse);
parcelHelpers.export(exports, "Dropdown", ()=>Dropdown);
parcelHelpers.export(exports, "Modal", ()=>Modal);
parcelHelpers.export(exports, "Offcanvas", ()=>Offcanvas);
parcelHelpers.export(exports, "Popover", ()=>Popover);
parcelHelpers.export(exports, "ScrollSpy", ()=>ScrollSpy);
parcelHelpers.export(exports, "Tab", ()=>Tab);
parcelHelpers.export(exports, "Toast", ()=>Toast);
parcelHelpers.export(exports, "Tooltip", ()=>Tooltip);
var _core = require("@popperjs/core");
/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/data.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const elementMap = new Map();
const Data = {
    set (element, key, instance) {
        if (!elementMap.has(element)) elementMap.set(element, new Map());
        const instanceMap = elementMap.get(element);
        // make it clear we only want one instance per element
        // can be removed later when multiple key/instances are fine to be used
        if (!instanceMap.has(key) && instanceMap.size !== 0) {
            // eslint-disable-next-line no-console
            console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
            return;
        }
        instanceMap.set(key, instance);
    },
    get (element, key) {
        if (elementMap.has(element)) return elementMap.get(element).get(key) || null;
        return null;
    },
    remove (element, key) {
        if (!elementMap.has(element)) return;
        const instanceMap = elementMap.get(element);
        instanceMap.delete(key);
        // free up element references if there are no instances left for an element
        if (instanceMap.size === 0) elementMap.delete(element);
    }
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/index.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ const MAX_UID = 1000000;
const MILLISECONDS_MULTIPLIER = 1000;
const TRANSITION_END = "transitionend";
/**
 * Properly escape IDs selectors to handle weird IDs
 * @param {string} selector
 * @returns {string}
 */ const parseSelector = (selector)=>{
    if (selector && window.CSS && window.CSS.escape) // document.querySelector needs escaping to handle IDs (html5+) containing for instance /
    selector = selector.replace(/#([^\s"#']+)/g, (match, id)=>`#${CSS.escape(id)}`);
    return selector;
};
// Shout-out Angus Croll (https://goo.gl/pxwQGp)
const toType = (object)=>{
    if (object === null || object === undefined) return `${object}`;
    return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
};
/**
 * Public Util API
 */ const getUID = (prefix)=>{
    do prefix += Math.floor(Math.random() * MAX_UID);
    while (document.getElementById(prefix));
    return prefix;
};
const getTransitionDurationFromElement = (element)=>{
    if (!element) return 0;
    // Get transition-duration of the element
    let { transitionDuration, transitionDelay } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay);
    // Return 0 if element or transition duration is not found
    if (!floatTransitionDuration && !floatTransitionDelay) return 0;
    // If multiple durations are defined, take the first
    transitionDuration = transitionDuration.split(",")[0];
    transitionDelay = transitionDelay.split(",")[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};
const triggerTransitionEnd = (element)=>{
    element.dispatchEvent(new Event(TRANSITION_END));
};
const isElement = (object)=>{
    if (!object || typeof object !== "object") return false;
    if (typeof object.jquery !== "undefined") object = object[0];
    return typeof object.nodeType !== "undefined";
};
const getElement = (object)=>{
    // it's a jQuery object or a node element
    if (isElement(object)) return object.jquery ? object[0] : object;
    if (typeof object === "string" && object.length > 0) return document.querySelector(parseSelector(object));
    return null;
};
const isVisible = (element)=>{
    if (!isElement(element) || element.getClientRects().length === 0) return false;
    const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
    // Handle `details` element as its content may falsie appear visible when it is closed
    const closedDetails = element.closest("details:not([open])");
    if (!closedDetails) return elementIsVisible;
    if (closedDetails !== element) {
        const summary = element.closest("summary");
        if (summary && summary.parentNode !== closedDetails) return false;
        if (summary === null) return false;
    }
    return elementIsVisible;
};
const isDisabled = (element)=>{
    if (!element || element.nodeType !== Node.ELEMENT_NODE) return true;
    if (element.classList.contains("disabled")) return true;
    if (typeof element.disabled !== "undefined") return element.disabled;
    return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
};
const findShadowRoot = (element)=>{
    if (!document.documentElement.attachShadow) return null;
    // Can find the shadow root otherwise it'll return the document
    if (typeof element.getRootNode === "function") {
        const root = element.getRootNode();
        return root instanceof ShadowRoot ? root : null;
    }
    if (element instanceof ShadowRoot) return element;
    // when we don't find a shadow root
    if (!element.parentNode) return null;
    return findShadowRoot(element.parentNode);
};
const noop = ()=>{};
/**
 * Trick to restart an element's animation
 *
 * @param {HTMLElement} element
 * @return void
 *
 * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
 */ const reflow = (element)=>{
    element.offsetHeight; // eslint-disable-line no-unused-expressions
};
const getjQuery = ()=>{
    if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) return window.jQuery;
    return null;
};
const DOMContentLoadedCallbacks = [];
const onDOMContentLoaded = (callback)=>{
    if (document.readyState === "loading") {
        // add listener on the first call when the document is in loading state
        if (!DOMContentLoadedCallbacks.length) document.addEventListener("DOMContentLoaded", ()=>{
            for (const callback of DOMContentLoadedCallbacks)callback();
        });
        DOMContentLoadedCallbacks.push(callback);
    } else callback();
};
const isRTL = ()=>document.documentElement.dir === "rtl";
const defineJQueryPlugin = (plugin)=>{
    onDOMContentLoaded(()=>{
        const $ = getjQuery();
        /* istanbul ignore if */ if ($) {
            const name = plugin.NAME;
            const JQUERY_NO_CONFLICT = $.fn[name];
            $.fn[name] = plugin.jQueryInterface;
            $.fn[name].Constructor = plugin;
            $.fn[name].noConflict = ()=>{
                $.fn[name] = JQUERY_NO_CONFLICT;
                return plugin.jQueryInterface;
            };
        }
    });
};
const execute = (possibleCallback, args = [], defaultValue = possibleCallback)=>{
    return typeof possibleCallback === "function" ? possibleCallback(...args) : defaultValue;
};
const executeAfterTransition = (callback, transitionElement, waitForTransition = true)=>{
    if (!waitForTransition) {
        execute(callback);
        return;
    }
    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;
    const handler = ({ target })=>{
        if (target !== transitionElement) return;
        called = true;
        transitionElement.removeEventListener(TRANSITION_END, handler);
        execute(callback);
    };
    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(()=>{
        if (!called) triggerTransitionEnd(transitionElement);
    }, emulatedDuration);
};
/**
 * Return the previous/next element of a list.
 *
 * @param {array} list    The list of elements
 * @param activeElement   The active element
 * @param shouldGetNext   Choose to get next or previous element
 * @param isCycleAllowed
 * @return {Element|elem} The proper element
 */ const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed)=>{
    const listLength = list.length;
    let index = list.indexOf(activeElement);
    // if the element does not exist in the list return an element
    // depending on the direction and if cycle is allowed
    if (index === -1) return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
    index += shouldGetNext ? 1 : -1;
    if (isCycleAllowed) index = (index + listLength) % listLength;
    return list[Math.max(0, Math.min(index, listLength - 1))];
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/event-handler.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
const stripNameRegex = /\..*/;
const stripUidRegex = /::\d+$/;
const eventRegistry = {}; // Events storage
let uidEvent = 1;
const customEvents = {
    mouseenter: "mouseover",
    mouseleave: "mouseout"
};
const nativeEvents = new Set([
    "click",
    "dblclick",
    "mouseup",
    "mousedown",
    "contextmenu",
    "mousewheel",
    "DOMMouseScroll",
    "mouseover",
    "mouseout",
    "mousemove",
    "selectstart",
    "selectend",
    "keydown",
    "keypress",
    "keyup",
    "orientationchange",
    "touchstart",
    "touchmove",
    "touchend",
    "touchcancel",
    "pointerdown",
    "pointermove",
    "pointerup",
    "pointerleave",
    "pointercancel",
    "gesturestart",
    "gesturechange",
    "gestureend",
    "focus",
    "blur",
    "change",
    "reset",
    "select",
    "submit",
    "focusin",
    "focusout",
    "load",
    "unload",
    "beforeunload",
    "resize",
    "move",
    "DOMContentLoaded",
    "readystatechange",
    "error",
    "abort",
    "scroll"
]);
/**
 * Private methods
 */ function makeEventUid(element, uid) {
    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
}
function getElementEvents(element) {
    const uid = makeEventUid(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
}
function bootstrapHandler(element, fn) {
    return function handler(event) {
        hydrateObj(event, {
            delegateTarget: element
        });
        if (handler.oneOff) EventHandler.off(element, event.type, fn);
        return fn.apply(element, [
            event
        ]);
    };
}
function bootstrapDelegationHandler(element, selector, fn) {
    return function handler(event) {
        const domElements = element.querySelectorAll(selector);
        for(let { target } = event; target && target !== this; target = target.parentNode)for (const domElement of domElements){
            if (domElement !== target) continue;
            hydrateObj(event, {
                delegateTarget: target
            });
            if (handler.oneOff) EventHandler.off(element, event.type, selector, fn);
            return fn.apply(target, [
                event
            ]);
        }
    };
}
function findHandler(events, callable, delegationSelector = null) {
    return Object.values(events).find((event)=>event.callable === callable && event.delegationSelector === delegationSelector);
}
function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
    const isDelegated = typeof handler === "string";
    // TODO: tooltip passes `false` instead of selector, so we need to check
    const callable = isDelegated ? delegationFunction : handler || delegationFunction;
    let typeEvent = getTypeEvent(originalTypeEvent);
    if (!nativeEvents.has(typeEvent)) typeEvent = originalTypeEvent;
    return [
        isDelegated,
        callable,
        typeEvent
    ];
}
function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
    if (typeof originalTypeEvent !== "string" || !element) return;
    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
    // this prevents the handler from being dispatched the same way as mouseover or mouseout does
    if (originalTypeEvent in customEvents) {
        const wrapFunction = (fn)=>{
            return function(event) {
                if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) return fn.call(this, event);
            };
        };
        callable = wrapFunction(callable);
    }
    const events = getElementEvents(element);
    const handlers = events[typeEvent] || (events[typeEvent] = {});
    const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
    if (previousFunction) {
        previousFunction.oneOff = previousFunction.oneOff && oneOff;
        return;
    }
    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
    const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
    fn.delegationSelector = isDelegated ? handler : null;
    fn.callable = callable;
    fn.oneOff = oneOff;
    fn.uidEvent = uid;
    handlers[uid] = fn;
    element.addEventListener(typeEvent, fn, isDelegated);
}
function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    const fn = findHandler(events[typeEvent], handler, delegationSelector);
    if (!fn) return;
    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
    delete events[typeEvent][fn.uidEvent];
}
function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    const storeElementEvent = events[typeEvent] || {};
    for (const [handlerKey, event] of Object.entries(storeElementEvent))if (handlerKey.includes(namespace)) removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
}
function getTypeEvent(event) {
    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
    event = event.replace(stripNameRegex, "");
    return customEvents[event] || event;
}
const EventHandler = {
    on (element, event, handler, delegationFunction) {
        addHandler(element, event, handler, delegationFunction, false);
    },
    one (element, event, handler, delegationFunction) {
        addHandler(element, event, handler, delegationFunction, true);
    },
    off (element, originalTypeEvent, handler, delegationFunction) {
        if (typeof originalTypeEvent !== "string" || !element) return;
        const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
        const inNamespace = typeEvent !== originalTypeEvent;
        const events = getElementEvents(element);
        const storeElementEvent = events[typeEvent] || {};
        const isNamespace = originalTypeEvent.startsWith(".");
        if (typeof callable !== "undefined") {
            // Simplest case: handler is passed, remove that listener ONLY.
            if (!Object.keys(storeElementEvent).length) return;
            removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
            return;
        }
        if (isNamespace) for (const elementEvent of Object.keys(events))removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        for (const [keyHandlers, event] of Object.entries(storeElementEvent)){
            const handlerKey = keyHandlers.replace(stripUidRegex, "");
            if (!inNamespace || originalTypeEvent.includes(handlerKey)) removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
        }
    },
    trigger (element, event, args) {
        if (typeof event !== "string" || !element) return null;
        const $ = getjQuery();
        const typeEvent = getTypeEvent(event);
        const inNamespace = event !== typeEvent;
        let jQueryEvent = null;
        let bubbles = true;
        let nativeDispatch = true;
        let defaultPrevented = false;
        if (inNamespace && $) {
            jQueryEvent = $.Event(event, args);
            $(element).trigger(jQueryEvent);
            bubbles = !jQueryEvent.isPropagationStopped();
            nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
            defaultPrevented = jQueryEvent.isDefaultPrevented();
        }
        const evt = hydrateObj(new Event(event, {
            bubbles,
            cancelable: true
        }), args);
        if (defaultPrevented) evt.preventDefault();
        if (nativeDispatch) element.dispatchEvent(evt);
        if (evt.defaultPrevented && jQueryEvent) jQueryEvent.preventDefault();
        return evt;
    }
};
function hydrateObj(obj, meta = {}) {
    for (const [key, value] of Object.entries(meta))try {
        obj[key] = value;
    } catch (_unused) {
        Object.defineProperty(obj, key, {
            configurable: true,
            get () {
                return value;
            }
        });
    }
    return obj;
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/manipulator.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ function normalizeData(value) {
    if (value === "true") return true;
    if (value === "false") return false;
    if (value === Number(value).toString()) return Number(value);
    if (value === "" || value === "null") return null;
    if (typeof value !== "string") return value;
    try {
        return JSON.parse(decodeURIComponent(value));
    } catch (_unused) {
        return value;
    }
}
function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, (chr)=>`-${chr.toLowerCase()}`);
}
const Manipulator = {
    setDataAttribute (element, key, value) {
        element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
    },
    removeDataAttribute (element, key) {
        element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
    },
    getDataAttributes (element) {
        if (!element) return {};
        const attributes = {};
        const bsKeys = Object.keys(element.dataset).filter((key)=>key.startsWith("bs") && !key.startsWith("bsConfig"));
        for (const key of bsKeys){
            let pureKey = key.replace(/^bs/, "");
            pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
            attributes[pureKey] = normalizeData(element.dataset[key]);
        }
        return attributes;
    },
    getDataAttribute (element, key) {
        return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
    }
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/config.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Class definition
 */ class Config {
    // Getters
    static get Default() {
        return {};
    }
    static get DefaultType() {
        return {};
    }
    static get NAME() {
        throw new Error('You have to implement the static method "NAME", for each component!');
    }
    _getConfig(config) {
        config = this._mergeConfigObj(config);
        config = this._configAfterMerge(config);
        this._typeCheckConfig(config);
        return config;
    }
    _configAfterMerge(config) {
        return config;
    }
    _mergeConfigObj(config, element) {
        const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, "config") : {}; // try to parse
        return {
            ...this.constructor.Default,
            ...typeof jsonConfig === "object" ? jsonConfig : {},
            ...isElement(element) ? Manipulator.getDataAttributes(element) : {},
            ...typeof config === "object" ? config : {}
        };
    }
    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
        for (const [property, expectedTypes] of Object.entries(configTypes)){
            const value = config[property];
            const valueType = isElement(value) ? "element" : toType(value);
            if (!new RegExp(expectedTypes).test(valueType)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
        }
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap base-component.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const VERSION = "5.3.2";
/**
 * Class definition
 */ class BaseComponent extends Config {
    constructor(element, config){
        super();
        element = getElement(element);
        if (!element) return;
        this._element = element;
        this._config = this._getConfig(config);
        Data.set(this._element, this.constructor.DATA_KEY, this);
    }
    // Public
    dispose() {
        Data.remove(this._element, this.constructor.DATA_KEY);
        EventHandler.off(this._element, this.constructor.EVENT_KEY);
        for (const propertyName of Object.getOwnPropertyNames(this))this[propertyName] = null;
    }
    _queueCallback(callback, element, isAnimated = true) {
        executeAfterTransition(callback, element, isAnimated);
    }
    _getConfig(config) {
        config = this._mergeConfigObj(config, this._element);
        config = this._configAfterMerge(config);
        this._typeCheckConfig(config);
        return config;
    }
    // Static
    static getInstance(element) {
        return Data.get(getElement(element), this.DATA_KEY);
    }
    static getOrCreateInstance(element, config = {}) {
        return this.getInstance(element) || new this(element, typeof config === "object" ? config : null);
    }
    static get VERSION() {
        return VERSION;
    }
    static get DATA_KEY() {
        return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
        return `.${this.DATA_KEY}`;
    }
    static eventName(name) {
        return `${name}${this.EVENT_KEY}`;
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap dom/selector-engine.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ const getSelector = (element)=>{
    let selector = element.getAttribute("data-bs-target");
    if (!selector || selector === "#") {
        let hrefAttribute = element.getAttribute("href");
        // The only valid content that could double as a selector are IDs or classes,
        // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
        // `document.querySelector` will rightfully complain it is invalid.
        // See https://github.com/twbs/bootstrap/issues/32273
        if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) return null;
        // Just in case some CMS puts out a full URL with the anchor appended
        if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
        selector = hrefAttribute && hrefAttribute !== "#" ? parseSelector(hrefAttribute.trim()) : null;
    }
    return selector;
};
const SelectorEngine = {
    find (selector, element = document.documentElement) {
        return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
    },
    findOne (selector, element = document.documentElement) {
        return Element.prototype.querySelector.call(element, selector);
    },
    children (element, selector) {
        return [].concat(...element.children).filter((child)=>child.matches(selector));
    },
    parents (element, selector) {
        const parents = [];
        let ancestor = element.parentNode.closest(selector);
        while(ancestor){
            parents.push(ancestor);
            ancestor = ancestor.parentNode.closest(selector);
        }
        return parents;
    },
    prev (element, selector) {
        let previous = element.previousElementSibling;
        while(previous){
            if (previous.matches(selector)) return [
                previous
            ];
            previous = previous.previousElementSibling;
        }
        return [];
    },
    // TODO: this is now unused; remove later along with prev()
    next (element, selector) {
        let next = element.nextElementSibling;
        while(next){
            if (next.matches(selector)) return [
                next
            ];
            next = next.nextElementSibling;
        }
        return [];
    },
    focusableChildren (element) {
        const focusables = [
            "a",
            "button",
            "input",
            "textarea",
            "select",
            "details",
            "[tabindex]",
            '[contenteditable="true"]'
        ].map((selector)=>`${selector}:not([tabindex^="-"])`).join(",");
        return this.find(focusables, element).filter((el)=>!isDisabled(el) && isVisible(el));
    },
    getSelectorFromElement (element) {
        const selector = getSelector(element);
        if (selector) return SelectorEngine.findOne(selector) ? selector : null;
        return null;
    },
    getElementFromSelector (element) {
        const selector = getSelector(element);
        return selector ? SelectorEngine.findOne(selector) : null;
    },
    getMultipleElementsFromSelector (element) {
        const selector = getSelector(element);
        return selector ? SelectorEngine.find(selector) : [];
    }
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/component-functions.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ const enableDismissTrigger = (component, method = "hide")=>{
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
        if ([
            "A",
            "AREA"
        ].includes(this.tagName)) event.preventDefault();
        if (isDisabled(this)) return;
        const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
        const instance = component.getOrCreateInstance(target);
        // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method
        instance[method]();
    });
};
/**
 * --------------------------------------------------------------------------
 * Bootstrap alert.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$f = "alert";
const DATA_KEY$a = "bs.alert";
const EVENT_KEY$b = `.${DATA_KEY$a}`;
const EVENT_CLOSE = `close${EVENT_KEY$b}`;
const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
const CLASS_NAME_FADE$5 = "fade";
const CLASS_NAME_SHOW$8 = "show";
/**
 * Class definition
 */ class Alert extends BaseComponent {
    // Getters
    static get NAME() {
        return NAME$f;
    }
    // Public
    close() {
        const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
        if (closeEvent.defaultPrevented) return;
        this._element.classList.remove(CLASS_NAME_SHOW$8);
        const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
        this._queueCallback(()=>this._destroyElement(), this._element, isAnimated);
    }
    // Private
    _destroyElement() {
        this._element.remove();
        EventHandler.trigger(this._element, EVENT_CLOSED);
        this.dispose();
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Alert.getOrCreateInstance(this);
            if (typeof config !== "string") return;
            if (data[config] === undefined || config.startsWith("_") || config === "constructor") throw new TypeError(`No method named "${config}"`);
            data[config](this);
        });
    }
}
/**
 * Data API implementation
 */ enableDismissTrigger(Alert, "close");
/**
 * jQuery
 */ defineJQueryPlugin(Alert);
/**
 * --------------------------------------------------------------------------
 * Bootstrap button.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$e = "button";
const DATA_KEY$9 = "bs.button";
const EVENT_KEY$a = `.${DATA_KEY$9}`;
const DATA_API_KEY$6 = ".data-api";
const CLASS_NAME_ACTIVE$3 = "active";
const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
/**
 * Class definition
 */ class Button extends BaseComponent {
    // Getters
    static get NAME() {
        return NAME$e;
    }
    // Public
    toggle() {
        // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
        this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Button.getOrCreateInstance(this);
            if (config === "toggle") data[config]();
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event)=>{
    event.preventDefault();
    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
    const data = Button.getOrCreateInstance(button);
    data.toggle();
});
/**
 * jQuery
 */ defineJQueryPlugin(Button);
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/swipe.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$d = "swipe";
const EVENT_KEY$9 = ".bs.swipe";
const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
const POINTER_TYPE_TOUCH = "touch";
const POINTER_TYPE_PEN = "pen";
const CLASS_NAME_POINTER_EVENT = "pointer-event";
const SWIPE_THRESHOLD = 40;
const Default$c = {
    endCallback: null,
    leftCallback: null,
    rightCallback: null
};
const DefaultType$c = {
    endCallback: "(function|null)",
    leftCallback: "(function|null)",
    rightCallback: "(function|null)"
};
/**
 * Class definition
 */ class Swipe extends Config {
    constructor(element, config){
        super();
        this._element = element;
        if (!element || !Swipe.isSupported()) return;
        this._config = this._getConfig(config);
        this._deltaX = 0;
        this._supportPointerEvents = Boolean(window.PointerEvent);
        this._initEvents();
    }
    // Getters
    static get Default() {
        return Default$c;
    }
    static get DefaultType() {
        return DefaultType$c;
    }
    static get NAME() {
        return NAME$d;
    }
    // Public
    dispose() {
        EventHandler.off(this._element, EVENT_KEY$9);
    }
    // Private
    _start(event) {
        if (!this._supportPointerEvents) {
            this._deltaX = event.touches[0].clientX;
            return;
        }
        if (this._eventIsPointerPenTouch(event)) this._deltaX = event.clientX;
    }
    _end(event) {
        if (this._eventIsPointerPenTouch(event)) this._deltaX = event.clientX - this._deltaX;
        this._handleSwipe();
        execute(this._config.endCallback);
    }
    _move(event) {
        this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
        const absDeltaX = Math.abs(this._deltaX);
        if (absDeltaX <= SWIPE_THRESHOLD) return;
        const direction = absDeltaX / this._deltaX;
        this._deltaX = 0;
        if (!direction) return;
        execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
    _initEvents() {
        if (this._supportPointerEvents) {
            EventHandler.on(this._element, EVENT_POINTERDOWN, (event)=>this._start(event));
            EventHandler.on(this._element, EVENT_POINTERUP, (event)=>this._end(event));
            this._element.classList.add(CLASS_NAME_POINTER_EVENT);
        } else {
            EventHandler.on(this._element, EVENT_TOUCHSTART, (event)=>this._start(event));
            EventHandler.on(this._element, EVENT_TOUCHMOVE, (event)=>this._move(event));
            EventHandler.on(this._element, EVENT_TOUCHEND, (event)=>this._end(event));
        }
    }
    _eventIsPointerPenTouch(event) {
        return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
    }
    // Static
    static isSupported() {
        return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap carousel.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$c = "carousel";
const DATA_KEY$8 = "bs.carousel";
const EVENT_KEY$8 = `.${DATA_KEY$8}`;
const DATA_API_KEY$5 = ".data-api";
const ARROW_LEFT_KEY$1 = "ArrowLeft";
const ARROW_RIGHT_KEY$1 = "ArrowRight";
const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch
const ORDER_NEXT = "next";
const ORDER_PREV = "prev";
const DIRECTION_LEFT = "left";
const DIRECTION_RIGHT = "right";
const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
const EVENT_SLID = `slid${EVENT_KEY$8}`;
const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
const CLASS_NAME_CAROUSEL = "carousel";
const CLASS_NAME_ACTIVE$2 = "active";
const CLASS_NAME_SLIDE = "slide";
const CLASS_NAME_END = "carousel-item-end";
const CLASS_NAME_START = "carousel-item-start";
const CLASS_NAME_NEXT = "carousel-item-next";
const CLASS_NAME_PREV = "carousel-item-prev";
const SELECTOR_ACTIVE = ".active";
const SELECTOR_ITEM = ".carousel-item";
const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
const SELECTOR_ITEM_IMG = ".carousel-item img";
const SELECTOR_INDICATORS = ".carousel-indicators";
const SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
const KEY_TO_DIRECTION = {
    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
};
const Default$b = {
    interval: 5000,
    keyboard: true,
    pause: "hover",
    ride: false,
    touch: true,
    wrap: true
};
const DefaultType$b = {
    interval: "(number|boolean)",
    // TODO:v6 remove boolean support
    keyboard: "boolean",
    pause: "(string|boolean)",
    ride: "(boolean|string)",
    touch: "boolean",
    wrap: "boolean"
};
/**
 * Class definition
 */ class Carousel extends BaseComponent {
    constructor(element, config){
        super(element, config);
        this._interval = null;
        this._activeElement = null;
        this._isSliding = false;
        this.touchTimeout = null;
        this._swipeHelper = null;
        this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
        this._addEventListeners();
        if (this._config.ride === CLASS_NAME_CAROUSEL) this.cycle();
    }
    // Getters
    static get Default() {
        return Default$b;
    }
    static get DefaultType() {
        return DefaultType$b;
    }
    static get NAME() {
        return NAME$c;
    }
    // Public
    next() {
        this._slide(ORDER_NEXT);
    }
    nextWhenVisible() {
        // FIXME TODO use `document.visibilityState`
        // Don't call next when the page isn't visible
        // or the carousel or its parent isn't visible
        if (!document.hidden && isVisible(this._element)) this.next();
    }
    prev() {
        this._slide(ORDER_PREV);
    }
    pause() {
        if (this._isSliding) triggerTransitionEnd(this._element);
        this._clearInterval();
    }
    cycle() {
        this._clearInterval();
        this._updateInterval();
        this._interval = setInterval(()=>this.nextWhenVisible(), this._config.interval);
    }
    _maybeEnableCycle() {
        if (!this._config.ride) return;
        if (this._isSliding) {
            EventHandler.one(this._element, EVENT_SLID, ()=>this.cycle());
            return;
        }
        this.cycle();
    }
    to(index) {
        const items = this._getItems();
        if (index > items.length - 1 || index < 0) return;
        if (this._isSliding) {
            EventHandler.one(this._element, EVENT_SLID, ()=>this.to(index));
            return;
        }
        const activeIndex = this._getItemIndex(this._getActive());
        if (activeIndex === index) return;
        const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
        this._slide(order, items[index]);
    }
    dispose() {
        if (this._swipeHelper) this._swipeHelper.dispose();
        super.dispose();
    }
    // Private
    _configAfterMerge(config) {
        config.defaultInterval = config.interval;
        return config;
    }
    _addEventListeners() {
        if (this._config.keyboard) EventHandler.on(this._element, EVENT_KEYDOWN$1, (event)=>this._keydown(event));
        if (this._config.pause === "hover") {
            EventHandler.on(this._element, EVENT_MOUSEENTER$1, ()=>this.pause());
            EventHandler.on(this._element, EVENT_MOUSELEAVE$1, ()=>this._maybeEnableCycle());
        }
        if (this._config.touch && Swipe.isSupported()) this._addTouchEventListeners();
    }
    _addTouchEventListeners() {
        for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element))EventHandler.on(img, EVENT_DRAG_START, (event)=>event.preventDefault());
        const endCallBack = ()=>{
            if (this._config.pause !== "hover") return;
            // If it's a touch-enabled device, mouseenter/leave are fired as
            // part of the mouse compatibility events on first tap - the carousel
            // would stop cycling until user tapped out of it;
            // here, we listen for touchend, explicitly pause the carousel
            // (as if it's the second time we tap on it, mouseenter compat event
            // is NOT fired) and after a timeout (to allow for mouse compatibility
            // events to fire) we explicitly restart cycling
            this.pause();
            if (this.touchTimeout) clearTimeout(this.touchTimeout);
            this.touchTimeout = setTimeout(()=>this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
        };
        const swipeConfig = {
            leftCallback: ()=>this._slide(this._directionToOrder(DIRECTION_LEFT)),
            rightCallback: ()=>this._slide(this._directionToOrder(DIRECTION_RIGHT)),
            endCallback: endCallBack
        };
        this._swipeHelper = new Swipe(this._element, swipeConfig);
    }
    _keydown(event) {
        if (/input|textarea/i.test(event.target.tagName)) return;
        const direction = KEY_TO_DIRECTION[event.key];
        if (direction) {
            event.preventDefault();
            this._slide(this._directionToOrder(direction));
        }
    }
    _getItemIndex(element) {
        return this._getItems().indexOf(element);
    }
    _setActiveIndicatorElement(index) {
        if (!this._indicatorsElement) return;
        const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
        activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
        activeIndicator.removeAttribute("aria-current");
        const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
        if (newActiveIndicator) {
            newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
            newActiveIndicator.setAttribute("aria-current", "true");
        }
    }
    _updateInterval() {
        const element = this._activeElement || this._getActive();
        if (!element) return;
        const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
        this._config.interval = elementInterval || this._config.defaultInterval;
    }
    _slide(order, element = null) {
        if (this._isSliding) return;
        const activeElement = this._getActive();
        const isNext = order === ORDER_NEXT;
        const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
        if (nextElement === activeElement) return;
        const nextElementIndex = this._getItemIndex(nextElement);
        const triggerEvent = (eventName)=>{
            return EventHandler.trigger(this._element, eventName, {
                relatedTarget: nextElement,
                direction: this._orderToDirection(order),
                from: this._getItemIndex(activeElement),
                to: nextElementIndex
            });
        };
        const slideEvent = triggerEvent(EVENT_SLIDE);
        if (slideEvent.defaultPrevented) return;
        if (!activeElement || !nextElement) // Some weirdness is happening, so we bail
        // TODO: change tests that use empty divs to avoid this check
        return;
        const isCycling = Boolean(this._interval);
        this.pause();
        this._isSliding = true;
        this._setActiveIndicatorElement(nextElementIndex);
        this._activeElement = nextElement;
        const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
        const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
        nextElement.classList.add(orderClassName);
        reflow(nextElement);
        activeElement.classList.add(directionalClassName);
        nextElement.classList.add(directionalClassName);
        const completeCallBack = ()=>{
            nextElement.classList.remove(directionalClassName, orderClassName);
            nextElement.classList.add(CLASS_NAME_ACTIVE$2);
            activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
            this._isSliding = false;
            triggerEvent(EVENT_SLID);
        };
        this._queueCallback(completeCallBack, activeElement, this._isAnimated());
        if (isCycling) this.cycle();
    }
    _isAnimated() {
        return this._element.classList.contains(CLASS_NAME_SLIDE);
    }
    _getActive() {
        return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
    }
    _getItems() {
        return SelectorEngine.find(SELECTOR_ITEM, this._element);
    }
    _clearInterval() {
        if (this._interval) {
            clearInterval(this._interval);
            this._interval = null;
        }
    }
    _directionToOrder(direction) {
        if (isRTL()) return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
        return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
    }
    _orderToDirection(order) {
        if (isRTL()) return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
        return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Carousel.getOrCreateInstance(this, config);
            if (typeof config === "number") {
                data.to(config);
                return;
            }
            if (typeof config === "string") {
                if (data[config] === undefined || config.startsWith("_") || config === "constructor") throw new TypeError(`No method named "${config}"`);
                data[config]();
            }
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) return;
    event.preventDefault();
    const carousel = Carousel.getOrCreateInstance(target);
    const slideIndex = this.getAttribute("data-bs-slide-to");
    if (slideIndex) {
        carousel.to(slideIndex);
        carousel._maybeEnableCycle();
        return;
    }
    if (Manipulator.getDataAttribute(this, "slide") === "next") {
        carousel.next();
        carousel._maybeEnableCycle();
        return;
    }
    carousel.prev();
    carousel._maybeEnableCycle();
});
EventHandler.on(window, EVENT_LOAD_DATA_API$3, ()=>{
    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
    for (const carousel of carousels)Carousel.getOrCreateInstance(carousel);
});
/**
 * jQuery
 */ defineJQueryPlugin(Carousel);
/**
 * --------------------------------------------------------------------------
 * Bootstrap collapse.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$b = "collapse";
const DATA_KEY$7 = "bs.collapse";
const EVENT_KEY$7 = `.${DATA_KEY$7}`;
const DATA_API_KEY$4 = ".data-api";
const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
const CLASS_NAME_SHOW$7 = "show";
const CLASS_NAME_COLLAPSE = "collapse";
const CLASS_NAME_COLLAPSING = "collapsing";
const CLASS_NAME_COLLAPSED = "collapsed";
const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
const CLASS_NAME_HORIZONTAL = "collapse-horizontal";
const WIDTH = "width";
const HEIGHT = "height";
const SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
const Default$a = {
    parent: null,
    toggle: true
};
const DefaultType$a = {
    parent: "(null|element)",
    toggle: "boolean"
};
/**
 * Class definition
 */ class Collapse extends BaseComponent {
    constructor(element, config){
        super(element, config);
        this._isTransitioning = false;
        this._triggerArray = [];
        const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
        for (const elem of toggleList){
            const selector = SelectorEngine.getSelectorFromElement(elem);
            const filterElement = SelectorEngine.find(selector).filter((foundElement)=>foundElement === this._element);
            if (selector !== null && filterElement.length) this._triggerArray.push(elem);
        }
        this._initializeChildren();
        if (!this._config.parent) this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
        if (this._config.toggle) this.toggle();
    }
    // Getters
    static get Default() {
        return Default$a;
    }
    static get DefaultType() {
        return DefaultType$a;
    }
    static get NAME() {
        return NAME$b;
    }
    // Public
    toggle() {
        if (this._isShown()) this.hide();
        else this.show();
    }
    show() {
        if (this._isTransitioning || this._isShown()) return;
        let activeChildren = [];
        // find active children
        if (this._config.parent) activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element)=>element !== this._element).map((element)=>Collapse.getOrCreateInstance(element, {
                toggle: false
            }));
        if (activeChildren.length && activeChildren[0]._isTransitioning) return;
        const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
        if (startEvent.defaultPrevented) return;
        for (const activeInstance of activeChildren)activeInstance.hide();
        const dimension = this._getDimension();
        this._element.classList.remove(CLASS_NAME_COLLAPSE);
        this._element.classList.add(CLASS_NAME_COLLAPSING);
        this._element.style[dimension] = 0;
        this._addAriaAndCollapsedClass(this._triggerArray, true);
        this._isTransitioning = true;
        const complete = ()=>{
            this._isTransitioning = false;
            this._element.classList.remove(CLASS_NAME_COLLAPSING);
            this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
            this._element.style[dimension] = "";
            EventHandler.trigger(this._element, EVENT_SHOWN$6);
        };
        const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        const scrollSize = `scroll${capitalizedDimension}`;
        this._queueCallback(complete, this._element, true);
        this._element.style[dimension] = `${this._element[scrollSize]}px`;
    }
    hide() {
        if (this._isTransitioning || !this._isShown()) return;
        const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
        if (startEvent.defaultPrevented) return;
        const dimension = this._getDimension();
        this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
        reflow(this._element);
        this._element.classList.add(CLASS_NAME_COLLAPSING);
        this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
        for (const trigger of this._triggerArray){
            const element = SelectorEngine.getElementFromSelector(trigger);
            if (element && !this._isShown(element)) this._addAriaAndCollapsedClass([
                trigger
            ], false);
        }
        this._isTransitioning = true;
        const complete = ()=>{
            this._isTransitioning = false;
            this._element.classList.remove(CLASS_NAME_COLLAPSING);
            this._element.classList.add(CLASS_NAME_COLLAPSE);
            EventHandler.trigger(this._element, EVENT_HIDDEN$6);
        };
        this._element.style[dimension] = "";
        this._queueCallback(complete, this._element, true);
    }
    _isShown(element = this._element) {
        return element.classList.contains(CLASS_NAME_SHOW$7);
    }
    // Private
    _configAfterMerge(config) {
        config.toggle = Boolean(config.toggle); // Coerce string values
        config.parent = getElement(config.parent);
        return config;
    }
    _getDimension() {
        return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }
    _initializeChildren() {
        if (!this._config.parent) return;
        const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
        for (const element of children){
            const selected = SelectorEngine.getElementFromSelector(element);
            if (selected) this._addAriaAndCollapsedClass([
                element
            ], this._isShown(selected));
        }
    }
    _getFirstLevelChildren(selector) {
        const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
        // remove children if greater depth
        return SelectorEngine.find(selector, this._config.parent).filter((element)=>!children.includes(element));
    }
    _addAriaAndCollapsedClass(triggerArray, isOpen) {
        if (!triggerArray.length) return;
        for (const element of triggerArray){
            element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
            element.setAttribute("aria-expanded", isOpen);
        }
    }
    // Static
    static jQueryInterface(config) {
        const _config = {};
        if (typeof config === "string" && /show|hide/.test(config)) _config.toggle = false;
        return this.each(function() {
            const data = Collapse.getOrCreateInstance(this, _config);
            if (typeof config === "string") {
                if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
                data[config]();
            }
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") event.preventDefault();
    for (const element of SelectorEngine.getMultipleElementsFromSelector(this))Collapse.getOrCreateInstance(element, {
        toggle: false
    }).toggle();
});
/**
 * jQuery
 */ defineJQueryPlugin(Collapse);
/**
 * --------------------------------------------------------------------------
 * Bootstrap dropdown.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$a = "dropdown";
const DATA_KEY$6 = "bs.dropdown";
const EVENT_KEY$6 = `.${DATA_KEY$6}`;
const DATA_API_KEY$3 = ".data-api";
const ESCAPE_KEY$2 = "Escape";
const TAB_KEY$1 = "Tab";
const ARROW_UP_KEY$1 = "ArrowUp";
const ARROW_DOWN_KEY$1 = "ArrowDown";
const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button
const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
const CLASS_NAME_SHOW$6 = "show";
const CLASS_NAME_DROPUP = "dropup";
const CLASS_NAME_DROPEND = "dropend";
const CLASS_NAME_DROPSTART = "dropstart";
const CLASS_NAME_DROPUP_CENTER = "dropup-center";
const CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
const SELECTOR_MENU = ".dropdown-menu";
const SELECTOR_NAVBAR = ".navbar";
const SELECTOR_NAVBAR_NAV = ".navbar-nav";
const SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
const PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
const PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
const PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
const PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
const PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
const PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
const PLACEMENT_TOPCENTER = "top";
const PLACEMENT_BOTTOMCENTER = "bottom";
const Default$9 = {
    autoClose: true,
    boundary: "clippingParents",
    display: "dynamic",
    offset: [
        0,
        2
    ],
    popperConfig: null,
    reference: "toggle"
};
const DefaultType$9 = {
    autoClose: "(boolean|string)",
    boundary: "(string|element)",
    display: "string",
    offset: "(array|string|function)",
    popperConfig: "(null|object|function)",
    reference: "(string|element|object)"
};
/**
 * Class definition
 */ class Dropdown extends BaseComponent {
    constructor(element, config){
        super(element, config);
        this._popper = null;
        this._parent = this._element.parentNode; // dropdown wrapper
        // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
        this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
        this._inNavbar = this._detectNavbar();
    }
    // Getters
    static get Default() {
        return Default$9;
    }
    static get DefaultType() {
        return DefaultType$9;
    }
    static get NAME() {
        return NAME$a;
    }
    // Public
    toggle() {
        return this._isShown() ? this.hide() : this.show();
    }
    show() {
        if (isDisabled(this._element) || this._isShown()) return;
        const relatedTarget = {
            relatedTarget: this._element
        };
        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
        if (showEvent.defaultPrevented) return;
        this._createPopper();
        // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
        if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) for (const element of [].concat(...document.body.children))EventHandler.on(element, "mouseover", noop);
        this._element.focus();
        this._element.setAttribute("aria-expanded", true);
        this._menu.classList.add(CLASS_NAME_SHOW$6);
        this._element.classList.add(CLASS_NAME_SHOW$6);
        EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
    }
    hide() {
        if (isDisabled(this._element) || !this._isShown()) return;
        const relatedTarget = {
            relatedTarget: this._element
        };
        this._completeHide(relatedTarget);
    }
    dispose() {
        if (this._popper) this._popper.destroy();
        super.dispose();
    }
    update() {
        this._inNavbar = this._detectNavbar();
        if (this._popper) this._popper.update();
    }
    // Private
    _completeHide(relatedTarget) {
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
        if (hideEvent.defaultPrevented) return;
        // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support
        if ("ontouchstart" in document.documentElement) for (const element of [].concat(...document.body.children))EventHandler.off(element, "mouseover", noop);
        if (this._popper) this._popper.destroy();
        this._menu.classList.remove(CLASS_NAME_SHOW$6);
        this._element.classList.remove(CLASS_NAME_SHOW$6);
        this._element.setAttribute("aria-expanded", "false");
        Manipulator.removeDataAttribute(this._menu, "popper");
        EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
    }
    _getConfig(config) {
        config = super._getConfig(config);
        if (typeof config.reference === "object" && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== "function") // Popper virtual elements require a getBoundingClientRect method
        throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
        return config;
    }
    _createPopper() {
        if (typeof _core === "undefined") throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
        let referenceElement = this._element;
        if (this._config.reference === "parent") referenceElement = this._parent;
        else if (isElement(this._config.reference)) referenceElement = getElement(this._config.reference);
        else if (typeof this._config.reference === "object") referenceElement = this._config.reference;
        const popperConfig = this._getPopperConfig();
        this._popper = _core.createPopper(referenceElement, this._menu, popperConfig);
    }
    _isShown() {
        return this._menu.classList.contains(CLASS_NAME_SHOW$6);
    }
    _getPlacement() {
        const parentDropdown = this._parent;
        if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) return PLACEMENT_RIGHT;
        if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) return PLACEMENT_LEFT;
        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) return PLACEMENT_TOPCENTER;
        if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) return PLACEMENT_BOTTOMCENTER;
        // We need to trim the value because custom properties can also include spaces
        const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
        return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
    _detectNavbar() {
        return this._element.closest(SELECTOR_NAVBAR) !== null;
    }
    _getOffset() {
        const { offset } = this._config;
        if (typeof offset === "string") return offset.split(",").map((value)=>Number.parseInt(value, 10));
        if (typeof offset === "function") return (popperData)=>offset(popperData, this._element);
        return offset;
    }
    _getPopperConfig() {
        const defaultBsPopperConfig = {
            placement: this._getPlacement(),
            modifiers: [
                {
                    name: "preventOverflow",
                    options: {
                        boundary: this._config.boundary
                    }
                },
                {
                    name: "offset",
                    options: {
                        offset: this._getOffset()
                    }
                }
            ]
        };
        // Disable Popper if we have a static display or Dropdown is in Navbar
        if (this._inNavbar || this._config.display === "static") {
            Manipulator.setDataAttribute(this._menu, "popper", "static"); // TODO: v6 remove
            defaultBsPopperConfig.modifiers = [
                {
                    name: "applyStyles",
                    enabled: false
                }
            ];
        }
        return {
            ...defaultBsPopperConfig,
            ...execute(this._config.popperConfig, [
                defaultBsPopperConfig
            ])
        };
    }
    _selectMenuItem({ key, target }) {
        const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element)=>isVisible(element));
        if (!items.length) return;
        // if target isn't included in items (e.g. when expanding the dropdown)
        // allow cycling to get the last item in case key equals ARROW_UP_KEY
        getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Dropdown.getOrCreateInstance(this, config);
            if (typeof config !== "string") return;
            if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
            data[config]();
        });
    }
    static clearMenus(event) {
        if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) return;
        const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
        for (const toggle of openToggles){
            const context = Dropdown.getInstance(toggle);
            if (!context || context._config.autoClose === false) continue;
            const composedPath = event.composedPath();
            const isMenuTarget = composedPath.includes(context._menu);
            if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) continue;
            // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu
            if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) continue;
            const relatedTarget = {
                relatedTarget: context._element
            };
            if (event.type === "click") relatedTarget.clickEvent = event;
            context._completeHide(relatedTarget);
        }
    }
    static dataApiKeydownHandler(event) {
        // If not an UP | DOWN | ESCAPE key => not a dropdown command
        // If input/textarea && if key is other than ESCAPE => not a dropdown command
        const isInput = /input|textarea/i.test(event.target.tagName);
        const isEscapeEvent = event.key === ESCAPE_KEY$2;
        const isUpOrDownEvent = [
            ARROW_UP_KEY$1,
            ARROW_DOWN_KEY$1
        ].includes(event.key);
        if (!isUpOrDownEvent && !isEscapeEvent) return;
        if (isInput && !isEscapeEvent) return;
        event.preventDefault();
        // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
        const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
        const instance = Dropdown.getOrCreateInstance(getToggleButton);
        if (isUpOrDownEvent) {
            event.stopPropagation();
            instance.show();
            instance._selectMenuItem(event);
            return;
        }
        if (instance._isShown()) {
            // else is escape and we check if it is shown
            event.stopPropagation();
            instance.hide();
            getToggleButton.focus();
        }
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
});
/**
 * jQuery
 */ defineJQueryPlugin(Dropdown);
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/backdrop.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$9 = "backdrop";
const CLASS_NAME_FADE$4 = "fade";
const CLASS_NAME_SHOW$5 = "show";
const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
const Default$8 = {
    className: "modal-backdrop",
    clickCallback: null,
    isAnimated: false,
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    rootElement: "body" // give the choice to place backdrop under different elements
};
const DefaultType$8 = {
    className: "string",
    clickCallback: "(function|null)",
    isAnimated: "boolean",
    isVisible: "boolean",
    rootElement: "(element|string)"
};
/**
 * Class definition
 */ class Backdrop extends Config {
    constructor(config){
        super();
        this._config = this._getConfig(config);
        this._isAppended = false;
        this._element = null;
    }
    // Getters
    static get Default() {
        return Default$8;
    }
    static get DefaultType() {
        return DefaultType$8;
    }
    static get NAME() {
        return NAME$9;
    }
    // Public
    show(callback) {
        if (!this._config.isVisible) {
            execute(callback);
            return;
        }
        this._append();
        const element = this._getElement();
        if (this._config.isAnimated) reflow(element);
        element.classList.add(CLASS_NAME_SHOW$5);
        this._emulateAnimation(()=>{
            execute(callback);
        });
    }
    hide(callback) {
        if (!this._config.isVisible) {
            execute(callback);
            return;
        }
        this._getElement().classList.remove(CLASS_NAME_SHOW$5);
        this._emulateAnimation(()=>{
            this.dispose();
            execute(callback);
        });
    }
    dispose() {
        if (!this._isAppended) return;
        EventHandler.off(this._element, EVENT_MOUSEDOWN);
        this._element.remove();
        this._isAppended = false;
    }
    // Private
    _getElement() {
        if (!this._element) {
            const backdrop = document.createElement("div");
            backdrop.className = this._config.className;
            if (this._config.isAnimated) backdrop.classList.add(CLASS_NAME_FADE$4);
            this._element = backdrop;
        }
        return this._element;
    }
    _configAfterMerge(config) {
        // use getElement() with the default "body" to get a fresh Element on each instantiation
        config.rootElement = getElement(config.rootElement);
        return config;
    }
    _append() {
        if (this._isAppended) return;
        const element = this._getElement();
        this._config.rootElement.append(element);
        EventHandler.on(element, EVENT_MOUSEDOWN, ()=>{
            execute(this._config.clickCallback);
        });
        this._isAppended = true;
    }
    _emulateAnimation(callback) {
        executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/focustrap.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$8 = "focustrap";
const DATA_KEY$5 = "bs.focustrap";
const EVENT_KEY$5 = `.${DATA_KEY$5}`;
const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
const TAB_KEY = "Tab";
const TAB_NAV_FORWARD = "forward";
const TAB_NAV_BACKWARD = "backward";
const Default$7 = {
    autofocus: true,
    trapElement: null // The element to trap focus inside of
};
const DefaultType$7 = {
    autofocus: "boolean",
    trapElement: "element"
};
/**
 * Class definition
 */ class FocusTrap extends Config {
    constructor(config){
        super();
        this._config = this._getConfig(config);
        this._isActive = false;
        this._lastTabNavDirection = null;
    }
    // Getters
    static get Default() {
        return Default$7;
    }
    static get DefaultType() {
        return DefaultType$7;
    }
    static get NAME() {
        return NAME$8;
    }
    // Public
    activate() {
        if (this._isActive) return;
        if (this._config.autofocus) this._config.trapElement.focus();
        EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop
        EventHandler.on(document, EVENT_FOCUSIN$2, (event)=>this._handleFocusin(event));
        EventHandler.on(document, EVENT_KEYDOWN_TAB, (event)=>this._handleKeydown(event));
        this._isActive = true;
    }
    deactivate() {
        if (!this._isActive) return;
        this._isActive = false;
        EventHandler.off(document, EVENT_KEY$5);
    }
    // Private
    _handleFocusin(event) {
        const { trapElement } = this._config;
        if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) return;
        const elements = SelectorEngine.focusableChildren(trapElement);
        if (elements.length === 0) trapElement.focus();
        else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) elements[elements.length - 1].focus();
        else elements[0].focus();
    }
    _handleKeydown(event) {
        if (event.key !== TAB_KEY) return;
        this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/scrollBar.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
const SELECTOR_STICKY_CONTENT = ".sticky-top";
const PROPERTY_PADDING = "padding-right";
const PROPERTY_MARGIN = "margin-right";
/**
 * Class definition
 */ class ScrollBarHelper {
    constructor(){
        this._element = document.body;
    }
    // Public
    getWidth() {
        // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
        const documentWidth = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - documentWidth);
    }
    hide() {
        const width = this.getWidth();
        this._disableOverFlow();
        // give padding to element to balance the hidden scrollbar width
        this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);
        // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth
        this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);
        this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue)=>calculatedValue - width);
    }
    reset() {
        this._resetElementAttributes(this._element, "overflow");
        this._resetElementAttributes(this._element, PROPERTY_PADDING);
        this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
        this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
    }
    isOverflowing() {
        return this.getWidth() > 0;
    }
    // Private
    _disableOverFlow() {
        this._saveInitialAttribute(this._element, "overflow");
        this._element.style.overflow = "hidden";
    }
    _setElementAttributes(selector, styleProperty, callback) {
        const scrollbarWidth = this.getWidth();
        const manipulationCallBack = (element)=>{
            if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) return;
            this._saveInitialAttribute(element, styleProperty);
            const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
            element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
        };
        this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _saveInitialAttribute(element, styleProperty) {
        const actualValue = element.style.getPropertyValue(styleProperty);
        if (actualValue) Manipulator.setDataAttribute(element, styleProperty, actualValue);
    }
    _resetElementAttributes(selector, styleProperty) {
        const manipulationCallBack = (element)=>{
            const value = Manipulator.getDataAttribute(element, styleProperty);
            // We only want to remove the property if the value is `null`; the value can also be zero
            if (value === null) {
                element.style.removeProperty(styleProperty);
                return;
            }
            Manipulator.removeDataAttribute(element, styleProperty);
            element.style.setProperty(styleProperty, value);
        };
        this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _applyManipulationCallback(selector, callBack) {
        if (isElement(selector)) {
            callBack(selector);
            return;
        }
        for (const sel of SelectorEngine.find(selector, this._element))callBack(sel);
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap modal.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$7 = "modal";
const DATA_KEY$4 = "bs.modal";
const EVENT_KEY$4 = `.${DATA_KEY$4}`;
const DATA_API_KEY$2 = ".data-api";
const ESCAPE_KEY$1 = "Escape";
const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
const CLASS_NAME_OPEN = "modal-open";
const CLASS_NAME_FADE$3 = "fade";
const CLASS_NAME_SHOW$4 = "show";
const CLASS_NAME_STATIC = "modal-static";
const OPEN_SELECTOR$1 = ".modal.show";
const SELECTOR_DIALOG = ".modal-dialog";
const SELECTOR_MODAL_BODY = ".modal-body";
const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
const Default$6 = {
    backdrop: true,
    focus: true,
    keyboard: true
};
const DefaultType$6 = {
    backdrop: "(boolean|string)",
    focus: "boolean",
    keyboard: "boolean"
};
/**
 * Class definition
 */ class Modal extends BaseComponent {
    constructor(element, config){
        super(element, config);
        this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
        this._backdrop = this._initializeBackDrop();
        this._focustrap = this._initializeFocusTrap();
        this._isShown = false;
        this._isTransitioning = false;
        this._scrollBar = new ScrollBarHelper();
        this._addEventListeners();
    }
    // Getters
    static get Default() {
        return Default$6;
    }
    static get DefaultType() {
        return DefaultType$6;
    }
    static get NAME() {
        return NAME$7;
    }
    // Public
    toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
        if (this._isShown || this._isTransitioning) return;
        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
            relatedTarget
        });
        if (showEvent.defaultPrevented) return;
        this._isShown = true;
        this._isTransitioning = true;
        this._scrollBar.hide();
        document.body.classList.add(CLASS_NAME_OPEN);
        this._adjustDialog();
        this._backdrop.show(()=>this._showElement(relatedTarget));
    }
    hide() {
        if (!this._isShown || this._isTransitioning) return;
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
        if (hideEvent.defaultPrevented) return;
        this._isShown = false;
        this._isTransitioning = true;
        this._focustrap.deactivate();
        this._element.classList.remove(CLASS_NAME_SHOW$4);
        this._queueCallback(()=>this._hideModal(), this._element, this._isAnimated());
    }
    dispose() {
        EventHandler.off(window, EVENT_KEY$4);
        EventHandler.off(this._dialog, EVENT_KEY$4);
        this._backdrop.dispose();
        this._focustrap.deactivate();
        super.dispose();
    }
    handleUpdate() {
        this._adjustDialog();
    }
    // Private
    _initializeBackDrop() {
        return new Backdrop({
            isVisible: Boolean(this._config.backdrop),
            // 'static' option will be translated to true, and booleans will keep their value,
            isAnimated: this._isAnimated()
        });
    }
    _initializeFocusTrap() {
        return new FocusTrap({
            trapElement: this._element
        });
    }
    _showElement(relatedTarget) {
        // try to append dynamic modal
        if (!document.body.contains(this._element)) document.body.append(this._element);
        this._element.style.display = "block";
        this._element.removeAttribute("aria-hidden");
        this._element.setAttribute("aria-modal", true);
        this._element.setAttribute("role", "dialog");
        this._element.scrollTop = 0;
        const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
        if (modalBody) modalBody.scrollTop = 0;
        reflow(this._element);
        this._element.classList.add(CLASS_NAME_SHOW$4);
        const transitionComplete = ()=>{
            if (this._config.focus) this._focustrap.activate();
            this._isTransitioning = false;
            EventHandler.trigger(this._element, EVENT_SHOWN$4, {
                relatedTarget
            });
        };
        this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
    }
    _addEventListeners() {
        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event)=>{
            if (event.key !== ESCAPE_KEY$1) return;
            if (this._config.keyboard) {
                this.hide();
                return;
            }
            this._triggerBackdropTransition();
        });
        EventHandler.on(window, EVENT_RESIZE$1, ()=>{
            if (this._isShown && !this._isTransitioning) this._adjustDialog();
        });
        EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event)=>{
            // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks
            EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2)=>{
                if (this._element !== event.target || this._element !== event2.target) return;
                if (this._config.backdrop === "static") {
                    this._triggerBackdropTransition();
                    return;
                }
                if (this._config.backdrop) this.hide();
            });
        });
    }
    _hideModal() {
        this._element.style.display = "none";
        this._element.setAttribute("aria-hidden", true);
        this._element.removeAttribute("aria-modal");
        this._element.removeAttribute("role");
        this._isTransitioning = false;
        this._backdrop.hide(()=>{
            document.body.classList.remove(CLASS_NAME_OPEN);
            this._resetAdjustments();
            this._scrollBar.reset();
            EventHandler.trigger(this._element, EVENT_HIDDEN$4);
        });
    }
    _isAnimated() {
        return this._element.classList.contains(CLASS_NAME_FADE$3);
    }
    _triggerBackdropTransition() {
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
        if (hideEvent.defaultPrevented) return;
        const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
        const initialOverflowY = this._element.style.overflowY;
        // return if the following background transition hasn't yet completed
        if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) return;
        if (!isModalOverflowing) this._element.style.overflowY = "hidden";
        this._element.classList.add(CLASS_NAME_STATIC);
        this._queueCallback(()=>{
            this._element.classList.remove(CLASS_NAME_STATIC);
            this._queueCallback(()=>{
                this._element.style.overflowY = initialOverflowY;
            }, this._dialog);
        }, this._dialog);
        this._element.focus();
    }
    /**
   * The following methods are used to handle overflowing modals
   */ _adjustDialog() {
        const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
        const scrollbarWidth = this._scrollBar.getWidth();
        const isBodyOverflowing = scrollbarWidth > 0;
        if (isBodyOverflowing && !isModalOverflowing) {
            const property = isRTL() ? "paddingLeft" : "paddingRight";
            this._element.style[property] = `${scrollbarWidth}px`;
        }
        if (!isBodyOverflowing && isModalOverflowing) {
            const property = isRTL() ? "paddingRight" : "paddingLeft";
            this._element.style[property] = `${scrollbarWidth}px`;
        }
    }
    _resetAdjustments() {
        this._element.style.paddingLeft = "";
        this._element.style.paddingRight = "";
    }
    // Static
    static jQueryInterface(config, relatedTarget) {
        return this.each(function() {
            const data = Modal.getOrCreateInstance(this, config);
            if (typeof config !== "string") return;
            if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
            data[config](relatedTarget);
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if ([
        "A",
        "AREA"
    ].includes(this.tagName)) event.preventDefault();
    EventHandler.one(target, EVENT_SHOW$4, (showEvent)=>{
        if (showEvent.defaultPrevented) // only register focus restorer if modal will actually get shown
        return;
        EventHandler.one(target, EVENT_HIDDEN$4, ()=>{
            if (isVisible(this)) this.focus();
        });
    });
    // avoid conflict when clicking modal toggler while another one is open
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
    if (alreadyOpen) Modal.getInstance(alreadyOpen).hide();
    const data = Modal.getOrCreateInstance(target);
    data.toggle(this);
});
enableDismissTrigger(Modal);
/**
 * jQuery
 */ defineJQueryPlugin(Modal);
/**
 * --------------------------------------------------------------------------
 * Bootstrap offcanvas.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$6 = "offcanvas";
const DATA_KEY$3 = "bs.offcanvas";
const EVENT_KEY$3 = `.${DATA_KEY$3}`;
const DATA_API_KEY$1 = ".data-api";
const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
const ESCAPE_KEY = "Escape";
const CLASS_NAME_SHOW$3 = "show";
const CLASS_NAME_SHOWING$1 = "showing";
const CLASS_NAME_HIDING = "hiding";
const CLASS_NAME_BACKDROP = "offcanvas-backdrop";
const OPEN_SELECTOR = ".offcanvas.show";
const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
const Default$5 = {
    backdrop: true,
    keyboard: true,
    scroll: false
};
const DefaultType$5 = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    scroll: "boolean"
};
/**
 * Class definition
 */ class Offcanvas extends BaseComponent {
    constructor(element, config){
        super(element, config);
        this._isShown = false;
        this._backdrop = this._initializeBackDrop();
        this._focustrap = this._initializeFocusTrap();
        this._addEventListeners();
    }
    // Getters
    static get Default() {
        return Default$5;
    }
    static get DefaultType() {
        return DefaultType$5;
    }
    static get NAME() {
        return NAME$6;
    }
    // Public
    toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
        if (this._isShown) return;
        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
            relatedTarget
        });
        if (showEvent.defaultPrevented) return;
        this._isShown = true;
        this._backdrop.show();
        if (!this._config.scroll) new ScrollBarHelper().hide();
        this._element.setAttribute("aria-modal", true);
        this._element.setAttribute("role", "dialog");
        this._element.classList.add(CLASS_NAME_SHOWING$1);
        const completeCallBack = ()=>{
            if (!this._config.scroll || this._config.backdrop) this._focustrap.activate();
            this._element.classList.add(CLASS_NAME_SHOW$3);
            this._element.classList.remove(CLASS_NAME_SHOWING$1);
            EventHandler.trigger(this._element, EVENT_SHOWN$3, {
                relatedTarget
            });
        };
        this._queueCallback(completeCallBack, this._element, true);
    }
    hide() {
        if (!this._isShown) return;
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
        if (hideEvent.defaultPrevented) return;
        this._focustrap.deactivate();
        this._element.blur();
        this._isShown = false;
        this._element.classList.add(CLASS_NAME_HIDING);
        this._backdrop.hide();
        const completeCallback = ()=>{
            this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
            this._element.removeAttribute("aria-modal");
            this._element.removeAttribute("role");
            if (!this._config.scroll) new ScrollBarHelper().reset();
            EventHandler.trigger(this._element, EVENT_HIDDEN$3);
        };
        this._queueCallback(completeCallback, this._element, true);
    }
    dispose() {
        this._backdrop.dispose();
        this._focustrap.deactivate();
        super.dispose();
    }
    // Private
    _initializeBackDrop() {
        const clickCallback = ()=>{
            if (this._config.backdrop === "static") {
                EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
                return;
            }
            this.hide();
        };
        // 'static' option will be translated to true, and booleans will keep their value
        const isVisible = Boolean(this._config.backdrop);
        return new Backdrop({
            className: CLASS_NAME_BACKDROP,
            isVisible,
            isAnimated: true,
            rootElement: this._element.parentNode,
            clickCallback: isVisible ? clickCallback : null
        });
    }
    _initializeFocusTrap() {
        return new FocusTrap({
            trapElement: this._element
        });
    }
    _addEventListeners() {
        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event)=>{
            if (event.key !== ESCAPE_KEY) return;
            if (this._config.keyboard) {
                this.hide();
                return;
            }
            EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
        });
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Offcanvas.getOrCreateInstance(this, config);
            if (typeof config !== "string") return;
            if (data[config] === undefined || config.startsWith("_") || config === "constructor") throw new TypeError(`No method named "${config}"`);
            data[config](this);
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if ([
        "A",
        "AREA"
    ].includes(this.tagName)) event.preventDefault();
    if (isDisabled(this)) return;
    EventHandler.one(target, EVENT_HIDDEN$3, ()=>{
        // focus on trigger when it is closed
        if (isVisible(this)) this.focus();
    });
    // avoid conflict when clicking a toggler of an offcanvas, while another is open
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
    if (alreadyOpen && alreadyOpen !== target) Offcanvas.getInstance(alreadyOpen).hide();
    const data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$2, ()=>{
    for (const selector of SelectorEngine.find(OPEN_SELECTOR))Offcanvas.getOrCreateInstance(selector).show();
});
EventHandler.on(window, EVENT_RESIZE, ()=>{
    for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]"))if (getComputedStyle(element).position !== "fixed") Offcanvas.getOrCreateInstance(element).hide();
});
enableDismissTrigger(Offcanvas);
/**
 * jQuery
 */ defineJQueryPlugin(Offcanvas);
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/sanitizer.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ // js-docs-start allow-list
const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
const DefaultAllowlist = {
    // Global attributes allowed on any supplied element below.
    "*": [
        "class",
        "dir",
        "id",
        "lang",
        "role",
        ARIA_ATTRIBUTE_PATTERN
    ],
    a: [
        "target",
        "href",
        "title",
        "rel"
    ],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: [
        "src",
        "srcset",
        "alt",
        "title",
        "width",
        "height"
    ],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
};
// js-docs-end allow-list
const uriAttributes = new Set([
    "background",
    "cite",
    "href",
    "itemtype",
    "longdesc",
    "poster",
    "src",
    "xlink:href"
]);
/**
 * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation
 * contexts.
 *
 * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38
 */ // eslint-disable-next-line unicorn/better-regex
const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
const allowedAttribute = (attribute, allowedAttributeList)=>{
    const attributeName = attribute.nodeName.toLowerCase();
    if (allowedAttributeList.includes(attributeName)) {
        if (uriAttributes.has(attributeName)) return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
        return true;
    }
    // Check if a regular expression validates the attribute.
    return allowedAttributeList.filter((attributeRegex)=>attributeRegex instanceof RegExp).some((regex)=>regex.test(attributeName));
};
function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
    if (!unsafeHtml.length) return unsafeHtml;
    if (sanitizeFunction && typeof sanitizeFunction === "function") return sanitizeFunction(unsafeHtml);
    const domParser = new window.DOMParser();
    const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
    const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
    for (const element of elements){
        const elementName = element.nodeName.toLowerCase();
        if (!Object.keys(allowList).includes(elementName)) {
            element.remove();
            continue;
        }
        const attributeList = [].concat(...element.attributes);
        const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
        for (const attribute of attributeList)if (!allowedAttribute(attribute, allowedAttributes)) element.removeAttribute(attribute.nodeName);
    }
    return createdDocument.body.innerHTML;
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap util/template-factory.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$5 = "TemplateFactory";
const Default$4 = {
    allowList: DefaultAllowlist,
    content: {},
    // { selector : text ,  selector2 : text2 , }
    extraClass: "",
    html: false,
    sanitize: true,
    sanitizeFn: null,
    template: "<div></div>"
};
const DefaultType$4 = {
    allowList: "object",
    content: "object",
    extraClass: "(string|function)",
    html: "boolean",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    template: "string"
};
const DefaultContentType = {
    entry: "(string|element|function|null)",
    selector: "(string|element)"
};
/**
 * Class definition
 */ class TemplateFactory extends Config {
    constructor(config){
        super();
        this._config = this._getConfig(config);
    }
    // Getters
    static get Default() {
        return Default$4;
    }
    static get DefaultType() {
        return DefaultType$4;
    }
    static get NAME() {
        return NAME$5;
    }
    // Public
    getContent() {
        return Object.values(this._config.content).map((config)=>this._resolvePossibleFunction(config)).filter(Boolean);
    }
    hasContent() {
        return this.getContent().length > 0;
    }
    changeContent(content) {
        this._checkContent(content);
        this._config.content = {
            ...this._config.content,
            ...content
        };
        return this;
    }
    toHtml() {
        const templateWrapper = document.createElement("div");
        templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
        for (const [selector, text] of Object.entries(this._config.content))this._setContent(templateWrapper, text, selector);
        const template = templateWrapper.children[0];
        const extraClass = this._resolvePossibleFunction(this._config.extraClass);
        if (extraClass) template.classList.add(...extraClass.split(" "));
        return template;
    }
    // Private
    _typeCheckConfig(config) {
        super._typeCheckConfig(config);
        this._checkContent(config.content);
    }
    _checkContent(arg) {
        for (const [selector, content] of Object.entries(arg))super._typeCheckConfig({
            selector,
            entry: content
        }, DefaultContentType);
    }
    _setContent(template, content, selector) {
        const templateElement = SelectorEngine.findOne(selector, template);
        if (!templateElement) return;
        content = this._resolvePossibleFunction(content);
        if (!content) {
            templateElement.remove();
            return;
        }
        if (isElement(content)) {
            this._putElementInTemplate(getElement(content), templateElement);
            return;
        }
        if (this._config.html) {
            templateElement.innerHTML = this._maybeSanitize(content);
            return;
        }
        templateElement.textContent = content;
    }
    _maybeSanitize(arg) {
        return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
    }
    _resolvePossibleFunction(arg) {
        return execute(arg, [
            this
        ]);
    }
    _putElementInTemplate(element, templateElement) {
        if (this._config.html) {
            templateElement.innerHTML = "";
            templateElement.append(element);
            return;
        }
        templateElement.textContent = element.textContent;
    }
}
/**
 * --------------------------------------------------------------------------
 * Bootstrap tooltip.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$4 = "tooltip";
const DISALLOWED_ATTRIBUTES = new Set([
    "sanitize",
    "allowList",
    "sanitizeFn"
]);
const CLASS_NAME_FADE$2 = "fade";
const CLASS_NAME_MODAL = "modal";
const CLASS_NAME_SHOW$2 = "show";
const SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
const EVENT_MODAL_HIDE = "hide.bs.modal";
const TRIGGER_HOVER = "hover";
const TRIGGER_FOCUS = "focus";
const TRIGGER_CLICK = "click";
const TRIGGER_MANUAL = "manual";
const EVENT_HIDE$2 = "hide";
const EVENT_HIDDEN$2 = "hidden";
const EVENT_SHOW$2 = "show";
const EVENT_SHOWN$2 = "shown";
const EVENT_INSERTED = "inserted";
const EVENT_CLICK$1 = "click";
const EVENT_FOCUSIN$1 = "focusin";
const EVENT_FOCUSOUT$1 = "focusout";
const EVENT_MOUSEENTER = "mouseenter";
const EVENT_MOUSELEAVE = "mouseleave";
const AttachmentMap = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: isRTL() ? "left" : "right",
    BOTTOM: "bottom",
    LEFT: isRTL() ? "right" : "left"
};
const Default$3 = {
    allowList: DefaultAllowlist,
    animation: true,
    boundary: "clippingParents",
    container: false,
    customClass: "",
    delay: 0,
    fallbackPlacements: [
        "top",
        "right",
        "bottom",
        "left"
    ],
    html: false,
    offset: [
        0,
        6
    ],
    placement: "top",
    popperConfig: null,
    sanitize: true,
    sanitizeFn: null,
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    title: "",
    trigger: "hover focus"
};
const DefaultType$3 = {
    allowList: "object",
    animation: "boolean",
    boundary: "(string|element)",
    container: "(string|element|boolean)",
    customClass: "(string|function)",
    delay: "(number|object)",
    fallbackPlacements: "array",
    html: "boolean",
    offset: "(array|string|function)",
    placement: "(string|function)",
    popperConfig: "(null|object|function)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    selector: "(string|boolean)",
    template: "string",
    title: "(string|element|function)",
    trigger: "string"
};
/**
 * Class definition
 */ class Tooltip extends BaseComponent {
    constructor(element, config){
        if (typeof _core === "undefined") throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
        super(element, config);
        // Private
        this._isEnabled = true;
        this._timeout = 0;
        this._isHovered = null;
        this._activeTrigger = {};
        this._popper = null;
        this._templateFactory = null;
        this._newContent = null;
        // Protected
        this.tip = null;
        this._setListeners();
        if (!this._config.selector) this._fixTitle();
    }
    // Getters
    static get Default() {
        return Default$3;
    }
    static get DefaultType() {
        return DefaultType$3;
    }
    static get NAME() {
        return NAME$4;
    }
    // Public
    enable() {
        this._isEnabled = true;
    }
    disable() {
        this._isEnabled = false;
    }
    toggleEnabled() {
        this._isEnabled = !this._isEnabled;
    }
    toggle() {
        if (!this._isEnabled) return;
        this._activeTrigger.click = !this._activeTrigger.click;
        if (this._isShown()) {
            this._leave();
            return;
        }
        this._enter();
    }
    dispose() {
        clearTimeout(this._timeout);
        EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
        if (this._element.getAttribute("data-bs-original-title")) this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"));
        this._disposePopper();
        super.dispose();
    }
    show() {
        if (this._element.style.display === "none") throw new Error("Please use show on visible elements");
        if (!(this._isWithContent() && this._isEnabled)) return;
        const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
        const shadowRoot = findShadowRoot(this._element);
        const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
        if (showEvent.defaultPrevented || !isInTheDom) return;
        // TODO: v6 remove this or make it optional
        this._disposePopper();
        const tip = this._getTipElement();
        this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
        const { container } = this._config;
        if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
            container.append(tip);
            EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
        }
        this._popper = this._createPopper(tip);
        tip.classList.add(CLASS_NAME_SHOW$2);
        // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
        if ("ontouchstart" in document.documentElement) for (const element of [].concat(...document.body.children))EventHandler.on(element, "mouseover", noop);
        const complete = ()=>{
            EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
            if (this._isHovered === false) this._leave();
            this._isHovered = false;
        };
        this._queueCallback(complete, this.tip, this._isAnimated());
    }
    hide() {
        if (!this._isShown()) return;
        const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
        if (hideEvent.defaultPrevented) return;
        const tip = this._getTipElement();
        tip.classList.remove(CLASS_NAME_SHOW$2);
        // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support
        if ("ontouchstart" in document.documentElement) for (const element of [].concat(...document.body.children))EventHandler.off(element, "mouseover", noop);
        this._activeTrigger[TRIGGER_CLICK] = false;
        this._activeTrigger[TRIGGER_FOCUS] = false;
        this._activeTrigger[TRIGGER_HOVER] = false;
        this._isHovered = null; // it is a trick to support manual triggering
        const complete = ()=>{
            if (this._isWithActiveTrigger()) return;
            if (!this._isHovered) this._disposePopper();
            this._element.removeAttribute("aria-describedby");
            EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
        };
        this._queueCallback(complete, this.tip, this._isAnimated());
    }
    update() {
        if (this._popper) this._popper.update();
    }
    // Protected
    _isWithContent() {
        return Boolean(this._getTitle());
    }
    _getTipElement() {
        if (!this.tip) this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
        return this.tip;
    }
    _createTipElement(content) {
        const tip = this._getTemplateFactory(content).toHtml();
        // TODO: remove this check in v6
        if (!tip) return null;
        tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
        // TODO: v6 the following can be achieved with CSS only
        tip.classList.add(`bs-${this.constructor.NAME}-auto`);
        const tipId = getUID(this.constructor.NAME).toString();
        tip.setAttribute("id", tipId);
        if (this._isAnimated()) tip.classList.add(CLASS_NAME_FADE$2);
        return tip;
    }
    setContent(content) {
        this._newContent = content;
        if (this._isShown()) {
            this._disposePopper();
            this.show();
        }
    }
    _getTemplateFactory(content) {
        if (this._templateFactory) this._templateFactory.changeContent(content);
        else this._templateFactory = new TemplateFactory({
            ...this._config,
            // the `content` var has to be after `this._config`
            // to override config.content in case of popover
            content,
            extraClass: this._resolvePossibleFunction(this._config.customClass)
        });
        return this._templateFactory;
    }
    _getContentForTemplate() {
        return {
            [SELECTOR_TOOLTIP_INNER]: this._getTitle()
        };
    }
    _getTitle() {
        return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
    }
    // Private
    _initializeOnDelegatedTarget(event) {
        return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
    }
    _isAnimated() {
        return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
    }
    _isShown() {
        return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
    }
    _createPopper(tip) {
        const placement = execute(this._config.placement, [
            this,
            tip,
            this._element
        ]);
        const attachment = AttachmentMap[placement.toUpperCase()];
        return _core.createPopper(this._element, tip, this._getPopperConfig(attachment));
    }
    _getOffset() {
        const { offset } = this._config;
        if (typeof offset === "string") return offset.split(",").map((value)=>Number.parseInt(value, 10));
        if (typeof offset === "function") return (popperData)=>offset(popperData, this._element);
        return offset;
    }
    _resolvePossibleFunction(arg) {
        return execute(arg, [
            this._element
        ]);
    }
    _getPopperConfig(attachment) {
        const defaultBsPopperConfig = {
            placement: attachment,
            modifiers: [
                {
                    name: "flip",
                    options: {
                        fallbackPlacements: this._config.fallbackPlacements
                    }
                },
                {
                    name: "offset",
                    options: {
                        offset: this._getOffset()
                    }
                },
                {
                    name: "preventOverflow",
                    options: {
                        boundary: this._config.boundary
                    }
                },
                {
                    name: "arrow",
                    options: {
                        element: `.${this.constructor.NAME}-arrow`
                    }
                },
                {
                    name: "preSetPlacement",
                    enabled: true,
                    phase: "beforeMain",
                    fn: (data)=>{
                        // Pre-set Popper's placement attribute in order to read the arrow sizes properly.
                        // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement
                        this._getTipElement().setAttribute("data-popper-placement", data.state.placement);
                    }
                }
            ]
        };
        return {
            ...defaultBsPopperConfig,
            ...execute(this._config.popperConfig, [
                defaultBsPopperConfig
            ])
        };
    }
    _setListeners() {
        const triggers = this._config.trigger.split(" ");
        for (const trigger of triggers){
            if (trigger === "click") EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event)=>{
                const context = this._initializeOnDelegatedTarget(event);
                context.toggle();
            });
            else if (trigger !== TRIGGER_MANUAL) {
                const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
                const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
                EventHandler.on(this._element, eventIn, this._config.selector, (event)=>{
                    const context = this._initializeOnDelegatedTarget(event);
                    context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
                    context._enter();
                });
                EventHandler.on(this._element, eventOut, this._config.selector, (event)=>{
                    const context = this._initializeOnDelegatedTarget(event);
                    context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
                    context._leave();
                });
            }
        }
        this._hideModalHandler = ()=>{
            if (this._element) this.hide();
        };
        EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    }
    _fixTitle() {
        const title = this._element.getAttribute("title");
        if (!title) return;
        if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) this._element.setAttribute("aria-label", title);
        this._element.setAttribute("data-bs-original-title", title); // DO NOT USE IT. Is only for backwards compatibility
        this._element.removeAttribute("title");
    }
    _enter() {
        if (this._isShown() || this._isHovered) {
            this._isHovered = true;
            return;
        }
        this._isHovered = true;
        this._setTimeout(()=>{
            if (this._isHovered) this.show();
        }, this._config.delay.show);
    }
    _leave() {
        if (this._isWithActiveTrigger()) return;
        this._isHovered = false;
        this._setTimeout(()=>{
            if (!this._isHovered) this.hide();
        }, this._config.delay.hide);
    }
    _setTimeout(handler, timeout) {
        clearTimeout(this._timeout);
        this._timeout = setTimeout(handler, timeout);
    }
    _isWithActiveTrigger() {
        return Object.values(this._activeTrigger).includes(true);
    }
    _getConfig(config) {
        const dataAttributes = Manipulator.getDataAttributes(this._element);
        for (const dataAttribute of Object.keys(dataAttributes))if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) delete dataAttributes[dataAttribute];
        config = {
            ...dataAttributes,
            ...typeof config === "object" && config ? config : {}
        };
        config = this._mergeConfigObj(config);
        config = this._configAfterMerge(config);
        this._typeCheckConfig(config);
        return config;
    }
    _configAfterMerge(config) {
        config.container = config.container === false ? document.body : getElement(config.container);
        if (typeof config.delay === "number") config.delay = {
            show: config.delay,
            hide: config.delay
        };
        if (typeof config.title === "number") config.title = config.title.toString();
        if (typeof config.content === "number") config.content = config.content.toString();
        return config;
    }
    _getDelegateConfig() {
        const config = {};
        for (const [key, value] of Object.entries(this._config))if (this.constructor.Default[key] !== value) config[key] = value;
        config.selector = false;
        config.trigger = "manual";
        // In the future can be replaced with:
        // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
        // `Object.fromEntries(keysWithDifferentValues)`
        return config;
    }
    _disposePopper() {
        if (this._popper) {
            this._popper.destroy();
            this._popper = null;
        }
        if (this.tip) {
            this.tip.remove();
            this.tip = null;
        }
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Tooltip.getOrCreateInstance(this, config);
            if (typeof config !== "string") return;
            if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
            data[config]();
        });
    }
}
/**
 * jQuery
 */ defineJQueryPlugin(Tooltip);
/**
 * --------------------------------------------------------------------------
 * Bootstrap popover.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$3 = "popover";
const SELECTOR_TITLE = ".popover-header";
const SELECTOR_CONTENT = ".popover-body";
const Default$2 = {
    ...Tooltip.Default,
    content: "",
    offset: [
        0,
        8
    ],
    placement: "right",
    template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    trigger: "click"
};
const DefaultType$2 = {
    ...Tooltip.DefaultType,
    content: "(null|string|element|function)"
};
/**
 * Class definition
 */ class Popover extends Tooltip {
    // Getters
    static get Default() {
        return Default$2;
    }
    static get DefaultType() {
        return DefaultType$2;
    }
    static get NAME() {
        return NAME$3;
    }
    // Overrides
    _isWithContent() {
        return this._getTitle() || this._getContent();
    }
    // Private
    _getContentForTemplate() {
        return {
            [SELECTOR_TITLE]: this._getTitle(),
            [SELECTOR_CONTENT]: this._getContent()
        };
    }
    _getContent() {
        return this._resolvePossibleFunction(this._config.content);
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Popover.getOrCreateInstance(this, config);
            if (typeof config !== "string") return;
            if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
            data[config]();
        });
    }
}
/**
 * jQuery
 */ defineJQueryPlugin(Popover);
/**
 * --------------------------------------------------------------------------
 * Bootstrap scrollspy.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$2 = "scrollspy";
const DATA_KEY$2 = "bs.scrollspy";
const EVENT_KEY$2 = `.${DATA_KEY$2}`;
const DATA_API_KEY = ".data-api";
const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
const EVENT_CLICK = `click${EVENT_KEY$2}`;
const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
const CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
const CLASS_NAME_ACTIVE$1 = "active";
const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
const SELECTOR_TARGET_LINKS = "[href]";
const SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
const SELECTOR_NAV_LINKS = ".nav-link";
const SELECTOR_NAV_ITEMS = ".nav-item";
const SELECTOR_LIST_ITEMS = ".list-group-item";
const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
const SELECTOR_DROPDOWN = ".dropdown";
const SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
const Default$1 = {
    offset: null,
    // TODO: v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "0px 0px -25%",
    smoothScroll: false,
    target: null,
    threshold: [
        0.1,
        0.5,
        1
    ]
};
const DefaultType$1 = {
    offset: "(number|null)",
    // TODO v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "string",
    smoothScroll: "boolean",
    target: "element",
    threshold: "array"
};
/**
 * Class definition
 */ class ScrollSpy extends BaseComponent {
    constructor(element, config){
        super(element, config);
        // this._element is the observablesContainer and config.target the menu links wrapper
        this._targetLinks = new Map();
        this._observableSections = new Map();
        this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
        this._activeTarget = null;
        this._observer = null;
        this._previousScrollData = {
            visibleEntryTop: 0,
            parentScrollTop: 0
        };
        this.refresh(); // initialize
    }
    // Getters
    static get Default() {
        return Default$1;
    }
    static get DefaultType() {
        return DefaultType$1;
    }
    static get NAME() {
        return NAME$2;
    }
    // Public
    refresh() {
        this._initializeTargetsAndObservables();
        this._maybeEnableSmoothScroll();
        if (this._observer) this._observer.disconnect();
        else this._observer = this._getNewObserver();
        for (const section of this._observableSections.values())this._observer.observe(section);
    }
    dispose() {
        this._observer.disconnect();
        super.dispose();
    }
    // Private
    _configAfterMerge(config) {
        // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case
        config.target = getElement(config.target) || document.body;
        // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only
        config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
        if (typeof config.threshold === "string") config.threshold = config.threshold.split(",").map((value)=>Number.parseFloat(value));
        return config;
    }
    _maybeEnableSmoothScroll() {
        if (!this._config.smoothScroll) return;
        // unregister any previous listeners
        EventHandler.off(this._config.target, EVENT_CLICK);
        EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event)=>{
            const observableSection = this._observableSections.get(event.target.hash);
            if (observableSection) {
                event.preventDefault();
                const root = this._rootElement || window;
                const height = observableSection.offsetTop - this._element.offsetTop;
                if (root.scrollTo) {
                    root.scrollTo({
                        top: height,
                        behavior: "smooth"
                    });
                    return;
                }
                // Chrome 60 doesn't support `scrollTo`
                root.scrollTop = height;
            }
        });
    }
    _getNewObserver() {
        const options = {
            root: this._rootElement,
            threshold: this._config.threshold,
            rootMargin: this._config.rootMargin
        };
        return new IntersectionObserver((entries)=>this._observerCallback(entries), options);
    }
    // The logic of selection
    _observerCallback(entries) {
        const targetElement = (entry)=>this._targetLinks.get(`#${entry.target.id}`);
        const activate = (entry)=>{
            this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
            this._process(targetElement(entry));
        };
        const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
        const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
        this._previousScrollData.parentScrollTop = parentScrollTop;
        for (const entry of entries){
            if (!entry.isIntersecting) {
                this._activeTarget = null;
                this._clearActiveClass(targetElement(entry));
                continue;
            }
            const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
            // if we are scrolling down, pick the bigger offsetTop
            if (userScrollsDown && entryIsLowerThanPrevious) {
                activate(entry);
                // if parent isn't scrolled, let's keep the first visible item, breaking the iteration
                if (!parentScrollTop) return;
                continue;
            }
            // if we are scrolling up, pick the smallest offsetTop
            if (!userScrollsDown && !entryIsLowerThanPrevious) activate(entry);
        }
    }
    _initializeTargetsAndObservables() {
        this._targetLinks = new Map();
        this._observableSections = new Map();
        const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
        for (const anchor of targetLinks){
            // ensure that the anchor has an id and is not disabled
            if (!anchor.hash || isDisabled(anchor)) continue;
            const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);
            // ensure that the observableSection exists & is visible
            if (isVisible(observableSection)) {
                this._targetLinks.set(decodeURI(anchor.hash), anchor);
                this._observableSections.set(anchor.hash, observableSection);
            }
        }
    }
    _process(target) {
        if (this._activeTarget === target) return;
        this._clearActiveClass(this._config.target);
        this._activeTarget = target;
        target.classList.add(CLASS_NAME_ACTIVE$1);
        this._activateParents(target);
        EventHandler.trigger(this._element, EVENT_ACTIVATE, {
            relatedTarget: target
        });
    }
    _activateParents(target) {
        // Activate dropdown parents
        if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
            SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
            return;
        }
        for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP))// Set triggered links parents as active
        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
        for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS))item.classList.add(CLASS_NAME_ACTIVE$1);
    }
    _clearActiveClass(parent) {
        parent.classList.remove(CLASS_NAME_ACTIVE$1);
        const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
        for (const node of activeNodes)node.classList.remove(CLASS_NAME_ACTIVE$1);
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = ScrollSpy.getOrCreateInstance(this, config);
            if (typeof config !== "string") return;
            if (data[config] === undefined || config.startsWith("_") || config === "constructor") throw new TypeError(`No method named "${config}"`);
            data[config]();
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(window, EVENT_LOAD_DATA_API$1, ()=>{
    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY))ScrollSpy.getOrCreateInstance(spy);
});
/**
 * jQuery
 */ defineJQueryPlugin(ScrollSpy);
/**
 * --------------------------------------------------------------------------
 * Bootstrap tab.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME$1 = "tab";
const DATA_KEY$1 = "bs.tab";
const EVENT_KEY$1 = `.${DATA_KEY$1}`;
const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
const ARROW_LEFT_KEY = "ArrowLeft";
const ARROW_RIGHT_KEY = "ArrowRight";
const ARROW_UP_KEY = "ArrowUp";
const ARROW_DOWN_KEY = "ArrowDown";
const HOME_KEY = "Home";
const END_KEY = "End";
const CLASS_NAME_ACTIVE = "active";
const CLASS_NAME_FADE$1 = "fade";
const CLASS_NAME_SHOW$1 = "show";
const CLASS_DROPDOWN = "dropdown";
const SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
const SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
const SELECTOR_OUTER = ".nav-item, .list-group-item";
const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; // TODO: could only be `tab` in v6
const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
/**
 * Class definition
 */ class Tab extends BaseComponent {
    constructor(element){
        super(element);
        this._parent = this._element.closest(SELECTOR_TAB_PANEL);
        if (!this._parent) return;
        // Set up initial aria attributes
        this._setInitialAttributes(this._parent, this._getChildren());
        EventHandler.on(this._element, EVENT_KEYDOWN, (event)=>this._keydown(event));
    }
    // Getters
    static get NAME() {
        return NAME$1;
    }
    // Public
    show() {
        // Shows this elem and deactivate the active sibling if exists
        const innerElem = this._element;
        if (this._elemIsActive(innerElem)) return;
        // Search for active tab on same parent to deactivate it
        const active = this._getActiveElem();
        const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
            relatedTarget: innerElem
        }) : null;
        const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
            relatedTarget: active
        });
        if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) return;
        this._deactivate(active, innerElem);
        this._activate(innerElem, active);
    }
    // Private
    _activate(element, relatedElem) {
        if (!element) return;
        element.classList.add(CLASS_NAME_ACTIVE);
        this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section
        const complete = ()=>{
            if (element.getAttribute("role") !== "tab") {
                element.classList.add(CLASS_NAME_SHOW$1);
                return;
            }
            element.removeAttribute("tabindex");
            element.setAttribute("aria-selected", true);
            this._toggleDropDown(element, true);
            EventHandler.trigger(element, EVENT_SHOWN$1, {
                relatedTarget: relatedElem
            });
        };
        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _deactivate(element, relatedElem) {
        if (!element) return;
        element.classList.remove(CLASS_NAME_ACTIVE);
        element.blur();
        this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too
        const complete = ()=>{
            if (element.getAttribute("role") !== "tab") {
                element.classList.remove(CLASS_NAME_SHOW$1);
                return;
            }
            element.setAttribute("aria-selected", false);
            element.setAttribute("tabindex", "-1");
            this._toggleDropDown(element, false);
            EventHandler.trigger(element, EVENT_HIDDEN$1, {
                relatedTarget: relatedElem
            });
        };
        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _keydown(event) {
        if (![
            ARROW_LEFT_KEY,
            ARROW_RIGHT_KEY,
            ARROW_UP_KEY,
            ARROW_DOWN_KEY,
            HOME_KEY,
            END_KEY
        ].includes(event.key)) return;
        event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page
        event.preventDefault();
        const children = this._getChildren().filter((element)=>!isDisabled(element));
        let nextActiveElement;
        if ([
            HOME_KEY,
            END_KEY
        ].includes(event.key)) nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
        else {
            const isNext = [
                ARROW_RIGHT_KEY,
                ARROW_DOWN_KEY
            ].includes(event.key);
            nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
        }
        if (nextActiveElement) {
            nextActiveElement.focus({
                preventScroll: true
            });
            Tab.getOrCreateInstance(nextActiveElement).show();
        }
    }
    _getChildren() {
        // collection of inner elements
        return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
    }
    _getActiveElem() {
        return this._getChildren().find((child)=>this._elemIsActive(child)) || null;
    }
    _setInitialAttributes(parent, children) {
        this._setAttributeIfNotExists(parent, "role", "tablist");
        for (const child of children)this._setInitialAttributesOnChild(child);
    }
    _setInitialAttributesOnChild(child) {
        child = this._getInnerElement(child);
        const isActive = this._elemIsActive(child);
        const outerElem = this._getOuterElement(child);
        child.setAttribute("aria-selected", isActive);
        if (outerElem !== child) this._setAttributeIfNotExists(outerElem, "role", "presentation");
        if (!isActive) child.setAttribute("tabindex", "-1");
        this._setAttributeIfNotExists(child, "role", "tab");
        // set attributes to the related panel too
        this._setInitialAttributesOnTargetPanel(child);
    }
    _setInitialAttributesOnTargetPanel(child) {
        const target = SelectorEngine.getElementFromSelector(child);
        if (!target) return;
        this._setAttributeIfNotExists(target, "role", "tabpanel");
        if (child.id) this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`);
    }
    _toggleDropDown(element, open) {
        const outerElem = this._getOuterElement(element);
        if (!outerElem.classList.contains(CLASS_DROPDOWN)) return;
        const toggle = (selector, className)=>{
            const element = SelectorEngine.findOne(selector, outerElem);
            if (element) element.classList.toggle(className, open);
        };
        toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
        toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
        outerElem.setAttribute("aria-expanded", open);
    }
    _setAttributeIfNotExists(element, attribute, value) {
        if (!element.hasAttribute(attribute)) element.setAttribute(attribute, value);
    }
    _elemIsActive(elem) {
        return elem.classList.contains(CLASS_NAME_ACTIVE);
    }
    // Try to get the inner element (usually the .nav-link)
    _getInnerElement(elem) {
        return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
    }
    // Try to get the outer element (usually the .nav-item)
    _getOuterElement(elem) {
        return elem.closest(SELECTOR_OUTER) || elem;
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Tab.getOrCreateInstance(this);
            if (typeof config !== "string") return;
            if (data[config] === undefined || config.startsWith("_") || config === "constructor") throw new TypeError(`No method named "${config}"`);
            data[config]();
        });
    }
}
/**
 * Data API implementation
 */ EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
    if ([
        "A",
        "AREA"
    ].includes(this.tagName)) event.preventDefault();
    if (isDisabled(this)) return;
    Tab.getOrCreateInstance(this).show();
});
/**
 * Initialize on focus
 */ EventHandler.on(window, EVENT_LOAD_DATA_API, ()=>{
    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE))Tab.getOrCreateInstance(element);
});
/**
 * jQuery
 */ defineJQueryPlugin(Tab);
/**
 * --------------------------------------------------------------------------
 * Bootstrap toast.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */ /**
 * Constants
 */ const NAME = "toast";
const DATA_KEY = "bs.toast";
const EVENT_KEY = `.${DATA_KEY}`;
const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
const EVENT_HIDE = `hide${EVENT_KEY}`;
const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
const EVENT_SHOW = `show${EVENT_KEY}`;
const EVENT_SHOWN = `shown${EVENT_KEY}`;
const CLASS_NAME_FADE = "fade";
const CLASS_NAME_HIDE = "hide"; // @deprecated - kept here only for backwards compatibility
const CLASS_NAME_SHOW = "show";
const CLASS_NAME_SHOWING = "showing";
const DefaultType = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number"
};
const Default = {
    animation: true,
    autohide: true,
    delay: 5000
};
/**
 * Class definition
 */ class Toast extends BaseComponent {
    constructor(element, config){
        super(element, config);
        this._timeout = null;
        this._hasMouseInteraction = false;
        this._hasKeyboardInteraction = false;
        this._setListeners();
    }
    // Getters
    static get Default() {
        return Default;
    }
    static get DefaultType() {
        return DefaultType;
    }
    static get NAME() {
        return NAME;
    }
    // Public
    show() {
        const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
        if (showEvent.defaultPrevented) return;
        this._clearTimeout();
        if (this._config.animation) this._element.classList.add(CLASS_NAME_FADE);
        const complete = ()=>{
            this._element.classList.remove(CLASS_NAME_SHOWING);
            EventHandler.trigger(this._element, EVENT_SHOWN);
            this._maybeScheduleHide();
        };
        this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated
        reflow(this._element);
        this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
        this._queueCallback(complete, this._element, this._config.animation);
    }
    hide() {
        if (!this.isShown()) return;
        const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
        if (hideEvent.defaultPrevented) return;
        const complete = ()=>{
            this._element.classList.add(CLASS_NAME_HIDE); // @deprecated
            this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
            EventHandler.trigger(this._element, EVENT_HIDDEN);
        };
        this._element.classList.add(CLASS_NAME_SHOWING);
        this._queueCallback(complete, this._element, this._config.animation);
    }
    dispose() {
        this._clearTimeout();
        if (this.isShown()) this._element.classList.remove(CLASS_NAME_SHOW);
        super.dispose();
    }
    isShown() {
        return this._element.classList.contains(CLASS_NAME_SHOW);
    }
    // Private
    _maybeScheduleHide() {
        if (!this._config.autohide) return;
        if (this._hasMouseInteraction || this._hasKeyboardInteraction) return;
        this._timeout = setTimeout(()=>{
            this.hide();
        }, this._config.delay);
    }
    _onInteraction(event, isInteracting) {
        switch(event.type){
            case "mouseover":
            case "mouseout":
                this._hasMouseInteraction = isInteracting;
                break;
            case "focusin":
            case "focusout":
                this._hasKeyboardInteraction = isInteracting;
                break;
        }
        if (isInteracting) {
            this._clearTimeout();
            return;
        }
        const nextElement = event.relatedTarget;
        if (this._element === nextElement || this._element.contains(nextElement)) return;
        this._maybeScheduleHide();
    }
    _setListeners() {
        EventHandler.on(this._element, EVENT_MOUSEOVER, (event)=>this._onInteraction(event, true));
        EventHandler.on(this._element, EVENT_MOUSEOUT, (event)=>this._onInteraction(event, false));
        EventHandler.on(this._element, EVENT_FOCUSIN, (event)=>this._onInteraction(event, true));
        EventHandler.on(this._element, EVENT_FOCUSOUT, (event)=>this._onInteraction(event, false));
    }
    _clearTimeout() {
        clearTimeout(this._timeout);
        this._timeout = null;
    }
    // Static
    static jQueryInterface(config) {
        return this.each(function() {
            const data = Toast.getOrCreateInstance(this, config);
            if (typeof config === "string") {
                if (typeof data[config] === "undefined") throw new TypeError(`No method named "${config}"`);
                data[config](this);
            }
        });
    }
}
/**
 * Data API implementation
 */ enableDismissTrigger(Toast);
/**
 * jQuery
 */ defineJQueryPlugin(Toast);

},{"@popperjs/core":"7unqC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7unqC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popperGenerator", ()=>(0, _createPopperJs.popperGenerator)) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _createPopperJs.detectOverflow));
parcelHelpers.export(exports, "createPopperBase", ()=>(0, _createPopperJs.createPopper));
parcelHelpers.export(exports, "createPopper", ()=>(0, _popperJs.createPopper)) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "createPopperLite", ()=>(0, _popperLiteJs.createPopper));
var _enumsJs = require("./enums.js");
parcelHelpers.exportAll(_enumsJs, exports);
var _indexJs = require("./modifiers/index.js"); // eslint-disable-next-line import/no-unused-modules
parcelHelpers.exportAll(_indexJs, exports);
var _createPopperJs = require("./createPopper.js");
var _popperJs = require("./popper.js");
var _popperLiteJs = require("./popper-lite.js");

},{"./enums.js":"lCAq5","./modifiers/index.js":"cap3W","./createPopper.js":"cHuNp","./popper.js":"1PuRF","./popper-lite.js":"gKW1N","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lCAq5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "top", ()=>top);
parcelHelpers.export(exports, "bottom", ()=>bottom);
parcelHelpers.export(exports, "right", ()=>right);
parcelHelpers.export(exports, "left", ()=>left);
parcelHelpers.export(exports, "auto", ()=>auto);
parcelHelpers.export(exports, "basePlacements", ()=>basePlacements);
parcelHelpers.export(exports, "start", ()=>start);
parcelHelpers.export(exports, "end", ()=>end);
parcelHelpers.export(exports, "clippingParents", ()=>clippingParents);
parcelHelpers.export(exports, "viewport", ()=>viewport);
parcelHelpers.export(exports, "popper", ()=>popper);
parcelHelpers.export(exports, "reference", ()=>reference);
parcelHelpers.export(exports, "variationPlacements", ()=>variationPlacements);
parcelHelpers.export(exports, "placements", ()=>placements);
parcelHelpers.export(exports, "beforeRead", ()=>beforeRead);
parcelHelpers.export(exports, "read", ()=>read);
parcelHelpers.export(exports, "afterRead", ()=>afterRead);
parcelHelpers.export(exports, "beforeMain", ()=>beforeMain);
parcelHelpers.export(exports, "main", ()=>main);
parcelHelpers.export(exports, "afterMain", ()=>afterMain);
parcelHelpers.export(exports, "beforeWrite", ()=>beforeWrite);
parcelHelpers.export(exports, "write", ()=>write);
parcelHelpers.export(exports, "afterWrite", ()=>afterWrite);
parcelHelpers.export(exports, "modifierPhases", ()=>modifierPhases);
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [
    top,
    bottom,
    right,
    left
];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /*#__PURE__*/ basePlacements.reduce(function(acc, placement) {
    return acc.concat([
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []);
var placements = /*#__PURE__*/ [].concat(basePlacements, [
    auto
]).reduce(function(acc, placement) {
    return acc.concat([
        placement,
        placement + "-" + start,
        placement + "-" + end
    ]);
}, []); // modifiers that need to read the DOM
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead"; // pure-logic modifiers
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain"; // modifier with the purpose to write to the DOM (or write into a framework state)
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [
    beforeRead,
    read,
    afterRead,
    beforeMain,
    main,
    afterMain,
    beforeWrite,
    write,
    afterWrite
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"cap3W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "applyStyles", ()=>(0, _applyStylesJsDefault.default));
parcelHelpers.export(exports, "arrow", ()=>(0, _arrowJsDefault.default));
parcelHelpers.export(exports, "computeStyles", ()=>(0, _computeStylesJsDefault.default));
parcelHelpers.export(exports, "eventListeners", ()=>(0, _eventListenersJsDefault.default));
parcelHelpers.export(exports, "flip", ()=>(0, _flipJsDefault.default));
parcelHelpers.export(exports, "hide", ()=>(0, _hideJsDefault.default));
parcelHelpers.export(exports, "offset", ()=>(0, _offsetJsDefault.default));
parcelHelpers.export(exports, "popperOffsets", ()=>(0, _popperOffsetsJsDefault.default));
parcelHelpers.export(exports, "preventOverflow", ()=>(0, _preventOverflowJsDefault.default));
var _applyStylesJs = require("./applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var _arrowJs = require("./arrow.js");
var _arrowJsDefault = parcelHelpers.interopDefault(_arrowJs);
var _computeStylesJs = require("./computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _eventListenersJs = require("./eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _flipJs = require("./flip.js");
var _flipJsDefault = parcelHelpers.interopDefault(_flipJs);
var _hideJs = require("./hide.js");
var _hideJsDefault = parcelHelpers.interopDefault(_hideJs);
var _offsetJs = require("./offset.js");
var _offsetJsDefault = parcelHelpers.interopDefault(_offsetJs);
var _popperOffsetsJs = require("./popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _preventOverflowJs = require("./preventOverflow.js");
var _preventOverflowJsDefault = parcelHelpers.interopDefault(_preventOverflowJs);

},{"./applyStyles.js":"4iMn4","./arrow.js":"31HFW","./computeStyles.js":"gDlm2","./eventListeners.js":"hBKsL","./flip.js":"fv5wq","./hide.js":"2g4OF","./offset.js":"3GKVY","./popperOffsets.js":"6I679","./preventOverflow.js":"1AMhb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4iMn4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNodeNameJs = require("../dom-utils/getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("../dom-utils/instanceOf.js"); // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow
function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements
        if (!(0, _instanceOfJs.isHTMLElement)(element) || !(0, _getNodeNameJsDefault.default)(element)) return;
         // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name) {
            var value = attributes[name];
            if (value === false) element.removeAttribute(name);
            else element.setAttribute(name, value === true ? "" : value);
        });
    });
}
function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
        popper: {
            position: state.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
        },
        arrow: {
            position: "absolute"
        },
        reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
    return function() {
        Object.keys(state.elements).forEach(function(name) {
            var element = state.elements[name];
            var attributes = state.attributes[name] || {};
            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them
            var style = styleProperties.reduce(function(style, property) {
                style[property] = "";
                return style;
            }, {}); // arrow is optional + virtual elements
            if (!(0, _instanceOfJs.isHTMLElement)(element) || !(0, _getNodeNameJsDefault.default)(element)) return;
            Object.assign(element.style, style);
            Object.keys(attributes).forEach(function(attribute) {
                element.removeAttribute(attribute);
            });
        });
    };
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect,
    requires: [
        "computeStyles"
    ]
};

},{"../dom-utils/getNodeName.js":"a2Qom","../dom-utils/instanceOf.js":"gYFUC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a2Qom":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getNodeName);
function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gYFUC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isElement", ()=>isElement);
parcelHelpers.export(exports, "isHTMLElement", ()=>isHTMLElement);
parcelHelpers.export(exports, "isShadowRoot", ()=>isShadowRoot);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function isElement(node) {
    var OwnElement = (0, _getWindowJsDefault.default)(node).Element;
    return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
    var OwnElement = (0, _getWindowJsDefault.default)(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === "undefined") return false;
    var OwnElement = (0, _getWindowJsDefault.default)(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
}

},{"./getWindow.js":"2SkOo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2SkOo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getWindow);
function getWindow(node) {
    if (node == null) return window;
    if (node.toString() !== "[object Window]") {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"31HFW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getLayoutRectJs = require("../dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _containsJs = require("../dom-utils/contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getMainAxisFromPlacementJs = require("../utils/getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _withinJs = require("../utils/within.js");
var _mergePaddingObjectJs = require("../utils/mergePaddingObject.js");
var _mergePaddingObjectJsDefault = parcelHelpers.interopDefault(_mergePaddingObjectJs);
var _expandToHashMapJs = require("../utils/expandToHashMap.js");
var _expandToHashMapJsDefault = parcelHelpers.interopDefault(_expandToHashMapJs);
var _enumsJs = require("../enums.js"); // eslint-disable-next-line import/no-unused-modules
var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
        placement: state.placement
    })) : padding;
    return (0, _mergePaddingObjectJsDefault.default)(typeof padding !== "number" ? padding : (0, _expandToHashMapJsDefault.default)(padding, (0, _enumsJs.basePlacements)));
};
function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = (0, _getBasePlacementJsDefault.default)(state.placement);
    var axis = (0, _getMainAxisFromPlacementJsDefault.default)(basePlacement);
    var isVertical = [
        (0, _enumsJs.left),
        (0, _enumsJs.right)
    ].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets) return;
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = (0, _getLayoutRectJsDefault.default)(arrowElement);
    var minProp = axis === "y" ? (0, _enumsJs.top) : (0, _enumsJs.left);
    var maxProp = axis === "y" ? (0, _enumsJs.bottom) : (0, _enumsJs.right);
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = (0, _getOffsetParentJsDefault.default)(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds
    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = (0, _withinJs.within)(min, center, max); // Prevents breaking syntax highlighting...
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) return;
     // CSS selector
    if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) return;
    }
    if (!(0, _containsJsDefault.default)(state.elements.popper, arrowElement)) return;
    state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect,
    requires: [
        "popperOffsets"
    ],
    requiresIfExists: [
        "preventOverflow"
    ]
};

},{"../utils/getBasePlacement.js":"59Wp3","../dom-utils/getLayoutRect.js":"jvjuf","../dom-utils/contains.js":"4QxRR","../dom-utils/getOffsetParent.js":"laoYw","../utils/getMainAxisFromPlacement.js":"1Xlom","../utils/within.js":"3glSz","../utils/mergePaddingObject.js":"lEIf9","../utils/expandToHashMap.js":"iQlH5","../enums.js":"lCAq5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"59Wp3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getBasePlacement);
var _enumsJs = require("../enums.js");
function getBasePlacement(placement) {
    return placement.split("-")[0];
}

},{"../enums.js":"lCAq5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jvjuf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getLayoutRect);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js"); // Returns the layout rect of an element relative to its offsetParent. Layout
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
function getLayoutRect(element) {
    var clientRect = (0, _getBoundingClientRectJsDefault.default)(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) width = clientRect.width;
    if (Math.abs(clientRect.height - height) <= 1) height = clientRect.height;
    return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
    };
}

},{"./getBoundingClientRect.js":"9CFSQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9CFSQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getBoundingClientRect);
var _instanceOfJs = require("./instanceOf.js");
var _mathJs = require("../utils/math.js");
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _isLayoutViewportJs = require("./isLayoutViewport.js");
var _isLayoutViewportJsDefault = parcelHelpers.interopDefault(_isLayoutViewportJs);
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) includeScale = false;
    if (isFixedStrategy === void 0) isFixedStrategy = false;
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && (0, _instanceOfJs.isHTMLElement)(element)) {
        scaleX = element.offsetWidth > 0 ? (0, _mathJs.round)(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? (0, _mathJs.round)(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = (0, _instanceOfJs.isElement)(element) ? (0, _getWindowJsDefault.default)(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !(0, _isLayoutViewportJsDefault.default)() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
        width: width,
        height: height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
        x: x,
        y: y
    };
}

},{"./instanceOf.js":"gYFUC","../utils/math.js":"gQqVe","./getWindow.js":"2SkOo","./isLayoutViewport.js":"3ipHv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gQqVe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "round", ()=>round);
var max = Math.max;
var min = Math.min;
var round = Math.round;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ipHv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isLayoutViewport);
var _userAgentJs = require("../utils/userAgent.js");
var _userAgentJsDefault = parcelHelpers.interopDefault(_userAgentJs);
function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test((0, _userAgentJsDefault.default)());
}

},{"../utils/userAgent.js":"1hEx0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1hEx0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getUAString);
function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
    }).join(" ");
    return navigator.userAgent;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4QxRR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>contains);
var _instanceOfJs = require("./instanceOf.js");
function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method
    if (parent.contains(child)) return true;
    else if (rootNode && (0, _instanceOfJs.isShadowRoot)(rootNode)) {
        var next = child;
        do {
            if (next && parent.isSameNode(next)) return true;
             // $FlowFixMe[prop-missing]: need a better way to handle this...
            next = next.parentNode || next.host;
        }while (next);
    } // Give up, the result is false
    return false;
}

},{"./instanceOf.js":"gYFUC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"laoYw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getOffsetParent);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _instanceOfJs = require("./instanceOf.js");
var _isTableElementJs = require("./isTableElement.js");
var _isTableElementJsDefault = parcelHelpers.interopDefault(_isTableElementJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _userAgentJs = require("../utils/userAgent.js");
var _userAgentJsDefault = parcelHelpers.interopDefault(_userAgentJs);
function getTrueOffsetParent(element) {
    if (!(0, _instanceOfJs.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837
    (0, _getComputedStyleJsDefault.default)(element).position === "fixed") return null;
    return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block
function getContainingBlock(element) {
    var isFirefox = /firefox/i.test((0, _userAgentJsDefault.default)());
    var isIE = /Trident/i.test((0, _userAgentJsDefault.default)());
    if (isIE && (0, _instanceOfJs.isHTMLElement)(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = (0, _getComputedStyleJsDefault.default)(element);
        if (elementCss.position === "fixed") return null;
    }
    var currentNode = (0, _getParentNodeJsDefault.default)(element);
    if ((0, _instanceOfJs.isShadowRoot)(currentNode)) currentNode = currentNode.host;
    while((0, _instanceOfJs.isHTMLElement)(currentNode) && [
        "html",
        "body"
    ].indexOf((0, _getNodeNameJsDefault.default)(currentNode)) < 0){
        var css = (0, _getComputedStyleJsDefault.default)(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || [
            "transform",
            "perspective"
        ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") return currentNode;
        else currentNode = currentNode.parentNode;
    }
    return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
function getOffsetParent(element) {
    var window = (0, _getWindowJsDefault.default)(element);
    var offsetParent = getTrueOffsetParent(element);
    while(offsetParent && (0, _isTableElementJsDefault.default)(offsetParent) && (0, _getComputedStyleJsDefault.default)(offsetParent).position === "static")offsetParent = getTrueOffsetParent(offsetParent);
    if (offsetParent && ((0, _getNodeNameJsDefault.default)(offsetParent) === "html" || (0, _getNodeNameJsDefault.default)(offsetParent) === "body" && (0, _getComputedStyleJsDefault.default)(offsetParent).position === "static")) return window;
    return offsetParent || getContainingBlock(element) || window;
}

},{"./getWindow.js":"2SkOo","./getNodeName.js":"a2Qom","./getComputedStyle.js":"3mZjB","./instanceOf.js":"gYFUC","./isTableElement.js":"2qBb7","./getParentNode.js":"bIHpd","../utils/userAgent.js":"1hEx0","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3mZjB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getComputedStyle);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function getComputedStyle(element) {
    return (0, _getWindowJsDefault.default)(element).getComputedStyle(element);
}

},{"./getWindow.js":"2SkOo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2qBb7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isTableElement);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
function isTableElement(element) {
    return [
        "table",
        "td",
        "th"
    ].indexOf((0, _getNodeNameJsDefault.default)(element)) >= 0;
}

},{"./getNodeName.js":"a2Qom","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bIHpd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getParentNode);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _instanceOfJs = require("./instanceOf.js");
function getParentNode(element) {
    if ((0, _getNodeNameJsDefault.default)(element) === "html") return element;
    return(// $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ((0, _instanceOfJs.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0, _getDocumentElementJsDefault.default)(element) // fallback
    );
}

},{"./getNodeName.js":"a2Qom","./getDocumentElement.js":"eJ9Y1","./instanceOf.js":"gYFUC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eJ9Y1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getDocumentElement);
var _instanceOfJs = require("./instanceOf.js");
function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return (((0, _instanceOfJs.isElement)(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}

},{"./instanceOf.js":"gYFUC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Xlom":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getMainAxisFromPlacement);
function getMainAxisFromPlacement(placement) {
    return [
        "top",
        "bottom"
    ].indexOf(placement) >= 0 ? "x" : "y";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3glSz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "within", ()=>within);
parcelHelpers.export(exports, "withinMaxClamp", ()=>withinMaxClamp);
var _mathJs = require("./math.js");
function within(min, value, max) {
    return (0, _mathJs.max)(min, (0, _mathJs.min)(value, max));
}
function withinMaxClamp(min, value, max) {
    var v = within(min, value, max);
    return v > max ? max : v;
}

},{"./math.js":"gQqVe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lEIf9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>mergePaddingObject);
var _getFreshSideObjectJs = require("./getFreshSideObject.js");
var _getFreshSideObjectJsDefault = parcelHelpers.interopDefault(_getFreshSideObjectJs);
function mergePaddingObject(paddingObject) {
    return Object.assign({}, (0, _getFreshSideObjectJsDefault.default)(), paddingObject);
}

},{"./getFreshSideObject.js":"g4xOt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g4xOt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getFreshSideObject);
function getFreshSideObject() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iQlH5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>expandToHashMap);
function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
    }, {});
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gDlm2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapToStyles", ()=>mapToStyles);
var _enumsJs = require("../enums.js");
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getWindowJs = require("../dom-utils/getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getDocumentElementJs = require("../dom-utils/getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("../dom-utils/getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getVariationJs = require("../utils/getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _mathJs = require("../utils/math.js"); // eslint-disable-next-line import/no-unused-modules
var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.
function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x, y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
        x: (0, _mathJs.round)(x * dpr) / dpr || 0,
        y: (0, _mathJs.round)(y * dpr) / dpr || 0
    };
}
function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x: x,
        y: y
    }) : {
        x: x,
        y: y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = (0, _enumsJs.left);
    var sideY = (0, _enumsJs.top);
    var win = window;
    if (adaptive) {
        var offsetParent = (0, _getOffsetParentJsDefault.default)(popper);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === (0, _getWindowJsDefault.default)(popper)) {
            offsetParent = (0, _getDocumentElementJsDefault.default)(popper);
            if ((0, _getComputedStyleJsDefault.default)(offsetParent).position !== "static" && position === "absolute") {
                heightProp = "scrollHeight";
                widthProp = "scrollWidth";
            }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it
        offsetParent;
        if (placement === (0, _enumsJs.top) || (placement === (0, _enumsJs.left) || placement === (0, _enumsJs.right)) && variation === (0, _enumsJs.end)) {
            sideY = (0, _enumsJs.bottom);
            var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
            y -= offsetY - popperRect.height;
            y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === (0, _enumsJs.left) || (placement === (0, _enumsJs.top) || placement === (0, _enumsJs.bottom)) && variation === (0, _enumsJs.end)) {
            sideX = (0, _enumsJs.right);
            var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
            x -= offsetX - popperRect.width;
            x *= gpuAcceleration ? 1 : -1;
        }
    }
    var commonStyles = Object.assign({
        position: position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
    }, (0, _getWindowJsDefault.default)(popper)) : {
        x: x,
        y: y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
        placement: (0, _getBasePlacementJsDefault.default)(state.placement),
        variation: (0, _getVariationJsDefault.default)(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
    })));
    if (state.modifiersData.arrow != null) state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets: roundOffsets
    })));
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
};

},{"../enums.js":"lCAq5","../dom-utils/getOffsetParent.js":"laoYw","../dom-utils/getWindow.js":"2SkOo","../dom-utils/getDocumentElement.js":"eJ9Y1","../dom-utils/getComputedStyle.js":"3mZjB","../utils/getBasePlacement.js":"59Wp3","../utils/getVariation.js":"hIo7Y","../utils/math.js":"gQqVe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hIo7Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getVariation);
function getVariation(placement) {
    return placement.split("-")[1];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hBKsL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getWindowJs = require("../dom-utils/getWindow.js"); // eslint-disable-next-line import/no-unused-modules
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var passive = {
    passive: true
};
function effect(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window = (0, _getWindowJsDefault.default)(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
    });
    if (resize) window.addEventListener("resize", instance.update, passive);
    return function() {
        if (scroll) scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, passive);
        });
        if (resize) window.removeEventListener("resize", instance.update, passive);
    };
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {},
    effect: effect,
    data: {}
};

},{"../dom-utils/getWindow.js":"2SkOo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fv5wq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getOppositePlacementJs = require("../utils/getOppositePlacement.js");
var _getOppositePlacementJsDefault = parcelHelpers.interopDefault(_getOppositePlacementJs);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getOppositeVariationPlacementJs = require("../utils/getOppositeVariationPlacement.js");
var _getOppositeVariationPlacementJsDefault = parcelHelpers.interopDefault(_getOppositeVariationPlacementJs);
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _computeAutoPlacementJs = require("../utils/computeAutoPlacement.js");
var _computeAutoPlacementJsDefault = parcelHelpers.interopDefault(_computeAutoPlacementJs);
var _enumsJs = require("../enums.js");
var _getVariationJs = require("../utils/getVariation.js"); // eslint-disable-next-line import/no-unused-modules
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
function getExpandedFallbackPlacements(placement) {
    if ((0, _getBasePlacementJsDefault.default)(placement) === (0, _enumsJs.auto)) return [];
    var oppositePlacement = (0, _getOppositePlacementJsDefault.default)(placement);
    return [
        (0, _getOppositeVariationPlacementJsDefault.default)(placement),
        oppositePlacement,
        (0, _getOppositeVariationPlacementJsDefault.default)(oppositePlacement)
    ];
}
function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) return;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = (0, _getBasePlacementJsDefault.default)(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [
        (0, _getOppositePlacementJsDefault.default)(preferredPlacement)
    ] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [
        preferredPlacement
    ].concat(fallbackPlacements).reduce(function(acc, placement) {
        return acc.concat((0, _getBasePlacementJsDefault.default)(placement) === (0, _enumsJs.auto) ? (0, _computeAutoPlacementJsDefault.default)(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding,
            flipVariations: flipVariations,
            allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];
    for(var i = 0; i < placements.length; i++){
        var placement = placements[i];
        var _basePlacement = (0, _getBasePlacementJsDefault.default)(placement);
        var isStartVariation = (0, _getVariationJsDefault.default)(placement) === (0, _enumsJs.start);
        var isVertical = [
            (0, _enumsJs.top),
            (0, _enumsJs.bottom)
        ].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = (0, _detectOverflowJsDefault.default)(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            altBoundary: altBoundary,
            padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? (0, _enumsJs.right) : (0, _enumsJs.left) : isStartVariation ? (0, _enumsJs.bottom) : (0, _enumsJs.top);
        if (referenceRect[len] > popperRect[len]) mainVariationSide = (0, _getOppositePlacementJsDefault.default)(mainVariationSide);
        var altVariationSide = (0, _getOppositePlacementJsDefault.default)(mainVariationSide);
        var checks = [];
        if (checkMainAxis) checks.push(overflow[_basePlacement] <= 0);
        if (checkAltAxis) checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        if (checks.every(function(check) {
            return check;
        })) {
            firstFittingPlacement = placement;
            makeFallbackChecks = false;
            break;
        }
        checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
        // `2` may be desired in some cases – research later
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop(_i) {
            var fittingPlacement = placements.find(function(placement) {
                var checks = checksMap.get(placement);
                if (checks) return checks.slice(0, _i).every(function(check) {
                    return check;
                });
            });
            if (fittingPlacement) {
                firstFittingPlacement = fittingPlacement;
                return "break";
            }
        };
        for(var _i = numberOfChecks; _i > 0; _i--){
            var _ret = _loop(_i);
            if (_ret === "break") break;
        }
    }
    if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
    }
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: [
        "offset"
    ],
    data: {
        _skip: false
    }
};

},{"../utils/getOppositePlacement.js":"a8CY0","../utils/getBasePlacement.js":"59Wp3","../utils/getOppositeVariationPlacement.js":"bKTLC","../utils/detectOverflow.js":"ltCuw","../utils/computeAutoPlacement.js":"gytMj","../enums.js":"lCAq5","../utils/getVariation.js":"hIo7Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a8CY0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getOppositePlacement);
var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash[matched];
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bKTLC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getOppositeVariationPlacement);
var hash = {
    start: "end",
    end: "start"
};
function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ltCuw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>detectOverflow);
var _getClippingRectJs = require("../dom-utils/getClippingRect.js");
var _getClippingRectJsDefault = parcelHelpers.interopDefault(_getClippingRectJs);
var _getDocumentElementJs = require("../dom-utils/getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getBoundingClientRectJs = require("../dom-utils/getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _computeOffsetsJs = require("./computeOffsets.js");
var _computeOffsetsJsDefault = parcelHelpers.interopDefault(_computeOffsetsJs);
var _rectToClientRectJs = require("./rectToClientRect.js");
var _rectToClientRectJsDefault = parcelHelpers.interopDefault(_rectToClientRectJs);
var _enumsJs = require("../enums.js");
var _instanceOfJs = require("../dom-utils/instanceOf.js");
var _mergePaddingObjectJs = require("./mergePaddingObject.js");
var _mergePaddingObjectJsDefault = parcelHelpers.interopDefault(_mergePaddingObjectJs);
var _expandToHashMapJs = require("./expandToHashMap.js"); // eslint-disable-next-line import/no-unused-modules
var _expandToHashMapJsDefault = parcelHelpers.interopDefault(_expandToHashMapJs);
function detectOverflow(state, options) {
    if (options === void 0) options = {};
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? (0, _enumsJs.clippingParents) : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? (0, _enumsJs.viewport) : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? (0, _enumsJs.popper) : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = (0, _mergePaddingObjectJsDefault.default)(typeof padding !== "number" ? padding : (0, _expandToHashMapJsDefault.default)(padding, (0, _enumsJs.basePlacements)));
    var altContext = elementContext === (0, _enumsJs.popper) ? (0, _enumsJs.reference) : (0, _enumsJs.popper);
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = (0, _getClippingRectJsDefault.default)((0, _instanceOfJs.isElement)(element) ? element : element.contextElement || (0, _getDocumentElementJsDefault.default)(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = (0, _getBoundingClientRectJsDefault.default)(state.elements.reference);
    var popperOffsets = (0, _computeOffsetsJsDefault.default)({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement: placement
    });
    var popperClientRect = (0, _rectToClientRectJsDefault.default)(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === (0, _enumsJs.popper) ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect
    var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element
    if (elementContext === (0, _enumsJs.popper) && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
            var multiply = [
                (0, _enumsJs.right),
                (0, _enumsJs.bottom)
            ].indexOf(key) >= 0 ? 1 : -1;
            var axis = [
                (0, _enumsJs.top),
                (0, _enumsJs.bottom)
            ].indexOf(key) >= 0 ? "y" : "x";
            overflowOffsets[key] += offset[axis] * multiply;
        });
    }
    return overflowOffsets;
}

},{"../dom-utils/getClippingRect.js":"eeg2s","../dom-utils/getDocumentElement.js":"eJ9Y1","../dom-utils/getBoundingClientRect.js":"9CFSQ","./computeOffsets.js":"7jtXk","./rectToClientRect.js":"cQ3tg","../enums.js":"lCAq5","../dom-utils/instanceOf.js":"gYFUC","./mergePaddingObject.js":"lEIf9","./expandToHashMap.js":"iQlH5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eeg2s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getClippingRect);
var _enumsJs = require("../enums.js");
var _getViewportRectJs = require("./getViewportRect.js");
var _getViewportRectJsDefault = parcelHelpers.interopDefault(_getViewportRectJs);
var _getDocumentRectJs = require("./getDocumentRect.js");
var _getDocumentRectJsDefault = parcelHelpers.interopDefault(_getDocumentRectJs);
var _listScrollParentsJs = require("./listScrollParents.js");
var _listScrollParentsJsDefault = parcelHelpers.interopDefault(_listScrollParentsJs);
var _getOffsetParentJs = require("./getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _instanceOfJs = require("./instanceOf.js");
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _containsJs = require("./contains.js");
var _containsJsDefault = parcelHelpers.interopDefault(_containsJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _rectToClientRectJs = require("../utils/rectToClientRect.js");
var _rectToClientRectJsDefault = parcelHelpers.interopDefault(_rectToClientRectJs);
var _mathJs = require("../utils/math.js");
function getInnerBoundingClientRect(element, strategy) {
    var rect = (0, _getBoundingClientRectJsDefault.default)(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === (0, _enumsJs.viewport) ? (0, _rectToClientRectJsDefault.default)((0, _getViewportRectJsDefault.default)(element, strategy)) : (0, _instanceOfJs.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0, _rectToClientRectJsDefault.default)((0, _getDocumentRectJsDefault.default)((0, _getDocumentElementJsDefault.default)(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`
function getClippingParents(element) {
    var clippingParents = (0, _listScrollParentsJsDefault.default)((0, _getParentNodeJsDefault.default)(element));
    var canEscapeClipping = [
        "absolute",
        "fixed"
    ].indexOf((0, _getComputedStyleJsDefault.default)(element).position) >= 0;
    var clipperElement = canEscapeClipping && (0, _instanceOfJs.isHTMLElement)(element) ? (0, _getOffsetParentJsDefault.default)(element) : element;
    if (!(0, _instanceOfJs.isElement)(clipperElement)) return [];
     // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414
    return clippingParents.filter(function(clippingParent) {
        return (0, _instanceOfJs.isElement)(clippingParent) && (0, _containsJsDefault.default)(clippingParent, clipperElement) && (0, _getNodeNameJsDefault.default)(clippingParent) !== "body";
    });
} // Gets the maximum area that the element is visible in due to any number of
function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [
        rootBoundary
    ]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = (0, _mathJs.max)(rect.top, accRect.top);
        accRect.right = (0, _mathJs.min)(rect.right, accRect.right);
        accRect.bottom = (0, _mathJs.min)(rect.bottom, accRect.bottom);
        accRect.left = (0, _mathJs.max)(rect.left, accRect.left);
        return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
}

},{"../enums.js":"lCAq5","./getViewportRect.js":"cnH2G","./getDocumentRect.js":"d94SC","./listScrollParents.js":"2di3T","./getOffsetParent.js":"laoYw","./getDocumentElement.js":"eJ9Y1","./getComputedStyle.js":"3mZjB","./instanceOf.js":"gYFUC","./getBoundingClientRect.js":"9CFSQ","./getParentNode.js":"bIHpd","./contains.js":"4QxRR","./getNodeName.js":"a2Qom","../utils/rectToClientRect.js":"cQ3tg","../utils/math.js":"gQqVe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cnH2G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getViewportRect);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
var _isLayoutViewportJs = require("./isLayoutViewport.js");
var _isLayoutViewportJsDefault = parcelHelpers.interopDefault(_isLayoutViewportJs);
function getViewportRect(element, strategy) {
    var win = (0, _getWindowJsDefault.default)(element);
    var html = (0, _getDocumentElementJsDefault.default)(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = (0, _isLayoutViewportJsDefault.default)();
        if (layoutViewport || !layoutViewport && strategy === "fixed") {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
        }
    }
    return {
        width: width,
        height: height,
        x: x + (0, _getWindowScrollBarXJsDefault.default)(element),
        y: y
    };
}

},{"./getWindow.js":"2SkOo","./getDocumentElement.js":"eJ9Y1","./getWindowScrollBarX.js":"sz4Ld","./isLayoutViewport.js":"3ipHv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"sz4Ld":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getWindowScrollBarX);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return (0, _getBoundingClientRectJsDefault.default)((0, _getDocumentElementJsDefault.default)(element)).left + (0, _getWindowScrollJsDefault.default)(element).scrollLeft;
}

},{"./getBoundingClientRect.js":"9CFSQ","./getDocumentElement.js":"eJ9Y1","./getWindowScroll.js":"1XUtN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1XUtN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getWindowScroll);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
function getWindowScroll(node) {
    var win = (0, _getWindowJsDefault.default)(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
    };
}

},{"./getWindow.js":"2SkOo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d94SC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getDocumentRect);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
var _mathJs = require("../utils/math.js"); // Gets the entire size of the scrollable document area, even extending outside
function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = (0, _getDocumentElementJsDefault.default)(element);
    var winScroll = (0, _getWindowScrollJsDefault.default)(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = (0, _mathJs.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = (0, _mathJs.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + (0, _getWindowScrollBarXJsDefault.default)(element);
    var y = -winScroll.scrollTop;
    if ((0, _getComputedStyleJsDefault.default)(body || html).direction === "rtl") x += (0, _mathJs.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
    return {
        width: width,
        height: height,
        x: x,
        y: y
    };
}

},{"./getDocumentElement.js":"eJ9Y1","./getComputedStyle.js":"3mZjB","./getWindowScrollBarX.js":"sz4Ld","./getWindowScroll.js":"1XUtN","../utils/math.js":"gQqVe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2di3T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>listScrollParents);
var _getScrollParentJs = require("./getScrollParent.js");
var _getScrollParentJsDefault = parcelHelpers.interopDefault(_getScrollParentJs);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) list = [];
    var scrollParent = (0, _getScrollParentJsDefault.default)(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = (0, _getWindowJsDefault.default)(scrollParent);
    var target = isBody ? [
        win
    ].concat(win.visualViewport || [], (0, _isScrollParentJsDefault.default)(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents((0, _getParentNodeJsDefault.default)(target)));
}

},{"./getScrollParent.js":"jy4ZS","./getParentNode.js":"bIHpd","./getWindow.js":"2SkOo","./isScrollParent.js":"9rLGO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jy4ZS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getScrollParent);
var _getParentNodeJs = require("./getParentNode.js");
var _getParentNodeJsDefault = parcelHelpers.interopDefault(_getParentNodeJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("./instanceOf.js");
function getScrollParent(node) {
    if ([
        "html",
        "body",
        "#document"
    ].indexOf((0, _getNodeNameJsDefault.default)(node)) >= 0) // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
    if ((0, _instanceOfJs.isHTMLElement)(node) && (0, _isScrollParentJsDefault.default)(node)) return node;
    return getScrollParent((0, _getParentNodeJsDefault.default)(node));
}

},{"./getParentNode.js":"bIHpd","./isScrollParent.js":"9rLGO","./getNodeName.js":"a2Qom","./instanceOf.js":"gYFUC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9rLGO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isScrollParent);
var _getComputedStyleJs = require("./getComputedStyle.js");
var _getComputedStyleJsDefault = parcelHelpers.interopDefault(_getComputedStyleJs);
function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = (0, _getComputedStyleJsDefault.default)(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

},{"./getComputedStyle.js":"3mZjB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cQ3tg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>rectToClientRect);
function rectToClientRect(rect) {
    return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7jtXk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>computeOffsets);
var _getBasePlacementJs = require("./getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getVariationJs = require("./getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _getMainAxisFromPlacementJs = require("./getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _enumsJs = require("../enums.js");
function computeOffsets(_ref) {
    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? (0, _getBasePlacementJsDefault.default)(placement) : null;
    var variation = placement ? (0, _getVariationJsDefault.default)(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;
    switch(basePlacement){
        case 0, _enumsJs.top:
            offsets = {
                x: commonX,
                y: reference.y - element.height
            };
            break;
        case 0, _enumsJs.bottom:
            offsets = {
                x: commonX,
                y: reference.y + reference.height
            };
            break;
        case 0, _enumsJs.right:
            offsets = {
                x: reference.x + reference.width,
                y: commonY
            };
            break;
        case 0, _enumsJs.left:
            offsets = {
                x: reference.x - element.width,
                y: commonY
            };
            break;
        default:
            offsets = {
                x: reference.x,
                y: reference.y
            };
    }
    var mainAxis = basePlacement ? (0, _getMainAxisFromPlacementJsDefault.default)(basePlacement) : null;
    if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch(variation){
            case 0, _enumsJs.start:
                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                break;
            case 0, _enumsJs.end:
                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                break;
            default:
        }
    }
    return offsets;
}

},{"./getBasePlacement.js":"59Wp3","./getVariation.js":"hIo7Y","./getMainAxisFromPlacement.js":"1Xlom","../enums.js":"lCAq5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gytMj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>computeAutoPlacement);
var _getVariationJs = require("./getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _enumsJs = require("../enums.js");
var _detectOverflowJs = require("./detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _getBasePlacementJs = require("./getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
function computeAutoPlacement(state, options) {
    if (options === void 0) options = {};
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? (0, _enumsJs.placements) : _options$allowedAutoP;
    var variation = (0, _getVariationJsDefault.default)(placement);
    var placements = variation ? flipVariations ? (0, _enumsJs.variationPlacements) : (0, _enumsJs.variationPlacements).filter(function(placement) {
        return (0, _getVariationJsDefault.default)(placement) === variation;
    }) : (0, _enumsJs.basePlacements);
    var allowedPlacements = placements.filter(function(placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
    });
    if (allowedPlacements.length === 0) allowedPlacements = placements;
     // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...
    var overflows = allowedPlacements.reduce(function(acc, placement) {
        acc[placement] = (0, _detectOverflowJsDefault.default)(state, {
            placement: placement,
            boundary: boundary,
            rootBoundary: rootBoundary,
            padding: padding
        })[(0, _getBasePlacementJsDefault.default)(placement)];
        return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
        return overflows[a] - overflows[b];
    });
}

},{"./getVariation.js":"hIo7Y","../enums.js":"lCAq5","./detectOverflow.js":"ltCuw","./getBasePlacement.js":"59Wp3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2g4OF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) preventedOffsets = {
        x: 0,
        y: 0
    };
    return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
    };
}
function isAnySideFullyClipped(overflow) {
    return [
        (0, _enumsJs.top),
        (0, _enumsJs.right),
        (0, _enumsJs.bottom),
        (0, _enumsJs.left)
    ].some(function(side) {
        return overflow[side] >= 0;
    });
}
function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = (0, _detectOverflowJsDefault.default)(state, {
        elementContext: "reference"
    });
    var popperAltOverflow = (0, _detectOverflowJsDefault.default)(state, {
        altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: [
        "preventOverflow"
    ],
    fn: hide
};

},{"../enums.js":"lCAq5","../utils/detectOverflow.js":"ltCuw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3GKVY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distanceAndSkiddingToXY", ()=>distanceAndSkiddingToXY);
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _enumsJs = require("../enums.js"); // eslint-disable-next-line import/no-unused-modules
function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = (0, _getBasePlacementJsDefault.default)(placement);
    var invertDistance = [
        (0, _enumsJs.left),
        (0, _enumsJs.top)
    ].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset === "function" ? offset(Object.assign({}, rects, {
        placement: placement
    })) : offset, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [
        (0, _enumsJs.left),
        (0, _enumsJs.right)
    ].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
    } : {
        x: skidding,
        y: distance
    };
}
function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset = _options$offset === void 0 ? [
        0,
        0
    ] : _options$offset;
    var data = (0, _enumsJs.placements).reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: [
        "popperOffsets"
    ],
    fn: offset
};

},{"../utils/getBasePlacement.js":"59Wp3","../enums.js":"lCAq5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6I679":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _computeOffsetsJs = require("../utils/computeOffsets.js");
var _computeOffsetsJsDefault = parcelHelpers.interopDefault(_computeOffsetsJs);
function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = (0, _computeOffsetsJsDefault.default)({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
    });
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
};

},{"../utils/computeOffsets.js":"7jtXk","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1AMhb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _enumsJs = require("../enums.js");
var _getBasePlacementJs = require("../utils/getBasePlacement.js");
var _getBasePlacementJsDefault = parcelHelpers.interopDefault(_getBasePlacementJs);
var _getMainAxisFromPlacementJs = require("../utils/getMainAxisFromPlacement.js");
var _getMainAxisFromPlacementJsDefault = parcelHelpers.interopDefault(_getMainAxisFromPlacementJs);
var _getAltAxisJs = require("../utils/getAltAxis.js");
var _getAltAxisJsDefault = parcelHelpers.interopDefault(_getAltAxisJs);
var _withinJs = require("../utils/within.js");
var _getLayoutRectJs = require("../dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _getOffsetParentJs = require("../dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _detectOverflowJs = require("../utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _getVariationJs = require("../utils/getVariation.js");
var _getVariationJsDefault = parcelHelpers.interopDefault(_getVariationJs);
var _getFreshSideObjectJs = require("../utils/getFreshSideObject.js");
var _getFreshSideObjectJsDefault = parcelHelpers.interopDefault(_getFreshSideObjectJs);
var _mathJs = require("../utils/math.js");
function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = (0, _detectOverflowJsDefault.default)(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
    });
    var basePlacement = (0, _getBasePlacementJsDefault.default)(state.placement);
    var variation = (0, _getVariationJsDefault.default)(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = (0, _getMainAxisFromPlacementJsDefault.default)(basePlacement);
    var altAxis = (0, _getAltAxisJsDefault.default)(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
    } : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
        x: 0,
        y: 0
    };
    if (!popperOffsets) return;
    if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? (0, _enumsJs.top) : (0, _enumsJs.left);
        var altSide = mainAxis === "y" ? (0, _enumsJs.bottom) : (0, _enumsJs.right);
        var len = mainAxis === "y" ? "height" : "width";
        var offset = popperOffsets[mainAxis];
        var min = offset + overflow[mainSide];
        var max = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === (0, _enumsJs.start) ? referenceRect[len] : popperRect[len];
        var maxLen = variation === (0, _enumsJs.start) ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? (0, _getLayoutRectJsDefault.default)(arrowElement) : {
            width: 0,
            height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : (0, _getFreshSideObjectJsDefault.default)();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)
        var arrowLen = (0, _withinJs.within)(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && (0, _getOffsetParentJsDefault.default)(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = (0, _withinJs.within)(tether ? (0, _mathJs.min)(min, tetherMin) : min, offset, tether ? (0, _mathJs.max)(max, tetherMax) : max);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
    }
    if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? (0, _enumsJs.top) : (0, _enumsJs.left);
        var _altSide = mainAxis === "x" ? (0, _enumsJs.bottom) : (0, _enumsJs.right);
        var _offset = popperOffsets[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [
            (0, _enumsJs.top),
            (0, _enumsJs.left)
        ].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? (0, _withinJs.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0, _withinJs.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules
exports.default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: [
        "offset"
    ]
};

},{"../enums.js":"lCAq5","../utils/getBasePlacement.js":"59Wp3","../utils/getMainAxisFromPlacement.js":"1Xlom","../utils/getAltAxis.js":"59FWE","../utils/within.js":"3glSz","../dom-utils/getLayoutRect.js":"jvjuf","../dom-utils/getOffsetParent.js":"laoYw","../utils/detectOverflow.js":"ltCuw","../utils/getVariation.js":"hIo7Y","../utils/getFreshSideObject.js":"g4xOt","../utils/math.js":"gQqVe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"59FWE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getAltAxis);
function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cHuNp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "popperGenerator", ()=>popperGenerator);
parcelHelpers.export(exports, "createPopper", ()=>createPopper);
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _detectOverflowJsDefault.default));
var _getCompositeRectJs = require("./dom-utils/getCompositeRect.js");
var _getCompositeRectJsDefault = parcelHelpers.interopDefault(_getCompositeRectJs);
var _getLayoutRectJs = require("./dom-utils/getLayoutRect.js");
var _getLayoutRectJsDefault = parcelHelpers.interopDefault(_getLayoutRectJs);
var _listScrollParentsJs = require("./dom-utils/listScrollParents.js");
var _listScrollParentsJsDefault = parcelHelpers.interopDefault(_listScrollParentsJs);
var _getOffsetParentJs = require("./dom-utils/getOffsetParent.js");
var _getOffsetParentJsDefault = parcelHelpers.interopDefault(_getOffsetParentJs);
var _orderModifiersJs = require("./utils/orderModifiers.js");
var _orderModifiersJsDefault = parcelHelpers.interopDefault(_orderModifiersJs);
var _debounceJs = require("./utils/debounce.js");
var _debounceJsDefault = parcelHelpers.interopDefault(_debounceJs);
var _mergeByNameJs = require("./utils/mergeByName.js");
var _mergeByNameJsDefault = parcelHelpers.interopDefault(_mergeByNameJs);
var _detectOverflowJs = require("./utils/detectOverflow.js");
var _detectOverflowJsDefault = parcelHelpers.interopDefault(_detectOverflowJs);
var _instanceOfJs = require("./dom-utils/instanceOf.js");
var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function areValidElements() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
    return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
    });
}
function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) generatorOptions = {};
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
        if (options === void 0) options = defaultOptions;
        var state = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
            modifiersData: {},
            elements: {
                reference: reference,
                popper: popper
            },
            attributes: {},
            styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
            state: state,
            setOptions: function setOptions(setOptionsAction) {
                var options = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
                cleanupModifierEffects();
                state.options = Object.assign({}, defaultOptions, state.options, options);
                state.scrollParents = {
                    reference: (0, _instanceOfJs.isElement)(reference) ? (0, _listScrollParentsJsDefault.default)(reference) : reference.contextElement ? (0, _listScrollParentsJsDefault.default)(reference.contextElement) : [],
                    popper: (0, _listScrollParentsJsDefault.default)(popper)
                }; // Orders the modifiers based on their dependencies and `phase`
                // properties
                var orderedModifiers = (0, _orderModifiersJsDefault.default)((0, _mergeByNameJsDefault.default)([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers
                state.orderedModifiers = orderedModifiers.filter(function(m) {
                    return m.enabled;
                });
                runModifierEffects();
                return instance.update();
            },
            // Sync update – it will always be executed, even if not necessary. This
            // is useful for low frequency updates where sync behavior simplifies the
            // logic.
            // For high frequency updates (e.g. `resize` and `scroll` events), always
            // prefer the async Popper#update method
            forceUpdate: function forceUpdate() {
                if (isDestroyed) return;
                var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
                // anymore
                if (!areValidElements(reference, popper)) return;
                 // Store the reference and popper rects to be read by modifiers
                state.rects = {
                    reference: (0, _getCompositeRectJsDefault.default)(reference, (0, _getOffsetParentJsDefault.default)(popper), state.options.strategy === "fixed"),
                    popper: (0, _getLayoutRectJsDefault.default)(popper)
                }; // Modifiers have the ability to reset the current update cycle. The
                // most common use case for this is the `flip` modifier changing the
                // placement, which then needs to re-run all the modifiers, because the
                // logic was previously ran for the previous placement and is therefore
                // stale/incorrect
                state.reset = false;
                state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
                // is filled with the initial data specified by the modifier. This means
                // it doesn't persist and is fresh on each update.
                // To ensure persistent data, use `${name}#persistent`
                state.orderedModifiers.forEach(function(modifier) {
                    return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                });
                for(var index = 0; index < state.orderedModifiers.length; index++){
                    if (state.reset === true) {
                        state.reset = false;
                        index = -1;
                        continue;
                    }
                    var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                    if (typeof fn === "function") state = fn({
                        state: state,
                        options: _options,
                        name: name,
                        instance: instance
                    }) || state;
                }
            },
            // Async and optimistically optimized update – it will not be executed if
            // not necessary (debounced to run at most once-per-tick)
            update: (0, _debounceJsDefault.default)(function() {
                return new Promise(function(resolve) {
                    instance.forceUpdate();
                    resolve(state);
                });
            }),
            destroy: function destroy() {
                cleanupModifierEffects();
                isDestroyed = true;
            }
        };
        if (!areValidElements(reference, popper)) return instance;
        instance.setOptions(options).then(function(state) {
            if (!isDestroyed && options.onFirstUpdate) options.onFirstUpdate(state);
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.
        function runModifierEffects() {
            state.orderedModifiers.forEach(function(_ref) {
                var name = _ref.name, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, effect = _ref.effect;
                if (typeof effect === "function") {
                    var cleanupFn = effect({
                        state: state,
                        name: name,
                        instance: instance,
                        options: options
                    });
                    var noopFn = function noopFn() {};
                    effectCleanupFns.push(cleanupFn || noopFn);
                }
            });
        }
        function cleanupModifierEffects() {
            effectCleanupFns.forEach(function(fn) {
                return fn();
            });
            effectCleanupFns = [];
        }
        return instance;
    };
}
var createPopper = /*#__PURE__*/ popperGenerator(); // eslint-disable-next-line import/no-unused-modules

},{"./dom-utils/getCompositeRect.js":"ijPls","./dom-utils/getLayoutRect.js":"jvjuf","./dom-utils/listScrollParents.js":"2di3T","./dom-utils/getOffsetParent.js":"laoYw","./utils/orderModifiers.js":"N0VO0","./utils/debounce.js":"g6Chr","./utils/mergeByName.js":"2zTVN","./utils/detectOverflow.js":"ltCuw","./dom-utils/instanceOf.js":"gYFUC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ijPls":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getCompositeRect);
var _getBoundingClientRectJs = require("./getBoundingClientRect.js");
var _getBoundingClientRectJsDefault = parcelHelpers.interopDefault(_getBoundingClientRectJs);
var _getNodeScrollJs = require("./getNodeScroll.js");
var _getNodeScrollJsDefault = parcelHelpers.interopDefault(_getNodeScrollJs);
var _getNodeNameJs = require("./getNodeName.js");
var _getNodeNameJsDefault = parcelHelpers.interopDefault(_getNodeNameJs);
var _instanceOfJs = require("./instanceOf.js");
var _getWindowScrollBarXJs = require("./getWindowScrollBarX.js");
var _getWindowScrollBarXJsDefault = parcelHelpers.interopDefault(_getWindowScrollBarXJs);
var _getDocumentElementJs = require("./getDocumentElement.js");
var _getDocumentElementJsDefault = parcelHelpers.interopDefault(_getDocumentElementJs);
var _isScrollParentJs = require("./isScrollParent.js");
var _isScrollParentJsDefault = parcelHelpers.interopDefault(_isScrollParentJs);
var _mathJs = require("../utils/math.js");
function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = (0, _mathJs.round)(rect.width) / element.offsetWidth || 1;
    var scaleY = (0, _mathJs.round)(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) isFixed = false;
    var isOffsetParentAnElement = (0, _instanceOfJs.isHTMLElement)(offsetParent);
    var offsetParentIsScaled = (0, _instanceOfJs.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
    var documentElement = (0, _getDocumentElementJsDefault.default)(offsetParent);
    var rect = (0, _getBoundingClientRectJsDefault.default)(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
        scrollLeft: 0,
        scrollTop: 0
    };
    var offsets = {
        x: 0,
        y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if ((0, _getNodeNameJsDefault.default)(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        (0, _isScrollParentJsDefault.default)(documentElement)) scroll = (0, _getNodeScrollJsDefault.default)(offsetParent);
        if ((0, _instanceOfJs.isHTMLElement)(offsetParent)) {
            offsets = (0, _getBoundingClientRectJsDefault.default)(offsetParent, true);
            offsets.x += offsetParent.clientLeft;
            offsets.y += offsetParent.clientTop;
        } else if (documentElement) offsets.x = (0, _getWindowScrollBarXJsDefault.default)(documentElement);
    }
    return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
    };
}

},{"./getBoundingClientRect.js":"9CFSQ","./getNodeScroll.js":"bBjCr","./getNodeName.js":"a2Qom","./instanceOf.js":"gYFUC","./getWindowScrollBarX.js":"sz4Ld","./getDocumentElement.js":"eJ9Y1","./isScrollParent.js":"9rLGO","../utils/math.js":"gQqVe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bBjCr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getNodeScroll);
var _getWindowScrollJs = require("./getWindowScroll.js");
var _getWindowScrollJsDefault = parcelHelpers.interopDefault(_getWindowScrollJs);
var _getWindowJs = require("./getWindow.js");
var _getWindowJsDefault = parcelHelpers.interopDefault(_getWindowJs);
var _instanceOfJs = require("./instanceOf.js");
var _getHTMLElementScrollJs = require("./getHTMLElementScroll.js");
var _getHTMLElementScrollJsDefault = parcelHelpers.interopDefault(_getHTMLElementScrollJs);
function getNodeScroll(node) {
    if (node === (0, _getWindowJsDefault.default)(node) || !(0, _instanceOfJs.isHTMLElement)(node)) return (0, _getWindowScrollJsDefault.default)(node);
    else return (0, _getHTMLElementScrollJsDefault.default)(node);
}

},{"./getWindowScroll.js":"1XUtN","./getWindow.js":"2SkOo","./instanceOf.js":"gYFUC","./getHTMLElementScroll.js":"6pwY2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6pwY2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getHTMLElementScroll);
function getHTMLElementScroll(element) {
    return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"N0VO0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>orderModifiers);
var _enumsJs = require("../enums.js"); // source: https://stackoverflow.com/questions/49875255
function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
        map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively
    function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
            if (!visited.has(dep)) {
                var depModifier = map.get(dep);
                if (depModifier) sort(depModifier);
            }
        });
        result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) // check for visited object
        sort(modifier);
    });
    return result;
}
function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase
    return (0, _enumsJs.modifierPhases).reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
            return modifier.phase === phase;
        }));
    }, []);
}

},{"../enums.js":"lCAq5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g6Chr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>debounce);
function debounce(fn) {
    var pending;
    return function() {
        if (!pending) pending = new Promise(function(resolve) {
            Promise.resolve().then(function() {
                pending = undefined;
                resolve(fn());
            });
        });
        return pending;
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2zTVN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>mergeByName);
function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
            options: Object.assign({}, existing.options, current.options),
            data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
    }, {}); // IE11 does not support Object.values
    return Object.keys(merged).map(function(key) {
        return merged[key];
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1PuRF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPopperLite", ()=>(0, _popperLiteJs.createPopper)) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "createPopper", ()=>createPopper) // eslint-disable-next-line import/no-unused-modules
;
parcelHelpers.export(exports, "popperGenerator", ()=>(0, _createPopperJs.popperGenerator));
parcelHelpers.export(exports, "defaultModifiers", ()=>defaultModifiers);
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _createPopperJs.detectOverflow));
var _createPopperJs = require("./createPopper.js");
var _eventListenersJs = require("./modifiers/eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _popperOffsetsJs = require("./modifiers/popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _computeStylesJs = require("./modifiers/computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _applyStylesJs = require("./modifiers/applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var _offsetJs = require("./modifiers/offset.js");
var _offsetJsDefault = parcelHelpers.interopDefault(_offsetJs);
var _flipJs = require("./modifiers/flip.js");
var _flipJsDefault = parcelHelpers.interopDefault(_flipJs);
var _preventOverflowJs = require("./modifiers/preventOverflow.js");
var _preventOverflowJsDefault = parcelHelpers.interopDefault(_preventOverflowJs);
var _arrowJs = require("./modifiers/arrow.js");
var _arrowJsDefault = parcelHelpers.interopDefault(_arrowJs);
var _hideJs = require("./modifiers/hide.js");
var _hideJsDefault = parcelHelpers.interopDefault(_hideJs);
var _popperLiteJs = require("./popper-lite.js");
var _indexJs = require("./modifiers/index.js");
parcelHelpers.exportAll(_indexJs, exports);
var defaultModifiers = [
    (0, _eventListenersJsDefault.default),
    (0, _popperOffsetsJsDefault.default),
    (0, _computeStylesJsDefault.default),
    (0, _applyStylesJsDefault.default),
    (0, _offsetJsDefault.default),
    (0, _flipJsDefault.default),
    (0, _preventOverflowJsDefault.default),
    (0, _arrowJsDefault.default),
    (0, _hideJsDefault.default)
];
var createPopper = /*#__PURE__*/ (0, _createPopperJs.popperGenerator)({
    defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

},{"./createPopper.js":"cHuNp","./modifiers/eventListeners.js":"hBKsL","./modifiers/popperOffsets.js":"6I679","./modifiers/computeStyles.js":"gDlm2","./modifiers/applyStyles.js":"4iMn4","./modifiers/offset.js":"3GKVY","./modifiers/flip.js":"fv5wq","./modifiers/preventOverflow.js":"1AMhb","./modifiers/arrow.js":"31HFW","./modifiers/hide.js":"2g4OF","./popper-lite.js":false,"./modifiers/index.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gKW1N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPopper", ()=>createPopper);
parcelHelpers.export(exports, "popperGenerator", ()=>(0, _createPopperJs.popperGenerator));
parcelHelpers.export(exports, "defaultModifiers", ()=>defaultModifiers);
parcelHelpers.export(exports, "detectOverflow", ()=>(0, _createPopperJs.detectOverflow));
var _createPopperJs = require("./createPopper.js");
var _eventListenersJs = require("./modifiers/eventListeners.js");
var _eventListenersJsDefault = parcelHelpers.interopDefault(_eventListenersJs);
var _popperOffsetsJs = require("./modifiers/popperOffsets.js");
var _popperOffsetsJsDefault = parcelHelpers.interopDefault(_popperOffsetsJs);
var _computeStylesJs = require("./modifiers/computeStyles.js");
var _computeStylesJsDefault = parcelHelpers.interopDefault(_computeStylesJs);
var _applyStylesJs = require("./modifiers/applyStyles.js");
var _applyStylesJsDefault = parcelHelpers.interopDefault(_applyStylesJs);
var defaultModifiers = [
    (0, _eventListenersJsDefault.default),
    (0, _popperOffsetsJsDefault.default),
    (0, _computeStylesJsDefault.default),
    (0, _applyStylesJsDefault.default)
];
var createPopper = /*#__PURE__*/ (0, _createPopperJs.popperGenerator)({
    defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

},{"./createPopper.js":"cHuNp","./modifiers/eventListeners.js":"hBKsL","./modifiers/popperOffsets.js":"6I679","./modifiers/computeStyles.js":"gDlm2","./modifiers/applyStyles.js":"4iMn4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b5QA5":[function(require,module,exports) {
module.exports = require("3ccfc8d60c78d8b5").getBundleURL("2MSMO") + "clouds_sun_sunny_icon.ec51c535.svg" + "?" + Date.now();

},{"3ccfc8d60c78d8b5":"lgJ39"}],"lgJ39":[function(require,module,exports) {
"use strict";
var bundleURL = {};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ("" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return "/";
}
function getBaseURL(url) {
    return ("" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/.+)\/[^/]+$/, "$1") + "/";
}
// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ("" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^/]+/);
    if (!matches) throw new Error("Origin not found");
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"d8NN9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _chartJs = require("../dist/chart.js");
parcelHelpers.exportAll(_chartJs, exports);
(0, _chartJs.Chart).register(...(0, _chartJs.registerables));
exports.default = (0, _chartJs.Chart);

},{"../dist/chart.js":"ipU8D","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ipU8D":[function(require,module,exports) {
/*!
 * Chart.js v4.4.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Animation", ()=>Animation);
parcelHelpers.export(exports, "Animations", ()=>Animations);
parcelHelpers.export(exports, "ArcElement", ()=>ArcElement);
parcelHelpers.export(exports, "BarController", ()=>BarController);
parcelHelpers.export(exports, "BarElement", ()=>BarElement);
parcelHelpers.export(exports, "BasePlatform", ()=>BasePlatform);
parcelHelpers.export(exports, "BasicPlatform", ()=>BasicPlatform);
parcelHelpers.export(exports, "BubbleController", ()=>BubbleController);
parcelHelpers.export(exports, "CategoryScale", ()=>CategoryScale);
parcelHelpers.export(exports, "Chart", ()=>Chart);
parcelHelpers.export(exports, "Colors", ()=>plugin_colors);
parcelHelpers.export(exports, "DatasetController", ()=>DatasetController);
parcelHelpers.export(exports, "Decimation", ()=>plugin_decimation);
parcelHelpers.export(exports, "DomPlatform", ()=>DomPlatform);
parcelHelpers.export(exports, "DoughnutController", ()=>DoughnutController);
parcelHelpers.export(exports, "Element", ()=>Element);
parcelHelpers.export(exports, "Filler", ()=>index);
parcelHelpers.export(exports, "Interaction", ()=>Interaction);
parcelHelpers.export(exports, "Legend", ()=>plugin_legend);
parcelHelpers.export(exports, "LineController", ()=>LineController);
parcelHelpers.export(exports, "LineElement", ()=>LineElement);
parcelHelpers.export(exports, "LinearScale", ()=>LinearScale);
parcelHelpers.export(exports, "LogarithmicScale", ()=>LogarithmicScale);
parcelHelpers.export(exports, "PieController", ()=>PieController);
parcelHelpers.export(exports, "PointElement", ()=>PointElement);
parcelHelpers.export(exports, "PolarAreaController", ()=>PolarAreaController);
parcelHelpers.export(exports, "RadarController", ()=>RadarController);
parcelHelpers.export(exports, "RadialLinearScale", ()=>RadialLinearScale);
parcelHelpers.export(exports, "Scale", ()=>Scale);
parcelHelpers.export(exports, "ScatterController", ()=>ScatterController);
parcelHelpers.export(exports, "SubTitle", ()=>plugin_subtitle);
parcelHelpers.export(exports, "Ticks", ()=>(0, _helpersSegmentJs.aL));
parcelHelpers.export(exports, "TimeScale", ()=>TimeScale);
parcelHelpers.export(exports, "TimeSeriesScale", ()=>TimeSeriesScale);
parcelHelpers.export(exports, "Title", ()=>plugin_title);
parcelHelpers.export(exports, "Tooltip", ()=>plugin_tooltip);
parcelHelpers.export(exports, "_adapters", ()=>adapters);
parcelHelpers.export(exports, "_detectPlatform", ()=>_detectPlatform);
parcelHelpers.export(exports, "animator", ()=>animator);
parcelHelpers.export(exports, "controllers", ()=>controllers);
parcelHelpers.export(exports, "defaults", ()=>(0, _helpersSegmentJs.d));
parcelHelpers.export(exports, "elements", ()=>elements);
parcelHelpers.export(exports, "layouts", ()=>layouts);
parcelHelpers.export(exports, "plugins", ()=>plugins);
parcelHelpers.export(exports, "registerables", ()=>registerables);
parcelHelpers.export(exports, "registry", ()=>registry);
parcelHelpers.export(exports, "scales", ()=>scales);
var _helpersSegmentJs = require("./chunks/helpers.segment.js");
var _color = require("@kurkle/color");
class Animator {
    constructor(){
        this._request = null;
        this._charts = new Map();
        this._running = false;
        this._lastDate = undefined;
    }
    _notify(chart, anims, date, type) {
        const callbacks = anims.listeners[type];
        const numSteps = anims.duration;
        callbacks.forEach((fn)=>fn({
                chart,
                initial: anims.initial,
                numSteps,
                currentStep: Math.min(date - anims.start, numSteps)
            }));
    }
    _refresh() {
        if (this._request) return;
        this._running = true;
        this._request = (0, _helpersSegmentJs.r).call(window, ()=>{
            this._update();
            this._request = null;
            if (this._running) this._refresh();
        });
    }
    _update(date = Date.now()) {
        let remaining = 0;
        this._charts.forEach((anims, chart)=>{
            if (!anims.running || !anims.items.length) return;
            const items = anims.items;
            let i = items.length - 1;
            let draw = false;
            let item;
            for(; i >= 0; --i){
                item = items[i];
                if (item._active) {
                    if (item._total > anims.duration) anims.duration = item._total;
                    item.tick(date);
                    draw = true;
                } else {
                    items[i] = items[items.length - 1];
                    items.pop();
                }
            }
            if (draw) {
                chart.draw();
                this._notify(chart, anims, date, "progress");
            }
            if (!items.length) {
                anims.running = false;
                this._notify(chart, anims, date, "complete");
                anims.initial = false;
            }
            remaining += items.length;
        });
        this._lastDate = date;
        if (remaining === 0) this._running = false;
    }
    _getAnims(chart) {
        const charts = this._charts;
        let anims = charts.get(chart);
        if (!anims) {
            anims = {
                running: false,
                initial: true,
                items: [],
                listeners: {
                    complete: [],
                    progress: []
                }
            };
            charts.set(chart, anims);
        }
        return anims;
    }
    listen(chart, event, cb) {
        this._getAnims(chart).listeners[event].push(cb);
    }
    add(chart, items) {
        if (!items || !items.length) return;
        this._getAnims(chart).items.push(...items);
    }
    has(chart) {
        return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
        const anims = this._charts.get(chart);
        if (!anims) return;
        anims.running = true;
        anims.start = Date.now();
        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);
        this._refresh();
    }
    running(chart) {
        if (!this._running) return false;
        const anims = this._charts.get(chart);
        if (!anims || !anims.running || !anims.items.length) return false;
        return true;
    }
    stop(chart) {
        const anims = this._charts.get(chart);
        if (!anims || !anims.items.length) return;
        const items = anims.items;
        let i = items.length - 1;
        for(; i >= 0; --i)items[i].cancel();
        anims.items = [];
        this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
        return this._charts.delete(chart);
    }
}
var animator = /* #__PURE__ */ new Animator();
const transparent = "transparent";
const interpolators = {
    boolean (from, to, factor) {
        return factor > 0.5 ? to : from;
    },
    color (from, to, factor) {
        const c0 = (0, _helpersSegmentJs.c)(from || transparent);
        const c1 = c0.valid && (0, _helpersSegmentJs.c)(to || transparent);
        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
    },
    number (from, to, factor) {
        return from + (to - from) * factor;
    }
};
class Animation {
    constructor(cfg, target, prop, to){
        const currentValue = target[prop];
        to = (0, _helpersSegmentJs.a)([
            cfg.to,
            to,
            currentValue,
            cfg.from
        ]);
        const from = (0, _helpersSegmentJs.a)([
            cfg.from,
            currentValue,
            to
        ]);
        this._active = true;
        this._fn = cfg.fn || interpolators[cfg.type || typeof from];
        this._easing = (0, _helpersSegmentJs.e)[cfg.easing] || (0, _helpersSegmentJs.e).linear;
        this._start = Math.floor(Date.now() + (cfg.delay || 0));
        this._duration = this._total = Math.floor(cfg.duration);
        this._loop = !!cfg.loop;
        this._target = target;
        this._prop = prop;
        this._from = from;
        this._to = to;
        this._promises = undefined;
    }
    active() {
        return this._active;
    }
    update(cfg, to, date) {
        if (this._active) {
            this._notify(false);
            const currentValue = this._target[this._prop];
            const elapsed = date - this._start;
            const remain = this._duration - elapsed;
            this._start = date;
            this._duration = Math.floor(Math.max(remain, cfg.duration));
            this._total += elapsed;
            this._loop = !!cfg.loop;
            this._to = (0, _helpersSegmentJs.a)([
                cfg.to,
                to,
                currentValue,
                cfg.from
            ]);
            this._from = (0, _helpersSegmentJs.a)([
                cfg.from,
                currentValue,
                to
            ]);
        }
    }
    cancel() {
        if (this._active) {
            this.tick(Date.now());
            this._active = false;
            this._notify(false);
        }
    }
    tick(date) {
        const elapsed = date - this._start;
        const duration = this._duration;
        const prop = this._prop;
        const from = this._from;
        const loop = this._loop;
        const to = this._to;
        let factor;
        this._active = from !== to && (loop || elapsed < duration);
        if (!this._active) {
            this._target[prop] = to;
            this._notify(true);
            return;
        }
        if (elapsed < 0) {
            this._target[prop] = from;
            return;
        }
        factor = elapsed / duration % 2;
        factor = loop && factor > 1 ? 2 - factor : factor;
        factor = this._easing(Math.min(1, Math.max(0, factor)));
        this._target[prop] = this._fn(from, to, factor);
    }
    wait() {
        const promises = this._promises || (this._promises = []);
        return new Promise((res, rej)=>{
            promises.push({
                res,
                rej
            });
        });
    }
    _notify(resolved) {
        const method = resolved ? "res" : "rej";
        const promises = this._promises || [];
        for(let i = 0; i < promises.length; i++)promises[i][method]();
    }
}
class Animations {
    constructor(chart, config){
        this._chart = chart;
        this._properties = new Map();
        this.configure(config);
    }
    configure(config) {
        if (!(0, _helpersSegmentJs.i)(config)) return;
        const animationOptions = Object.keys((0, _helpersSegmentJs.d).animation);
        const animatedProps = this._properties;
        Object.getOwnPropertyNames(config).forEach((key)=>{
            const cfg = config[key];
            if (!(0, _helpersSegmentJs.i)(cfg)) return;
            const resolved = {};
            for (const option of animationOptions)resolved[option] = cfg[option];
            ((0, _helpersSegmentJs.b)(cfg.properties) && cfg.properties || [
                key
            ]).forEach((prop)=>{
                if (prop === key || !animatedProps.has(prop)) animatedProps.set(prop, resolved);
            });
        });
    }
    _animateOptions(target, values) {
        const newOptions = values.options;
        const options = resolveTargetOptions(target, newOptions);
        if (!options) return [];
        const animations = this._createAnimations(options, newOptions);
        if (newOptions.$shared) awaitAll(target.options.$animations, newOptions).then(()=>{
            target.options = newOptions;
        }, ()=>{});
        return animations;
    }
    _createAnimations(target, values) {
        const animatedProps = this._properties;
        const animations = [];
        const running = target.$animations || (target.$animations = {});
        const props = Object.keys(values);
        const date = Date.now();
        let i;
        for(i = props.length - 1; i >= 0; --i){
            const prop = props[i];
            if (prop.charAt(0) === "$") continue;
            if (prop === "options") {
                animations.push(...this._animateOptions(target, values));
                continue;
            }
            const value = values[prop];
            let animation = running[prop];
            const cfg = animatedProps.get(prop);
            if (animation) {
                if (cfg && animation.active()) {
                    animation.update(cfg, value, date);
                    continue;
                } else animation.cancel();
            }
            if (!cfg || !cfg.duration) {
                target[prop] = value;
                continue;
            }
            running[prop] = animation = new Animation(cfg, target, prop, value);
            animations.push(animation);
        }
        return animations;
    }
    update(target, values) {
        if (this._properties.size === 0) {
            Object.assign(target, values);
            return;
        }
        const animations = this._createAnimations(target, values);
        if (animations.length) {
            animator.add(this._chart, animations);
            return true;
        }
    }
}
function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for(let i = 0; i < keys.length; i++){
        const anim = animations[keys[i]];
        if (anim && anim.active()) running.push(anim.wait());
    }
    return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
    if (!newOptions) return;
    let options = target.options;
    if (!options) {
        target.options = newOptions;
        return;
    }
    if (options.$shared) target.options = options = Object.assign({}, options, {
        $shared: false,
        $animations: {}
    });
    return options;
}
function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min = opts.min === undefined ? allowedOverflow : 0;
    const max = opts.max === undefined ? allowedOverflow : 0;
    return {
        start: reverse ? max : min,
        end: reverse ? min : max
    };
}
function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) return false;
    const x = scaleClip(xScale, allowedOverflow);
    const y = scaleClip(yScale, allowedOverflow);
    return {
        top: y.end,
        right: x.end,
        bottom: y.start,
        left: x.start
    };
}
function toClip(value) {
    let t, r, b, l;
    if ((0, _helpersSegmentJs.i)(value)) {
        t = value.top;
        r = value.right;
        b = value.bottom;
        l = value.left;
    } else t = r = b = l = value;
    return {
        top: t,
        right: r,
        bottom: b,
        left: l,
        disabled: value === false
    };
}
function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i, ilen;
    for(i = 0, ilen = metasets.length; i < ilen; ++i)keys.push(metasets[i].index);
    return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === "single";
    let i, ilen, datasetIndex, otherValue;
    if (value === null) return;
    for(i = 0, ilen = keys.length; i < ilen; ++i){
        datasetIndex = +keys[i];
        if (datasetIndex === dsIndex) {
            if (options.all) continue;
            break;
        }
        otherValue = stack.values[datasetIndex];
        if ((0, _helpersSegmentJs.g)(otherValue) && (singleMode || value === 0 || (0, _helpersSegmentJs.s)(value) === (0, _helpersSegmentJs.s)(otherValue))) value += otherValue;
    }
    return value;
}
function convertObjectDataToArray(data) {
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i, ilen, key;
    for(i = 0, ilen = keys.length; i < ilen; ++i){
        key = keys[i];
        adata[i] = {
            x: key,
            y: data[key]
        };
    }
    return adata;
}
function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === undefined && meta.stack !== undefined;
}
function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
    const { min, max, minDefined, maxDefined } = scale.getUserBounds();
    return {
        min: minDefined ? min : Number.NEGATIVE_INFINITY,
        max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){
        const value = stack[meta.index];
        if (positive && value > 0 || !positive && value < 0) return meta.index;
    }
    return null;
}
function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for(let i = 0; i < ilen; ++i){
        const item = parsed[i];
        const { [iAxis]: index, [vAxis]: value } = item;
        const itemStacks = item._stacks || (item._stacks = {});
        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
        stack[datasetIndex] = value;
        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
        const visualValues = stack._visualValues || (stack._visualValues = {});
        visualValues[datasetIndex] = value;
    }
}
function getFirstScaleId(chart, axis) {
    const scales = chart.scales;
    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
    return (0, _helpersSegmentJs.j)(parent, {
        active: false,
        dataset: undefined,
        datasetIndex: index,
        index,
        mode: "default",
        type: "dataset"
    });
}
function createDataContext(parent, index, element) {
    return (0, _helpersSegmentJs.j)(parent, {
        active: false,
        dataIndex: index,
        parsed: undefined,
        raw: undefined,
        element,
        index,
        mode: "default",
        type: "data"
    });
}
function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) return;
    items = items || meta._parsed;
    for (const parsed of items){
        const stacks = parsed._stacks;
        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) return;
        delete stacks[axis][datasetIndex];
        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) delete stacks[axis]._visualValues[datasetIndex];
    }
}
const isDirectUpdateMode = (mode)=>mode === "reset" || mode === "none";
const cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {
        keys: getSortedDatasetIndices(chart, true),
        values: null
    };
class DatasetController {
    static defaults = {};
    static datasetElementType = null;
    static dataElementType = null;
    constructor(chart, datasetIndex){
        this.chart = chart;
        this._ctx = chart.ctx;
        this.index = datasetIndex;
        this._cachedDataOpts = {};
        this._cachedMeta = this.getMeta();
        this._type = this._cachedMeta.type;
        this.options = undefined;
        this._parsing = false;
        this._data = undefined;
        this._objectData = undefined;
        this._sharedOptions = undefined;
        this._drawStart = undefined;
        this._drawCount = undefined;
        this.enableOptionSharing = false;
        this.supportsDecimation = false;
        this.$context = undefined;
        this._syncList = [];
        this.datasetElementType = new.target.datasetElementType;
        this.dataElementType = new.target.dataElementType;
        this.initialize();
    }
    initialize() {
        const meta = this._cachedMeta;
        this.configure();
        this.linkScales();
        meta._stacked = isStacked(meta.vScale, meta);
        this.addElements();
        if (this.options.fill && !this.chart.isPluginEnabled("filler")) console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
    updateIndex(datasetIndex) {
        if (this.index !== datasetIndex) clearStacks(this._cachedMeta);
        this.index = datasetIndex;
    }
    linkScales() {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        const chooseId = (axis, x, y, r)=>axis === "x" ? x : axis === "r" ? r : y;
        const xid = meta.xAxisID = (0, _helpersSegmentJs.v)(dataset.xAxisID, getFirstScaleId(chart, "x"));
        const yid = meta.yAxisID = (0, _helpersSegmentJs.v)(dataset.yAxisID, getFirstScaleId(chart, "y"));
        const rid = meta.rAxisID = (0, _helpersSegmentJs.v)(dataset.rAxisID, getFirstScaleId(chart, "r"));
        const indexAxis = meta.indexAxis;
        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
        meta.xScale = this.getScaleForId(xid);
        meta.yScale = this.getScaleForId(yid);
        meta.rScale = this.getScaleForId(rid);
        meta.iScale = this.getScaleForId(iid);
        meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
        return this.chart.data.datasets[this.index];
    }
    getMeta() {
        return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
        return this.chart.scales[scaleID];
    }
    _getOtherScale(scale) {
        const meta = this._cachedMeta;
        return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
        this._update("reset");
    }
    _destroy() {
        const meta = this._cachedMeta;
        if (this._data) (0, _helpersSegmentJs.u)(this._data, this);
        if (meta._stacked) clearStacks(meta);
    }
    _dataCheck() {
        const dataset = this.getDataset();
        const data = dataset.data || (dataset.data = []);
        const _data = this._data;
        if ((0, _helpersSegmentJs.i)(data)) this._data = convertObjectDataToArray(data);
        else if (_data !== data) {
            if (_data) {
                (0, _helpersSegmentJs.u)(_data, this);
                const meta = this._cachedMeta;
                clearStacks(meta);
                meta._parsed = [];
            }
            if (data && Object.isExtensible(data)) (0, _helpersSegmentJs.l)(data, this);
            this._syncList = [];
            this._data = data;
        }
    }
    addElements() {
        const meta = this._cachedMeta;
        this._dataCheck();
        if (this.datasetElementType) meta.dataset = new this.datasetElementType();
    }
    buildOrUpdateElements(resetNewElements) {
        const meta = this._cachedMeta;
        const dataset = this.getDataset();
        let stackChanged = false;
        this._dataCheck();
        const oldStacked = meta._stacked;
        meta._stacked = isStacked(meta.vScale, meta);
        if (meta.stack !== dataset.stack) {
            stackChanged = true;
            clearStacks(meta);
            meta.stack = dataset.stack;
        }
        this._resyncElements(resetNewElements);
        if (stackChanged || oldStacked !== meta._stacked) updateStacks(this, meta._parsed);
    }
    configure() {
        const config = this.chart.config;
        const scopeKeys = config.datasetScopeKeys(this._type);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
        this.options = config.createResolver(scopes, this.getContext());
        this._parsing = this.options.parsing;
        this._cachedDataOpts = {};
    }
    parse(start, count) {
        const { _cachedMeta: meta, _data: data } = this;
        const { iScale, _stacked } = meta;
        const iAxis = iScale.axis;
        let sorted = start === 0 && count === data.length ? true : meta._sorted;
        let prev = start > 0 && meta._parsed[start - 1];
        let i, cur, parsed;
        if (this._parsing === false) {
            meta._parsed = data;
            meta._sorted = true;
            parsed = data;
        } else {
            if ((0, _helpersSegmentJs.b)(data[start])) parsed = this.parseArrayData(meta, data, start, count);
            else if ((0, _helpersSegmentJs.i)(data[start])) parsed = this.parseObjectData(meta, data, start, count);
            else parsed = this.parsePrimitiveData(meta, data, start, count);
            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
            for(i = 0; i < count; ++i){
                meta._parsed[i + start] = cur = parsed[i];
                if (sorted) {
                    if (isNotInOrderComparedToPrev()) sorted = false;
                    prev = cur;
                }
            }
            meta._sorted = sorted;
        }
        if (_stacked) updateStacks(this, parsed);
    }
    parsePrimitiveData(meta, data, start, count) {
        const { iScale, vScale } = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = new Array(count);
        let i, ilen, index;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            parsed[i] = {
                [iAxis]: singleScale || iScale.parse(labels[index], index),
                [vAxis]: vScale.parse(data[index], index)
            };
        }
        return parsed;
    }
    parseArrayData(meta, data, start, count) {
        const { xScale, yScale } = meta;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            item = data[index];
            parsed[i] = {
                x: xScale.parse(item[0], index),
                y: yScale.parse(item[1], index)
            };
        }
        return parsed;
    }
    parseObjectData(meta, data, start, count) {
        const { xScale, yScale } = meta;
        const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
        const parsed = new Array(count);
        let i, ilen, index, item;
        for(i = 0, ilen = count; i < ilen; ++i){
            index = i + start;
            item = data[index];
            parsed[i] = {
                x: xScale.parse((0, _helpersSegmentJs.f)(item, xAxisKey), index),
                y: yScale.parse((0, _helpersSegmentJs.f)(item, yAxisKey), index)
            };
        }
        return parsed;
    }
    getParsed(index) {
        return this._cachedMeta._parsed[index];
    }
    getDataElement(index) {
        return this._cachedMeta.data[index];
    }
    applyStack(scale, parsed, mode) {
        const chart = this.chart;
        const meta = this._cachedMeta;
        const value = parsed[scale.axis];
        const stack = {
            keys: getSortedDatasetIndices(chart, true),
            values: parsed._stacks[scale.axis]._visualValues
        };
        return applyStack(stack, value, meta.index, {
            mode
        });
    }
    updateRangeFromParsed(range, scale, parsed, stack) {
        const parsedValue = parsed[scale.axis];
        let value = parsedValue === null ? NaN : parsedValue;
        const values = stack && parsed._stacks[scale.axis];
        if (stack && values) {
            stack.values = values;
            value = applyStack(stack, parsedValue, this._cachedMeta.index);
        }
        range.min = Math.min(range.min, value);
        range.max = Math.max(range.max, value);
    }
    getMinMax(scale, canStack) {
        const meta = this._cachedMeta;
        const _parsed = meta._parsed;
        const sorted = meta._sorted && scale === meta.iScale;
        const ilen = _parsed.length;
        const otherScale = this._getOtherScale(scale);
        const stack = createStack(canStack, meta, this.chart);
        const range = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        };
        const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
        let i, parsed;
        function _skip() {
            parsed = _parsed[i];
            const otherValue = parsed[otherScale.axis];
            return !(0, _helpersSegmentJs.g)(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
        }
        for(i = 0; i < ilen; ++i){
            if (_skip()) continue;
            this.updateRangeFromParsed(range, scale, parsed, stack);
            if (sorted) break;
        }
        if (sorted) for(i = ilen - 1; i >= 0; --i){
            if (_skip()) continue;
            this.updateRangeFromParsed(range, scale, parsed, stack);
            break;
        }
        return range;
    }
    getAllParsedValues(scale) {
        const parsed = this._cachedMeta._parsed;
        const values = [];
        let i, ilen, value;
        for(i = 0, ilen = parsed.length; i < ilen; ++i){
            value = parsed[i][scale.axis];
            if ((0, _helpersSegmentJs.g)(value)) values.push(value);
        }
        return values;
    }
    getMaxOverflow() {
        return false;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const parsed = this.getParsed(index);
        return {
            label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
            value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
        };
    }
    _update(mode) {
        const meta = this._cachedMeta;
        this.update(mode || "default");
        meta._clip = toClip((0, _helpersSegmentJs.v)(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
    update(mode) {}
    draw() {
        const ctx = this._ctx;
        const chart = this.chart;
        const meta = this._cachedMeta;
        const elements = meta.data || [];
        const area = chart.chartArea;
        const active = [];
        const start = this._drawStart || 0;
        const count = this._drawCount || elements.length - start;
        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
        let i;
        if (meta.dataset) meta.dataset.draw(ctx, area, start, count);
        for(i = start; i < start + count; ++i){
            const element = elements[i];
            if (element.hidden) continue;
            if (element.active && drawActiveElementsOnTop) active.push(element);
            else element.draw(ctx, area);
        }
        for(i = 0; i < active.length; ++i)active[i].draw(ctx, area);
    }
    getStyle(index, active) {
        const mode = active ? "active" : "default";
        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
    }
    getContext(index, active, mode) {
        const dataset = this.getDataset();
        let context;
        if (index >= 0 && index < this._cachedMeta.data.length) {
            const element = this._cachedMeta.data[index];
            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
            context.parsed = this.getParsed(index);
            context.raw = dataset.data[index];
            context.index = context.dataIndex = index;
        } else {
            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
            context.dataset = dataset;
            context.index = context.datasetIndex = this.index;
        }
        context.active = !!active;
        context.mode = mode;
        return context;
    }
    resolveDatasetElementOptions(mode) {
        return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index, mode) {
        return this._resolveElementOptions(this.dataElementType.id, mode, index);
    }
    _resolveElementOptions(elementType, mode = "default", index) {
        const active = mode === "active";
        const cache = this._cachedDataOpts;
        const cacheKey = elementType + "-" + mode;
        const cached = cache[cacheKey];
        const sharing = this.enableOptionSharing && (0, _helpersSegmentJs.h)(index);
        if (cached) return cloneIfNotShared(cached, sharing);
        const config = this.chart.config;
        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
        const prefixes = active ? [
            `${elementType}Hover`,
            "hover",
            elementType,
            ""
        ] : [
            elementType,
            ""
        ];
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        const names = Object.keys((0, _helpersSegmentJs.d).elements[elementType]);
        const context = ()=>this.getContext(index, active, mode);
        const values = config.resolveNamedOptions(scopes, names, context, prefixes);
        if (values.$shared) {
            values.$shared = sharing;
            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
        }
        return values;
    }
    _resolveAnimations(index, transition, active) {
        const chart = this.chart;
        const cache = this._cachedDataOpts;
        const cacheKey = `animation-${transition}`;
        const cached = cache[cacheKey];
        if (cached) return cached;
        let options;
        if (chart.options.animation !== false) {
            const config = this.chart.config;
            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            options = config.createResolver(scopes, this.getContext(index, active, transition));
        }
        const animations = new Animations(chart, options && options.animations);
        if (options && options._cacheable) cache[cacheKey] = Object.freeze(animations);
        return animations;
    }
    getSharedOptions(options) {
        if (!options.$shared) return;
        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
    includeOptions(mode, sharedOptions) {
        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start, mode) {
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const previouslySharedOptions = this._sharedOptions;
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
        return {
            sharedOptions,
            includeOptions
        };
    }
    updateElement(element, index, properties, mode) {
        if (isDirectUpdateMode(mode)) Object.assign(element, properties);
        else this._resolveAnimations(index, mode).update(element, properties);
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
        if (sharedOptions && !isDirectUpdateMode(mode)) this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
    }
    _setStyle(element, index, mode, active) {
        element.active = active;
        const options = this.getStyle(index, active);
        this._resolveAnimations(index, mode, active).update(element, {
            options: !active && this.getSharedOptions(options) || options
        });
    }
    removeHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, "active", false);
    }
    setHoverStyle(element, datasetIndex, index) {
        this._setStyle(element, index, "active", true);
    }
    _removeDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) this._setStyle(element, undefined, "active", false);
    }
    _setDatasetHoverStyle() {
        const element = this._cachedMeta.dataset;
        if (element) this._setStyle(element, undefined, "active", true);
    }
    _resyncElements(resetNewElements) {
        const data = this._data;
        const elements = this._cachedMeta.data;
        for (const [method, arg1, arg2] of this._syncList)this[method](arg1, arg2);
        this._syncList = [];
        const numMeta = elements.length;
        const numData = data.length;
        const count = Math.min(numData, numMeta);
        if (count) this.parse(0, count);
        if (numData > numMeta) this._insertElements(numMeta, numData - numMeta, resetNewElements);
        else if (numData < numMeta) this._removeElements(numData, numMeta - numData);
    }
    _insertElements(start, count, resetNewElements = true) {
        const meta = this._cachedMeta;
        const data = meta.data;
        const end = start + count;
        let i;
        const move = (arr)=>{
            arr.length += count;
            for(i = arr.length - 1; i >= end; i--)arr[i] = arr[i - count];
        };
        move(data);
        for(i = start; i < end; ++i)data[i] = new this.dataElementType();
        if (this._parsing) move(meta._parsed);
        this.parse(start, count);
        if (resetNewElements) this.updateElements(data, start, count, "reset");
    }
    updateElements(element, start, count, mode) {}
    _removeElements(start, count) {
        const meta = this._cachedMeta;
        if (this._parsing) {
            const removed = meta._parsed.splice(start, count);
            if (meta._stacked) clearStacks(meta, removed);
        }
        meta.data.splice(start, count);
    }
    _sync(args) {
        if (this._parsing) this._syncList.push(args);
        else {
            const [method, arg1, arg2] = args;
            this[method](arg1, arg2);
        }
        this.chart._dataChanges.push([
            this.index,
            ...args
        ]);
    }
    _onDataPush() {
        const count = arguments.length;
        this._sync([
            "_insertElements",
            this.getDataset().data.length - count,
            count
        ]);
    }
    _onDataPop() {
        this._sync([
            "_removeElements",
            this._cachedMeta.data.length - 1,
            1
        ]);
    }
    _onDataShift() {
        this._sync([
            "_removeElements",
            0,
            1
        ]);
    }
    _onDataSplice(start, count) {
        if (count) this._sync([
            "_removeElements",
            start,
            count
        ]);
        const newCount = arguments.length - 2;
        if (newCount) this._sync([
            "_insertElements",
            start,
            newCount
        ]);
    }
    _onDataUnshift() {
        this._sync([
            "_insertElements",
            0,
            arguments.length
        ]);
    }
}
function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
        const visibleMetas = scale.getMatchingVisibleMetas(type);
        let values = [];
        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++)values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
        scale._cache.$bar = (0, _helpersSegmentJs._)(values.sort((a, b)=>a - b));
    }
    return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min = scale._length;
    let i, ilen, curr, prev;
    const updateMinAndPrev = ()=>{
        if (curr === 32767 || curr === -32768) return;
        if ((0, _helpersSegmentJs.h)(prev)) min = Math.min(min, Math.abs(curr - prev) || min);
        prev = curr;
    };
    for(i = 0, ilen = values.length; i < ilen; ++i){
        curr = scale.getPixelForValue(values[i]);
        updateMinAndPrev();
    }
    prev = undefined;
    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){
        curr = scale.getPixelForTick(i);
        updateMinAndPrev();
    }
    return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if ((0, _helpersSegmentJs.k)(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
    } else {
        size = thickness * stackCount;
        ratio = 1;
    }
    return {
        chunk: size / stackCount,
        ratio,
        start: ruler.pixels[index] - size / 2
    };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index];
    let prev = index > 0 ? pixels[index - 1] : null;
    let next = index < pixels.length - 1 ? pixels[index + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    if (next === null) next = curr + curr - prev;
    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
        chunk: size / stackCount,
        ratio: options.barPercentage,
        start
    };
}
function parseFloatBar(entry, item, vScale, i) {
    const startValue = vScale.parse(entry[0], i);
    const endValue = vScale.parse(entry[1], i);
    const min = Math.min(startValue, endValue);
    const max = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
        barStart = max;
        barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
        barStart,
        barEnd,
        start: startValue,
        end: endValue,
        min,
        max
    };
}
function parseValue(entry, item, vScale, i) {
    if ((0, _helpersSegmentJs.b)(entry)) parseFloatBar(entry, item, vScale, i);
    else item[vScale.axis] = vScale.parse(entry, i);
    return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i, ilen, item, entry;
    for(i = start, ilen = start + count; i < ilen; ++i){
        entry = data[i];
        item = {};
        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
        parsed.push(parseValue(entry, item, vScale, i));
    }
    return parsed;
}
function isFloatBar(custom) {
    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
}
function barSign(size, vScale, actualBase) {
    if (size !== 0) return (0, _helpersSegmentJs.s)(size);
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
    let reverse, start, end, top, bottom;
    if (properties.horizontal) {
        reverse = properties.base > properties.x;
        start = "left";
        end = "right";
    } else {
        reverse = properties.base < properties.y;
        start = "bottom";
        end = "top";
    }
    if (reverse) {
        top = "end";
        bottom = "start";
    } else {
        top = "start";
        bottom = "end";
    }
    return {
        start,
        end,
        reverse,
        top,
        bottom
    };
}
function setBorderSkipped(properties, options, stack, index) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
        properties.borderSkipped = res;
        return;
    }
    if (edge === true) {
        properties.borderSkipped = {
            top: true,
            right: true,
            bottom: true,
            left: true
        };
        return;
    }
    const { start, end, reverse, top, bottom } = borderProps(properties);
    if (edge === "middle" && stack) {
        properties.enableBorderRadius = true;
        if ((stack._top || 0) === index) edge = top;
        else if ((stack._bottom || 0) === index) edge = bottom;
        else {
            res[parseEdge(bottom, start, end, reverse)] = true;
            edge = top;
        }
    }
    res[parseEdge(edge, start, end, reverse)] = true;
    properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
    if (reverse) {
        edge = swap(edge, a, b);
        edge = startEnd(edge, b, a);
    } else edge = startEnd(edge, a, b);
    return edge;
}
function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
    return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
class BarController extends DatasetController {
    static id = "bar";
    static defaults = {
        datasetElementType: false,
        dataElementType: "bar",
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        grouped: true,
        animations: {
            numbers: {
                type: "number",
                properties: [
                    "x",
                    "y",
                    "base",
                    "width",
                    "height"
                ]
            }
        }
    };
    static overrides = {
        scales: {
            _index_: {
                type: "category",
                offset: true,
                grid: {
                    offset: true
                }
            },
            _value_: {
                type: "linear",
                beginAtZero: true
            }
        }
    };
    parsePrimitiveData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseArrayData(meta, data, start, count) {
        return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseObjectData(meta, data, start, count) {
        const { iScale, vScale } = meta;
        const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
        const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
        const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
        const parsed = [];
        let i, ilen, item, obj;
        for(i = start, ilen = start + count; i < ilen; ++i){
            obj = data[i];
            item = {};
            item[iScale.axis] = iScale.parse((0, _helpersSegmentJs.f)(obj, iAxisKey), i);
            parsed.push(parseValue((0, _helpersSegmentJs.f)(obj, vAxisKey), item, vScale, i));
        }
        return parsed;
    }
    updateRangeFromParsed(range, scale, parsed, stack) {
        super.updateRangeFromParsed(range, scale, parsed, stack);
        const custom = parsed._custom;
        if (custom && scale === this._cachedMeta.vScale) {
            range.min = Math.min(range.min, custom.min);
            range.max = Math.max(range.max, custom.max);
        }
    }
    getMaxOverflow() {
        return 0;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const { iScale, vScale } = meta;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
        return {
            label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
            value
        };
    }
    initialize() {
        this.enableOptionSharing = true;
        super.initialize();
        const meta = this._cachedMeta;
        meta.stack = this.getDataset().stack;
    }
    update(mode) {
        const meta = this._cachedMeta;
        this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start, count, mode) {
        const reset = mode === "reset";
        const { index, _cachedMeta: { vScale } } = this;
        const base = vScale.getBasePixel();
        const horizontal = vScale.isHorizontal();
        const ruler = this._getRuler();
        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
        for(let i = start; i < start + count; i++){
            const parsed = this.getParsed(i);
            const vpixels = reset || (0, _helpersSegmentJs.k)(parsed[vScale.axis]) ? {
                base,
                head: base
            } : this._calculateBarValuePixels(i);
            const ipixels = this._calculateBarIndexPixels(i, ruler);
            const stack = (parsed._stacks || {})[vScale.axis];
            const properties = {
                horizontal,
                base: vpixels.base,
                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
                x: horizontal ? vpixels.head : ipixels.center,
                y: horizontal ? ipixels.center : vpixels.head,
                height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                width: horizontal ? Math.abs(vpixels.size) : ipixels.size
            };
            if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
            const options = properties.options || bars[i].options;
            setBorderSkipped(properties, options, stack, index);
            setInflateAmount(properties, options, ruler.ratio);
            this.updateElement(bars[i], i, properties, mode);
        }
    }
    _getStacks(last, dataIndex) {
        const { iScale } = this._cachedMeta;
        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);
        const stacked = iScale.options.stacked;
        const stacks = [];
        const skipNull = (meta)=>{
            const parsed = meta.controller.getParsed(dataIndex);
            const val = parsed && parsed[meta.vScale.axis];
            if ((0, _helpersSegmentJs.k)(val) || isNaN(val)) return true;
        };
        for (const meta of metasets){
            if (dataIndex !== undefined && skipNull(meta)) continue;
            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) stacks.push(meta.stack);
            if (meta.index === last) break;
        }
        if (!stacks.length) stacks.push(undefined);
        return stacks;
    }
    _getStackCount(index) {
        return this._getStacks(undefined, index).length;
    }
    _getStackIndex(datasetIndex, name, dataIndex) {
        const stacks = this._getStacks(datasetIndex, dataIndex);
        const index = name !== undefined ? stacks.indexOf(name) : -1;
        return index === -1 ? stacks.length - 1 : index;
    }
    _getRuler() {
        const opts = this.options;
        const meta = this._cachedMeta;
        const iScale = meta.iScale;
        const pixels = [];
        let i, ilen;
        for(i = 0, ilen = meta.data.length; i < ilen; ++i)pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
        const barThickness = opts.barThickness;
        const min = barThickness || computeMinSampleSize(meta);
        return {
            min,
            pixels,
            start: iScale._startPixel,
            end: iScale._endPixel,
            stackCount: this._getStackCount(),
            scale: iScale,
            grouped: opts.grouped,
            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
        };
    }
    _calculateBarValuePixels(index) {
        const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
        const actualBase = baseValue || 0;
        const parsed = this.getParsed(index);
        const custom = parsed._custom;
        const floating = isFloatBar(custom);
        let value = parsed[vScale.axis];
        let start = 0;
        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
        let head, size;
        if (length !== value) {
            start = length - value;
            length = value;
        }
        if (floating) {
            value = custom.barStart;
            length = custom.barEnd - custom.barStart;
            if (value !== 0 && (0, _helpersSegmentJs.s)(value) !== (0, _helpersSegmentJs.s)(custom.barEnd)) start = 0;
            start += value;
        }
        const startValue = !(0, _helpersSegmentJs.k)(baseValue) && !floating ? baseValue : start;
        let base = vScale.getPixelForValue(startValue);
        if (this.chart.getDataVisibility(index)) head = vScale.getPixelForValue(start + length);
        else head = base;
        size = head - base;
        if (Math.abs(size) < minBarLength) {
            size = barSign(size, vScale, actualBase) * minBarLength;
            if (value === actualBase) base -= size / 2;
            const startPixel = vScale.getPixelForDecimal(0);
            const endPixel = vScale.getPixelForDecimal(1);
            const min = Math.min(startPixel, endPixel);
            const max = Math.max(startPixel, endPixel);
            base = Math.max(Math.min(base, max), min);
            head = base + size;
            if (_stacked && !floating) parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
        }
        if (base === vScale.getPixelForValue(actualBase)) {
            const halfGrid = (0, _helpersSegmentJs.s)(size) * vScale.getLineWidthForValue(actualBase) / 2;
            base += halfGrid;
            size -= halfGrid;
        }
        return {
            size,
            base,
            head,
            center: head + size / 2
        };
    }
    _calculateBarIndexPixels(index, ruler) {
        const scale = ruler.scale;
        const options = this.options;
        const skipNull = options.skipNull;
        const maxBarThickness = (0, _helpersSegmentJs.v)(options.maxBarThickness, Infinity);
        let center, size;
        if (ruler.grouped) {
            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
            const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);
            center = range.start + range.chunk * stackIndex + range.chunk / 2;
            size = Math.min(maxBarThickness, range.chunk * range.ratio);
        } else {
            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
        }
        return {
            base: center - size / 2,
            head: center + size / 2,
            center,
            size
        };
    }
    draw() {
        const meta = this._cachedMeta;
        const vScale = meta.vScale;
        const rects = meta.data;
        const ilen = rects.length;
        let i = 0;
        for(; i < ilen; ++i)if (this.getParsed(i)[vScale.axis] !== null) rects[i].draw(this._ctx);
    }
}
class BubbleController extends DatasetController {
    static id = "bubble";
    static defaults = {
        datasetElementType: false,
        dataElementType: "point",
        animations: {
            numbers: {
                type: "number",
                properties: [
                    "x",
                    "y",
                    "borderWidth",
                    "radius"
                ]
            }
        }
    };
    static overrides = {
        scales: {
            x: {
                type: "linear"
            },
            y: {
                type: "linear"
            }
        }
    };
    initialize() {
        this.enableOptionSharing = true;
        super.initialize();
    }
    parsePrimitiveData(meta, data, start, count) {
        const parsed = super.parsePrimitiveData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++)parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
        return parsed;
    }
    parseArrayData(meta, data, start, count) {
        const parsed = super.parseArrayData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++){
            const item = data[start + i];
            parsed[i]._custom = (0, _helpersSegmentJs.v)(item[2], this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
    }
    parseObjectData(meta, data, start, count) {
        const parsed = super.parseObjectData(meta, data, start, count);
        for(let i = 0; i < parsed.length; i++){
            const item = data[start + i];
            parsed[i]._custom = (0, _helpersSegmentJs.v)(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
        }
        return parsed;
    }
    getMaxOverflow() {
        const data = this._cachedMeta.data;
        let max = 0;
        for(let i = data.length - 1; i >= 0; --i)max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
        return max > 0 && max;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const labels = this.chart.data.labels || [];
        const { xScale, yScale } = meta;
        const parsed = this.getParsed(index);
        const x = xScale.getLabelForValue(parsed.x);
        const y = yScale.getLabelForValue(parsed.y);
        const r = parsed._custom;
        return {
            label: labels[index] || "",
            value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
        };
    }
    update(mode) {
        const points = this._cachedMeta.data;
        this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
        const reset = mode === "reset";
        const { iScale, vScale } = this._cachedMeta;
        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        for(let i = start; i < start + count; i++){
            const point = points[i];
            const parsed = !reset && this.getParsed(i);
            const properties = {};
            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
            properties.skip = isNaN(iPixel) || isNaN(vPixel);
            if (includeOptions) {
                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                if (reset) properties.options.radius = 0;
            }
            this.updateElement(point, i, properties, mode);
        }
    }
    resolveDataElementOptions(index, mode) {
        const parsed = this.getParsed(index);
        let values = super.resolveDataElementOptions(index, mode);
        if (values.$shared) values = Object.assign({}, values, {
            $shared: false
        });
        const radius = values.radius;
        if (mode !== "active") values.radius = 0;
        values.radius += (0, _helpersSegmentJs.v)(parsed && parsed._custom, radius);
        return values;
    }
}
function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < (0, _helpersSegmentJs.T)) {
        const startAngle = rotation;
        const endAngle = startAngle + circumference;
        const startX = Math.cos(startAngle);
        const startY = Math.sin(startAngle);
        const endX = Math.cos(endAngle);
        const endY = Math.sin(endAngle);
        const calcMax = (angle, a, b)=>(0, _helpersSegmentJs.p)(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
        const calcMin = (angle, a, b)=>(0, _helpersSegmentJs.p)(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
        const maxX = calcMax(0, startX, endX);
        const maxY = calcMax((0, _helpersSegmentJs.H), startY, endY);
        const minX = calcMin((0, _helpersSegmentJs.P), startX, endX);
        const minY = calcMin((0, _helpersSegmentJs.P) + (0, _helpersSegmentJs.H), startY, endY);
        ratioX = (maxX - minX) / 2;
        ratioY = (maxY - minY) / 2;
        offsetX = -(maxX + minX) / 2;
        offsetY = -(maxY + minY) / 2;
    }
    return {
        ratioX,
        ratioY,
        offsetX,
        offsetY
    };
}
class DoughnutController extends DatasetController {
    static id = "doughnut";
    static defaults = {
        datasetElementType: false,
        dataElementType: "arc",
        animation: {
            animateRotate: true,
            animateScale: false
        },
        animations: {
            numbers: {
                type: "number",
                properties: [
                    "circumference",
                    "endAngle",
                    "innerRadius",
                    "outerRadius",
                    "startAngle",
                    "x",
                    "y",
                    "offset",
                    "borderWidth",
                    "spacing"
                ]
            }
        },
        cutout: "50%",
        rotation: 0,
        circumference: 360,
        radius: "100%",
        spacing: 0,
        indexAxis: "r"
    };
    static descriptors = {
        _scriptable: (name)=>name !== "spacing",
        _indexable: (name)=>name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
    };
    static overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels (chart) {
                        const data = chart.data;
                        if (data.labels.length && data.datasets.length) {
                            const { labels: { pointStyle, color } } = chart.legend.options;
                            return data.labels.map((label, i)=>{
                                const meta = chart.getDatasetMeta(0);
                                const style = meta.controller.getStyle(i);
                                return {
                                    text: label,
                                    fillStyle: style.backgroundColor,
                                    strokeStyle: style.borderColor,
                                    fontColor: color,
                                    lineWidth: style.borderWidth,
                                    pointStyle: pointStyle,
                                    hidden: !chart.getDataVisibility(i),
                                    index: i
                                };
                            });
                        }
                        return [];
                    }
                },
                onClick (e, legendItem, legend) {
                    legend.chart.toggleDataVisibility(legendItem.index);
                    legend.chart.update();
                }
            }
        }
    };
    constructor(chart, datasetIndex){
        super(chart, datasetIndex);
        this.enableOptionSharing = true;
        this.innerRadius = undefined;
        this.outerRadius = undefined;
        this.offsetX = undefined;
        this.offsetY = undefined;
    }
    linkScales() {}
    parse(start, count) {
        const data = this.getDataset().data;
        const meta = this._cachedMeta;
        if (this._parsing === false) meta._parsed = data;
        else {
            let getter = (i)=>+data[i];
            if ((0, _helpersSegmentJs.i)(data[start])) {
                const { key = "value" } = this._parsing;
                getter = (i)=>+(0, _helpersSegmentJs.f)(data[i], key);
            }
            let i, ilen;
            for(i = start, ilen = start + count; i < ilen; ++i)meta._parsed[i] = getter(i);
        }
    }
    _getRotation() {
        return (0, _helpersSegmentJs.t)(this.options.rotation - 90);
    }
    _getCircumference() {
        return (0, _helpersSegmentJs.t)(this.options.circumference);
    }
    _getRotationExtents() {
        let min = (0, _helpersSegmentJs.T);
        let max = -(0, _helpersSegmentJs.T);
        for(let i = 0; i < this.chart.data.datasets.length; ++i)if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
            const controller = this.chart.getDatasetMeta(i).controller;
            const rotation = controller._getRotation();
            const circumference = controller._getCircumference();
            min = Math.min(min, rotation);
            max = Math.max(max, rotation + circumference);
        }
        return {
            rotation: min,
            circumference: max - min
        };
    }
    update(mode) {
        const chart = this.chart;
        const { chartArea } = chart;
        const meta = this._cachedMeta;
        const arcs = meta.data;
        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
        const cutout = Math.min((0, _helpersSegmentJs.m)(this.options.cutout, maxSize), 1);
        const chartWeight = this._getRingWeight(this.index);
        const { circumference, rotation } = this._getRotationExtents();
        const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
        const maxWidth = (chartArea.width - spacing) / ratioX;
        const maxHeight = (chartArea.height - spacing) / ratioY;
        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
        const outerRadius = (0, _helpersSegmentJs.n)(this.options.radius, maxRadius);
        const innerRadius = Math.max(outerRadius * cutout, 0);
        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
        this.offsetX = offsetX * outerRadius;
        this.offsetY = offsetY * outerRadius;
        meta.total = this.calculateTotal();
        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
        this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i, reset) {
        const opts = this.options;
        const meta = this._cachedMeta;
        const circumference = this._getCircumference();
        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) return 0;
        return this.calculateCircumference(meta._parsed[i] * circumference / (0, _helpersSegmentJs.T));
    }
    updateElements(arcs, start, count, mode) {
        const reset = mode === "reset";
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const animationOpts = opts.animation;
        const centerX = (chartArea.left + chartArea.right) / 2;
        const centerY = (chartArea.top + chartArea.bottom) / 2;
        const animateScale = reset && animationOpts.animateScale;
        const innerRadius = animateScale ? 0 : this.innerRadius;
        const outerRadius = animateScale ? 0 : this.outerRadius;
        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
        let startAngle = this._getRotation();
        let i;
        for(i = 0; i < start; ++i)startAngle += this._circumference(i, reset);
        for(i = start; i < start + count; ++i){
            const circumference = this._circumference(i, reset);
            const arc = arcs[i];
            const properties = {
                x: centerX + this.offsetX,
                y: centerY + this.offsetY,
                startAngle,
                endAngle: startAngle + circumference,
                circumference,
                outerRadius,
                innerRadius
            };
            if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
            startAngle += circumference;
            this.updateElement(arc, i, properties, mode);
        }
    }
    calculateTotal() {
        const meta = this._cachedMeta;
        const metaData = meta.data;
        let total = 0;
        let i;
        for(i = 0; i < metaData.length; i++){
            const value = meta._parsed[i];
            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) total += Math.abs(value);
        }
        return total;
    }
    calculateCircumference(value) {
        const total = this._cachedMeta.total;
        if (total > 0 && !isNaN(value)) return (0, _helpersSegmentJs.T) * (Math.abs(value) / total);
        return 0;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = (0, _helpersSegmentJs.o)(meta._parsed[index], chart.options.locale);
        return {
            label: labels[index] || "",
            value
        };
    }
    getMaxBorderWidth(arcs) {
        let max = 0;
        const chart = this.chart;
        let i, ilen, meta, controller, options;
        if (!arcs) {
            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i)if (chart.isDatasetVisible(i)) {
                meta = chart.getDatasetMeta(i);
                arcs = meta.data;
                controller = meta.controller;
                break;
            }
        }
        if (!arcs) return 0;
        for(i = 0, ilen = arcs.length; i < ilen; ++i){
            options = controller.resolveDataElementOptions(i);
            if (options.borderAlign !== "inner") max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
        }
        return max;
    }
    getMaxOffset(arcs) {
        let max = 0;
        for(let i = 0, ilen = arcs.length; i < ilen; ++i){
            const options = this.resolveDataElementOptions(i);
            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
        }
        return max;
    }
    _getRingWeightOffset(datasetIndex) {
        let ringWeightOffset = 0;
        for(let i = 0; i < datasetIndex; ++i)if (this.chart.isDatasetVisible(i)) ringWeightOffset += this._getRingWeight(i);
        return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
        return Math.max((0, _helpersSegmentJs.v)(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
}
class LineController extends DatasetController {
    static id = "line";
    static defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        showLine: true,
        spanGaps: false
    };
    static overrides = {
        scales: {
            _index_: {
                type: "category"
            },
            _value_: {
                type: "linear"
            }
        }
    };
    initialize() {
        this.enableOptionSharing = true;
        this.supportsDecimation = true;
        super.initialize();
    }
    update(mode) {
        const meta = this._cachedMeta;
        const { dataset: line, data: points = [], _dataset } = meta;
        const animationsDisabled = this.chart._animationsDisabled;
        let { start, count } = (0, _helpersSegmentJs.q)(meta, points, animationsDisabled);
        this._drawStart = start;
        this._drawCount = count;
        if ((0, _helpersSegmentJs.w)(meta)) {
            start = 0;
            count = points.length;
        }
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) options.borderWidth = 0;
        options.segment = this.options.segment;
        this.updateElement(line, undefined, {
            animated: !animationsDisabled,
            options
        }, mode);
        this.updateElements(points, start, count, mode);
    }
    updateElements(points, start, count, mode) {
        const reset = mode === "reset";
        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const { spanGaps, segment } = this.options;
        const maxGapLength = (0, _helpersSegmentJs.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
        const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
        const end = start + count;
        const pointsCount = points.length;
        let prevParsed = start > 0 && this.getParsed(start - 1);
        for(let i = 0; i < pointsCount; ++i){
            const point = points[i];
            const properties = directUpdate ? point : {};
            if (i < start || i >= end) {
                properties.skip = true;
                continue;
            }
            const parsed = this.getParsed(i);
            const nullData = (0, _helpersSegmentJs.k)(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
            }
            if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
            if (!directUpdate) this.updateElement(point, i, properties, mode);
            prevParsed = parsed;
        }
    }
    getMaxOverflow() {
        const meta = this._cachedMeta;
        const dataset = meta.dataset;
        const border = dataset.options && dataset.options.borderWidth || 0;
        const data = meta.data || [];
        if (!data.length) return border;
        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
        return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
        const meta = this._cachedMeta;
        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
        super.draw();
    }
}
class PolarAreaController extends DatasetController {
    static id = "polarArea";
    static defaults = {
        dataElementType: "arc",
        animation: {
            animateRotate: true,
            animateScale: true
        },
        animations: {
            numbers: {
                type: "number",
                properties: [
                    "x",
                    "y",
                    "startAngle",
                    "endAngle",
                    "innerRadius",
                    "outerRadius"
                ]
            }
        },
        indexAxis: "r",
        startAngle: 0
    };
    static overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels (chart) {
                        const data = chart.data;
                        if (data.labels.length && data.datasets.length) {
                            const { labels: { pointStyle, color } } = chart.legend.options;
                            return data.labels.map((label, i)=>{
                                const meta = chart.getDatasetMeta(0);
                                const style = meta.controller.getStyle(i);
                                return {
                                    text: label,
                                    fillStyle: style.backgroundColor,
                                    strokeStyle: style.borderColor,
                                    fontColor: color,
                                    lineWidth: style.borderWidth,
                                    pointStyle: pointStyle,
                                    hidden: !chart.getDataVisibility(i),
                                    index: i
                                };
                            });
                        }
                        return [];
                    }
                },
                onClick (e, legendItem, legend) {
                    legend.chart.toggleDataVisibility(legendItem.index);
                    legend.chart.update();
                }
            }
        },
        scales: {
            r: {
                type: "radialLinear",
                angleLines: {
                    display: false
                },
                beginAtZero: true,
                grid: {
                    circular: true
                },
                pointLabels: {
                    display: false
                },
                startAngle: 0
            }
        }
    };
    constructor(chart, datasetIndex){
        super(chart, datasetIndex);
        this.innerRadius = undefined;
        this.outerRadius = undefined;
    }
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const chart = this.chart;
        const labels = chart.data.labels || [];
        const value = (0, _helpersSegmentJs.o)(meta._parsed[index].r, chart.options.locale);
        return {
            label: labels[index] || "",
            value
        };
    }
    parseObjectData(meta, data, start, count) {
        return (0, _helpersSegmentJs.y).bind(this)(meta, data, start, count);
    }
    update(mode) {
        const arcs = this._cachedMeta.data;
        this._updateRadius();
        this.updateElements(arcs, 0, arcs.length, mode);
    }
    getMinMax() {
        const meta = this._cachedMeta;
        const range = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY
        };
        meta.data.forEach((element, index)=>{
            const parsed = this.getParsed(index).r;
            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {
                if (parsed < range.min) range.min = parsed;
                if (parsed > range.max) range.max = parsed;
            }
        });
        return range;
    }
    _updateRadius() {
        const chart = this.chart;
        const chartArea = chart.chartArea;
        const opts = chart.options;
        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        const outerRadius = Math.max(minSize / 2, 0);
        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
        this.outerRadius = outerRadius - radiusLength * this.index;
        this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start, count, mode) {
        const reset = mode === "reset";
        const chart = this.chart;
        const opts = chart.options;
        const animationOpts = opts.animation;
        const scale = this._cachedMeta.rScale;
        const centerX = scale.xCenter;
        const centerY = scale.yCenter;
        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * (0, _helpersSegmentJs.P);
        let angle = datasetStartAngle;
        let i;
        const defaultAngle = 360 / this.countVisibleElements();
        for(i = 0; i < start; ++i)angle += this._computeAngle(i, mode, defaultAngle);
        for(i = start; i < start + count; i++){
            const arc = arcs[i];
            let startAngle = angle;
            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
            angle = endAngle;
            if (reset) {
                if (animationOpts.animateScale) outerRadius = 0;
                if (animationOpts.animateRotate) startAngle = endAngle = datasetStartAngle;
            }
            const properties = {
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius,
                startAngle,
                endAngle,
                options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
            };
            this.updateElement(arc, i, properties, mode);
        }
    }
    countVisibleElements() {
        const meta = this._cachedMeta;
        let count = 0;
        meta.data.forEach((element, index)=>{
            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) count++;
        });
        return count;
    }
    _computeAngle(index, mode, defaultAngle) {
        return this.chart.getDataVisibility(index) ? (0, _helpersSegmentJs.t)(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
    }
}
class PieController extends DoughnutController {
    static id = "pie";
    static defaults = {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: "100%"
    };
}
class RadarController extends DatasetController {
    static id = "radar";
    static defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        indexAxis: "r",
        showLine: true,
        elements: {
            line: {
                fill: "start"
            }
        }
    };
    static overrides = {
        aspectRatio: 1,
        scales: {
            r: {
                type: "radialLinear"
            }
        }
    };
    getLabelAndValue(index) {
        const vScale = this._cachedMeta.vScale;
        const parsed = this.getParsed(index);
        return {
            label: vScale.getLabels()[index],
            value: "" + vScale.getLabelForValue(parsed[vScale.axis])
        };
    }
    parseObjectData(meta, data, start, count) {
        return (0, _helpersSegmentJs.y).bind(this)(meta, data, start, count);
    }
    update(mode) {
        const meta = this._cachedMeta;
        const line = meta.dataset;
        const points = meta.data || [];
        const labels = meta.iScale.getLabels();
        line.points = points;
        if (mode !== "resize") {
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) options.borderWidth = 0;
            const properties = {
                _loop: true,
                _fullLoop: labels.length === points.length,
                options
            };
            this.updateElement(line, undefined, properties, mode);
        }
        this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
        const scale = this._cachedMeta.rScale;
        const reset = mode === "reset";
        for(let i = start; i < start + count; i++){
            const point = points[i];
            const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
            const x = reset ? scale.xCenter : pointPosition.x;
            const y = reset ? scale.yCenter : pointPosition.y;
            const properties = {
                x,
                y,
                angle: pointPosition.angle,
                skip: isNaN(x) || isNaN(y),
                options
            };
            this.updateElement(point, i, properties, mode);
        }
    }
}
class ScatterController extends DatasetController {
    static id = "scatter";
    static defaults = {
        datasetElementType: false,
        dataElementType: "point",
        showLine: false,
        fill: false
    };
    static overrides = {
        interaction: {
            mode: "point"
        },
        scales: {
            x: {
                type: "linear"
            },
            y: {
                type: "linear"
            }
        }
    };
    getLabelAndValue(index) {
        const meta = this._cachedMeta;
        const labels = this.chart.data.labels || [];
        const { xScale, yScale } = meta;
        const parsed = this.getParsed(index);
        const x = xScale.getLabelForValue(parsed.x);
        const y = yScale.getLabelForValue(parsed.y);
        return {
            label: labels[index] || "",
            value: "(" + x + ", " + y + ")"
        };
    }
    update(mode) {
        const meta = this._cachedMeta;
        const { data: points = [] } = meta;
        const animationsDisabled = this.chart._animationsDisabled;
        let { start, count } = (0, _helpersSegmentJs.q)(meta, points, animationsDisabled);
        this._drawStart = start;
        this._drawCount = count;
        if ((0, _helpersSegmentJs.w)(meta)) {
            start = 0;
            count = points.length;
        }
        if (this.options.showLine) {
            if (!this.datasetElementType) this.addElements();
            const { dataset: line, _dataset } = meta;
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            options.segment = this.options.segment;
            this.updateElement(line, undefined, {
                animated: !animationsDisabled,
                options
            }, mode);
        } else if (this.datasetElementType) {
            delete meta.dataset;
            this.datasetElementType = false;
        }
        this.updateElements(points, start, count, mode);
    }
    addElements() {
        const { showLine } = this.options;
        if (!this.datasetElementType && showLine) this.datasetElementType = this.chart.registry.getElement("line");
        super.addElements();
    }
    updateElements(points, start, count, mode) {
        const reset = mode === "reset";
        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
        const firstOpts = this.resolveDataElementOptions(start, mode);
        const sharedOptions = this.getSharedOptions(firstOpts);
        const includeOptions = this.includeOptions(mode, sharedOptions);
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const { spanGaps, segment } = this.options;
        const maxGapLength = (0, _helpersSegmentJs.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
        const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
        let prevParsed = start > 0 && this.getParsed(start - 1);
        for(let i = start; i < start + count; ++i){
            const point = points[i];
            const parsed = this.getParsed(i);
            const properties = directUpdate ? point : {};
            const nullData = (0, _helpersSegmentJs.k)(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
            if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
            }
            if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
            if (!directUpdate) this.updateElement(point, i, properties, mode);
            prevParsed = parsed;
        }
        this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    getMaxOverflow() {
        const meta = this._cachedMeta;
        const data = meta.data || [];
        if (!this.options.showLine) {
            let max = 0;
            for(let i = data.length - 1; i >= 0; --i)max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
            return max > 0 && max;
        }
        const dataset = meta.dataset;
        const border = dataset.options && dataset.options.borderWidth || 0;
        if (!data.length) return border;
        const firstPoint = data[0].size(this.resolveDataElementOptions(0));
        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
        return Math.max(border, firstPoint, lastPoint) / 2;
    }
}
var controllers = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    BarController: BarController,
    BubbleController: BubbleController,
    DoughnutController: DoughnutController,
    LineController: LineController,
    PieController: PieController,
    PolarAreaController: PolarAreaController,
    RadarController: RadarController,
    ScatterController: ScatterController
});
/**
 * @namespace Chart._adapters
 * @since 2.8.0
 * @private
 */ function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
/**
 * Date adapter (current used by the time scale)
 * @namespace Chart._adapters._date
 * @memberof Chart._adapters
 * @private
 */ class DateAdapterBase {
    /**
   * Override default date adapter methods.
   * Accepts type parameter to define options type.
   * @example
   * Chart._adapters._date.override<{myAdapterOption: string}>({
   *   init() {
   *     console.log(this.options.myAdapterOption);
   *   }
   * })
   */ static override(members) {
        Object.assign(DateAdapterBase.prototype, members);
    }
    options;
    constructor(options){
        this.options = options || {};
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {}
    formats() {
        return abstract();
    }
    parse() {
        return abstract();
    }
    format() {
        return abstract();
    }
    add() {
        return abstract();
    }
    diff() {
        return abstract();
    }
    startOf() {
        return abstract();
    }
    endOf() {
        return abstract();
    }
}
var adapters = {
    _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
    const { controller, data, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
        const lookupMethod = iScale._reversePixels ? (0, _helpersSegmentJs.A) : (0, _helpersSegmentJs.B);
        if (!intersect) return lookupMethod(data, axis, value);
        else if (controller._sharedOptions) {
            const el = data[0];
            const range = typeof el.getRange === "function" && el.getRange(axis);
            if (range) {
                const start = lookupMethod(data, axis, value - range);
                const end = lookupMethod(data, axis, value + range);
                return {
                    lo: start.lo,
                    hi: end.hi
                };
            }
        }
    }
    return {
        lo: 0,
        hi: data.length - 1
    };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for(let i = 0, ilen = metasets.length; i < ilen; ++i){
        const { index, data } = metasets[i];
        const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
        for(let j = lo; j <= hi; ++j){
            const element = data[j];
            if (!element.skip) handler(element, index, j);
        }
    }
}
function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) return items;
    const evaluationFunc = function(element, datasetIndex, index) {
        if (!includeInvisible && !(0, _helpersSegmentJs.C)(element, chart.chartArea, 0)) return;
        if (element.inRange(position.x, position.y, useFinalPosition)) items.push({
            element,
            datasetIndex,
            index
        });
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index) {
        const { startAngle, endAngle } = element.getProps([
            "startAngle",
            "endAngle"
        ], useFinalPosition);
        const { angle } = (0, _helpersSegmentJs.D)(element, {
            x: position.x,
            y: position.y
        });
        if ((0, _helpersSegmentJs.p)(angle, startAngle, endAngle)) items.push({
            element,
            datasetIndex,
            index
        });
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index) {
        const inRange = element.inRange(position.x, position.y, useFinalPosition);
        if (intersect && !inRange) return;
        const center = element.getCenterPoint(useFinalPosition);
        const pointInArea = !!includeInvisible || chart.isPointInArea(center);
        if (!pointInArea && !inRange) return;
        const distance = distanceMetric(position, center);
        if (distance < minDistance) {
            items = [
                {
                    element,
                    datasetIndex,
                    index
                }
            ];
            minDistance = distance;
        } else if (distance === minDistance) items.push({
            element,
            datasetIndex,
            index
        });
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) return [];
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{
        if (element[rangeMethod](position[axis], useFinalPosition)) {
            items.push({
                element,
                datasetIndex,
                index
            });
            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
        }
    });
    if (intersect && !intersectsItem) return [];
    return items;
}
var Interaction = {
    evaluateInteractionItems,
    modes: {
        index (chart, e, options, useFinalPosition) {
            const position = (0, _helpersSegmentJs.z)(e, chart);
            const axis = options.axis || "x";
            const includeInvisible = options.includeInvisible || false;
            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            const elements = [];
            if (!items.length) return [];
            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{
                const index = items[0].index;
                const element = meta.data[index];
                if (element && !element.skip) elements.push({
                    element,
                    datasetIndex: meta.index,
                    index
                });
            });
            return elements;
        },
        dataset (chart, e, options, useFinalPosition) {
            const position = (0, _helpersSegmentJs.z)(e, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
            if (items.length > 0) {
                const datasetIndex = items[0].datasetIndex;
                const data = chart.getDatasetMeta(datasetIndex).data;
                items = [];
                for(let i = 0; i < data.length; ++i)items.push({
                    element: data[i],
                    datasetIndex,
                    index: i
                });
            }
            return items;
        },
        point (chart, e, options, useFinalPosition) {
            const position = (0, _helpersSegmentJs.z)(e, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
        },
        nearest (chart, e, options, useFinalPosition) {
            const position = (0, _helpersSegmentJs.z)(e, chart);
            const axis = options.axis || "xy";
            const includeInvisible = options.includeInvisible || false;
            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
        },
        x (chart, e, options, useFinalPosition) {
            const position = (0, _helpersSegmentJs.z)(e, chart);
            return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
        },
        y (chart, e, options, useFinalPosition) {
            const position = (0, _helpersSegmentJs.z)(e, chart);
            return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
        }
    }
};
const STATIC_POSITIONS = [
    "left",
    "top",
    "right",
    "bottom"
];
function filterByPosition(array, position) {
    return array.filter((v)=>v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
    return array.sort((a, b)=>{
        const v0 = reverse ? b : a;
        const v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
}
function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i, ilen, box, pos, stack, stackWeight;
    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){
        box = boxes[i];
        ({ position: pos, options: { stack, stackWeight = 1 } } = box);
        layoutBoxes.push({
            index: i,
            box,
            pos,
            horizontal: box.isHorizontal(),
            weight: box.weight,
            stack: stack && pos + stack,
            stackWeight
        });
    }
    return layoutBoxes;
}
function buildStacks(layouts) {
    const stacks = {};
    for (const wrap of layouts){
        const { stack, pos, stackWeight } = wrap;
        if (!stack || !STATIC_POSITIONS.includes(pos)) continue;
        const _stack = stacks[stack] || (stacks[stack] = {
            count: 0,
            placed: 0,
            weight: 0,
            size: 0
        });
        _stack.count++;
        _stack.weight += stackWeight;
    }
    return stacks;
}
function setLayoutDims(layouts, params) {
    const stacks = buildStacks(layouts);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i, ilen, layout;
    for(i = 0, ilen = layouts.length; i < ilen; ++i){
        layout = layouts[i];
        const { fullSize } = layout.box;
        const stack = stacks[layout.stack];
        const factor = stack && layout.stackWeight / stack.weight;
        if (layout.horizontal) {
            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
            layout.height = hBoxMaxHeight;
        } else {
            layout.width = vBoxMaxWidth;
            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
        }
    }
    return stacks;
}
function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);
    const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
        fullSize,
        leftAndTop: left.concat(top),
        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
        chartArea: filterByPosition(layoutBoxes, "chartArea"),
        vertical: left.concat(right).concat(centerVertical),
        horizontal: top.concat(bottom).concat(centerHorizontal)
    };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!(0, _helpersSegmentJs.i)(pos)) {
        if (layout.size) chartArea[pos] -= layout.size;
        const stack = stacks[layout.stack] || {
            size: 0,
            count: 1
        };
        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
        layout.size = stack.size / stack.count;
        chartArea[pos] += layout.size;
    }
    if (box.getPadding) updateMaxPadding(maxPadding, box.getPadding());
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
        same: widthChanged,
        other: heightChanged
    } : {
        same: heightChanged,
        other: widthChanged
    };
}
function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
        chartArea[pos] += change;
        return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions) {
        const margin = {
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
        };
        positions.forEach((pos)=>{
            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
        });
        return margin;
    }
    return horizontal ? marginForPositions([
        "left",
        "right"
    ]) : marginForPositions([
        "top",
        "bottom"
    ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i, ilen, layout, box, refit, changed;
    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){
        layout = boxes[i];
        box = layout.box;
        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
        const { same, other } = updateDims(chartArea, params, layout, stacks);
        refit |= same && refitBoxes.length;
        changed = changed || other;
        if (!box.fullSize) refitBoxes.push(layout);
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
    box.top = top;
    box.left = left;
    box.right = left + width;
    box.bottom = top + height;
    box.width = width;
    box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x, y } = chartArea;
    for (const layout of boxes){
        const box = layout.box;
        const stack = stacks[layout.stack] || {
            count: 1,
            placed: 0,
            weight: 1
        };
        const weight = layout.stackWeight / stack.weight || 1;
        if (layout.horizontal) {
            const width = chartArea.w * weight;
            const height = stack.size || box.height;
            if ((0, _helpersSegmentJs.h)(stack.start)) y = stack.start;
            if (box.fullSize) setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
            else setBoxDims(box, chartArea.left + stack.placed, y, width, height);
            stack.start = y;
            stack.placed += width;
            y = box.bottom;
        } else {
            const height = chartArea.h * weight;
            const width = stack.size || box.width;
            if ((0, _helpersSegmentJs.h)(stack.start)) x = stack.start;
            if (box.fullSize) setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
            else setBoxDims(box, x, chartArea.top + stack.placed, width, height);
            stack.start = x;
            stack.placed += height;
            x = box.right;
        }
    }
    chartArea.x = x;
    chartArea.y = y;
}
var layouts = {
    addBox (chart, item) {
        if (!chart.boxes) chart.boxes = [];
        item.fullSize = item.fullSize || false;
        item.position = item.position || "top";
        item.weight = item.weight || 0;
        item._layers = item._layers || function() {
            return [
                {
                    z: 0,
                    draw (chartArea) {
                        item.draw(chartArea);
                    }
                }
            ];
        };
        chart.boxes.push(item);
    },
    removeBox (chart, layoutItem) {
        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
        if (index !== -1) chart.boxes.splice(index, 1);
    },
    configure (chart, item, options) {
        item.fullSize = options.fullSize;
        item.position = options.position;
        item.weight = options.weight;
    },
    update (chart, width, height, minPadding) {
        if (!chart) return;
        const padding = (0, _helpersSegmentJs.E)(chart.options.layout.padding);
        const availableWidth = Math.max(width - padding.width, 0);
        const availableHeight = Math.max(height - padding.height, 0);
        const boxes = buildLayoutBoxes(chart.boxes);
        const verticalBoxes = boxes.vertical;
        const horizontalBoxes = boxes.horizontal;
        (0, _helpersSegmentJs.F)(chart.boxes, (box)=>{
            if (typeof box.beforeLayout === "function") box.beforeLayout();
        });
        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
        const params = Object.freeze({
            outerWidth: width,
            outerHeight: height,
            padding,
            availableWidth,
            availableHeight,
            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
            hBoxMaxHeight: availableHeight / 2
        });
        const maxPadding = Object.assign({}, padding);
        updateMaxPadding(maxPadding, (0, _helpersSegmentJs.E)(minPadding));
        const chartArea = Object.assign({
            maxPadding,
            w: availableWidth,
            h: availableHeight,
            x: padding.left,
            y: padding.top
        }, padding);
        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
        fitBoxes(boxes.fullSize, chartArea, params, stacks);
        fitBoxes(verticalBoxes, chartArea, params, stacks);
        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) fitBoxes(verticalBoxes, chartArea, params, stacks);
        handleMaxPadding(chartArea);
        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
        chartArea.x += chartArea.w;
        chartArea.y += chartArea.h;
        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
        chart.chartArea = {
            left: chartArea.left,
            top: chartArea.top,
            right: chartArea.left + chartArea.w,
            bottom: chartArea.top + chartArea.h,
            height: chartArea.h,
            width: chartArea.w
        };
        (0, _helpersSegmentJs.F)(boxes.chartArea, (layout)=>{
            const box = layout.box;
            Object.assign(box, chart.chartArea);
            box.update(chartArea.w, chartArea.h, {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            });
        });
    }
};
class BasePlatform {
    acquireContext(canvas, aspectRatio) {}
    releaseContext(context) {
        return false;
    }
    addEventListener(chart, type, listener) {}
    removeEventListener(chart, type, listener) {}
    getDevicePixelRatio() {
        return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
        width = Math.max(0, width || element.width);
        height = height || element.height;
        return {
            width,
            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
        };
    }
    isAttached(canvas) {
        return true;
    }
    updateConfig(config) {}
}
class BasicPlatform extends BasePlatform {
    acquireContext(item) {
        return item && item.getContext && item.getContext("2d") || null;
    }
    updateConfig(config) {
        config.options.animation = false;
    }
}
const EXPANDO_KEY = "$chartjs";
const EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
};
const isNullOrEmpty = (value)=>value === null || value === "";
function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
        initial: {
            height: renderHeight,
            width: renderWidth,
            style: {
                display: style.display,
                height: style.height,
                width: style.width
            }
        }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
        const displayWidth = (0, _helpersSegmentJs.J)(canvas, "width");
        if (displayWidth !== undefined) canvas.width = displayWidth;
    }
    if (isNullOrEmpty(renderHeight)) {
        if (canvas.style.height === "") canvas.height = canvas.width / (aspectRatio || 2);
        else {
            const displayHeight = (0, _helpersSegmentJs.J)(canvas, "height");
            if (displayHeight !== undefined) canvas.height = displayHeight;
        }
    }
    return canvas;
}
const eventListenerOptions = (0, _helpersSegmentJs.K) ? {
    passive: true
} : false;
function addListener(node, type, listener) {
    node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x, y } = (0, _helpersSegmentJs.z)(event, chart);
    return {
        type,
        chart,
        native: event,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null
    };
}
function nodeListContains(nodeList, canvas) {
    for (const node of nodeList){
        if (node === canvas || node.contains(canvas)) return true;
    }
}
function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries)=>{
        let trigger = false;
        for (const entry of entries){
            trigger = trigger || nodeListContains(entry.addedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
        }
        if (trigger) listener();
    });
    observer.observe(document, {
        childList: true,
        subtree: true
    });
    return observer;
}
function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries)=>{
        let trigger = false;
        for (const entry of entries){
            trigger = trigger || nodeListContains(entry.removedNodes, canvas);
            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
        }
        if (trigger) listener();
    });
    observer.observe(document, {
        childList: true,
        subtree: true
    });
    return observer;
}
const drpListeningCharts = new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) return;
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart)=>{
        if (chart.currentDevicePixelRatio !== dpr) resize();
    });
}
function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) window.addEventListener("resize", onWindowResize);
    drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) window.removeEventListener("resize", onWindowResize);
}
function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && (0, _helpersSegmentJs.I)(canvas);
    if (!container) return;
    const resize = (0, _helpersSegmentJs.L)((width, height)=>{
        const w = container.clientWidth;
        listener(width, height);
        if (w < container.clientWidth) listener();
    }, window);
    const observer = new ResizeObserver((entries)=>{
        const entry = entries[0];
        const width = entry.contentRect.width;
        const height = entry.contentRect.height;
        if (width === 0 && height === 0) return;
        resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
}
function releaseObserver(chart, type, observer) {
    if (observer) observer.disconnect();
    if (type === "resize") unlistenDevicePixelRatioChanges(chart);
}
function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = (0, _helpersSegmentJs.L)((event)=>{
        if (chart.ctx !== null) listener(fromNativeEvent(event, chart));
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
}
class DomPlatform extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
        const context = canvas && canvas.getContext && canvas.getContext("2d");
        if (context && context.canvas === canvas) {
            initCanvas(canvas, aspectRatio);
            return context;
        }
        return null;
    }
    releaseContext(context) {
        const canvas = context.canvas;
        if (!canvas[EXPANDO_KEY]) return false;
        const initial = canvas[EXPANDO_KEY].initial;
        [
            "height",
            "width"
        ].forEach((prop)=>{
            const value = initial[prop];
            if ((0, _helpersSegmentJs.k)(value)) canvas.removeAttribute(prop);
            else canvas.setAttribute(prop, value);
        });
        const style = initial.style || {};
        Object.keys(style).forEach((key)=>{
            canvas.style[key] = style[key];
        });
        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
        return true;
    }
    addEventListener(chart, type, listener) {
        this.removeEventListener(chart, type);
        const proxies = chart.$proxies || (chart.$proxies = {});
        const handlers = {
            attach: createAttachObserver,
            detach: createDetachObserver,
            resize: createResizeObserver
        };
        const handler = handlers[type] || createProxyAndListen;
        proxies[type] = handler(chart, type, listener);
    }
    removeEventListener(chart, type) {
        const proxies = chart.$proxies || (chart.$proxies = {});
        const proxy = proxies[type];
        if (!proxy) return;
        const handlers = {
            attach: releaseObserver,
            detach: releaseObserver,
            resize: releaseObserver
        };
        const handler = handlers[type] || removeListener;
        handler(chart, type, proxy);
        proxies[type] = undefined;
    }
    getDevicePixelRatio() {
        return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
        return (0, _helpersSegmentJs.G)(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
        const container = (0, _helpersSegmentJs.I)(canvas);
        return !!(container && container.isConnected);
    }
}
function _detectPlatform(canvas) {
    if (!(0, _helpersSegmentJs.M)() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) return BasicPlatform;
    return DomPlatform;
}
class Element {
    static defaults = {};
    static defaultRoutes = undefined;
    x;
    y;
    active = false;
    options;
    $animations;
    tooltipPosition(useFinalPosition) {
        const { x, y } = this.getProps([
            "x",
            "y"
        ], useFinalPosition);
        return {
            x,
            y
        };
    }
    hasValue() {
        return (0, _helpersSegmentJs.x)(this.x) && (0, _helpersSegmentJs.x)(this.y);
    }
    getProps(props, final) {
        const anims = this.$animations;
        if (!final || !anims) // let's not create an object, if not needed
        return this;
        const ret = {};
        props.forEach((prop)=>{
            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
        });
        return ret;
    }
}
function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
        return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
        let i, ilen;
        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
        skip(ticks, newTicks, spacing, (0, _helpersSegmentJs.k)(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++)skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
        skip(ticks, newTicks, spacing, last, (0, _helpersSegmentJs.k)(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
        return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
}
function determineMaxTicks(scale) {
    const offset = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) return Math.max(spacing, 1);
    const factors = (0, _helpersSegmentJs.N)(evenMajorSpacing);
    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){
        const factor = factors[i];
        if (factor > spacing) return factor;
    }
    return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
    const result = [];
    let i, ilen;
    for(i = 0, ilen = ticks.length; i < ilen; i++)if (ticks[i].major) result.push(i);
    return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i;
    spacing = Math.ceil(spacing);
    for(i = 0; i < ticks.length; i++)if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = majorIndices[count * spacing];
    }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start = (0, _helpersSegmentJs.v)(majorStart, 0);
    const end = Math.min((0, _helpersSegmentJs.v)(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
        length = majorEnd - majorStart;
        spacing = length / Math.floor(length / spacing);
    }
    next = start;
    while(next < 0){
        count++;
        next = Math.round(start + count * spacing);
    }
    for(i = Math.max(start, 0); i < end; i++)if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = Math.round(start + count * spacing);
    }
}
function getEvenSpacing(arr) {
    const len = arr.length;
    let i, diff;
    if (len < 2) return false;
    for(diff = arr[0], i = 1; i < len; ++i){
        if (arr[i] - arr[i - 1] !== diff) return false;
    }
    return diff;
}
const reverseAlign = (align)=>align === "left" ? "right" : align === "right" ? "left" : align;
const offsetFromEdge = (scale, edge, offset)=>edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
const getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i = 0;
    for(; i < len; i += increment)result.push(arr[Math.floor(i)]);
    return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex = Math.min(index, length - 1);
    const start = scale._startPixel;
    const end = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex);
    let offset;
    if (offsetGridLines) {
        if (length === 1) offset = Math.max(lineValue - start, end - lineValue);
        else if (index === 0) offset = (scale.getPixelForTick(1) - lineValue) / 2;
        else offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
        lineValue += validIndex < index ? offset : -offset;
        if (lineValue < start - epsilon || lineValue > end + epsilon) return;
    }
    return lineValue;
}
function garbageCollect(caches, length) {
    (0, _helpersSegmentJs.F)(caches, (cache)=>{
        const gc = cache.gc;
        const gcLen = gc.length / 2;
        let i;
        if (gcLen > length) {
            for(i = 0; i < gcLen; ++i)delete cache.data[gc[i]];
            gc.splice(0, gcLen);
        }
    });
}
function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
    if (!options.display) return 0;
    const font = (0, _helpersSegmentJs.a0)(options.font, fallback);
    const padding = (0, _helpersSegmentJs.E)(options.padding);
    const lines = (0, _helpersSegmentJs.b)(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
    return (0, _helpersSegmentJs.j)(parent, {
        scale,
        type: "scale"
    });
}
function createTickContext(parent, index, tick) {
    return (0, _helpersSegmentJs.j)(parent, {
        tick,
        index,
        type: "tick"
    });
}
function titleAlign(align, position, reverse) {
    let ret = (0, _helpersSegmentJs.a1)(align);
    if (reverse && position !== "right" || !reverse && position === "right") ret = reverseAlign(ret);
    return ret;
}
function titleArgs(scale, offset, position, align) {
    const { top, left, bottom, right, chart } = scale;
    const { chartArea, scales } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom - top;
    const width = right - left;
    if (scale.isHorizontal()) {
        titleX = (0, _helpersSegmentJs.a2)(align, left, right);
        if ((0, _helpersSegmentJs.i)(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
        } else if (position === "center") titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
        else titleY = offsetFromEdge(scale, position, offset);
        maxWidth = right - left;
    } else {
        if ((0, _helpersSegmentJs.i)(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
        } else if (position === "center") titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
        else titleX = offsetFromEdge(scale, position, offset);
        titleY = (0, _helpersSegmentJs.a2)(align, bottom, top);
        rotation = position === "left" ? -(0, _helpersSegmentJs.H) : (0, _helpersSegmentJs.H);
    }
    return {
        titleX,
        titleY,
        maxWidth,
        rotation
    };
}
class Scale extends Element {
    constructor(cfg){
        super();
        this.id = cfg.id;
        this.type = cfg.type;
        this.options = undefined;
        this.ctx = cfg.ctx;
        this.chart = cfg.chart;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.width = undefined;
        this.height = undefined;
        this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        };
        this.maxWidth = undefined;
        this.maxHeight = undefined;
        this.paddingTop = undefined;
        this.paddingBottom = undefined;
        this.paddingLeft = undefined;
        this.paddingRight = undefined;
        this.axis = undefined;
        this.labelRotation = undefined;
        this.min = undefined;
        this.max = undefined;
        this._range = undefined;
        this.ticks = [];
        this._gridLineItems = null;
        this._labelItems = null;
        this._labelSizes = null;
        this._length = 0;
        this._maxLength = 0;
        this._longestTextCache = {};
        this._startPixel = undefined;
        this._endPixel = undefined;
        this._reversePixels = false;
        this._userMax = undefined;
        this._userMin = undefined;
        this._suggestedMax = undefined;
        this._suggestedMin = undefined;
        this._ticksLength = 0;
        this._borderValue = 0;
        this._cache = {};
        this._dataLimitsCached = false;
        this.$context = undefined;
    }
    init(options) {
        this.options = options.setContext(this.getContext());
        this.axis = options.axis;
        this._userMin = this.parse(options.min);
        this._userMax = this.parse(options.max);
        this._suggestedMin = this.parse(options.suggestedMin);
        this._suggestedMax = this.parse(options.suggestedMax);
    }
    parse(raw, index) {
        return raw;
    }
    getUserBounds() {
        let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
        _userMin = (0, _helpersSegmentJs.O)(_userMin, Number.POSITIVE_INFINITY);
        _userMax = (0, _helpersSegmentJs.O)(_userMax, Number.NEGATIVE_INFINITY);
        _suggestedMin = (0, _helpersSegmentJs.O)(_suggestedMin, Number.POSITIVE_INFINITY);
        _suggestedMax = (0, _helpersSegmentJs.O)(_suggestedMax, Number.NEGATIVE_INFINITY);
        return {
            min: (0, _helpersSegmentJs.O)(_userMin, _suggestedMin),
            max: (0, _helpersSegmentJs.O)(_userMax, _suggestedMax),
            minDefined: (0, _helpersSegmentJs.g)(_userMin),
            maxDefined: (0, _helpersSegmentJs.g)(_userMax)
        };
    }
    getMinMax(canStack) {
        let { min, max, minDefined, maxDefined } = this.getUserBounds();
        let range;
        if (minDefined && maxDefined) return {
            min,
            max
        };
        const metas = this.getMatchingVisibleMetas();
        for(let i = 0, ilen = metas.length; i < ilen; ++i){
            range = metas[i].controller.getMinMax(this, canStack);
            if (!minDefined) min = Math.min(min, range.min);
            if (!maxDefined) max = Math.max(max, range.max);
        }
        min = maxDefined && min > max ? max : min;
        max = minDefined && min > max ? min : max;
        return {
            min: (0, _helpersSegmentJs.O)(min, (0, _helpersSegmentJs.O)(max, min)),
            max: (0, _helpersSegmentJs.O)(max, (0, _helpersSegmentJs.O)(min, max))
        };
    }
    getPadding() {
        return {
            left: this.paddingLeft || 0,
            top: this.paddingTop || 0,
            right: this.paddingRight || 0,
            bottom: this.paddingBottom || 0
        };
    }
    getTicks() {
        return this.ticks;
    }
    getLabels() {
        const data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
    getLabelItems(chartArea = this.chart.chartArea) {
        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
        return items;
    }
    beforeLayout() {
        this._cache = {};
        this._dataLimitsCached = false;
    }
    beforeUpdate() {
        (0, _helpersSegmentJs.Q)(this.options.beforeUpdate, [
            this
        ]);
    }
    update(maxWidth, maxHeight, margins) {
        const { beginAtZero, grace, ticks: tickOpts } = this.options;
        const sampleSize = tickOpts.sampleSize;
        this.beforeUpdate();
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        }, margins);
        this.ticks = null;
        this._labelSizes = null;
        this._gridLineItems = null;
        this._labelItems = null;
        this.beforeSetDimensions();
        this.setDimensions();
        this.afterSetDimensions();
        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
        if (!this._dataLimitsCached) {
            this.beforeDataLimits();
            this.determineDataLimits();
            this.afterDataLimits();
            this._range = (0, _helpersSegmentJs.R)(this, grace, beginAtZero);
            this._dataLimitsCached = true;
        }
        this.beforeBuildTicks();
        this.ticks = this.buildTicks() || [];
        this.afterBuildTicks();
        const samplingEnabled = sampleSize < this.ticks.length;
        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
        this.configure();
        this.beforeCalculateLabelRotation();
        this.calculateLabelRotation();
        this.afterCalculateLabelRotation();
        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
            this.ticks = autoSkip(this, this.ticks);
            this._labelSizes = null;
            this.afterAutoSkip();
        }
        if (samplingEnabled) this._convertTicksToLabels(this.ticks);
        this.beforeFit();
        this.fit();
        this.afterFit();
        this.afterUpdate();
    }
    configure() {
        let reversePixels = this.options.reverse;
        let startPixel, endPixel;
        if (this.isHorizontal()) {
            startPixel = this.left;
            endPixel = this.right;
        } else {
            startPixel = this.top;
            endPixel = this.bottom;
            reversePixels = !reversePixels;
        }
        this._startPixel = startPixel;
        this._endPixel = endPixel;
        this._reversePixels = reversePixels;
        this._length = endPixel - startPixel;
        this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
        (0, _helpersSegmentJs.Q)(this.options.afterUpdate, [
            this
        ]);
    }
    beforeSetDimensions() {
        (0, _helpersSegmentJs.Q)(this.options.beforeSetDimensions, [
            this
        ]);
    }
    setDimensions() {
        if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = 0;
            this.right = this.width;
        } else {
            this.height = this.maxHeight;
            this.top = 0;
            this.bottom = this.height;
        }
        this.paddingLeft = 0;
        this.paddingTop = 0;
        this.paddingRight = 0;
        this.paddingBottom = 0;
    }
    afterSetDimensions() {
        (0, _helpersSegmentJs.Q)(this.options.afterSetDimensions, [
            this
        ]);
    }
    _callHooks(name) {
        this.chart.notifyPlugins(name, this.getContext());
        (0, _helpersSegmentJs.Q)(this.options[name], [
            this
        ]);
    }
    beforeDataLimits() {
        this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {}
    afterDataLimits() {
        this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
        this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
        return [];
    }
    afterBuildTicks() {
        this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
        (0, _helpersSegmentJs.Q)(this.options.beforeTickToLabelConversion, [
            this
        ]);
    }
    generateTickLabels(ticks) {
        const tickOpts = this.options.ticks;
        let i, ilen, tick;
        for(i = 0, ilen = ticks.length; i < ilen; i++){
            tick = ticks[i];
            tick.label = (0, _helpersSegmentJs.Q)(tickOpts.callback, [
                tick.value,
                i,
                ticks
            ], this);
        }
    }
    afterTickToLabelConversion() {
        (0, _helpersSegmentJs.Q)(this.options.afterTickToLabelConversion, [
            this
        ]);
    }
    beforeCalculateLabelRotation() {
        (0, _helpersSegmentJs.Q)(this.options.beforeCalculateLabelRotation, [
            this
        ]);
    }
    calculateLabelRotation() {
        const options = this.options;
        const tickOpts = options.ticks;
        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
        const minRotation = tickOpts.minRotation || 0;
        const maxRotation = tickOpts.maxRotation;
        let labelRotation = minRotation;
        let tickWidth, maxHeight, maxLabelDiagonal;
        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
            this.labelRotation = minRotation;
            return;
        }
        const labelSizes = this._getLabelSizes();
        const maxLabelWidth = labelSizes.widest.width;
        const maxLabelHeight = labelSizes.highest.height;
        const maxWidth = (0, _helpersSegmentJs.S)(this.chart.width - maxLabelWidth, 0, this.maxWidth);
        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
        if (maxLabelWidth + 6 > tickWidth) {
            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
            labelRotation = (0, _helpersSegmentJs.U)(Math.min(Math.asin((0, _helpersSegmentJs.S)((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin((0, _helpersSegmentJs.S)(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin((0, _helpersSegmentJs.S)(maxLabelHeight / maxLabelDiagonal, -1, 1))));
            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
        }
        this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
        (0, _helpersSegmentJs.Q)(this.options.afterCalculateLabelRotation, [
            this
        ]);
    }
    afterAutoSkip() {}
    beforeFit() {
        (0, _helpersSegmentJs.Q)(this.options.beforeFit, [
            this
        ]);
    }
    fit() {
        const minSize = {
            width: 0,
            height: 0
        };
        const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
        const display = this._isVisible();
        const isHorizontal = this.isHorizontal();
        if (display) {
            const titleHeight = getTitleHeight(titleOpts, chart.options.font);
            if (isHorizontal) {
                minSize.width = this.maxWidth;
                minSize.height = getTickMarkLength(gridOpts) + titleHeight;
            } else {
                minSize.height = this.maxHeight;
                minSize.width = getTickMarkLength(gridOpts) + titleHeight;
            }
            if (tickOpts.display && this.ticks.length) {
                const { first, last, widest, highest } = this._getLabelSizes();
                const tickPadding = tickOpts.padding * 2;
                const angleRadians = (0, _helpersSegmentJs.t)(this.labelRotation);
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                if (isHorizontal) {
                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                } else {
                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                }
                this._calculatePadding(first, last, sin, cos);
            }
        }
        this._handleMargins();
        if (isHorizontal) {
            this.width = this._length = chart.width - this._margins.left - this._margins.right;
            this.height = minSize.height;
        } else {
            this.width = minSize.width;
            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
        }
    }
    _calculatePadding(first, last, sin, cos) {
        const { ticks: { align, padding }, position } = this.options;
        const isRotated = this.labelRotation !== 0;
        const labelsBelowTicks = position !== "top" && this.axis === "x";
        if (this.isHorizontal()) {
            const offsetLeft = this.getPixelForTick(0) - this.left;
            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
            let paddingLeft = 0;
            let paddingRight = 0;
            if (isRotated) {
                if (labelsBelowTicks) {
                    paddingLeft = cos * first.width;
                    paddingRight = sin * last.height;
                } else {
                    paddingLeft = sin * first.height;
                    paddingRight = cos * last.width;
                }
            } else if (align === "start") paddingRight = last.width;
            else if (align === "end") paddingLeft = first.width;
            else if (align !== "inner") {
                paddingLeft = first.width / 2;
                paddingRight = last.width / 2;
            }
            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
        } else {
            let paddingTop = last.height / 2;
            let paddingBottom = first.height / 2;
            if (align === "start") {
                paddingTop = 0;
                paddingBottom = first.height;
            } else if (align === "end") {
                paddingTop = last.height;
                paddingBottom = 0;
            }
            this.paddingTop = paddingTop + padding;
            this.paddingBottom = paddingBottom + padding;
        }
    }
    _handleMargins() {
        if (this._margins) {
            this._margins.left = Math.max(this.paddingLeft, this._margins.left);
            this._margins.top = Math.max(this.paddingTop, this._margins.top);
            this._margins.right = Math.max(this.paddingRight, this._margins.right);
            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
        }
    }
    afterFit() {
        (0, _helpersSegmentJs.Q)(this.options.afterFit, [
            this
        ]);
    }
    isHorizontal() {
        const { axis, position } = this.options;
        return position === "top" || position === "bottom" || axis === "x";
    }
    isFullSize() {
        return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
        this.beforeTickToLabelConversion();
        this.generateTickLabels(ticks);
        let i, ilen;
        for(i = 0, ilen = ticks.length; i < ilen; i++)if ((0, _helpersSegmentJs.k)(ticks[i].label)) {
            ticks.splice(i, 1);
            ilen--;
            i--;
        }
        this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
        let labelSizes = this._labelSizes;
        if (!labelSizes) {
            const sampleSize = this.options.ticks.sampleSize;
            let ticks = this.ticks;
            if (sampleSize < ticks.length) ticks = sample(ticks, sampleSize);
            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
        }
        return labelSizes;
    }
    _computeLabelSizes(ticks, length, maxTicksLimit) {
        const { ctx, _longestTextCache: caches } = this;
        const widths = [];
        const heights = [];
        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
        let widestLabelSize = 0;
        let highestLabelSize = 0;
        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
        for(i = 0; i < length; i += increment){
            label = ticks[i].label;
            tickFont = this._resolveTickFontOptions(i);
            ctx.font = fontString = tickFont.string;
            cache = caches[fontString] = caches[fontString] || {
                data: {},
                gc: []
            };
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!(0, _helpersSegmentJs.k)(label) && !(0, _helpersSegmentJs.b)(label)) {
                width = (0, _helpersSegmentJs.V)(ctx, cache.data, cache.gc, width, label);
                height = lineHeight;
            } else if ((0, _helpersSegmentJs.b)(label)) for(j = 0, jlen = label.length; j < jlen; ++j){
                nestedLabel = label[j];
                if (!(0, _helpersSegmentJs.k)(nestedLabel) && !(0, _helpersSegmentJs.b)(nestedLabel)) {
                    width = (0, _helpersSegmentJs.V)(ctx, cache.data, cache.gc, width, nestedLabel);
                    height += lineHeight;
                }
            }
            widths.push(width);
            heights.push(height);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
        }
        garbageCollect(caches, length);
        const widest = widths.indexOf(widestLabelSize);
        const highest = heights.indexOf(highestLabelSize);
        const valueAt = (idx)=>({
                width: widths[idx] || 0,
                height: heights[idx] || 0
            });
        return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest),
            widths,
            heights
        };
    }
    getLabelForValue(value) {
        return value;
    }
    getPixelForValue(value, index) {
        return NaN;
    }
    getValueForPixel(pixel) {}
    getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) return null;
        return this.getPixelForValue(ticks[index].value);
    }
    getPixelForDecimal(decimal) {
        if (this._reversePixels) decimal = 1 - decimal;
        const pixel = this._startPixel + decimal * this._length;
        return (0, _helpersSegmentJs.W)(this._alignToPixels ? (0, _helpersSegmentJs.X)(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
        const decimal = (pixel - this._startPixel) / this._length;
        return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
        return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
        const { min, max } = this;
        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    }
    getContext(index) {
        const ticks = this.ticks || [];
        if (index >= 0 && index < ticks.length) {
            const tick = ticks[index];
            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
        }
        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
        const optionTicks = this.options.ticks;
        const rot = (0, _helpersSegmentJs.t)(this.labelRotation);
        const cos = Math.abs(Math.cos(rot));
        const sin = Math.abs(Math.sin(rot));
        const labelSizes = this._getLabelSizes();
        const padding = optionTicks.autoSkipPadding || 0;
        const w = labelSizes ? labelSizes.widest.width + padding : 0;
        const h = labelSizes ? labelSizes.highest.height + padding : 0;
        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
    }
    _isVisible() {
        const display = this.options.display;
        if (display !== "auto") return !!display;
        return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
        const axis = this.axis;
        const chart = this.chart;
        const options = this.options;
        const { grid, position, border } = options;
        const offset = grid.offset;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const ticksLength = ticks.length + (offset ? 1 : 0);
        const tl = getTickMarkLength(grid);
        const items = [];
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = borderOpts.display ? borderOpts.width : 0;
        const axisHalfWidth = axisWidth / 2;
        const alignBorderValue = function(pixel) {
            return (0, _helpersSegmentJs.X)(chart, pixel, axisWidth);
        };
        let borderValue, i, lineValue, alignedLineValue;
        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
        if (position === "top") {
            borderValue = alignBorderValue(this.bottom);
            ty1 = this.bottom - tl;
            ty2 = borderValue - axisHalfWidth;
            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
            y2 = chartArea.bottom;
        } else if (position === "bottom") {
            borderValue = alignBorderValue(this.top);
            y1 = chartArea.top;
            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
            ty1 = borderValue + axisHalfWidth;
            ty2 = this.top + tl;
        } else if (position === "left") {
            borderValue = alignBorderValue(this.right);
            tx1 = this.right - tl;
            tx2 = borderValue - axisHalfWidth;
            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
            x2 = chartArea.right;
        } else if (position === "right") {
            borderValue = alignBorderValue(this.left);
            x1 = chartArea.left;
            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
            tx1 = borderValue + axisHalfWidth;
            tx2 = this.left + tl;
        } else if (axis === "x") {
            if (position === "center") borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
            else if ((0, _helpersSegmentJs.i)(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            y1 = chartArea.top;
            y2 = chartArea.bottom;
            ty1 = borderValue + axisHalfWidth;
            ty2 = ty1 + tl;
        } else if (axis === "y") {
            if (position === "center") borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
            else if ((0, _helpersSegmentJs.i)(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
            }
            tx1 = borderValue - axisHalfWidth;
            tx2 = tx1 - tl;
            x1 = chartArea.left;
            x2 = chartArea.right;
        }
        const limit = (0, _helpersSegmentJs.v)(options.ticks.maxTicksLimit, ticksLength);
        const step = Math.max(1, Math.ceil(ticksLength / limit));
        for(i = 0; i < ticksLength; i += step){
            const context = this.getContext(i);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            const lineWidth = optsAtIndex.lineWidth;
            const lineColor = optsAtIndex.color;
            const borderDash = optsAtIndexBorder.dash || [];
            const borderDashOffset = optsAtIndexBorder.dashOffset;
            const tickWidth = optsAtIndex.tickWidth;
            const tickColor = optsAtIndex.tickColor;
            const tickBorderDash = optsAtIndex.tickBorderDash || [];
            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
            lineValue = getPixelForGridLine(this, i, offset);
            if (lineValue === undefined) continue;
            alignedLineValue = (0, _helpersSegmentJs.X)(chart, lineValue, lineWidth);
            if (isHorizontal) tx1 = tx2 = x1 = x2 = alignedLineValue;
            else ty1 = ty2 = y1 = y2 = alignedLineValue;
            items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset,
                tickWidth,
                tickColor,
                tickBorderDash,
                tickBorderDashOffset
            });
        }
        this._ticksLength = ticksLength;
        this._borderValue = borderValue;
        return items;
    }
    _computeLabelItems(chartArea) {
        const axis = this.axis;
        const options = this.options;
        const { position, ticks: optionTicks } = options;
        const isHorizontal = this.isHorizontal();
        const ticks = this.ticks;
        const { align, crossAlign, padding, mirror } = optionTicks;
        const tl = getTickMarkLength(options.grid);
        const tickAndPadding = tl + padding;
        const hTickAndPadding = mirror ? -padding : tickAndPadding;
        const rotation = -(0, _helpersSegmentJs.t)(this.labelRotation);
        const items = [];
        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
        let textBaseline = "middle";
        if (position === "top") {
            y = this.bottom - hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
        } else if (position === "bottom") {
            y = this.top + hTickAndPadding;
            textAlign = this._getXAxisLabelAlignment();
        } else if (position === "left") {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
        } else if (position === "right") {
            const ret = this._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
        } else if (axis === "x") {
            if (position === "center") y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
            else if ((0, _helpersSegmentJs.i)(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
            }
            textAlign = this._getXAxisLabelAlignment();
        } else if (axis === "y") {
            if (position === "center") x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
            else if ((0, _helpersSegmentJs.i)(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                x = this.chart.scales[positionAxisID].getPixelForValue(value);
            }
            textAlign = this._getYAxisLabelAlignment(tl).textAlign;
        }
        if (axis === "y") {
            if (align === "start") textBaseline = "top";
            else if (align === "end") textBaseline = "bottom";
        }
        const labelSizes = this._getLabelSizes();
        for(i = 0, ilen = ticks.length; i < ilen; ++i){
            tick = ticks[i];
            label = tick.label;
            const optsAtIndex = optionTicks.setContext(this.getContext(i));
            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
            font = this._resolveTickFontOptions(i);
            lineHeight = font.lineHeight;
            lineCount = (0, _helpersSegmentJs.b)(label) ? label.length : 1;
            const halfCount = lineCount / 2;
            const color = optsAtIndex.color;
            const strokeColor = optsAtIndex.textStrokeColor;
            const strokeWidth = optsAtIndex.textStrokeWidth;
            let tickTextAlign = textAlign;
            if (isHorizontal) {
                x = pixel;
                if (textAlign === "inner") {
                    if (i === ilen - 1) tickTextAlign = !this.options.reverse ? "right" : "left";
                    else if (i === 0) tickTextAlign = !this.options.reverse ? "left" : "right";
                    else tickTextAlign = "center";
                }
                if (position === "top") {
                    if (crossAlign === "near" || rotation !== 0) textOffset = -lineCount * lineHeight + lineHeight / 2;
                    else if (crossAlign === "center") textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                    else textOffset = -labelSizes.highest.height + lineHeight / 2;
                } else {
                    if (crossAlign === "near" || rotation !== 0) textOffset = lineHeight / 2;
                    else if (crossAlign === "center") textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                    else textOffset = labelSizes.highest.height - lineCount * lineHeight;
                }
                if (mirror) textOffset *= -1;
                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) x += lineHeight / 2 * Math.sin(rotation);
            } else {
                y = pixel;
                textOffset = (1 - lineCount) * lineHeight / 2;
            }
            let backdrop;
            if (optsAtIndex.showLabelBackdrop) {
                const labelPadding = (0, _helpersSegmentJs.E)(optsAtIndex.backdropPadding);
                const height = labelSizes.heights[i];
                const width = labelSizes.widths[i];
                let top = textOffset - labelPadding.top;
                let left = 0 - labelPadding.left;
                switch(textBaseline){
                    case "middle":
                        top -= height / 2;
                        break;
                    case "bottom":
                        top -= height;
                        break;
                }
                switch(textAlign){
                    case "center":
                        left -= width / 2;
                        break;
                    case "right":
                        left -= width;
                        break;
                    case "inner":
                        if (i === ilen - 1) left -= width;
                        else if (i > 0) left -= width / 2;
                        break;
                }
                backdrop = {
                    left,
                    top,
                    width: width + labelPadding.width,
                    height: height + labelPadding.height,
                    color: optsAtIndex.backdropColor
                };
            }
            items.push({
                label,
                font,
                textOffset,
                options: {
                    rotation,
                    color,
                    strokeColor,
                    strokeWidth,
                    textAlign: tickTextAlign,
                    textBaseline,
                    translation: [
                        x,
                        y
                    ],
                    backdrop
                }
            });
        }
        return items;
    }
    _getXAxisLabelAlignment() {
        const { position, ticks } = this.options;
        const rotation = -(0, _helpersSegmentJs.t)(this.labelRotation);
        if (rotation) return position === "top" ? "left" : "right";
        let align = "center";
        if (ticks.align === "start") align = "left";
        else if (ticks.align === "end") align = "right";
        else if (ticks.align === "inner") align = "inner";
        return align;
    }
    _getYAxisLabelAlignment(tl) {
        const { position, ticks: { crossAlign, mirror, padding } } = this.options;
        const labelSizes = this._getLabelSizes();
        const tickAndPadding = tl + padding;
        const widest = labelSizes.widest.width;
        let textAlign;
        let x;
        if (position === "left") {
            if (mirror) {
                x = this.right + padding;
                if (crossAlign === "near") textAlign = "left";
                else if (crossAlign === "center") {
                    textAlign = "center";
                    x += widest / 2;
                } else {
                    textAlign = "right";
                    x += widest;
                }
            } else {
                x = this.right - tickAndPadding;
                if (crossAlign === "near") textAlign = "right";
                else if (crossAlign === "center") {
                    textAlign = "center";
                    x -= widest / 2;
                } else {
                    textAlign = "left";
                    x = this.left;
                }
            }
        } else if (position === "right") {
            if (mirror) {
                x = this.left + padding;
                if (crossAlign === "near") textAlign = "right";
                else if (crossAlign === "center") {
                    textAlign = "center";
                    x -= widest / 2;
                } else {
                    textAlign = "left";
                    x -= widest;
                }
            } else {
                x = this.left + tickAndPadding;
                if (crossAlign === "near") textAlign = "left";
                else if (crossAlign === "center") {
                    textAlign = "center";
                    x += widest / 2;
                } else {
                    textAlign = "right";
                    x = this.right;
                }
            }
        } else textAlign = "right";
        return {
            textAlign,
            x
        };
    }
    _computeLabelArea() {
        if (this.options.ticks.mirror) return;
        const chart = this.chart;
        const position = this.options.position;
        if (position === "left" || position === "right") return {
            top: 0,
            left: this.left,
            bottom: chart.height,
            right: this.right
        };
        if (position === "top" || position === "bottom") return {
            top: this.top,
            left: 0,
            bottom: this.bottom,
            right: chart.width
        };
    }
    drawBackground() {
        const { ctx, options: { backgroundColor }, left, top, width, height } = this;
        if (backgroundColor) {
            ctx.save();
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(left, top, width, height);
            ctx.restore();
        }
    }
    getLineWidthForValue(value) {
        const grid = this.options.grid;
        if (!this._isVisible() || !grid.display) return 0;
        const ticks = this.ticks;
        const index = ticks.findIndex((t)=>t.value === value);
        if (index >= 0) {
            const opts = grid.setContext(this.getContext(index));
            return opts.lineWidth;
        }
        return 0;
    }
    drawGrid(chartArea) {
        const grid = this.options.grid;
        const ctx = this.ctx;
        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
        let i, ilen;
        const drawLine = (p1, p2, style)=>{
            if (!style.width || !style.color) return;
            ctx.save();
            ctx.lineWidth = style.width;
            ctx.strokeStyle = style.color;
            ctx.setLineDash(style.borderDash || []);
            ctx.lineDashOffset = style.borderDashOffset;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.restore();
        };
        if (grid.display) for(i = 0, ilen = items.length; i < ilen; ++i){
            const item = items[i];
            if (grid.drawOnChartArea) drawLine({
                x: item.x1,
                y: item.y1
            }, {
                x: item.x2,
                y: item.y2
            }, item);
            if (grid.drawTicks) drawLine({
                x: item.tx1,
                y: item.ty1
            }, {
                x: item.tx2,
                y: item.ty2
            }, {
                color: item.tickColor,
                width: item.tickWidth,
                borderDash: item.tickBorderDash,
                borderDashOffset: item.tickBorderDashOffset
            });
        }
    }
    drawBorder() {
        const { chart, ctx, options: { border, grid } } = this;
        const borderOpts = border.setContext(this.getContext());
        const axisWidth = border.display ? borderOpts.width : 0;
        if (!axisWidth) return;
        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
        const borderValue = this._borderValue;
        let x1, x2, y1, y2;
        if (this.isHorizontal()) {
            x1 = (0, _helpersSegmentJs.X)(chart, this.left, axisWidth) - axisWidth / 2;
            x2 = (0, _helpersSegmentJs.X)(chart, this.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
        } else {
            y1 = (0, _helpersSegmentJs.X)(chart, this.top, axisWidth) - axisWidth / 2;
            y2 = (0, _helpersSegmentJs.X)(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
        }
        ctx.save();
        ctx.lineWidth = borderOpts.width;
        ctx.strokeStyle = borderOpts.color;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.restore();
    }
    drawLabels(chartArea) {
        const optionTicks = this.options.ticks;
        if (!optionTicks.display) return;
        const ctx = this.ctx;
        const area = this._computeLabelArea();
        if (area) (0, _helpersSegmentJs.Y)(ctx, area);
        const items = this.getLabelItems(chartArea);
        for (const item of items){
            const renderTextOptions = item.options;
            const tickFont = item.font;
            const label = item.label;
            const y = item.textOffset;
            (0, _helpersSegmentJs.Z)(ctx, label, 0, y, tickFont, renderTextOptions);
        }
        if (area) (0, _helpersSegmentJs.$)(ctx);
    }
    drawTitle() {
        const { ctx, options: { position, title, reverse } } = this;
        if (!title.display) return;
        const font = (0, _helpersSegmentJs.a0)(title.font);
        const padding = (0, _helpersSegmentJs.E)(title.padding);
        const align = title.align;
        let offset = font.lineHeight / 2;
        if (position === "bottom" || position === "center" || (0, _helpersSegmentJs.i)(position)) {
            offset += padding.bottom;
            if ((0, _helpersSegmentJs.b)(title.text)) offset += font.lineHeight * (title.text.length - 1);
        } else offset += padding.top;
        const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
        (0, _helpersSegmentJs.Z)(ctx, title.text, 0, 0, font, {
            color: title.color,
            maxWidth,
            rotation,
            textAlign: titleAlign(align, position, reverse),
            textBaseline: "middle",
            translation: [
                titleX,
                titleY
            ]
        });
    }
    draw(chartArea) {
        if (!this._isVisible()) return;
        this.drawBackground();
        this.drawGrid(chartArea);
        this.drawBorder();
        this.drawTitle();
        this.drawLabels(chartArea);
    }
    _layers() {
        const opts = this.options;
        const tz = opts.ticks && opts.ticks.z || 0;
        const gz = (0, _helpersSegmentJs.v)(opts.grid && opts.grid.z, -1);
        const bz = (0, _helpersSegmentJs.v)(opts.border && opts.border.z, 0);
        if (!this._isVisible() || this.draw !== Scale.prototype.draw) return [
            {
                z: tz,
                draw: (chartArea)=>{
                    this.draw(chartArea);
                }
            }
        ];
        return [
            {
                z: gz,
                draw: (chartArea)=>{
                    this.drawBackground();
                    this.drawGrid(chartArea);
                    this.drawTitle();
                }
            },
            {
                z: bz,
                draw: ()=>{
                    this.drawBorder();
                }
            },
            {
                z: tz,
                draw: (chartArea)=>{
                    this.drawLabels(chartArea);
                }
            }
        ];
    }
    getMatchingVisibleMetas(type) {
        const metas = this.chart.getSortedVisibleDatasetMetas();
        const axisID = this.axis + "AxisID";
        const result = [];
        let i, ilen;
        for(i = 0, ilen = metas.length; i < ilen; ++i){
            const meta = metas[i];
            if (meta[axisID] === this.id && (!type || meta.type === type)) result.push(meta);
        }
        return result;
    }
    _resolveTickFontOptions(index) {
        const opts = this.options.ticks.setContext(this.getContext(index));
        return (0, _helpersSegmentJs.a0)(opts.font);
    }
    _maxDigits() {
        const fontSize = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
}
class TypedRegistry {
    constructor(type, scope, override){
        this.type = type;
        this.scope = scope;
        this.override = override;
        this.items = Object.create(null);
    }
    isForType(type) {
        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
        const proto = Object.getPrototypeOf(item);
        let parentScope;
        if (isIChartComponent(proto)) parentScope = this.register(proto);
        const items = this.items;
        const id = item.id;
        const scope = this.scope + "." + id;
        if (!id) throw new Error("class does not have id: " + item);
        if (id in items) return scope;
        items[id] = item;
        registerDefaults(item, scope, parentScope);
        if (this.override) (0, _helpersSegmentJs.d).override(item.id, item.overrides);
        return scope;
    }
    get(id) {
        return this.items[id];
    }
    unregister(item) {
        const items = this.items;
        const id = item.id;
        const scope = this.scope;
        if (id in items) delete items[id];
        if (scope && id in (0, _helpersSegmentJs.d)[scope]) {
            delete (0, _helpersSegmentJs.d)[scope][id];
            if (this.override) delete (0, _helpersSegmentJs.a3)[id];
        }
    }
}
function registerDefaults(item, scope, parentScope) {
    const itemDefaults = (0, _helpersSegmentJs.a4)(Object.create(null), [
        parentScope ? (0, _helpersSegmentJs.d).get(parentScope) : {},
        (0, _helpersSegmentJs.d).get(scope),
        item.defaults
    ]);
    (0, _helpersSegmentJs.d).set(scope, itemDefaults);
    if (item.defaultRoutes) routeDefaults(scope, item.defaultRoutes);
    if (item.descriptors) (0, _helpersSegmentJs.d).describe(scope, item.descriptors);
}
function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property)=>{
        const propertyParts = property.split(".");
        const sourceName = propertyParts.pop();
        const sourceScope = [
            scope
        ].concat(propertyParts).join(".");
        const parts = routes[property].split(".");
        const targetName = parts.pop();
        const targetScope = parts.join(".");
        (0, _helpersSegmentJs.d).route(sourceScope, sourceName, targetScope, targetName);
    });
}
function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
}
class Registry {
    constructor(){
        this.controllers = new TypedRegistry(DatasetController, "datasets", true);
        this.elements = new TypedRegistry(Element, "elements");
        this.plugins = new TypedRegistry(Object, "plugins");
        this.scales = new TypedRegistry(Scale, "scales");
        this._typedRegistries = [
            this.controllers,
            this.scales,
            this.elements
        ];
    }
    add(...args) {
        this._each("register", args);
    }
    remove(...args) {
        this._each("unregister", args);
    }
    addControllers(...args) {
        this._each("register", args, this.controllers);
    }
    addElements(...args) {
        this._each("register", args, this.elements);
    }
    addPlugins(...args) {
        this._each("register", args, this.plugins);
    }
    addScales(...args) {
        this._each("register", args, this.scales);
    }
    getController(id) {
        return this._get(id, this.controllers, "controller");
    }
    getElement(id) {
        return this._get(id, this.elements, "element");
    }
    getPlugin(id) {
        return this._get(id, this.plugins, "plugin");
    }
    getScale(id) {
        return this._get(id, this.scales, "scale");
    }
    removeControllers(...args) {
        this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
        this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
        this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
        this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
        [
            ...args
        ].forEach((arg)=>{
            const reg = typedRegistry || this._getRegistryForType(arg);
            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) this._exec(method, reg, arg);
            else (0, _helpersSegmentJs.F)(arg, (item)=>{
                const itemReg = typedRegistry || this._getRegistryForType(item);
                this._exec(method, itemReg, item);
            });
        });
    }
    _exec(method, registry, component) {
        const camelMethod = (0, _helpersSegmentJs.a5)(method);
        (0, _helpersSegmentJs.Q)(component["before" + camelMethod], [], component);
        registry[method](component);
        (0, _helpersSegmentJs.Q)(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
        for(let i = 0; i < this._typedRegistries.length; i++){
            const reg = this._typedRegistries[i];
            if (reg.isForType(type)) return reg;
        }
        return this.plugins;
    }
    _get(id, typedRegistry, type) {
        const item = typedRegistry.get(id);
        if (item === undefined) throw new Error('"' + id + '" is not a registered ' + type + ".");
        return item;
    }
}
var registry = /* #__PURE__ */ new Registry();
class PluginService {
    constructor(){
        this._init = [];
    }
    notify(chart, hook, args, filter) {
        if (hook === "beforeInit") {
            this._init = this._createDescriptors(chart, true);
            this._notify(this._init, chart, "install");
        }
        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
        const result = this._notify(descriptors, chart, hook, args);
        if (hook === "afterDestroy") {
            this._notify(descriptors, chart, "stop");
            this._notify(this._init, chart, "uninstall");
        }
        return result;
    }
    _notify(descriptors, chart, hook, args) {
        args = args || {};
        for (const descriptor of descriptors){
            const plugin = descriptor.plugin;
            const method = plugin[hook];
            const params = [
                chart,
                args,
                descriptor.options
            ];
            if ((0, _helpersSegmentJs.Q)(method, params, plugin) === false && args.cancelable) return false;
        }
        return true;
    }
    invalidate() {
        if (!(0, _helpersSegmentJs.k)(this._cache)) {
            this._oldCache = this._cache;
            this._cache = undefined;
        }
    }
    _descriptors(chart) {
        if (this._cache) return this._cache;
        const descriptors = this._cache = this._createDescriptors(chart);
        this._notifyStateChanges(chart);
        return descriptors;
    }
    _createDescriptors(chart, all) {
        const config = chart && chart.config;
        const options = (0, _helpersSegmentJs.v)(config.options && config.options.plugins, {});
        const plugins = allPlugins(config);
        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
    }
    _notifyStateChanges(chart) {
        const previousDescriptors = this._oldCache || [];
        const descriptors = this._cache;
        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));
        this._notify(diff(previousDescriptors, descriptors), chart, "stop");
        this._notify(diff(descriptors, previousDescriptors), chart, "start");
    }
}
function allPlugins(config) {
    const localIds = {};
    const plugins = [];
    const keys = Object.keys(registry.plugins.items);
    for(let i = 0; i < keys.length; i++)plugins.push(registry.getPlugin(keys[i]));
    const local = config.plugins || [];
    for(let i = 0; i < local.length; i++){
        const plugin = local[i];
        if (plugins.indexOf(plugin) === -1) {
            plugins.push(plugin);
            localIds[plugin.id] = true;
        }
    }
    return {
        plugins,
        localIds
    };
}
function getOpts(options, all) {
    if (!all && options === false) return null;
    if (options === true) return {};
    return options;
}
function createDescriptors(chart, { plugins, localIds }, options, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin of plugins){
        const id = plugin.id;
        const opts = getOpts(options[id], all);
        if (opts === null) continue;
        result.push({
            plugin,
            options: pluginOpts(chart.config, {
                plugin,
                local: localIds[id]
            }, opts, context)
        });
    }
    return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) scopes.push(plugin.defaults);
    return config.createResolver(scopes, context, [
        ""
    ], {
        scriptable: false,
        indexable: false,
        allKeys: true
    });
}
function getIndexAxis(type, options) {
    const datasetDefaults = (0, _helpersSegmentJs.d).datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === "_index_") axis = indexAxis;
    else if (id === "_value_") axis = indexAxis === "x" ? "y" : "x";
    return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
    if (id === "x" || id === "y" || id === "r") return id;
}
function axisFromPosition(position) {
    if (position === "top" || position === "bottom") return "x";
    if (position === "left" || position === "right") return "y";
}
function determineAxis(id, ...scaleOptions) {
    if (idMatchesAxis(id)) return id;
    for (const opts of scaleOptions){
        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
        if (axis) return axis;
    }
    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
    if (dataset[axis + "AxisID"] === id) return {
        axis
    };
}
function retrieveAxisFromDatasets(id, config) {
    if (config.data && config.data.datasets) {
        const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);
        if (boundDs.length) return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
    return {};
}
function mergeScaleConfig(config, options) {
    const chartDefaults = (0, _helpersSegmentJs.a3)[config.type] || {
        scales: {}
    };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const scales = Object.create(null);
    Object.keys(configScales).forEach((id)=>{
        const scaleConf = configScales[id];
        if (!(0, _helpersSegmentJs.i)(scaleConf)) return console.error(`Invalid scale configuration for scale: ${id}`);
        if (scaleConf._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), (0, _helpersSegmentJs.d).scales[scaleConf.type]);
        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
        const defaultScaleOptions = chartDefaults.scales || {};
        scales[id] = (0, _helpersSegmentJs.ab)(Object.create(null), [
            {
                axis
            },
            scaleConf,
            defaultScaleOptions[axis],
            defaultScaleOptions[defaultId]
        ]);
    });
    config.data.datasets.forEach((dataset)=>{
        const type = dataset.type || config.type;
        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
        const datasetDefaults = (0, _helpersSegmentJs.a3)[type] || {};
        const defaultScaleOptions = datasetDefaults.scales || {};
        Object.keys(defaultScaleOptions).forEach((defaultID)=>{
            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
            const id = dataset[axis + "AxisID"] || axis;
            scales[id] = scales[id] || Object.create(null);
            (0, _helpersSegmentJs.ab)(scales[id], [
                {
                    axis
                },
                configScales[id],
                defaultScaleOptions[defaultID]
            ]);
        });
    });
    Object.keys(scales).forEach((key)=>{
        const scale = scales[key];
        (0, _helpersSegmentJs.ab)(scale, [
            (0, _helpersSegmentJs.d).scales[scale.type],
            (0, _helpersSegmentJs.d).scale
        ]);
    });
    return scales;
}
function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = (0, _helpersSegmentJs.v)(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
}
function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
}
const keyCache = new Map();
const keysCached = new Set();
function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
        keys = generate();
        keyCache.set(cacheKey, keys);
        keysCached.add(keys);
    }
    return keys;
}
const addIfFound = (set, obj, key)=>{
    const opts = (0, _helpersSegmentJs.f)(obj, key);
    if (opts !== undefined) set.add(opts);
};
class Config {
    constructor(config){
        this._config = initConfig(config);
        this._scopeCache = new Map();
        this._resolverCache = new Map();
    }
    get platform() {
        return this._config.platform;
    }
    get type() {
        return this._config.type;
    }
    set type(type) {
        this._config.type = type;
    }
    get data() {
        return this._config.data;
    }
    set data(data) {
        this._config.data = initData(data);
    }
    get options() {
        return this._config.options;
    }
    set options(options) {
        this._config.options = options;
    }
    get plugins() {
        return this._config.plugins;
    }
    update() {
        const config = this._config;
        this.clearCache();
        initOptions(config);
    }
    clearCache() {
        this._scopeCache.clear();
        this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
        return cachedKeys(datasetType, ()=>[
                [
                    `datasets.${datasetType}`,
                    ""
                ]
            ]);
    }
    datasetAnimationScopeKeys(datasetType, transition) {
        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[
                [
                    `datasets.${datasetType}.transitions.${transition}`,
                    `transitions.${transition}`
                ],
                [
                    `datasets.${datasetType}`,
                    ""
                ]
            ]);
    }
    datasetElementScopeKeys(datasetType, elementType) {
        return cachedKeys(`${datasetType}-${elementType}`, ()=>[
                [
                    `datasets.${datasetType}.elements.${elementType}`,
                    `datasets.${datasetType}`,
                    `elements.${elementType}`,
                    ""
                ]
            ]);
    }
    pluginScopeKeys(plugin) {
        const id = plugin.id;
        const type = this.type;
        return cachedKeys(`${type}-plugin-${id}`, ()=>[
                [
                    `plugins.${id}`,
                    ...plugin.additionalOptionScopes || []
                ]
            ]);
    }
    _cachedScopes(mainScope, resetCache) {
        const _scopeCache = this._scopeCache;
        let cache = _scopeCache.get(mainScope);
        if (!cache || resetCache) {
            cache = new Map();
            _scopeCache.set(mainScope, cache);
        }
        return cache;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
        const { options, type } = this;
        const cache = this._cachedScopes(mainScope, resetCache);
        const cached = cache.get(keyLists);
        if (cached) return cached;
        const scopes = new Set();
        keyLists.forEach((keys)=>{
            if (mainScope) {
                scopes.add(mainScope);
                keys.forEach((key)=>addIfFound(scopes, mainScope, key));
            }
            keys.forEach((key)=>addIfFound(scopes, options, key));
            keys.forEach((key)=>addIfFound(scopes, (0, _helpersSegmentJs.a3)[type] || {}, key));
            keys.forEach((key)=>addIfFound(scopes, (0, _helpersSegmentJs.d), key));
            keys.forEach((key)=>addIfFound(scopes, (0, _helpersSegmentJs.a6), key));
        });
        const array = Array.from(scopes);
        if (array.length === 0) array.push(Object.create(null));
        if (keysCached.has(keyLists)) cache.set(keyLists, array);
        return array;
    }
    chartOptionScopes() {
        const { options, type } = this;
        return [
            options,
            (0, _helpersSegmentJs.a3)[type] || {},
            (0, _helpersSegmentJs.d).datasets[type] || {},
            {
                type
            },
            (0, _helpersSegmentJs.d),
            (0, _helpersSegmentJs.a6)
        ];
    }
    resolveNamedOptions(scopes, names, context, prefixes = [
        ""
    ]) {
        const result = {
            $shared: true
        };
        const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
        let options = resolver;
        if (needContext(resolver, names)) {
            result.$shared = false;
            context = (0, _helpersSegmentJs.a7)(context) ? context() : context;
            const subResolver = this.createResolver(scopes, context, subPrefixes);
            options = (0, _helpersSegmentJs.a8)(resolver, context, subResolver);
        }
        for (const prop of names)result[prop] = options[prop];
        return result;
    }
    createResolver(scopes, context, prefixes = [
        ""
    ], descriptorDefaults) {
        const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
        return (0, _helpersSegmentJs.i)(context) ? (0, _helpersSegmentJs.a8)(resolver, context, undefined, descriptorDefaults) : resolver;
    }
}
function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
        cache = new Map();
        resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
        const resolver = (0, _helpersSegmentJs.a9)(scopes, prefixes);
        cached = {
            resolver,
            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes("hover"))
        };
        cache.set(cacheKey, cached);
    }
    return cached;
}
const hasFunction = (value)=>(0, _helpersSegmentJs.i)(value) && Object.getOwnPropertyNames(value).some((key)=>(0, _helpersSegmentJs.a7)(value[key]));
function needContext(proxy, names) {
    const { isScriptable, isIndexable } = (0, _helpersSegmentJs.aa)(proxy);
    for (const prop of names){
        const scriptable = isScriptable(prop);
        const indexable = isIndexable(prop);
        const value = (indexable || scriptable) && proxy[prop];
        if (scriptable && ((0, _helpersSegmentJs.a7)(value) || hasFunction(value)) || indexable && (0, _helpersSegmentJs.b)(value)) return true;
    }
    return false;
}
var version = "4.4.1";
const KNOWN_POSITIONS = [
    "top",
    "bottom",
    "left",
    "right",
    "chartArea"
];
function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
    return function(a, b) {
        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
}
function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins("afterRender");
    (0, _helpersSegmentJs.Q)(animationOptions && animationOptions.onComplete, [
        context
    ], chart);
}
function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    (0, _helpersSegmentJs.Q)(animationOptions && animationOptions.onProgress, [
        context
    ], chart);
}
function getCanvas(item) {
    if ((0, _helpersSegmentJs.M)() && typeof item === "string") item = document.getElementById(item);
    else if (item && item.length) item = item[0];
    if (item && item.canvas) item = item.canvas;
    return item;
}
const instances = {};
const getChart = (key)=>{
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
    const keys = Object.keys(obj);
    for (const key of keys){
        const intKey = +key;
        if (intKey >= start) {
            const value = obj[key];
            delete obj[key];
            if (move > 0 || intKey > start) obj[intKey + move] = value;
        }
    }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === "mouseout") return null;
    if (isClick) return lastEvent;
    return e;
}
function getSizeForArea(scale, chartArea, field) {
    return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
    const { xScale, yScale } = meta;
    if (xScale && yScale) return {
        left: getSizeForArea(xScale, chartArea, "left"),
        right: getSizeForArea(xScale, chartArea, "right"),
        top: getSizeForArea(yScale, chartArea, "top"),
        bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
    return chartArea;
}
class Chart {
    static defaults = (0, _helpersSegmentJs.d);
    static instances = instances;
    static overrides = (0, _helpersSegmentJs.a3);
    static registry = registry;
    static version = version;
    static getChart = getChart;
    static register(...items) {
        registry.add(...items);
        invalidatePlugins();
    }
    static unregister(...items) {
        registry.remove(...items);
        invalidatePlugins();
    }
    constructor(item, userConfig){
        const config = this.config = new Config(userConfig);
        const initialCanvas = getCanvas(item);
        const existingChart = getChart(initialCanvas);
        if (existingChart) throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "'" + " must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
        const options = config.createResolver(config.chartOptionScopes(), this.getContext());
        this.platform = new (config.platform || _detectPlatform(initialCanvas))();
        this.platform.updateConfig(config);
        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
        const canvas = context && context.canvas;
        const height = canvas && canvas.height;
        const width = canvas && canvas.width;
        this.id = (0, _helpersSegmentJs.ac)();
        this.ctx = context;
        this.canvas = canvas;
        this.width = width;
        this.height = height;
        this._options = options;
        this._aspectRatio = this.aspectRatio;
        this._layers = [];
        this._metasets = [];
        this._stacks = undefined;
        this.boxes = [];
        this.currentDevicePixelRatio = undefined;
        this.chartArea = undefined;
        this._active = [];
        this._lastEvent = undefined;
        this._listeners = {};
        this._responsiveListeners = undefined;
        this._sortedMetasets = [];
        this.scales = {};
        this._plugins = new PluginService();
        this.$proxies = {};
        this._hiddenIndices = {};
        this.attached = false;
        this._animationsDisabled = undefined;
        this.$context = undefined;
        this._doResize = (0, _helpersSegmentJs.ad)((mode)=>this.update(mode), options.resizeDelay || 0);
        this._dataChanges = [];
        instances[this.id] = this;
        if (!context || !canvas) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
        }
        animator.listen(this, "complete", onAnimationsComplete);
        animator.listen(this, "progress", onAnimationProgress);
        this._initialize();
        if (this.attached) this.update();
    }
    get aspectRatio() {
        const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
        if (!(0, _helpersSegmentJs.k)(aspectRatio)) return aspectRatio;
        if (maintainAspectRatio && _aspectRatio) return _aspectRatio;
        return height ? width / height : null;
    }
    get data() {
        return this.config.data;
    }
    set data(data) {
        this.config.data = data;
    }
    get options() {
        return this._options;
    }
    set options(options) {
        this.config.options = options;
    }
    get registry() {
        return registry;
    }
    _initialize() {
        this.notifyPlugins("beforeInit");
        if (this.options.responsive) this.resize();
        else (0, _helpersSegmentJs.ae)(this, this.options.devicePixelRatio);
        this.bindEvents();
        this.notifyPlugins("afterInit");
        return this;
    }
    clear() {
        (0, _helpersSegmentJs.af)(this.canvas, this.ctx);
        return this;
    }
    stop() {
        animator.stop(this);
        return this;
    }
    resize(width, height) {
        if (!animator.running(this)) this._resize(width, height);
        else this._resizeBeforeDraw = {
            width,
            height
        };
    }
    _resize(width, height) {
        const options = this.options;
        const canvas = this.canvas;
        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
        const mode = this.width ? "resize" : "attach";
        this.width = newSize.width;
        this.height = newSize.height;
        this._aspectRatio = this.aspectRatio;
        if (!(0, _helpersSegmentJs.ae)(this, newRatio, true)) return;
        this.notifyPlugins("resize", {
            size: newSize
        });
        (0, _helpersSegmentJs.Q)(options.onResize, [
            this,
            newSize
        ], this);
        if (this.attached) {
            if (this._doResize(mode)) this.render();
        }
    }
    ensureScalesHaveIDs() {
        const options = this.options;
        const scalesOptions = options.scales || {};
        (0, _helpersSegmentJs.F)(scalesOptions, (axisOptions, axisID)=>{
            axisOptions.id = axisID;
        });
    }
    buildOrUpdateScales() {
        const options = this.options;
        const scaleOpts = options.scales;
        const scales = this.scales;
        const updated = Object.keys(scales).reduce((obj, id)=>{
            obj[id] = false;
            return obj;
        }, {});
        let items = [];
        if (scaleOpts) items = items.concat(Object.keys(scaleOpts).map((id)=>{
            const scaleOptions = scaleOpts[id];
            const axis = determineAxis(id, scaleOptions);
            const isRadial = axis === "r";
            const isHorizontal = axis === "x";
            return {
                options: scaleOptions,
                dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
            };
        }));
        (0, _helpersSegmentJs.F)(items, (item)=>{
            const scaleOptions = item.options;
            const id = scaleOptions.id;
            const axis = determineAxis(id, scaleOptions);
            const scaleType = (0, _helpersSegmentJs.v)(scaleOptions.type, item.dtype);
            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) scaleOptions.position = item.dposition;
            updated[id] = true;
            let scale = null;
            if (id in scales && scales[id].type === scaleType) scale = scales[id];
            else {
                const scaleClass = registry.getScale(scaleType);
                scale = new scaleClass({
                    id,
                    type: scaleType,
                    ctx: this.ctx,
                    chart: this
                });
                scales[scale.id] = scale;
            }
            scale.init(scaleOptions, options);
        });
        (0, _helpersSegmentJs.F)(updated, (hasUpdated, id)=>{
            if (!hasUpdated) delete scales[id];
        });
        (0, _helpersSegmentJs.F)(scales, (scale)=>{
            layouts.configure(this, scale, scale.options);
            layouts.addBox(this, scale);
        });
    }
    _updateMetasets() {
        const metasets = this._metasets;
        const numData = this.data.datasets.length;
        const numMeta = metasets.length;
        metasets.sort((a, b)=>a.index - b.index);
        if (numMeta > numData) {
            for(let i = numData; i < numMeta; ++i)this._destroyDatasetMeta(i);
            metasets.splice(numData, numMeta - numData);
        }
        this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
        const { _metasets: metasets, data: { datasets } } = this;
        if (metasets.length > datasets.length) delete this._stacks;
        metasets.forEach((meta, index)=>{
            if (datasets.filter((x)=>x === meta._dataset).length === 0) this._destroyDatasetMeta(index);
        });
    }
    buildOrUpdateControllers() {
        const newControllers = [];
        const datasets = this.data.datasets;
        let i, ilen;
        this._removeUnreferencedMetasets();
        for(i = 0, ilen = datasets.length; i < ilen; i++){
            const dataset = datasets[i];
            let meta = this.getDatasetMeta(i);
            const type = dataset.type || this.config.type;
            if (meta.type && meta.type !== type) {
                this._destroyDatasetMeta(i);
                meta = this.getDatasetMeta(i);
            }
            meta.type = type;
            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
            meta.order = dataset.order || 0;
            meta.index = i;
            meta.label = "" + dataset.label;
            meta.visible = this.isDatasetVisible(i);
            if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
            } else {
                const ControllerClass = registry.getController(type);
                const { datasetElementType, dataElementType } = (0, _helpersSegmentJs.d).datasets[type];
                Object.assign(ControllerClass, {
                    dataElementType: registry.getElement(dataElementType),
                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                });
                meta.controller = new ControllerClass(this, i);
                newControllers.push(meta.controller);
            }
        }
        this._updateMetasets();
        return newControllers;
    }
    _resetElements() {
        (0, _helpersSegmentJs.F)(this.data.datasets, (dataset, datasetIndex)=>{
            this.getDatasetMeta(datasetIndex).controller.reset();
        }, this);
    }
    reset() {
        this._resetElements();
        this.notifyPlugins("reset");
    }
    update(mode) {
        const config = this.config;
        config.update();
        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
        const animsDisabled = this._animationsDisabled = !options.animation;
        this._updateScales();
        this._checkEventBindings();
        this._updateHiddenIndices();
        this._plugins.invalidate();
        if (this.notifyPlugins("beforeUpdate", {
            mode,
            cancelable: true
        }) === false) return;
        const newControllers = this.buildOrUpdateControllers();
        this.notifyPlugins("beforeElementsUpdate");
        let minPadding = 0;
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){
            const { controller } = this.getDatasetMeta(i);
            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
            controller.buildOrUpdateElements(reset);
            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
        }
        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
        this._updateLayout(minPadding);
        if (!animsDisabled) (0, _helpersSegmentJs.F)(newControllers, (controller)=>{
            controller.reset();
        });
        this._updateDatasets(mode);
        this.notifyPlugins("afterUpdate", {
            mode
        });
        this._layers.sort(compare2Level("z", "_idx"));
        const { _active, _lastEvent } = this;
        if (_lastEvent) this._eventHandler(_lastEvent, true);
        else if (_active.length) this._updateHoverStyles(_active, _active, true);
        this.render();
    }
    _updateScales() {
        (0, _helpersSegmentJs.F)(this.scales, (scale)=>{
            layouts.removeBox(this, scale);
        });
        this.ensureScalesHaveIDs();
        this.buildOrUpdateScales();
    }
    _checkEventBindings() {
        const options = this.options;
        const existingEvents = new Set(Object.keys(this._listeners));
        const newEvents = new Set(options.events);
        if (!(0, _helpersSegmentJs.ag)(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
            this.unbindEvents();
            this.bindEvents();
        }
    }
    _updateHiddenIndices() {
        const { _hiddenIndices } = this;
        const changes = this._getUniformDataChanges() || [];
        for (const { method, start, count } of changes){
            const move = method === "_removeElements" ? -count : count;
            moveNumericKeys(_hiddenIndices, start, move);
        }
    }
    _getUniformDataChanges() {
        const _dataChanges = this._dataChanges;
        if (!_dataChanges || !_dataChanges.length) return;
        this._dataChanges = [];
        const datasetCount = this.data.datasets.length;
        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + "," + c.splice(1).join(",")));
        const changeSet = makeSet(0);
        for(let i = 1; i < datasetCount; i++){
            if (!(0, _helpersSegmentJs.ag)(changeSet, makeSet(i))) return;
        }
        return Array.from(changeSet).map((c)=>c.split(",")).map((a)=>({
                method: a[1],
                start: +a[2],
                count: +a[3]
            }));
    }
    _updateLayout(minPadding) {
        if (this.notifyPlugins("beforeLayout", {
            cancelable: true
        }) === false) return;
        layouts.update(this, this.width, this.height, minPadding);
        const area = this.chartArea;
        const noArea = area.width <= 0 || area.height <= 0;
        this._layers = [];
        (0, _helpersSegmentJs.F)(this.boxes, (box)=>{
            if (noArea && box.position === "chartArea") return;
            if (box.configure) box.configure();
            this._layers.push(...box._layers());
        }, this);
        this._layers.forEach((item, index)=>{
            item._idx = index;
        });
        this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
        if (this.notifyPlugins("beforeDatasetsUpdate", {
            mode,
            cancelable: true
        }) === false) return;
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i)this.getDatasetMeta(i).controller.configure();
        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i)this._updateDataset(i, (0, _helpersSegmentJs.a7)(mode) ? mode({
            datasetIndex: i
        }) : mode);
        this.notifyPlugins("afterDatasetsUpdate", {
            mode
        });
    }
    _updateDataset(index, mode) {
        const meta = this.getDatasetMeta(index);
        const args = {
            meta,
            index,
            mode,
            cancelable: true
        };
        if (this.notifyPlugins("beforeDatasetUpdate", args) === false) return;
        meta.controller._update(mode);
        args.cancelable = false;
        this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
        if (this.notifyPlugins("beforeRender", {
            cancelable: true
        }) === false) return;
        if (animator.has(this)) {
            if (this.attached && !animator.running(this)) animator.start(this);
        } else {
            this.draw();
            onAnimationsComplete({
                chart: this
            });
        }
    }
    draw() {
        let i;
        if (this._resizeBeforeDraw) {
            const { width, height } = this._resizeBeforeDraw;
            this._resize(width, height);
            this._resizeBeforeDraw = null;
        }
        this.clear();
        if (this.width <= 0 || this.height <= 0) return;
        if (this.notifyPlugins("beforeDraw", {
            cancelable: true
        }) === false) return;
        const layers = this._layers;
        for(i = 0; i < layers.length && layers[i].z <= 0; ++i)layers[i].draw(this.chartArea);
        this._drawDatasets();
        for(; i < layers.length; ++i)layers[i].draw(this.chartArea);
        this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
        const metasets = this._sortedMetasets;
        const result = [];
        let i, ilen;
        for(i = 0, ilen = metasets.length; i < ilen; ++i){
            const meta = metasets[i];
            if (!filterVisible || meta.visible) result.push(meta);
        }
        return result;
    }
    getSortedVisibleDatasetMetas() {
        return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
        if (this.notifyPlugins("beforeDatasetsDraw", {
            cancelable: true
        }) === false) return;
        const metasets = this.getSortedVisibleDatasetMetas();
        for(let i = metasets.length - 1; i >= 0; --i)this._drawDataset(metasets[i]);
        this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta) {
        const ctx = this.ctx;
        const clip = meta._clip;
        const useClip = !clip.disabled;
        const area = getDatasetArea(meta, this.chartArea);
        const args = {
            meta,
            index: meta.index,
            cancelable: true
        };
        if (this.notifyPlugins("beforeDatasetDraw", args) === false) return;
        if (useClip) (0, _helpersSegmentJs.Y)(ctx, {
            left: clip.left === false ? 0 : area.left - clip.left,
            right: clip.right === false ? this.width : area.right + clip.right,
            top: clip.top === false ? 0 : area.top - clip.top,
            bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
        });
        meta.controller.draw();
        if (useClip) (0, _helpersSegmentJs.$)(ctx);
        args.cancelable = false;
        this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point) {
        return (0, _helpersSegmentJs.C)(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e, mode, options, useFinalPosition) {
        const method = Interaction.modes[mode];
        if (typeof method === "function") return method(this, e, options, useFinalPosition);
        return [];
    }
    getDatasetMeta(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        const metasets = this._metasets;
        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();
        if (!meta) {
            meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: dataset && dataset.order || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: false
            };
            metasets.push(meta);
        }
        return meta;
    }
    getContext() {
        return this.$context || (this.$context = (0, _helpersSegmentJs.j)(null, {
            chart: this,
            type: "chart"
        }));
    }
    getVisibleDatasetCount() {
        return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
        const dataset = this.data.datasets[datasetIndex];
        if (!dataset) return false;
        const meta = this.getDatasetMeta(datasetIndex);
        return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
        const meta = this.getDatasetMeta(datasetIndex);
        meta.hidden = !visible;
    }
    toggleDataVisibility(index) {
        this._hiddenIndices[index] = !this._hiddenIndices[index];
    }
    getDataVisibility(index) {
        return !this._hiddenIndices[index];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
        const mode = visible ? "show" : "hide";
        const meta = this.getDatasetMeta(datasetIndex);
        const anims = meta.controller._resolveAnimations(undefined, mode);
        if ((0, _helpersSegmentJs.h)(dataIndex)) {
            meta.data[dataIndex].hidden = !visible;
            this.update();
        } else {
            this.setDatasetVisibility(datasetIndex, visible);
            anims.update(meta, {
                visible
            });
            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);
        }
    }
    hide(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
        this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
        const meta = this._metasets[datasetIndex];
        if (meta && meta.controller) meta.controller._destroy();
        delete this._metasets[datasetIndex];
    }
    _stop() {
        let i, ilen;
        this.stop();
        animator.remove(this);
        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i)this._destroyDatasetMeta(i);
    }
    destroy() {
        this.notifyPlugins("beforeDestroy");
        const { canvas, ctx } = this;
        this._stop();
        this.config.clearCache();
        if (canvas) {
            this.unbindEvents();
            (0, _helpersSegmentJs.af)(canvas, ctx);
            this.platform.releaseContext(ctx);
            this.canvas = null;
            this.ctx = null;
        }
        delete instances[this.id];
        this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
        return this.canvas.toDataURL(...args);
    }
    bindEvents() {
        this.bindUserEvents();
        if (this.options.responsive) this.bindResponsiveEvents();
        else this.attached = true;
    }
    bindUserEvents() {
        const listeners = this._listeners;
        const platform = this.platform;
        const _add = (type, listener)=>{
            platform.addEventListener(this, type, listener);
            listeners[type] = listener;
        };
        const listener = (e, x, y)=>{
            e.offsetX = x;
            e.offsetY = y;
            this._eventHandler(e);
        };
        (0, _helpersSegmentJs.F)(this.options.events, (type)=>_add(type, listener));
    }
    bindResponsiveEvents() {
        if (!this._responsiveListeners) this._responsiveListeners = {};
        const listeners = this._responsiveListeners;
        const platform = this.platform;
        const _add = (type, listener)=>{
            platform.addEventListener(this, type, listener);
            listeners[type] = listener;
        };
        const _remove = (type, listener)=>{
            if (listeners[type]) {
                platform.removeEventListener(this, type, listener);
                delete listeners[type];
            }
        };
        const listener = (width, height)=>{
            if (this.canvas) this.resize(width, height);
        };
        let detached;
        const attached = ()=>{
            _remove("attach", attached);
            this.attached = true;
            this.resize();
            _add("resize", listener);
            _add("detach", detached);
        };
        detached = ()=>{
            this.attached = false;
            _remove("resize", listener);
            this._stop();
            this._resize(0, 0);
            _add("attach", attached);
        };
        if (platform.isAttached(this.canvas)) attached();
        else detached();
    }
    unbindEvents() {
        (0, _helpersSegmentJs.F)(this._listeners, (listener, type)=>{
            this.platform.removeEventListener(this, type, listener);
        });
        this._listeners = {};
        (0, _helpersSegmentJs.F)(this._responsiveListeners, (listener, type)=>{
            this.platform.removeEventListener(this, type, listener);
        });
        this._responsiveListeners = undefined;
    }
    updateHoverStyle(items, mode, enabled) {
        const prefix = enabled ? "set" : "remove";
        let meta, item, i, ilen;
        if (mode === "dataset") {
            meta = this.getDatasetMeta(items[0].datasetIndex);
            meta.controller["_" + prefix + "DatasetHoverStyle"]();
        }
        for(i = 0, ilen = items.length; i < ilen; ++i){
            item = items[i];
            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
            if (controller) controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
        }
    }
    getActiveElements() {
        return this._active || [];
    }
    setActiveElements(activeElements) {
        const lastActive = this._active || [];
        const active = activeElements.map(({ datasetIndex, index })=>{
            const meta = this.getDatasetMeta(datasetIndex);
            if (!meta) throw new Error("No dataset found at index " + datasetIndex);
            return {
                datasetIndex,
                element: meta.data[index],
                index
            };
        });
        const changed = !(0, _helpersSegmentJs.ah)(active, lastActive);
        if (changed) {
            this._active = active;
            this._lastEvent = null;
            this._updateHoverStyles(active, lastActive);
        }
    }
    notifyPlugins(hook, args, filter) {
        return this._plugins.notify(this, hook, args, filter);
    }
    isPluginEnabled(pluginId) {
        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;
    }
    _updateHoverStyles(active, lastActive, replay) {
        const hoverOptions = this.options.hover;
        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));
        const deactivated = diff(lastActive, active);
        const activated = replay ? active : diff(active, lastActive);
        if (deactivated.length) this.updateHoverStyle(deactivated, hoverOptions.mode, false);
        if (activated.length && hoverOptions.mode) this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
    _eventHandler(e, replay) {
        const args = {
            event: e,
            replay,
            cancelable: true,
            inChartArea: this.isPointInArea(e)
        };
        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);
        if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) return;
        const changed = this._handleEvent(e, replay, args.inChartArea);
        args.cancelable = false;
        this.notifyPlugins("afterEvent", args, eventFilter);
        if (changed || args.changed) this.render();
        return this;
    }
    _handleEvent(e, replay, inChartArea) {
        const { _active: lastActive = [], options } = this;
        const useFinalPosition = replay;
        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
        const isClick = (0, _helpersSegmentJs.ai)(e);
        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
        if (inChartArea) {
            this._lastEvent = null;
            (0, _helpersSegmentJs.Q)(options.onHover, [
                e,
                active,
                this
            ], this);
            if (isClick) (0, _helpersSegmentJs.Q)(options.onClick, [
                e,
                active,
                this
            ], this);
        }
        const changed = !(0, _helpersSegmentJs.ah)(active, lastActive);
        if (changed || replay) {
            this._active = active;
            this._updateHoverStyles(active, lastActive, replay);
        }
        this._lastEvent = lastEvent;
        return changed;
    }
    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
        if (e.type === "mouseout") return [];
        if (!inChartArea) return lastActive;
        const hoverOptions = this.options.hover;
        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
}
function invalidatePlugins() {
    return (0, _helpersSegmentJs.F)(Chart.instances, (chart)=>chart._plugins.invalidate());
}
function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    // Draw an inner border by clipping the arc and drawing a double-width border
    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
        angleMargin = pixelMargin / innerRadius;
        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else ctx.arc(x, y, pixelMargin, endAngle + (0, _helpersSegmentJs.H), startAngle - (0, _helpersSegmentJs.H));
    ctx.closePath();
    ctx.clip();
}
function toRadiusCorners(value) {
    return (0, _helpersSegmentJs.ak)(value, [
        "outerStart",
        "outerEnd",
        "innerStart",
        "innerEnd"
    ]);
}
/**
 * Parse border radius from the provided options
 */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    // Outer limits are complicated. We want to compute the available angular distance at
    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.
    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.
    //
    // If the borderRadius is large, that value can become negative.
    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius
    // we know that the thickness term will dominate and compute the limits at that point
    const computeOuterLimit = (val)=>{
        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
        return (0, _helpersSegmentJs.S)(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
        outerStart: computeOuterLimit(o.outerStart),
        outerEnd: computeOuterLimit(o.outerEnd),
        innerStart: (0, _helpersSegmentJs.S)(o.innerStart, 0, innerLimit),
        innerEnd: (0, _helpersSegmentJs.S)(o.innerEnd, 0, innerLimit)
    };
}
/**
 * Convert (r, 𝜃) to (x, y)
 */ function rThetaToXY(r, theta, x, y) {
    return {
        x: x + r * Math.cos(theta),
        y: y + r * Math.sin(theta)
    };
}
/**
 * Path the arc, respecting border radius by separating into left and right halves.
 *
 *   Start      End
 *
 *    1--->a--->2    Outer
 *   /           \
 *   8           3
 *   |           |
 *   |           |
 *   7           4
 *   \           /
 *    6<---b<---5    Inner
 */ function pathArc(ctx, element, offset, spacing, end, circular) {
    const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha = end - start;
    if (spacing) {
        // When spacing is present, it is the same for all items
        // So we adjust the start and end angle of the arc such that
        // the distance is the same as it would be without the spacing
        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
        spacingOffset = (alpha - adjustedAngle) / 2;
    }
    const beta = Math.max(0.001, alpha * outerRadius - offset / (0, _helpersSegmentJs.P)) / outerRadius;
    const angleOffset = (alpha - beta) / 2;
    const startAngle = start + angleOffset + spacingOffset;
    const endAngle = end - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
        // The first arc segments from point 1 to point a to point 2
        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
        // The corner segment from point 2 to point 3
        if (outerEnd > 0) {
            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + (0, _helpersSegmentJs.H));
        }
        // The line from point 3 to point 4
        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
        ctx.lineTo(p4.x, p4.y);
        // The corner segment from point 4 to point 5
        if (innerEnd > 0) {
            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + (0, _helpersSegmentJs.H), innerEndAdjustedAngle + Math.PI);
        }
        // The inner arc from point 5 to point b to point 6
        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
        // The corner segment from point 6 to point 7
        if (innerStart > 0) {
            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - (0, _helpersSegmentJs.H));
        }
        // The line from point 7 to point 8
        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
        ctx.lineTo(p8.x, p8.y);
        // The corner segment from point 8 to point 1
        if (outerStart > 0) {
            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - (0, _helpersSegmentJs.H), outerStartAdjustedAngle);
        }
    } else {
        ctx.moveTo(x, y);
        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
        ctx.lineTo(outerStartX, outerStartY);
        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
        ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        for(let i = 0; i < fullCircles; ++i)ctx.fill();
        if (!isNaN(circumference)) endAngle = startAngle + (circumference % (0, _helpersSegmentJs.T) || (0, _helpersSegmentJs.T));
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference, options } = element;
    const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
    const inner = options.borderAlign === "inner";
    if (!borderWidth) return;
    ctx.setLineDash(borderDash || []);
    ctx.lineDashOffset = borderDashOffset;
    if (inner) {
        ctx.lineWidth = borderWidth * 2;
        ctx.lineJoin = borderJoinStyle || "round";
    } else {
        ctx.lineWidth = borderWidth;
        ctx.lineJoin = borderJoinStyle || "bevel";
    }
    let endAngle = element.endAngle;
    if (fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        for(let i = 0; i < fullCircles; ++i)ctx.stroke();
        if (!isNaN(circumference)) endAngle = startAngle + (circumference % (0, _helpersSegmentJs.T) || (0, _helpersSegmentJs.T));
    }
    if (inner) clipArc(ctx, element, endAngle);
    if (!fullCircles) {
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        ctx.stroke();
    }
}
class ArcElement extends Element {
    static id = "arc";
    static defaults = {
        borderAlign: "center",
        borderColor: "#fff",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: undefined,
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: undefined,
        circular: true
    };
    static defaultRoutes = {
        backgroundColor: "backgroundColor"
    };
    static descriptors = {
        _scriptable: true,
        _indexable: (name)=>name !== "borderDash"
    };
    circumference;
    endAngle;
    fullCircles;
    innerRadius;
    outerRadius;
    pixelMargin;
    startAngle;
    constructor(cfg){
        super();
        this.options = undefined;
        this.circumference = undefined;
        this.startAngle = undefined;
        this.endAngle = undefined;
        this.innerRadius = undefined;
        this.outerRadius = undefined;
        this.pixelMargin = 0;
        this.fullCircles = 0;
        if (cfg) Object.assign(this, cfg);
    }
    inRange(chartX, chartY, useFinalPosition) {
        const point = this.getProps([
            "x",
            "y"
        ], useFinalPosition);
        const { angle, distance } = (0, _helpersSegmentJs.D)(point, {
            x: chartX,
            y: chartY
        });
        const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius",
            "circumference"
        ], useFinalPosition);
        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
        const _circumference = (0, _helpersSegmentJs.v)(circumference, endAngle - startAngle);
        const betweenAngles = _circumference >= (0, _helpersSegmentJs.T) || (0, _helpersSegmentJs.p)(angle, startAngle, endAngle);
        const withinRadius = (0, _helpersSegmentJs.aj)(distance, innerRadius + rAdjust, outerRadius + rAdjust);
        return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
        const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
            "x",
            "y",
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius"
        ], useFinalPosition);
        const { offset, spacing } = this.options;
        const halfAngle = (startAngle + endAngle) / 2;
        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
        return {
            x: x + Math.cos(halfAngle) * halfRadius,
            y: y + Math.sin(halfAngle) * halfRadius
        };
    }
    tooltipPosition(useFinalPosition) {
        return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
        const { options, circumference } = this;
        const offset = (options.offset || 0) / 4;
        const spacing = (options.spacing || 0) / 2;
        const circular = options.circular;
        this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
        this.fullCircles = circumference > (0, _helpersSegmentJs.T) ? Math.floor(circumference / (0, _helpersSegmentJs.T)) : 0;
        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) return;
        ctx.save();
        const halfAngle = (this.startAngle + this.endAngle) / 2;
        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
        const fix = 1 - Math.sin(Math.min((0, _helpersSegmentJs.P), circumference || 0));
        const radiusOffset = offset * fix;
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        drawArc(ctx, this, radiusOffset, spacing, circular);
        drawBorder(ctx, this, radiusOffset, spacing, circular);
        ctx.restore();
    }
}
function setStyle(ctx, options, style = options) {
    ctx.lineCap = (0, _helpersSegmentJs.v)(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash((0, _helpersSegmentJs.v)(style.borderDash, options.borderDash));
    ctx.lineDashOffset = (0, _helpersSegmentJs.v)(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = (0, _helpersSegmentJs.v)(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = (0, _helpersSegmentJs.v)(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = (0, _helpersSegmentJs.v)(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
    if (options.stepped) return 0, _helpersSegmentJs.ar;
    if (options.tension || options.cubicInterpolationMode === "monotone") return 0, _helpersSegmentJs.as;
    return lineTo;
}
function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start = Math.max(paramsStart, segmentStart);
    const end = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
        count,
        start,
        loop: segment.loop,
        ilen: end < start && !outside ? count + end - start : end - start
    };
}
function pathSegment(ctx, line, segment, params) {
    const { points, options } = line;
    const { count, start, loop, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move = true, reverse } = params || {};
    let i, point, prev;
    for(i = 0; i <= ilen; ++i){
        point = points[(start + (reverse ? ilen - i : i)) % count];
        if (point.skip) continue;
        else if (move) {
            ctx.moveTo(point.x, point.y);
            move = false;
        } else lineMethod(ctx, prev, point, reverse, options.stepped);
        prev = point;
    }
    if (loop) {
        point = points[(start + (reverse ? ilen : 0)) % count];
        lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count, start, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i, point, prevX, minY, maxY, lastY;
    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;
    const drawX = ()=>{
        if (minY !== maxY) {
            ctx.lineTo(avgX, maxY);
            ctx.lineTo(avgX, minY);
            ctx.lineTo(avgX, lastY);
        }
    };
    if (move) {
        point = points[pointIndex(0)];
        ctx.moveTo(point.x, point.y);
    }
    for(i = 0; i <= ilen; ++i){
        point = points[pointIndex(i)];
        if (point.skip) continue;
        const x = point.x;
        const y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
            if (y < minY) minY = y;
            else if (y > maxY) maxY = y;
            avgX = (countX * avgX + x) / ++countX;
        } else {
            drawX();
            ctx.lineTo(x, y);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
        }
        lastY = y;
    }
    drawX();
}
function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
    if (options.stepped) return 0, _helpersSegmentJs.ao;
    if (options.tension || options.cubicInterpolationMode === "monotone") return 0, _helpersSegmentJs.ap;
    return 0, _helpersSegmentJs.aq;
}
function strokePathWithCache(ctx, line, start, count) {
    let path = line._path;
    if (!path) {
        path = line._path = new Path2D();
        if (line.path(path, start, count)) path.closePath();
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
    const { segments, options } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments){
        setStyle(ctx, options, segment.style);
        ctx.beginPath();
        if (segmentMethod(ctx, line, segment, {
            start,
            end: start + count - 1
        })) ctx.closePath();
        ctx.stroke();
    }
}
const usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
    if (usePath2D && !line.options.segment) strokePathWithCache(ctx, line, start, count);
    else strokePathDirect(ctx, line, start, count);
}
class LineElement extends Element {
    static id = "line";
    static defaults = {
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderWidth: 3,
        capBezierPoints: true,
        cubicInterpolationMode: "default",
        fill: false,
        spanGaps: false,
        stepped: false,
        tension: 0
    };
    static defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    static descriptors = {
        _scriptable: true,
        _indexable: (name)=>name !== "borderDash" && name !== "fill"
    };
    constructor(cfg){
        super();
        this.animated = true;
        this.options = undefined;
        this._chart = undefined;
        this._loop = undefined;
        this._fullLoop = undefined;
        this._path = undefined;
        this._points = undefined;
        this._segments = undefined;
        this._decimated = false;
        this._pointsUpdated = false;
        this._datasetIndex = undefined;
        if (cfg) Object.assign(this, cfg);
    }
    updateControlPoints(chartArea, indexAxis) {
        const options = this.options;
        if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
            const loop = options.spanGaps ? this._loop : this._fullLoop;
            (0, _helpersSegmentJs.al)(this._points, options, chartArea, loop, indexAxis);
            this._pointsUpdated = true;
        }
    }
    set points(points) {
        this._points = points;
        delete this._segments;
        delete this._path;
        this._pointsUpdated = false;
    }
    get points() {
        return this._points;
    }
    get segments() {
        return this._segments || (this._segments = (0, _helpersSegmentJs.am)(this, this.options.segment));
    }
    first() {
        const segments = this.segments;
        const points = this.points;
        return segments.length && points[segments[0].start];
    }
    last() {
        const segments = this.segments;
        const points = this.points;
        const count = segments.length;
        return count && points[segments[count - 1].end];
    }
    interpolate(point, property) {
        const options = this.options;
        const value = point[property];
        const points = this.points;
        const segments = (0, _helpersSegmentJs.an)(this, {
            property,
            start: value,
            end: value
        });
        if (!segments.length) return;
        const result = [];
        const _interpolate = _getInterpolationMethod(options);
        let i, ilen;
        for(i = 0, ilen = segments.length; i < ilen; ++i){
            const { start, end } = segments[i];
            const p1 = points[start];
            const p2 = points[end];
            if (p1 === p2) {
                result.push(p1);
                continue;
            }
            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
            const interpolated = _interpolate(p1, p2, t, options.stepped);
            interpolated[property] = point[property];
            result.push(interpolated);
        }
        return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
        const segmentMethod = _getSegmentMethod(this);
        return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start, count) {
        const segments = this.segments;
        const segmentMethod = _getSegmentMethod(this);
        let loop = this._loop;
        start = start || 0;
        count = count || this.points.length - start;
        for (const segment of segments)loop &= segmentMethod(ctx, this, segment, {
            start,
            end: start + count - 1
        });
        return !!loop;
    }
    draw(ctx, chartArea, start, count) {
        const options = this.options || {};
        const points = this.points || [];
        if (points.length && options.borderWidth) {
            ctx.save();
            draw(ctx, this, start, count);
            ctx.restore();
        }
        if (this.animated) {
            this._pointsUpdated = false;
            this._path = undefined;
        }
    }
}
function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value } = el.getProps([
        axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
}
class PointElement extends Element {
    static id = "point";
    parsed;
    skip;
    stop;
    /**
   * @type {any}
   */ static defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: "circle",
        radius: 3,
        rotation: 0
    };
    /**
   * @type {any}
   */ static defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    constructor(cfg){
        super();
        this.options = undefined;
        this.parsed = undefined;
        this.skip = undefined;
        this.stop = undefined;
        if (cfg) Object.assign(this, cfg);
    }
    inRange(mouseX, mouseY, useFinalPosition) {
        const options = this.options;
        const { x, y } = this.getProps([
            "x",
            "y"
        ], useFinalPosition);
        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
        return inRange$1(this, mouseX, "x", useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
        return inRange$1(this, mouseY, "y", useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
        const { x, y } = this.getProps([
            "x",
            "y"
        ], useFinalPosition);
        return {
            x,
            y
        };
    }
    size(options) {
        options = options || this.options || {};
        let radius = options.radius || 0;
        radius = Math.max(radius, radius && options.hoverRadius || 0);
        const borderWidth = radius && options.borderWidth || 0;
        return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
        const options = this.options;
        if (this.skip || options.radius < 0.1 || !(0, _helpersSegmentJs.C)(this, area, this.size(options) / 2)) return;
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.fillStyle = options.backgroundColor;
        (0, _helpersSegmentJs.at)(ctx, options, this.x, this.y);
    }
    getRange() {
        const options = this.options || {};
        // @ts-expect-error Fallbacks should never be hit in practice
        return options.radius + options.hitRadius;
    }
}
function getBarBounds(bar, useFinalPosition) {
    const { x, y, base, width, height } = bar.getProps([
        "x",
        "y",
        "base",
        "width",
        "height"
    ], useFinalPosition);
    let left, right, top, bottom, half;
    if (bar.horizontal) {
        half = height / 2;
        left = Math.min(x, base);
        right = Math.max(x, base);
        top = y - half;
        bottom = y + half;
    } else {
        half = width / 2;
        left = x - half;
        right = x + half;
        top = Math.min(y, base);
        bottom = Math.max(y, base);
    }
    return {
        left,
        top,
        right,
        bottom
    };
}
function skipOrLimit(skip, value, min, max) {
    return skip ? 0 : (0, _helpersSegmentJs.S)(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip = bar.borderSkipped;
    const o = (0, _helpersSegmentJs.av)(value);
    return {
        t: skipOrLimit(skip.top, o.top, 0, maxH),
        r: skipOrLimit(skip.right, o.right, 0, maxW),
        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
        l: skipOrLimit(skip.left, o.left, 0, maxW)
    };
}
function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps([
        "enableBorderRadius"
    ]);
    const value = bar.options.borderRadius;
    const o = (0, _helpersSegmentJs.aw)(value);
    const maxR = Math.min(maxW, maxH);
    const skip = bar.borderSkipped;
    const enableBorder = enableBorderRadius || (0, _helpersSegmentJs.i)(value);
    return {
        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
    };
}
function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
        outer: {
            x: bounds.left,
            y: bounds.top,
            w: width,
            h: height,
            radius
        },
        inner: {
            x: bounds.left + border.l,
            y: bounds.top + border.t,
            w: width - border.l - border.r,
            h: height - border.t - border.b,
            radius: {
                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
            }
        }
    };
}
function inRange(bar, x, y, useFinalPosition) {
    const skipX = x === null;
    const skipY = y === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || (0, _helpersSegmentJs.aj)(x, bounds.left, bounds.right)) && (skipY || (0, _helpersSegmentJs.aj)(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
    const x = rect.x !== refRect.x ? -amount : 0;
    const y = rect.y !== refRect.y ? -amount : 0;
    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
    return {
        x: rect.x + x,
        y: rect.y + y,
        w: rect.w + w,
        h: rect.h + h,
        radius: rect.radius
    };
}
class BarElement extends Element {
    static id = "bar";
    static defaults = {
        borderSkipped: "start",
        borderWidth: 0,
        borderRadius: 0,
        inflateAmount: "auto",
        pointStyle: undefined
    };
    static defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    constructor(cfg){
        super();
        this.options = undefined;
        this.horizontal = undefined;
        this.base = undefined;
        this.width = undefined;
        this.height = undefined;
        this.inflateAmount = undefined;
        if (cfg) Object.assign(this, cfg);
    }
    draw(ctx) {
        const { inflateAmount, options: { borderColor, backgroundColor } } = this;
        const { inner, outer } = boundingRects(this);
        const addRectPath = hasRadius(outer.radius) ? (0, _helpersSegmentJs.au) : addNormalRectPath;
        ctx.save();
        if (outer.w !== inner.w || outer.h !== inner.h) {
            ctx.beginPath();
            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
            ctx.clip();
            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
            ctx.fillStyle = borderColor;
            ctx.fill("evenodd");
        }
        ctx.beginPath();
        addRectPath(ctx, inflateRect(inner, inflateAmount));
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
        return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
        return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
        return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
        const { x, y, base, horizontal } = this.getProps([
            "x",
            "y",
            "base",
            "horizontal"
        ], useFinalPosition);
        return {
            x: horizontal ? (x + base) / 2 : x,
            y: horizontal ? y : (y + base) / 2
        };
    }
    getRange(axis) {
        return axis === "x" ? this.width / 2 : this.height / 2;
    }
}
var elements = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ArcElement: ArcElement,
    BarElement: BarElement,
    LineElement: LineElement,
    PointElement: PointElement
});
const BORDER_COLORS = [
    "rgb(54, 162, 235)",
    "rgb(255, 99, 132)",
    "rgb(255, 159, 64)",
    "rgb(255, 205, 86)",
    "rgb(75, 192, 192)",
    "rgb(153, 102, 255)",
    "rgb(201, 203, 207)" // grey
];
// Border colors with 50% transparency
const BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function getBorderColor(i) {
    return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i) {
    dataset.borderColor = getBorderColor(i);
    dataset.backgroundColor = getBackgroundColor(i);
    return ++i;
}
function colorizeDoughnutDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));
    return i;
}
function colorizePolarAreaDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));
    return i;
}
function getColorizer(chart) {
    let i = 0;
    return (dataset, datasetIndex)=>{
        const controller = chart.getDatasetMeta(datasetIndex).controller;
        if (controller instanceof DoughnutController) i = colorizeDoughnutDataset(dataset, i);
        else if (controller instanceof PolarAreaController) i = colorizePolarAreaDataset(dataset, i);
        else if (controller) i = colorizeDefaultDataset(dataset, i);
    };
}
function containsColorsDefinitions(descriptors) {
    let k;
    for(k in descriptors){
        if (descriptors[k].borderColor || descriptors[k].backgroundColor) return true;
    }
    return false;
}
function containsColorsDefinition(descriptor) {
    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
var plugin_colors = {
    id: "colors",
    defaults: {
        enabled: true,
        forceOverride: false
    },
    beforeLayout (chart, _args, options) {
        if (!options.enabled) return;
        const { data: { datasets }, options: chartOptions } = chart.config;
        const { elements } = chartOptions;
        if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements))) return;
        const colorizer = getColorizer(chart);
        datasets.forEach(colorizer);
    }
};
function lttbDecimation(data, start, count, availableWidth, options) {
    const samples = options.samples || availableWidth;
    if (samples >= count) return data.slice(start, start + count);
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start + count - 1;
    let a = start;
    let i, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a];
    for(i = 0; i < samples - 2; i++){
        let avgX = 0;
        let avgY = 0;
        let j;
        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
        const avgRangeLength = avgRangeEnd - avgRangeStart;
        for(j = avgRangeStart; j < avgRangeEnd; j++){
            avgX += data[j].x;
            avgY += data[j].y;
        }
        avgX /= avgRangeLength;
        avgY /= avgRangeLength;
        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
        const { x: pointAx, y: pointAy } = data[a];
        maxArea = area = -1;
        for(j = rangeOffs; j < rangeTo; j++){
            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
            if (area > maxArea) {
                maxArea = area;
                maxAreaPoint = data[j];
                nextA = j;
            }
        }
        decimated[sampledIndex++] = maxAreaPoint;
        a = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start + count - 1;
    const xMin = data[start].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for(i = start; i < start + count; ++i){
        point = data[i];
        x = (point.x - xMin) / dx * availableWidth;
        y = point.y;
        const truncX = x | 0;
        if (truncX === prevX) {
            if (y < minY) {
                minY = y;
                minIndex = i;
            } else if (y > maxY) {
                maxY = y;
                maxIndex = i;
            }
            avgX = (countX * avgX + point.x) / ++countX;
        } else {
            const lastIndex = i - 1;
            if (!(0, _helpersSegmentJs.k)(minIndex) && !(0, _helpersSegmentJs.k)(maxIndex)) {
                const intermediateIndex1 = Math.min(minIndex, maxIndex);
                const intermediateIndex2 = Math.max(minIndex, maxIndex);
                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) decimated.push({
                    ...data[intermediateIndex1],
                    x: avgX
                });
                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) decimated.push({
                    ...data[intermediateIndex2],
                    x: avgX
                });
            }
            if (i > 0 && lastIndex !== startIndex) decimated.push(data[lastIndex]);
            decimated.push(point);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
            minIndex = maxIndex = startIndex = i;
        }
    }
    return decimated;
}
function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
        const data = dataset._data;
        delete dataset._decimated;
        delete dataset._data;
        Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            writable: true,
            value: data
        });
    }
}
function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset)=>{
        cleanDecimatedDataset(dataset);
    });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start = 0;
    let count;
    const { iScale } = meta;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) start = (0, _helpersSegmentJs.S)((0, _helpersSegmentJs.B)(points, iScale.axis, min).lo, 0, pointCount - 1);
    if (maxDefined) count = (0, _helpersSegmentJs.S)((0, _helpersSegmentJs.B)(points, iScale.axis, max).hi + 1, start, pointCount) - start;
    else count = pointCount - start;
    return {
        start,
        count
    };
}
var plugin_decimation = {
    id: "decimation",
    defaults: {
        algorithm: "min-max",
        enabled: false
    },
    beforeElementsUpdate: (chart, args, options)=>{
        if (!options.enabled) {
            cleanDecimatedData(chart);
            return;
        }
        const availableWidth = chart.width;
        chart.data.datasets.forEach((dataset, datasetIndex)=>{
            const { _data, indexAxis } = dataset;
            const meta = chart.getDatasetMeta(datasetIndex);
            const data = _data || dataset.data;
            if ((0, _helpersSegmentJs.a)([
                indexAxis,
                chart.options.indexAxis
            ]) === "y") return;
            if (!meta.controller.supportsDecimation) return;
            const xAxis = chart.scales[meta.xAxisID];
            if (xAxis.type !== "linear" && xAxis.type !== "time") return;
            if (chart.options.parsing) return;
            let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
            const threshold = options.threshold || 4 * availableWidth;
            if (count <= threshold) {
                cleanDecimatedDataset(dataset);
                return;
            }
            if ((0, _helpersSegmentJs.k)(_data)) {
                dataset._data = data;
                delete dataset.data;
                Object.defineProperty(dataset, "data", {
                    configurable: true,
                    enumerable: true,
                    get: function() {
                        return this._decimated;
                    },
                    set: function(d) {
                        this._data = d;
                    }
                });
            }
            let decimated;
            switch(options.algorithm){
                case "lttb":
                    decimated = lttbDecimation(data, start, count, availableWidth, options);
                    break;
                case "min-max":
                    decimated = minMaxDecimation(data, start, count, availableWidth);
                    break;
                default:
                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
            }
            dataset._decimated = decimated;
        });
    },
    destroy (chart) {
        cleanDecimatedData(chart);
    }
};
function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments){
        let { start, end } = segment;
        end = _findSegmentEnd(start, end, points);
        const bounds = _getBounds(property, points[start], points[end], segment.loop);
        if (!target.segments) {
            parts.push({
                source: segment,
                target: bounds,
                start: points[start],
                end: points[end]
            });
            continue;
        }
        const targetSegments = (0, _helpersSegmentJs.an)(target, bounds);
        for (const tgt of targetSegments){
            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
            const fillSources = (0, _helpersSegmentJs.ax)(segment, points, subBounds);
            for (const fillSource of fillSources)parts.push({
                source: fillSource,
                target: tgt,
                start: {
                    [property]: _getEdge(bounds, subBounds, "start", Math.max)
                },
                end: {
                    [property]: _getEdge(bounds, subBounds, "end", Math.min)
                }
            });
        }
    }
    return parts;
}
function _getBounds(property, first, last, loop) {
    if (loop) return;
    let start = first[property];
    let end = last[property];
    if (property === "angle") {
        start = (0, _helpersSegmentJs.ay)(start);
        end = (0, _helpersSegmentJs.ay)(end);
    }
    return {
        property,
        start,
        end
    };
}
function _pointsFromSegments(boundary, line) {
    const { x = null, y = null } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start, end })=>{
        end = _findSegmentEnd(start, end, linePoints);
        const first = linePoints[start];
        const last = linePoints[end];
        if (y !== null) {
            points.push({
                x: first.x,
                y
            });
            points.push({
                x: last.x,
                y
            });
        } else if (x !== null) {
            points.push({
                x,
                y: first.y
            });
            points.push({
                x,
                y: last.y
            });
        }
    });
    return points;
}
function _findSegmentEnd(start, end, points) {
    for(; end > start; end--){
        const point = points[end];
        if (!isNaN(point.x) && !isNaN(point.y)) break;
    }
    return end;
}
function _getEdge(a, b, prop, fn) {
    if (a && b) return fn(a[prop], b[prop]);
    return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if ((0, _helpersSegmentJs.b)(boundary)) {
        _loop = true;
        points = boundary;
    } else points = _pointsFromSegments(boundary, line);
    return points.length ? new LineElement({
        points,
        options: {
            tension: 0
        },
        _loop,
        _fullLoop: _loop
    }) : null;
}
function _shouldApplyFill(source) {
    return source && source.fill !== false;
}
function _resolveTarget(sources, index, propagate) {
    const source = sources[index];
    let fill = source.fill;
    const visited = [
        index
    ];
    let target;
    if (!propagate) return fill;
    while(fill !== false && visited.indexOf(fill) === -1){
        if (!(0, _helpersSegmentJs.g)(fill)) return fill;
        target = sources[fill];
        if (!target) return false;
        if (target.visible) return fill;
        visited.push(fill);
        fill = target.fill;
    }
    return false;
}
function _decodeFill(line, index, count) {
    const fill = parseFillOption(line);
    if ((0, _helpersSegmentJs.i)(fill)) return isNaN(fill.value) ? false : fill;
    let target = parseFloat(fill);
    if ((0, _helpersSegmentJs.g)(target) && Math.floor(target) === target) return decodeTargetIndex(fill[0], index, target, count);
    return [
        "origin",
        "start",
        "end",
        "stack",
        "shape"
    ].indexOf(fill) >= 0 && fill;
}
function decodeTargetIndex(firstCh, index, target, count) {
    if (firstCh === "-" || firstCh === "+") target = index + target;
    if (target === index || target < 0 || target >= count) return false;
    return target;
}
function _getTargetPixel(fill, scale) {
    let pixel = null;
    if (fill === "start") pixel = scale.bottom;
    else if (fill === "end") pixel = scale.top;
    else if ((0, _helpersSegmentJs.i)(fill)) pixel = scale.getPixelForValue(fill.value);
    else if (scale.getBasePixel) pixel = scale.getBasePixel();
    return pixel;
}
function _getTargetValue(fill, scale, startValue) {
    let value;
    if (fill === "start") value = startValue;
    else if (fill === "end") value = scale.options.reverse ? scale.min : scale.max;
    else if ((0, _helpersSegmentJs.i)(fill)) value = fill.value;
    else value = scale.getBaseValue();
    return value;
}
function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill = (0, _helpersSegmentJs.v)(fillOption && fillOption.target, fillOption);
    if (fill === undefined) fill = !!options.backgroundColor;
    if (fill === false || fill === null) return false;
    if (fill === true) return "origin";
    return fill;
}
function _buildStackLine(source) {
    const { scale, index, line } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index);
    linesBelow.push(_createBoundaryLine({
        x: null,
        y: scale.bottom
    }, line));
    for(let i = 0; i < segments.length; i++){
        const segment = segments[i];
        for(let j = segment.start; j <= segment.end; j++)addPointsBelow(points, sourcePoints[j], linesBelow);
    }
    return new LineElement({
        points,
        options: {}
    });
}
function getLinesBelow(scale, index) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas("line");
    for(let i = 0; i < metas.length; i++){
        const meta = metas[i];
        if (meta.index === index) break;
        if (!meta.hidden) below.unshift(meta.dataset);
    }
    return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for(let j = 0; j < linesBelow.length; j++){
        const line = linesBelow[j];
        const { first, last, point } = findPoint(line, sourcePoint, "x");
        if (!point || first && last) continue;
        if (first) postponed.unshift(point);
        else {
            points.push(point);
            if (!last) break;
        }
    }
    points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) return {};
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last = false;
    for(let i = 0; i < segments.length; i++){
        const segment = segments[i];
        const firstValue = linePoints[segment.start][property];
        const lastValue = linePoints[segment.end][property];
        if ((0, _helpersSegmentJs.aj)(pointValue, firstValue, lastValue)) {
            first = pointValue === firstValue;
            last = pointValue === lastValue;
            break;
        }
    }
    return {
        first,
        last,
        point
    };
}
class simpleArc {
    constructor(opts){
        this.x = opts.x;
        this.y = opts.y;
        this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
        const { x, y, radius } = this;
        bounds = bounds || {
            start: 0,
            end: (0, _helpersSegmentJs.T)
        };
        ctx.arc(x, y, radius, bounds.end, bounds.start, true);
        return !opts.bounds;
    }
    interpolate(point) {
        const { x, y, radius } = this;
        const angle = point.angle;
        return {
            x: x + Math.cos(angle) * radius,
            y: y + Math.sin(angle) * radius,
            angle
        };
    }
}
function _getTarget(source) {
    const { chart, fill, line } = source;
    if ((0, _helpersSegmentJs.g)(fill)) return getLineByIndex(chart, fill);
    if (fill === "stack") return _buildStackLine(source);
    if (fill === "shape") return true;
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) return boundary;
    return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index) {
    const meta = chart.getDatasetMeta(index);
    const visible = meta && chart.isDatasetVisible(index);
    return visible ? meta.dataset : null;
}
function computeBoundary(source) {
    const scale = source.scale || {};
    if (scale.getPointPositionForValue) return computeCircularBoundary(source);
    return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
    const { scale = {}, fill } = source;
    const pixel = _getTargetPixel(fill, scale);
    if ((0, _helpersSegmentJs.g)(pixel)) {
        const horizontal = scale.isHorizontal();
        return {
            x: horizontal ? pixel : null,
            y: horizontal ? null : pixel
        };
    }
    return null;
}
function computeCircularBoundary(source) {
    const { scale, fill } = source;
    const options = scale.options;
    const length = scale.getLabels().length;
    const start = options.reverse ? scale.max : scale.min;
    const value = _getTargetValue(fill, scale, start);
    const target = [];
    if (options.grid.circular) {
        const center = scale.getPointPositionForValue(0, start);
        return new simpleArc({
            x: center.x,
            y: center.y,
            radius: scale.getDistanceFromCenterForValue(value)
        });
    }
    for(let i = 0; i < length; ++i)target.push(scale.getPointPositionForValue(i, value));
    return target;
}
function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { line, scale, axis } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color = lineOpts.backgroundColor;
    const { above = color, below = color } = fillOption || {};
    if (target && line.points.length) {
        (0, _helpersSegmentJs.Y)(ctx, area);
        doFill(ctx, {
            line,
            target,
            above,
            below,
            area,
            scale,
            axis
        });
        (0, _helpersSegmentJs.$)(ctx);
    }
}
function doFill(ctx, cfg) {
    const { line, target, above, below, area, scale } = cfg;
    const property = line._loop ? "angle" : cfg.axis;
    ctx.save();
    if (property === "x" && below !== above) {
        clipVertical(ctx, target, area.top);
        fill(ctx, {
            line,
            target,
            color: above,
            scale,
            property
        });
        ctx.restore();
        ctx.save();
        clipVertical(ctx, target, area.bottom);
    }
    fill(ctx, {
        line,
        target,
        color: below,
        scale,
        property
    });
    ctx.restore();
}
function clipVertical(ctx, target, clipY) {
    const { segments, points } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments){
        const { start, end } = segment;
        const firstPoint = points[start];
        const lastPoint = points[_findSegmentEnd(start, end, points)];
        if (first) {
            ctx.moveTo(firstPoint.x, firstPoint.y);
            first = false;
        } else {
            ctx.lineTo(firstPoint.x, clipY);
            ctx.lineTo(firstPoint.x, firstPoint.y);
        }
        lineLoop = !!target.pathSegment(ctx, segment, {
            move: lineLoop
        });
        if (lineLoop) ctx.closePath();
        else ctx.lineTo(lastPoint.x, clipY);
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
}
function fill(ctx, cfg) {
    const { line, target, property, color, scale } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src, target: tgt, start, end } of segments){
        const { style: { backgroundColor = color } = {} } = src;
        const notShape = target !== true;
        ctx.save();
        ctx.fillStyle = backgroundColor;
        clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
        ctx.beginPath();
        const lineLoop = !!line.pathSegment(ctx, src);
        let loop;
        if (notShape) {
            if (lineLoop) ctx.closePath();
            else interpolatedLineTo(ctx, target, end, property);
            const targetLoop = !!target.pathSegment(ctx, tgt, {
                move: lineLoop,
                reverse: true
            });
            loop = lineLoop && targetLoop;
            if (!loop) interpolatedLineTo(ctx, target, start, property);
        }
        ctx.closePath();
        ctx.fill(loop ? "evenodd" : "nonzero");
        ctx.restore();
    }
}
function clipBounds(ctx, scale, bounds) {
    const { top, bottom } = scale.chart.chartArea;
    const { property, start, end } = bounds || {};
    if (property === "x") {
        ctx.beginPath();
        ctx.rect(start, top, end - start, bottom - top);
        ctx.clip();
    }
}
function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
}
var index = {
    id: "filler",
    afterDatasetsUpdate (chart, _args, options) {
        const count = (chart.data.datasets || []).length;
        const sources = [];
        let meta, i, line, source;
        for(i = 0; i < count; ++i){
            meta = chart.getDatasetMeta(i);
            line = meta.dataset;
            source = null;
            if (line && line.options && line instanceof LineElement) source = {
                visible: chart.isDatasetVisible(i),
                index: i,
                fill: _decodeFill(line, i, count),
                chart,
                axis: meta.controller.options.indexAxis,
                scale: meta.vScale,
                line
            };
            meta.$filler = source;
            sources.push(source);
        }
        for(i = 0; i < count; ++i){
            source = sources[i];
            if (!source || source.fill === false) continue;
            source.fill = _resolveTarget(sources, i, options.propagate);
        }
    },
    beforeDraw (chart, _args, options) {
        const draw = options.drawTime === "beforeDraw";
        const metasets = chart.getSortedVisibleDatasetMetas();
        const area = chart.chartArea;
        for(let i = metasets.length - 1; i >= 0; --i){
            const source = metasets[i].$filler;
            if (!source) continue;
            source.line.updateControlPoints(area, source.axis);
            if (draw && source.fill) _drawfill(chart.ctx, source, area);
        }
    },
    beforeDatasetsDraw (chart, _args, options) {
        if (options.drawTime !== "beforeDatasetsDraw") return;
        const metasets = chart.getSortedVisibleDatasetMetas();
        for(let i = metasets.length - 1; i >= 0; --i){
            const source = metasets[i].$filler;
            if (_shouldApplyFill(source)) _drawfill(chart.ctx, source, chart.chartArea);
        }
    },
    beforeDatasetDraw (chart, args, options) {
        const source = args.meta.$filler;
        if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") return;
        _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
        propagate: true,
        drawTime: "beforeDatasetDraw"
    }
};
const getBoxSize = (labelOpts, fontSize)=>{
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
        boxHeight = Math.min(boxHeight, fontSize);
        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
        boxWidth,
        boxHeight,
        itemHeight: Math.max(fontSize, boxHeight)
    };
};
const itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class Legend extends Element {
    constructor(config){
        super();
        this._added = false;
        this.legendHitBoxes = [];
        this._hoveredItem = null;
        this.doughnutMode = false;
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this.legendItems = undefined;
        this.columnSizes = undefined;
        this.lineWidths = undefined;
        this.maxHeight = undefined;
        this.maxWidth = undefined;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.height = undefined;
        this.width = undefined;
        this._margins = undefined;
        this.position = undefined;
        this.weight = undefined;
        this.fullSize = undefined;
    }
    update(maxWidth, maxHeight, margins) {
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
        this._margins = margins;
        this.setDimensions();
        this.buildLabels();
        this.fit();
    }
    setDimensions() {
        if (this.isHorizontal()) {
            this.width = this.maxWidth;
            this.left = this._margins.left;
            this.right = this.width;
        } else {
            this.height = this.maxHeight;
            this.top = this._margins.top;
            this.bottom = this.height;
        }
    }
    buildLabels() {
        const labelOpts = this.options.labels || {};
        let legendItems = (0, _helpersSegmentJs.Q)(labelOpts.generateLabels, [
            this.chart
        ], this) || [];
        if (labelOpts.filter) legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));
        if (labelOpts.sort) legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));
        if (this.options.reverse) legendItems.reverse();
        this.legendItems = legendItems;
    }
    fit() {
        const { options, ctx } = this;
        if (!options.display) {
            this.width = this.height = 0;
            return;
        }
        const labelOpts = options.labels;
        const labelFont = (0, _helpersSegmentJs.a0)(labelOpts.font);
        const fontSize = labelFont.size;
        const titleHeight = this._computeTitleHeight();
        const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
        let width, height;
        ctx.font = labelFont.string;
        if (this.isHorizontal()) {
            width = this.maxWidth;
            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
        } else {
            height = this.maxHeight;
            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
        }
        this.width = Math.min(width, options.maxWidth || this.maxWidth);
        this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
        const { ctx, maxWidth, options: { labels: { padding } } } = this;
        const hitboxes = this.legendHitBoxes = [];
        const lineWidths = this.lineWidths = [
            0
        ];
        const lineHeight = itemHeight + padding;
        let totalHeight = titleHeight;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        let row = -1;
        let top = -lineHeight;
        this.legendItems.forEach((legendItem, i)=>{
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                totalHeight += lineHeight;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                top += lineHeight;
                row++;
            }
            hitboxes[i] = {
                left: 0,
                top,
                row,
                width: itemWidth,
                height: itemHeight
            };
            lineWidths[lineWidths.length - 1] += itemWidth + padding;
        });
        return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
        const { ctx, maxHeight, options: { labels: { padding } } } = this;
        const hitboxes = this.legendHitBoxes = [];
        const columnSizes = this.columnSizes = [];
        const heightLimit = maxHeight - titleHeight;
        let totalWidth = padding;
        let currentColWidth = 0;
        let currentColHeight = 0;
        let left = 0;
        let col = 0;
        this.legendItems.forEach((legendItem, i)=>{
            const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                totalWidth += currentColWidth + padding;
                columnSizes.push({
                    width: currentColWidth,
                    height: currentColHeight
                });
                left += currentColWidth + padding;
                col++;
                currentColWidth = currentColHeight = 0;
            }
            hitboxes[i] = {
                left,
                top: currentColHeight,
                col,
                width: itemWidth,
                height: itemHeight
            };
            currentColWidth = Math.max(currentColWidth, itemWidth);
            currentColHeight += itemHeight + padding;
        });
        totalWidth += currentColWidth;
        columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
        });
        return totalWidth;
    }
    adjustHitBoxes() {
        if (!this.options.display) return;
        const titleHeight = this._computeTitleHeight();
        const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
        const rtlHelper = (0, _helpersSegmentJs.az)(rtl, this.left, this.width);
        if (this.isHorizontal()) {
            let row = 0;
            let left = (0, _helpersSegmentJs.a2)(align, this.left + padding, this.right - this.lineWidths[row]);
            for (const hitbox of hitboxes){
                if (row !== hitbox.row) {
                    row = hitbox.row;
                    left = (0, _helpersSegmentJs.a2)(align, this.left + padding, this.right - this.lineWidths[row]);
                }
                hitbox.top += this.top + titleHeight + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                left += hitbox.width + padding;
            }
        } else {
            let col = 0;
            let top = (0, _helpersSegmentJs.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
            for (const hitbox of hitboxes){
                if (hitbox.col !== col) {
                    col = hitbox.col;
                    top = (0, _helpersSegmentJs.a2)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                }
                hitbox.top = top;
                hitbox.left += this.left + padding;
                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                top += hitbox.height + padding;
            }
        }
    }
    isHorizontal() {
        return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
        if (this.options.display) {
            const ctx = this.ctx;
            (0, _helpersSegmentJs.Y)(ctx, this);
            this._draw();
            (0, _helpersSegmentJs.$)(ctx);
        }
    }
    _draw() {
        const { options: opts, columnSizes, lineWidths, ctx } = this;
        const { align, labels: labelOpts } = opts;
        const defaultColor = (0, _helpersSegmentJs.d).color;
        const rtlHelper = (0, _helpersSegmentJs.az)(opts.rtl, this.left, this.width);
        const labelFont = (0, _helpersSegmentJs.a0)(labelOpts.font);
        const { padding } = labelOpts;
        const fontSize = labelFont.size;
        const halfFontSize = fontSize / 2;
        let cursor;
        this.drawTitle();
        ctx.textAlign = rtlHelper.textAlign("left");
        ctx.textBaseline = "middle";
        ctx.lineWidth = 0.5;
        ctx.font = labelFont.string;
        const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
        const drawLegendBox = function(x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) return;
            ctx.save();
            const lineWidth = (0, _helpersSegmentJs.v)(legendItem.lineWidth, 1);
            ctx.fillStyle = (0, _helpersSegmentJs.v)(legendItem.fillStyle, defaultColor);
            ctx.lineCap = (0, _helpersSegmentJs.v)(legendItem.lineCap, "butt");
            ctx.lineDashOffset = (0, _helpersSegmentJs.v)(legendItem.lineDashOffset, 0);
            ctx.lineJoin = (0, _helpersSegmentJs.v)(legendItem.lineJoin, "miter");
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = (0, _helpersSegmentJs.v)(legendItem.strokeStyle, defaultColor);
            ctx.setLineDash((0, _helpersSegmentJs.v)(legendItem.lineDash, []));
            if (labelOpts.usePointStyle) {
                const drawOptions = {
                    radius: boxHeight * Math.SQRT2 / 2,
                    pointStyle: legendItem.pointStyle,
                    rotation: legendItem.rotation,
                    borderWidth: lineWidth
                };
                const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                const centerY = y + halfFontSize;
                (0, _helpersSegmentJs.aD)(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
            } else {
                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                const borderRadius = (0, _helpersSegmentJs.aw)(legendItem.borderRadius);
                ctx.beginPath();
                if (Object.values(borderRadius).some((v)=>v !== 0)) (0, _helpersSegmentJs.au)(ctx, {
                    x: xBoxLeft,
                    y: yBoxTop,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius
                });
                else ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                ctx.fill();
                if (lineWidth !== 0) ctx.stroke();
            }
            ctx.restore();
        };
        const fillText = function(x, y, legendItem) {
            (0, _helpersSegmentJs.Z)(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                strikethrough: legendItem.hidden,
                textAlign: rtlHelper.textAlign(legendItem.textAlign)
            });
        };
        const isHorizontal = this.isHorizontal();
        const titleHeight = this._computeTitleHeight();
        if (isHorizontal) cursor = {
            x: (0, _helpersSegmentJs.a2)(align, this.left + padding, this.right - lineWidths[0]),
            y: this.top + padding + titleHeight,
            line: 0
        };
        else cursor = {
            x: this.left + padding,
            y: (0, _helpersSegmentJs.a2)(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
            line: 0
        };
        (0, _helpersSegmentJs.aA)(this.ctx, opts.textDirection);
        const lineHeight = itemHeight + padding;
        this.legendItems.forEach((legendItem, i)=>{
            ctx.strokeStyle = legendItem.fontColor;
            ctx.fillStyle = legendItem.fontColor;
            const textWidth = ctx.measureText(legendItem.text).width;
            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
            const width = boxWidth + halfFontSize + textWidth;
            let x = cursor.x;
            let y = cursor.y;
            rtlHelper.setWidth(this.width);
            if (isHorizontal) {
                if (i > 0 && x + width + padding > this.right) {
                    y = cursor.y += lineHeight;
                    cursor.line++;
                    x = cursor.x = (0, _helpersSegmentJs.a2)(align, this.left + padding, this.right - lineWidths[cursor.line]);
                }
            } else if (i > 0 && y + lineHeight > this.bottom) {
                x = cursor.x = x + columnSizes[cursor.line].width + padding;
                cursor.line++;
                y = cursor.y = (0, _helpersSegmentJs.a2)(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
            }
            const realX = rtlHelper.x(x);
            drawLegendBox(realX, y, legendItem);
            x = (0, _helpersSegmentJs.aB)(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
            fillText(rtlHelper.x(x), y, legendItem);
            if (isHorizontal) cursor.x += width + padding;
            else if (typeof legendItem.text !== "string") {
                const fontLineHeight = labelFont.lineHeight;
                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
            } else cursor.y += lineHeight;
        });
        (0, _helpersSegmentJs.aC)(this.ctx, opts.textDirection);
    }
    drawTitle() {
        const opts = this.options;
        const titleOpts = opts.title;
        const titleFont = (0, _helpersSegmentJs.a0)(titleOpts.font);
        const titlePadding = (0, _helpersSegmentJs.E)(titleOpts.padding);
        if (!titleOpts.display) return;
        const rtlHelper = (0, _helpersSegmentJs.az)(opts.rtl, this.left, this.width);
        const ctx = this.ctx;
        const position = titleOpts.position;
        const halfFontSize = titleFont.size / 2;
        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
        let y;
        let left = this.left;
        let maxWidth = this.width;
        if (this.isHorizontal()) {
            maxWidth = Math.max(...this.lineWidths);
            y = this.top + topPaddingPlusHalfFontSize;
            left = (0, _helpersSegmentJs.a2)(opts.align, left, this.right - maxWidth);
        } else {
            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);
            y = topPaddingPlusHalfFontSize + (0, _helpersSegmentJs.a2)(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
        }
        const x = (0, _helpersSegmentJs.a2)(position, left, left + maxWidth);
        ctx.textAlign = rtlHelper.textAlign((0, _helpersSegmentJs.a1)(position));
        ctx.textBaseline = "middle";
        ctx.strokeStyle = titleOpts.color;
        ctx.fillStyle = titleOpts.color;
        ctx.font = titleFont.string;
        (0, _helpersSegmentJs.Z)(ctx, titleOpts.text, x, y, titleFont);
    }
    _computeTitleHeight() {
        const titleOpts = this.options.title;
        const titleFont = (0, _helpersSegmentJs.a0)(titleOpts.font);
        const titlePadding = (0, _helpersSegmentJs.E)(titleOpts.padding);
        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x, y) {
        let i, hitBox, lh;
        if ((0, _helpersSegmentJs.aj)(x, this.left, this.right) && (0, _helpersSegmentJs.aj)(y, this.top, this.bottom)) {
            lh = this.legendHitBoxes;
            for(i = 0; i < lh.length; ++i){
                hitBox = lh[i];
                if ((0, _helpersSegmentJs.aj)(x, hitBox.left, hitBox.left + hitBox.width) && (0, _helpersSegmentJs.aj)(y, hitBox.top, hitBox.top + hitBox.height)) return this.legendItems[i];
            }
        }
        return null;
    }
    handleEvent(e) {
        const opts = this.options;
        if (!isListened(e.type, opts)) return;
        const hoveredItem = this._getLegendItemAt(e.x, e.y);
        if (e.type === "mousemove" || e.type === "mouseout") {
            const previous = this._hoveredItem;
            const sameItem = itemsEqual(previous, hoveredItem);
            if (previous && !sameItem) (0, _helpersSegmentJs.Q)(opts.onLeave, [
                e,
                previous,
                this
            ], this);
            this._hoveredItem = hoveredItem;
            if (hoveredItem && !sameItem) (0, _helpersSegmentJs.Q)(opts.onHover, [
                e,
                hoveredItem,
                this
            ], this);
        } else if (hoveredItem) (0, _helpersSegmentJs.Q)(opts.onClick, [
            e,
            hoveredItem,
            this
        ], this);
    }
}
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
        itemWidth,
        itemHeight
    };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== "string") legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== "string") itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length : 0;
    return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) return true;
    if (opts.onClick && (type === "click" || type === "mouseup")) return true;
    return false;
}
var plugin_legend = {
    id: "legend",
    _element: Legend,
    start (chart, _args, options) {
        const legend = chart.legend = new Legend({
            ctx: chart.ctx,
            options,
            chart
        });
        layouts.configure(chart, legend, options);
        layouts.addBox(chart, legend);
    },
    stop (chart) {
        layouts.removeBox(chart, chart.legend);
        delete chart.legend;
    },
    beforeUpdate (chart, _args, options) {
        const legend = chart.legend;
        layouts.configure(chart, legend, options);
        legend.options = options;
    },
    afterUpdate (chart) {
        const legend = chart.legend;
        legend.buildLabels();
        legend.adjustHitBoxes();
    },
    afterEvent (chart, args) {
        if (!args.replay) chart.legend.handleEvent(args.event);
    },
    defaults: {
        display: true,
        position: "top",
        align: "center",
        fullSize: true,
        reverse: false,
        weight: 1000,
        onClick (e, legendItem, legend) {
            const index = legendItem.datasetIndex;
            const ci = legend.chart;
            if (ci.isDatasetVisible(index)) {
                ci.hide(index);
                legendItem.hidden = true;
            } else {
                ci.show(index);
                legendItem.hidden = false;
            }
        },
        onHover: null,
        onLeave: null,
        labels: {
            color: (ctx)=>ctx.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels (chart) {
                const datasets = chart.data.datasets;
                const { labels: { usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius } } = chart.legend.options;
                return chart._getSortedDatasetMetas().map((meta)=>{
                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
                    const borderWidth = (0, _helpersSegmentJs.E)(style.borderWidth);
                    return {
                        text: datasets[meta.index].label,
                        fillStyle: style.backgroundColor,
                        fontColor: color,
                        hidden: !meta.visible,
                        lineCap: style.borderCapStyle,
                        lineDash: style.borderDash,
                        lineDashOffset: style.borderDashOffset,
                        lineJoin: style.borderJoinStyle,
                        lineWidth: (borderWidth.width + borderWidth.height) / 4,
                        strokeStyle: style.borderColor,
                        pointStyle: pointStyle || style.pointStyle,
                        rotation: style.rotation,
                        textAlign: textAlign || style.textAlign,
                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                        datasetIndex: meta.index
                    };
                }, this);
            }
        },
        title: {
            color: (ctx)=>ctx.chart.options.color,
            display: false,
            position: "center",
            text: ""
        }
    },
    descriptors: {
        _scriptable: (name)=>!name.startsWith("on"),
        labels: {
            _scriptable: (name)=>![
                    "generateLabels",
                    "filter",
                    "sort"
                ].includes(name)
        }
    }
};
class Title extends Element {
    constructor(config){
        super();
        this.chart = config.chart;
        this.options = config.options;
        this.ctx = config.ctx;
        this._padding = undefined;
        this.top = undefined;
        this.bottom = undefined;
        this.left = undefined;
        this.right = undefined;
        this.width = undefined;
        this.height = undefined;
        this.position = undefined;
        this.weight = undefined;
        this.fullSize = undefined;
    }
    update(maxWidth, maxHeight) {
        const opts = this.options;
        this.left = 0;
        this.top = 0;
        if (!opts.display) {
            this.width = this.height = this.right = this.bottom = 0;
            return;
        }
        this.width = this.right = maxWidth;
        this.height = this.bottom = maxHeight;
        const lineCount = (0, _helpersSegmentJs.b)(opts.text) ? opts.text.length : 1;
        this._padding = (0, _helpersSegmentJs.E)(opts.padding);
        const textSize = lineCount * (0, _helpersSegmentJs.a0)(opts.font).lineHeight + this._padding.height;
        if (this.isHorizontal()) this.height = textSize;
        else this.width = textSize;
    }
    isHorizontal() {
        const pos = this.options.position;
        return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset) {
        const { top, left, bottom, right, options } = this;
        const align = options.align;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        if (this.isHorizontal()) {
            titleX = (0, _helpersSegmentJs.a2)(align, left, right);
            titleY = top + offset;
            maxWidth = right - left;
        } else {
            if (options.position === "left") {
                titleX = left + offset;
                titleY = (0, _helpersSegmentJs.a2)(align, bottom, top);
                rotation = (0, _helpersSegmentJs.P) * -0.5;
            } else {
                titleX = right - offset;
                titleY = (0, _helpersSegmentJs.a2)(align, top, bottom);
                rotation = (0, _helpersSegmentJs.P) * 0.5;
            }
            maxWidth = bottom - top;
        }
        return {
            titleX,
            titleY,
            maxWidth,
            rotation
        };
    }
    draw() {
        const ctx = this.ctx;
        const opts = this.options;
        if (!opts.display) return;
        const fontOpts = (0, _helpersSegmentJs.a0)(opts.font);
        const lineHeight = fontOpts.lineHeight;
        const offset = lineHeight / 2 + this._padding.top;
        const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
        (0, _helpersSegmentJs.Z)(ctx, opts.text, 0, 0, fontOpts, {
            color: opts.color,
            maxWidth,
            rotation,
            textAlign: (0, _helpersSegmentJs.a1)(opts.align),
            textBaseline: "middle",
            translation: [
                titleX,
                titleY
            ]
        });
    }
}
function createTitle(chart, titleOpts) {
    const title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
}
var plugin_title = {
    id: "title",
    _element: Title,
    start (chart, _args, options) {
        createTitle(chart, options);
    },
    stop (chart) {
        const titleBlock = chart.titleBlock;
        layouts.removeBox(chart, titleBlock);
        delete chart.titleBlock;
    },
    beforeUpdate (chart, _args, options) {
        const title = chart.titleBlock;
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: "center",
        display: false,
        font: {
            weight: "bold"
        },
        fullSize: true,
        padding: 10,
        position: "top",
        text: "",
        weight: 2000
    },
    defaultRoutes: {
        color: "color"
    },
    descriptors: {
        _scriptable: true,
        _indexable: false
    }
};
const map = new WeakMap();
var plugin_subtitle = {
    id: "subtitle",
    start (chart, _args, options) {
        const title = new Title({
            ctx: chart.ctx,
            options,
            chart
        });
        layouts.configure(chart, title, options);
        layouts.addBox(chart, title);
        map.set(chart, title);
    },
    stop (chart) {
        layouts.removeBox(chart, map.get(chart));
        map.delete(chart);
    },
    beforeUpdate (chart, _args, options) {
        const title = map.get(chart);
        layouts.configure(chart, title, options);
        title.options = options;
    },
    defaults: {
        align: "center",
        display: false,
        font: {
            weight: "normal"
        },
        fullSize: true,
        padding: 0,
        position: "top",
        text: "",
        weight: 1500
    },
    defaultRoutes: {
        color: "color"
    },
    descriptors: {
        _scriptable: true,
        _indexable: false
    }
};
const positioners = {
    average (items) {
        if (!items.length) return false;
        let i, len;
        let x = 0;
        let y = 0;
        let count = 0;
        for(i = 0, len = items.length; i < len; ++i){
            const el = items[i].element;
            if (el && el.hasValue()) {
                const pos = el.tooltipPosition();
                x += pos.x;
                y += pos.y;
                ++count;
            }
        }
        return {
            x: x / count,
            y: y / count
        };
    },
    nearest (items, eventPosition) {
        if (!items.length) return false;
        let x = eventPosition.x;
        let y = eventPosition.y;
        let minDistance = Number.POSITIVE_INFINITY;
        let i, len, nearestElement;
        for(i = 0, len = items.length; i < len; ++i){
            const el = items[i].element;
            if (el && el.hasValue()) {
                const center = el.getCenterPoint();
                const d = (0, _helpersSegmentJs.aE)(eventPosition, center);
                if (d < minDistance) {
                    minDistance = d;
                    nearestElement = el;
                }
            }
        }
        if (nearestElement) {
            const tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y;
        }
        return {
            x,
            y
        };
    }
};
function pushOrConcat(base, toPush) {
    if (toPush) {
        if ((0, _helpersSegmentJs.b)(toPush)) Array.prototype.push.apply(base, toPush);
        else base.push(toPush);
    }
    return base;
}
function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) return str.split("\n");
    return str;
}
function createTooltipItem(chart, item) {
    const { element, datasetIndex, index } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index);
    return {
        chart,
        label,
        parsed: controller.getParsed(index),
        raw: chart.data.datasets[datasetIndex].data[index],
        formattedValue: value,
        dataset: controller.getDataset(),
        dataIndex: index,
        datasetIndex,
        element
    };
}
function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options;
    const bodyFont = (0, _helpersSegmentJs.a0)(options.bodyFont);
    const titleFont = (0, _helpersSegmentJs.a0)(options.titleFont);
    const footerFont = (0, _helpersSegmentJs.a0)(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = (0, _helpersSegmentJs.E)(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    if (combinedBodyLength) {
        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    let widthPadding = 0;
    const maxLineWidth = function(line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    (0, _helpersSegmentJs.F)(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    (0, _helpersSegmentJs.F)(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    (0, _helpersSegmentJs.F)(body, (bodyItem)=>{
        (0, _helpersSegmentJs.F)(bodyItem.before, maxLineWidth);
        (0, _helpersSegmentJs.F)(bodyItem.lines, maxLineWidth);
        (0, _helpersSegmentJs.F)(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    (0, _helpersSegmentJs.F)(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
        width,
        height
    };
}
function determineYAlign(chart, size) {
    const { y, height } = size;
    if (y < height / 2) return "top";
    else if (y > chart.height - height / 2) return "bottom";
    return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x, width } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x + width + caret > chart.width) return true;
    if (xAlign === "right" && x - width - caret < 0) return true;
}
function determineXAlign(chart, options, size, yAlign) {
    const { x, width } = size;
    const { width: chartWidth, chartArea: { left, right } } = chart;
    let xAlign = "center";
    if (yAlign === "center") xAlign = x <= (left + right) / 2 ? "left" : "right";
    else if (x <= width / 2) xAlign = "left";
    else if (x >= chartWidth - width / 2) xAlign = "right";
    if (doesNotFitWithAlign(xAlign, chart, options, size)) xAlign = "center";
    return xAlign;
}
function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
        yAlign
    };
}
function alignX(size, xAlign) {
    let { x, width } = size;
    if (xAlign === "right") x -= width;
    else if (xAlign === "center") x -= width / 2;
    return x;
}
function alignY(size, yAlign, paddingAndSize) {
    let { y, height } = size;
    if (yAlign === "top") y += paddingAndSize;
    else if (yAlign === "bottom") y -= height + paddingAndSize;
    else y -= height / 2;
    return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = (0, _helpersSegmentJs.aw)(cornerRadius);
    let x = alignX(size, xAlign);
    const y = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
        if (xAlign === "left") x += paddingAndSize;
        else if (xAlign === "right") x -= paddingAndSize;
    } else if (xAlign === "left") x -= Math.max(topLeft, bottomLeft) + caretSize;
    else if (xAlign === "right") x += Math.max(topRight, bottomRight) + caretSize;
    return {
        x: (0, _helpersSegmentJs.S)(x, 0, chart.width - size.width),
        y: (0, _helpersSegmentJs.S)(y, 0, chart.height - size.height)
    };
}
function getAlignedX(tooltip, align, options) {
    const padding = (0, _helpersSegmentJs.E)(options.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback) {
    return pushOrConcat([], splitNewlines(callback));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
    return (0, _helpersSegmentJs.j)(parent, {
        tooltip,
        tooltipItems,
        type: "tooltip"
    });
}
function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
}
const defaultCallbacks = {
    beforeTitle: (0, _helpersSegmentJs.aF),
    title (tooltipItems) {
        if (tooltipItems.length > 0) {
            const item = tooltipItems[0];
            const labels = item.chart.data.labels;
            const labelCount = labels ? labels.length : 0;
            if (this && this.options && this.options.mode === "dataset") return item.dataset.label || "";
            else if (item.label) return item.label;
            else if (labelCount > 0 && item.dataIndex < labelCount) return labels[item.dataIndex];
        }
        return "";
    },
    afterTitle: (0, _helpersSegmentJs.aF),
    beforeBody: (0, _helpersSegmentJs.aF),
    beforeLabel: (0, _helpersSegmentJs.aF),
    label (tooltipItem) {
        if (this && this.options && this.options.mode === "dataset") return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
        let label = tooltipItem.dataset.label || "";
        if (label) label += ": ";
        const value = tooltipItem.formattedValue;
        if (!(0, _helpersSegmentJs.k)(value)) label += value;
        return label;
    },
    labelColor (tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
            borderColor: options.borderColor,
            backgroundColor: options.backgroundColor,
            borderWidth: options.borderWidth,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderRadius: 0
        };
    },
    labelTextColor () {
        return this.options.bodyColor;
    },
    labelPointStyle (tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
            pointStyle: options.pointStyle,
            rotation: options.rotation
        };
    },
    afterLabel: (0, _helpersSegmentJs.aF),
    afterBody: (0, _helpersSegmentJs.aF),
    beforeFooter: (0, _helpersSegmentJs.aF),
    footer: (0, _helpersSegmentJs.aF),
    afterFooter: (0, _helpersSegmentJs.aF)
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    const result = callbacks[name].call(ctx, arg);
    if (typeof result === "undefined") return defaultCallbacks[name].call(ctx, arg);
    return result;
}
class Tooltip extends Element {
    static positioners = positioners;
    constructor(config){
        super();
        this.opacity = 0;
        this._active = [];
        this._eventPosition = undefined;
        this._size = undefined;
        this._cachedAnimations = undefined;
        this._tooltipItems = [];
        this.$animations = undefined;
        this.$context = undefined;
        this.chart = config.chart;
        this.options = config.options;
        this.dataPoints = undefined;
        this.title = undefined;
        this.beforeBody = undefined;
        this.body = undefined;
        this.afterBody = undefined;
        this.footer = undefined;
        this.xAlign = undefined;
        this.yAlign = undefined;
        this.x = undefined;
        this.y = undefined;
        this.height = undefined;
        this.width = undefined;
        this.caretX = undefined;
        this.caretY = undefined;
        this.labelColors = undefined;
        this.labelPointStyles = undefined;
        this.labelTextColors = undefined;
    }
    initialize(options) {
        this.options = options;
        this._cachedAnimations = undefined;
        this.$context = undefined;
    }
    _resolveAnimations() {
        const cached = this._cachedAnimations;
        if (cached) return cached;
        const chart = this.chart;
        const options = this.options.setContext(this.getContext());
        const opts = options.enabled && chart.options.animation && options.animations;
        const animations = new Animations(this.chart, opts);
        if (opts._cacheable) this._cachedAnimations = Object.freeze(animations);
        return animations;
    }
    getContext() {
        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options) {
        const { callbacks } = options;
        const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
        const title = invokeCallbackWithFallback(callbacks, "title", this, context);
        const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
    }
    getBeforeBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
    }
    getBody(tooltipItems, options) {
        const { callbacks } = options;
        const bodyItems = [];
        (0, _helpersSegmentJs.F)(tooltipItems, (context)=>{
            const bodyItem = {
                before: [],
                lines: [],
                after: []
            };
            const scoped = overrideCallbacks(callbacks, context);
            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
            bodyItems.push(bodyItem);
        });
        return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
    }
    getFooter(tooltipItems, options) {
        const { callbacks } = options;
        const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
        const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
        const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
        let lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
    }
    _createItems(options) {
        const active = this._active;
        const data = this.chart.data;
        const labelColors = [];
        const labelPointStyles = [];
        const labelTextColors = [];
        let tooltipItems = [];
        let i, len;
        for(i = 0, len = active.length; i < len; ++i)tooltipItems.push(createTooltipItem(this.chart, active[i]));
        if (options.filter) tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));
        if (options.itemSort) tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));
        (0, _helpersSegmentJs.F)(tooltipItems, (context)=>{
            const scoped = overrideCallbacks(options.callbacks, context);
            labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
            labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
            labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
        });
        this.labelColors = labelColors;
        this.labelPointStyles = labelPointStyles;
        this.labelTextColors = labelTextColors;
        this.dataPoints = tooltipItems;
        return tooltipItems;
    }
    update(changed, replay) {
        const options = this.options.setContext(this.getContext());
        const active = this._active;
        let properties;
        let tooltipItems = [];
        if (!active.length) {
            if (this.opacity !== 0) properties = {
                opacity: 0
            };
        } else {
            const position = positioners[options.position].call(this, active, this._eventPosition);
            tooltipItems = this._createItems(options);
            this.title = this.getTitle(tooltipItems, options);
            this.beforeBody = this.getBeforeBody(tooltipItems, options);
            this.body = this.getBody(tooltipItems, options);
            this.afterBody = this.getAfterBody(tooltipItems, options);
            this.footer = this.getFooter(tooltipItems, options);
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, size);
            const alignment = determineAlignment(this.chart, options, positionAndSize);
            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
            this.xAlign = alignment.xAlign;
            this.yAlign = alignment.yAlign;
            properties = {
                opacity: 1,
                x: backgroundPoint.x,
                y: backgroundPoint.y,
                width: size.width,
                height: size.height,
                caretX: position.x,
                caretY: position.y
            };
        }
        this._tooltipItems = tooltipItems;
        this.$context = undefined;
        if (properties) this._resolveAnimations().update(this, properties);
        if (changed && options.external) options.external.call(this, {
            chart: this.chart,
            tooltip: this,
            replay
        });
    }
    drawCaret(tooltipPoint, ctx, size, options) {
        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
        const { xAlign, yAlign } = this;
        const { caretSize, cornerRadius } = options;
        const { topLeft, topRight, bottomLeft, bottomRight } = (0, _helpersSegmentJs.aw)(cornerRadius);
        const { x: ptX, y: ptY } = tooltipPoint;
        const { width, height } = size;
        let x1, x2, x3, y1, y2, y3;
        if (yAlign === "center") {
            y2 = ptY + height / 2;
            if (xAlign === "left") {
                x1 = ptX;
                x2 = x1 - caretSize;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
            } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
            }
            x3 = x1;
        } else {
            if (xAlign === "left") x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
            else if (xAlign === "right") x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
            else x2 = this.caretX;
            if (yAlign === "top") {
                y1 = ptY;
                y2 = y1 - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
            } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                x1 = x2 + caretSize;
                x3 = x2 - caretSize;
            }
            y3 = y1;
        }
        return {
            x1,
            x2,
            x3,
            y1,
            y2,
            y3
        };
    }
    drawTitle(pt, ctx, options) {
        const title = this.title;
        const length = title.length;
        let titleFont, titleSpacing, i;
        if (length) {
            const rtlHelper = (0, _helpersSegmentJs.az)(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.titleAlign, options);
            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
            ctx.textBaseline = "middle";
            titleFont = (0, _helpersSegmentJs.a0)(options.titleFont);
            titleSpacing = options.titleSpacing;
            ctx.fillStyle = options.titleColor;
            ctx.font = titleFont.string;
            for(i = 0; i < length; ++i){
                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                pt.y += titleFont.lineHeight + titleSpacing;
                if (i + 1 === length) pt.y += options.titleMarginBottom - titleSpacing;
            }
        }
    }
    _drawColorBox(ctx, pt, i, rtlHelper, options) {
        const labelColor = this.labelColors[i];
        const labelPointStyle = this.labelPointStyles[i];
        const { boxHeight, boxWidth } = options;
        const bodyFont = (0, _helpersSegmentJs.a0)(options.bodyFont);
        const colorX = getAlignedX(this, "left", options);
        const rtlColorX = rtlHelper.x(colorX);
        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
        const colorY = pt.y + yOffSet;
        if (options.usePointStyle) {
            const drawOptions = {
                radius: Math.min(boxWidth, boxHeight) / 2,
                pointStyle: labelPointStyle.pointStyle,
                rotation: labelPointStyle.rotation,
                borderWidth: 1
            };
            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
            const centerY = colorY + boxHeight / 2;
            ctx.strokeStyle = options.multiKeyBackground;
            ctx.fillStyle = options.multiKeyBackground;
            (0, _helpersSegmentJs.at)(ctx, drawOptions, centerX, centerY);
            ctx.strokeStyle = labelColor.borderColor;
            ctx.fillStyle = labelColor.backgroundColor;
            (0, _helpersSegmentJs.at)(ctx, drawOptions, centerX, centerY);
        } else {
            ctx.lineWidth = (0, _helpersSegmentJs.i)(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
            ctx.strokeStyle = labelColor.borderColor;
            ctx.setLineDash(labelColor.borderDash || []);
            ctx.lineDashOffset = labelColor.borderDashOffset || 0;
            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
            const borderRadius = (0, _helpersSegmentJs.aw)(labelColor.borderRadius);
            if (Object.values(borderRadius).some((v)=>v !== 0)) {
                ctx.beginPath();
                ctx.fillStyle = options.multiKeyBackground;
                (0, _helpersSegmentJs.au)(ctx, {
                    x: outerX,
                    y: colorY,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius
                });
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = labelColor.backgroundColor;
                ctx.beginPath();
                (0, _helpersSegmentJs.au)(ctx, {
                    x: innerX,
                    y: colorY + 1,
                    w: boxWidth - 2,
                    h: boxHeight - 2,
                    radius: borderRadius
                });
                ctx.fill();
            } else {
                ctx.fillStyle = options.multiKeyBackground;
                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                ctx.fillStyle = labelColor.backgroundColor;
                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
            }
        }
        ctx.fillStyle = this.labelTextColors[i];
    }
    drawBody(pt, ctx, options) {
        const { body } = this;
        const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
        const bodyFont = (0, _helpersSegmentJs.a0)(options.bodyFont);
        let bodyLineHeight = bodyFont.lineHeight;
        let xLinePadding = 0;
        const rtlHelper = (0, _helpersSegmentJs.az)(options.rtl, this.x, this.width);
        const fillLineOfText = function(line) {
            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
            pt.y += bodyLineHeight + bodySpacing;
        };
        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
        let bodyItem, textColor, lines, i, j, ilen, jlen;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = "middle";
        ctx.font = bodyFont.string;
        pt.x = getAlignedX(this, bodyAlignForCalculation, options);
        ctx.fillStyle = options.bodyColor;
        (0, _helpersSegmentJs.F)(this.beforeBody, fillLineOfText);
        xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
        for(i = 0, ilen = body.length; i < ilen; ++i){
            bodyItem = body[i];
            textColor = this.labelTextColors[i];
            ctx.fillStyle = textColor;
            (0, _helpersSegmentJs.F)(bodyItem.before, fillLineOfText);
            lines = bodyItem.lines;
            if (displayColors && lines.length) {
                this._drawColorBox(ctx, pt, i, rtlHelper, options);
                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
            }
            for(j = 0, jlen = lines.length; j < jlen; ++j){
                fillLineOfText(lines[j]);
                bodyLineHeight = bodyFont.lineHeight;
            }
            (0, _helpersSegmentJs.F)(bodyItem.after, fillLineOfText);
        }
        xLinePadding = 0;
        bodyLineHeight = bodyFont.lineHeight;
        (0, _helpersSegmentJs.F)(this.afterBody, fillLineOfText);
        pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options) {
        const footer = this.footer;
        const length = footer.length;
        let footerFont, i;
        if (length) {
            const rtlHelper = (0, _helpersSegmentJs.az)(options.rtl, this.x, this.width);
            pt.x = getAlignedX(this, options.footerAlign, options);
            pt.y += options.footerMarginTop;
            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
            ctx.textBaseline = "middle";
            footerFont = (0, _helpersSegmentJs.a0)(options.footerFont);
            ctx.fillStyle = options.footerColor;
            ctx.font = footerFont.string;
            for(i = 0; i < length; ++i){
                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                pt.y += footerFont.lineHeight + options.footerSpacing;
            }
        }
    }
    drawBackground(pt, ctx, tooltipSize, options) {
        const { xAlign, yAlign } = this;
        const { x, y } = pt;
        const { width, height } = tooltipSize;
        const { topLeft, topRight, bottomLeft, bottomRight } = (0, _helpersSegmentJs.aw)(options.cornerRadius);
        ctx.fillStyle = options.backgroundColor;
        ctx.strokeStyle = options.borderColor;
        ctx.lineWidth = options.borderWidth;
        ctx.beginPath();
        ctx.moveTo(x + topLeft, y);
        if (yAlign === "top") this.drawCaret(pt, ctx, tooltipSize, options);
        ctx.lineTo(x + width - topRight, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
        if (yAlign === "center" && xAlign === "right") this.drawCaret(pt, ctx, tooltipSize, options);
        ctx.lineTo(x + width, y + height - bottomRight);
        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
        if (yAlign === "bottom") this.drawCaret(pt, ctx, tooltipSize, options);
        ctx.lineTo(x + bottomLeft, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
        if (yAlign === "center" && xAlign === "left") this.drawCaret(pt, ctx, tooltipSize, options);
        ctx.lineTo(x, y + topLeft);
        ctx.quadraticCurveTo(x, y, x + topLeft, y);
        ctx.closePath();
        ctx.fill();
        if (options.borderWidth > 0) ctx.stroke();
    }
    _updateAnimationTarget(options) {
        const chart = this.chart;
        const anims = this.$animations;
        const animX = anims && anims.x;
        const animY = anims && anims.y;
        if (animX || animY) {
            const position = positioners[options.position].call(this, this._active, this._eventPosition);
            if (!position) return;
            const size = this._size = getTooltipSize(this, options);
            const positionAndSize = Object.assign({}, position, this._size);
            const alignment = determineAlignment(chart, options, positionAndSize);
            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
            if (animX._to !== point.x || animY._to !== point.y) {
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                this.width = size.width;
                this.height = size.height;
                this.caretX = position.x;
                this.caretY = position.y;
                this._resolveAnimations().update(this, point);
            }
        }
    }
    _willRender() {
        return !!this.opacity;
    }
    draw(ctx) {
        const options = this.options.setContext(this.getContext());
        let opacity = this.opacity;
        if (!opacity) return;
        this._updateAnimationTarget(options);
        const tooltipSize = {
            width: this.width,
            height: this.height
        };
        const pt = {
            x: this.x,
            y: this.y
        };
        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
        const padding = (0, _helpersSegmentJs.E)(options.padding);
        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
        if (options.enabled && hasTooltipContent) {
            ctx.save();
            ctx.globalAlpha = opacity;
            this.drawBackground(pt, ctx, tooltipSize, options);
            (0, _helpersSegmentJs.aA)(ctx, options.textDirection);
            pt.y += padding.top;
            this.drawTitle(pt, ctx, options);
            this.drawBody(pt, ctx, options);
            this.drawFooter(pt, ctx, options);
            (0, _helpersSegmentJs.aC)(ctx, options.textDirection);
            ctx.restore();
        }
    }
    getActiveElements() {
        return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
        const lastActive = this._active;
        const active = activeElements.map(({ datasetIndex, index })=>{
            const meta = this.chart.getDatasetMeta(datasetIndex);
            if (!meta) throw new Error("Cannot find a dataset at index " + datasetIndex);
            return {
                datasetIndex,
                element: meta.data[index],
                index
            };
        });
        const changed = !(0, _helpersSegmentJs.ah)(lastActive, active);
        const positionChanged = this._positionChanged(active, eventPosition);
        if (changed || positionChanged) {
            this._active = active;
            this._eventPosition = eventPosition;
            this._ignoreReplayEvents = true;
            this.update(true);
        }
    }
    handleEvent(e, replay, inChartArea = true) {
        if (replay && this._ignoreReplayEvents) return false;
        this._ignoreReplayEvents = false;
        const options = this.options;
        const lastActive = this._active || [];
        const active = this._getActiveElements(e, lastActive, replay, inChartArea);
        const positionChanged = this._positionChanged(active, e);
        const changed = replay || !(0, _helpersSegmentJs.ah)(active, lastActive) || positionChanged;
        if (changed) {
            this._active = active;
            if (options.enabled || options.external) {
                this._eventPosition = {
                    x: e.x,
                    y: e.y
                };
                this.update(true, replay);
            }
        }
        return changed;
    }
    _getActiveElements(e, lastActive, replay, inChartArea) {
        const options = this.options;
        if (e.type === "mouseout") return [];
        if (!inChartArea) return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);
        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
        if (options.reverse) active.reverse();
        return active;
    }
    _positionChanged(active, e) {
        const { caretX, caretY, options } = this;
        const position = positioners[options.position].call(this, active, e);
        return position !== false && (caretX !== position.x || caretY !== position.y);
    }
}
var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners,
    afterInit (chart, _args, options) {
        if (options) chart.tooltip = new Tooltip({
            chart,
            options
        });
    },
    beforeUpdate (chart, _args, options) {
        if (chart.tooltip) chart.tooltip.initialize(options);
    },
    reset (chart, _args, options) {
        if (chart.tooltip) chart.tooltip.initialize(options);
    },
    afterDraw (chart) {
        const tooltip = chart.tooltip;
        if (tooltip && tooltip._willRender()) {
            const args = {
                tooltip
            };
            if (chart.notifyPlugins("beforeTooltipDraw", {
                ...args,
                cancelable: true
            }) === false) return;
            tooltip.draw(chart.ctx);
            chart.notifyPlugins("afterTooltipDraw", args);
        }
    },
    afterEvent (chart, args) {
        if (chart.tooltip) {
            const useFinalPosition = args.replay;
            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) args.changed = true;
        }
    },
    defaults: {
        enabled: true,
        external: null,
        position: "average",
        backgroundColor: "rgba(0,0,0,0.8)",
        titleColor: "#fff",
        titleFont: {
            weight: "bold"
        },
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleAlign: "left",
        bodyColor: "#fff",
        bodySpacing: 2,
        bodyFont: {},
        bodyAlign: "left",
        footerColor: "#fff",
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFont: {
            weight: "bold"
        },
        footerAlign: "left",
        padding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        boxHeight: (ctx, opts)=>opts.bodyFont.size,
        boxWidth: (ctx, opts)=>opts.bodyFont.size,
        multiKeyBackground: "#fff",
        displayColors: true,
        boxPadding: 0,
        borderColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        animation: {
            duration: 400,
            easing: "easeOutQuart"
        },
        animations: {
            numbers: {
                type: "number",
                properties: [
                    "x",
                    "y",
                    "width",
                    "height",
                    "caretX",
                    "caretY"
                ]
            },
            opacity: {
                easing: "linear",
                duration: 200
            }
        },
        callbacks: defaultCallbacks
    },
    defaultRoutes: {
        bodyFont: "font",
        footerFont: "font",
        titleFont: "font"
    },
    descriptors: {
        _scriptable: (name)=>name !== "filter" && name !== "itemSort" && name !== "external",
        _indexable: false,
        callbacks: {
            _scriptable: false,
            _indexable: false
        },
        animation: {
            _fallback: false
        },
        animations: {
            _fallback: "animation"
        }
    },
    additionalOptionScopes: [
        "interaction"
    ]
};
var plugins = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    Colors: plugin_colors,
    Decimation: plugin_decimation,
    Filler: index,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
});
const addIfString = (labels, raw, index, addedLabels)=>{
    if (typeof raw === "string") {
        index = labels.push(raw) - 1;
        addedLabels.unshift({
            index,
            label: raw
        });
    } else if (isNaN(raw)) index = null;
    return index;
};
function findOrAddLabel(labels, raw, index, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) return addIfString(labels, raw, index, addedLabels);
    const last = labels.lastIndexOf(raw);
    return first !== last ? index : first;
}
const validIndex = (index, max)=>index === null ? null : (0, _helpersSegmentJs.S)(Math.round(index), 0, max);
function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) return labels[value];
    return value;
}
class CategoryScale extends Scale {
    static id = "category";
    static defaults = {
        ticks: {
            callback: _getLabelForValue
        }
    };
    constructor(cfg){
        super(cfg);
        this._startValue = undefined;
        this._valueRange = 0;
        this._addedLabels = [];
    }
    init(scaleOptions) {
        const added = this._addedLabels;
        if (added.length) {
            const labels = this.getLabels();
            for (const { index, label } of added)if (labels[index] === label) labels.splice(index, 1);
            this._addedLabels = [];
        }
        super.init(scaleOptions);
    }
    parse(raw, index) {
        if ((0, _helpersSegmentJs.k)(raw)) return null;
        const labels = this.getLabels();
        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, (0, _helpersSegmentJs.v)(index, raw), this._addedLabels);
        return validIndex(index, labels.length - 1);
    }
    determineDataLimits() {
        const { minDefined, maxDefined } = this.getUserBounds();
        let { min, max } = this.getMinMax(true);
        if (this.options.bounds === "ticks") {
            if (!minDefined) min = 0;
            if (!maxDefined) max = this.getLabels().length - 1;
        }
        this.min = min;
        this.max = max;
    }
    buildTicks() {
        const min = this.min;
        const max = this.max;
        const offset = this.options.offset;
        const ticks = [];
        let labels = this.getLabels();
        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
        this._startValue = this.min - (offset ? 0.5 : 0);
        for(let value = min; value <= max; value++)ticks.push({
            value
        });
        return ticks;
    }
    getLabelForValue(value) {
        return _getLabelForValue.call(this, value);
    }
    configure() {
        super.configure();
        if (!this.isHorizontal()) this._reversePixels = !this._reversePixels;
    }
    getPixelForValue(value) {
        if (typeof value !== "number") value = this.parse(value);
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index) {
        const ticks = this.ticks;
        if (index < 0 || index > ticks.length - 1) return null;
        return this.getPixelForValue(ticks[index].value);
    }
    getValueForPixel(pixel) {
        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
        return this.bottom;
    }
}
function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !(0, _helpersSegmentJs.k)(min);
    const maxDefined = !(0, _helpersSegmentJs.k)(max);
    const countDefined = !(0, _helpersSegmentJs.k)(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = (0, _helpersSegmentJs.aH)((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) return [
        {
            value: rmin
        },
        {
            value: rmax
        }
    ];
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) spacing = (0, _helpersSegmentJs.aH)(numSpaces * spacing / maxSpaces / unit) * unit;
    if (!(0, _helpersSegmentJs.k)(precision)) {
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
        niceMin = Math.floor(rmin / spacing) * spacing;
        niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
        niceMin = rmin;
        niceMax = rmax;
    }
    if (minDefined && maxDefined && step && (0, _helpersSegmentJs.aI)((max - min) / step, spacing / 1000)) {
        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
        spacing = (max - min) / numSpaces;
        niceMin = min;
        niceMax = max;
    } else if (countDefined) {
        niceMin = minDefined ? min : niceMin;
        niceMax = maxDefined ? max : niceMax;
        numSpaces = count - 1;
        spacing = (niceMax - niceMin) / numSpaces;
    } else {
        numSpaces = (niceMax - niceMin) / spacing;
        if ((0, _helpersSegmentJs.aJ)(numSpaces, Math.round(numSpaces), spacing / 1000)) numSpaces = Math.round(numSpaces);
        else numSpaces = Math.ceil(numSpaces);
    }
    const decimalPlaces = Math.max((0, _helpersSegmentJs.aK)(spacing), (0, _helpersSegmentJs.aK)(niceMin));
    factor = Math.pow(10, (0, _helpersSegmentJs.k)(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
        if (includeBounds && niceMin !== min) {
            ticks.push({
                value: min
            });
            if (niceMin < min) j++;
            if ((0, _helpersSegmentJs.aJ)(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) j++;
        } else if (niceMin < min) j++;
    }
    for(; j < numSpaces; ++j){
        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
        if (maxDefined && tickValue > max) break;
        ticks.push({
            value: tickValue
        });
    }
    if (maxDefined && includeBounds && niceMax !== max) {
        if (ticks.length && (0, _helpersSegmentJs.aJ)(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) ticks[ticks.length - 1].value = max;
        else ticks.push({
            value: max
        });
    } else if (!maxDefined || niceMax === max) ticks.push({
        value: niceMax
    });
    return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = (0, _helpersSegmentJs.t)(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
    const length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
    constructor(cfg){
        super(cfg);
        this.start = undefined;
        this.end = undefined;
        this._startValue = undefined;
        this._endValue = undefined;
        this._valueRange = 0;
    }
    parse(raw, index) {
        if ((0, _helpersSegmentJs.k)(raw)) return null;
        if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) return null;
        return +raw;
    }
    handleTickRangeOptions() {
        const { beginAtZero } = this.options;
        const { minDefined, maxDefined } = this.getUserBounds();
        let { min, max } = this;
        const setMin = (v)=>min = minDefined ? min : v;
        const setMax = (v)=>max = maxDefined ? max : v;
        if (beginAtZero) {
            const minSign = (0, _helpersSegmentJs.s)(min);
            const maxSign = (0, _helpersSegmentJs.s)(max);
            if (minSign < 0 && maxSign < 0) setMax(0);
            else if (minSign > 0 && maxSign > 0) setMin(0);
        }
        if (min === max) {
            let offset = max === 0 ? 1 : Math.abs(max * 0.05);
            setMax(max + offset);
            if (!beginAtZero) setMin(min - offset);
        }
        this.min = min;
        this.max = max;
    }
    getTickLimit() {
        const tickOpts = this.options.ticks;
        let { maxTicksLimit, stepSize } = tickOpts;
        let maxTicks;
        if (stepSize) {
            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
            if (maxTicks > 1000) {
                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                maxTicks = 1000;
            }
        } else {
            maxTicks = this.computeTickLimit();
            maxTicksLimit = maxTicksLimit || 11;
        }
        if (maxTicksLimit) maxTicks = Math.min(maxTicksLimit, maxTicks);
        return maxTicks;
    }
    computeTickLimit() {
        return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
        const opts = this.options;
        const tickOpts = opts.ticks;
        let maxTicks = this.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        const numericGeneratorOptions = {
            maxTicks,
            bounds: opts.bounds,
            min: opts.min,
            max: opts.max,
            precision: tickOpts.precision,
            step: tickOpts.stepSize,
            count: tickOpts.count,
            maxDigits: this._maxDigits(),
            horizontal: this.isHorizontal(),
            minRotation: tickOpts.minRotation || 0,
            includeBounds: tickOpts.includeBounds !== false
        };
        const dataRange = this._range || this;
        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
        if (opts.bounds === "ticks") (0, _helpersSegmentJs.aG)(ticks, this, "value");
        if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
        } else {
            this.start = this.min;
            this.end = this.max;
        }
        return ticks;
    }
    configure() {
        const ticks = this.ticks;
        let start = this.min;
        let end = this.max;
        super.configure();
        if (this.options.offset && ticks.length) {
            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
            start -= offset;
            end += offset;
        }
        this._startValue = start;
        this._endValue = end;
        this._valueRange = end - start;
    }
    getLabelForValue(value) {
        return (0, _helpersSegmentJs.o)(value, this.chart.options.locale, this.options.ticks.format);
    }
}
class LinearScale extends LinearScaleBase {
    static id = "linear";
    static defaults = {
        ticks: {
            callback: (0, _helpersSegmentJs.aL).formatters.numeric
        }
    };
    determineDataLimits() {
        const { min, max } = this.getMinMax(true);
        this.min = (0, _helpersSegmentJs.g)(min) ? min : 0;
        this.max = (0, _helpersSegmentJs.g)(max) ? max : 1;
        this.handleTickRangeOptions();
    }
    computeTickLimit() {
        const horizontal = this.isHorizontal();
        const length = horizontal ? this.width : this.height;
        const minRotation = (0, _helpersSegmentJs.t)(this.options.ticks.minRotation);
        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
        const tickFont = this._resolveTickFontOptions(0);
        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
}
const log10Floor = (v)=>Math.floor((0, _helpersSegmentJs.aM)(v));
const changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
}
function steps(min, max, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start = Math.floor(min / rangeStep);
    const end = Math.ceil(max / rangeStep);
    return end - start;
}
function startExp(min, max) {
    const range = max - min;
    let rangeExp = log10Floor(range);
    while(steps(min, max, rangeExp) > 10)rangeExp++;
    while(steps(min, max, rangeExp) < 10)rangeExp--;
    return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
    min = (0, _helpersSegmentJs.O)(generationOptions.min, min);
    const ticks = [];
    const minExp = log10Floor(min);
    let exp = startExp(min, max);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base = minExp > exp ? Math.pow(10, minExp) : 0;
    const start = Math.round((min - base) * precision) / precision;
    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start - offset) / Math.pow(10, exp));
    let value = (0, _helpersSegmentJs.O)(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
    while(value < max){
        ticks.push({
            value,
            major: isMajor(value),
            significand
        });
        if (significand >= 10) significand = significand < 15 ? 15 : 20;
        else significand++;
        if (significand >= 20) {
            exp++;
            significand = 2;
            precision = exp >= 0 ? 1 : precision;
        }
        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = (0, _helpersSegmentJs.O)(generationOptions.max, value);
    ticks.push({
        value: lastTick,
        major: isMajor(lastTick),
        significand
    });
    return ticks;
}
class LogarithmicScale extends Scale {
    static id = "logarithmic";
    static defaults = {
        ticks: {
            callback: (0, _helpersSegmentJs.aL).formatters.logarithmic,
            major: {
                enabled: true
            }
        }
    };
    constructor(cfg){
        super(cfg);
        this.start = undefined;
        this.end = undefined;
        this._startValue = undefined;
        this._valueRange = 0;
    }
    parse(raw, index) {
        const value = LinearScaleBase.prototype.parse.apply(this, [
            raw,
            index
        ]);
        if (value === 0) {
            this._zero = true;
            return undefined;
        }
        return (0, _helpersSegmentJs.g)(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
        const { min, max } = this.getMinMax(true);
        this.min = (0, _helpersSegmentJs.g)(min) ? Math.max(0, min) : null;
        this.max = (0, _helpersSegmentJs.g)(max) ? Math.max(0, max) : null;
        if (this.options.beginAtZero) this._zero = true;
        if (this._zero && this.min !== this._suggestedMin && !(0, _helpersSegmentJs.g)(this._userMin)) this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
        this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
        const { minDefined, maxDefined } = this.getUserBounds();
        let min = this.min;
        let max = this.max;
        const setMin = (v)=>min = minDefined ? min : v;
        const setMax = (v)=>max = maxDefined ? max : v;
        if (min === max) {
            if (min <= 0) {
                setMin(1);
                setMax(10);
            } else {
                setMin(changeExponent(min, -1));
                setMax(changeExponent(max, 1));
            }
        }
        if (min <= 0) setMin(changeExponent(max, -1));
        if (max <= 0) setMax(changeExponent(min, 1));
        this.min = min;
        this.max = max;
    }
    buildTicks() {
        const opts = this.options;
        const generationOptions = {
            min: this._userMin,
            max: this._userMax
        };
        const ticks = generateTicks(generationOptions, this);
        if (opts.bounds === "ticks") (0, _helpersSegmentJs.aG)(ticks, this, "value");
        if (opts.reverse) {
            ticks.reverse();
            this.start = this.max;
            this.end = this.min;
        } else {
            this.start = this.min;
            this.end = this.max;
        }
        return ticks;
    }
    getLabelForValue(value) {
        return value === undefined ? "0" : (0, _helpersSegmentJs.o)(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
        const start = this.min;
        super.configure();
        this._startValue = (0, _helpersSegmentJs.aM)(start);
        this._valueRange = (0, _helpersSegmentJs.aM)(this.max) - (0, _helpersSegmentJs.aM)(start);
    }
    getPixelForValue(value) {
        if (value === undefined || value === 0) value = this.min;
        if (value === null || isNaN(value)) return NaN;
        return this.getPixelForDecimal(value === this.min ? 0 : ((0, _helpersSegmentJs.aM)(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
        const decimal = this.getDecimalForPixel(pixel);
        return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
}
function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
        const padding = (0, _helpersSegmentJs.E)(tickOpts.backdropPadding);
        return (0, _helpersSegmentJs.v)(tickOpts.font && tickOpts.font.size, (0, _helpersSegmentJs.d).font.size) + padding.height;
    }
    return 0;
}
function measureLabelSize(ctx, font, label) {
    label = (0, _helpersSegmentJs.b)(label) ? label : [
        label
    ];
    return {
        w: (0, _helpersSegmentJs.aN)(ctx, font.string, label),
        h: label.length * font.lineHeight
    };
}
function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) return {
        start: pos - size / 2,
        end: pos + size / 2
    };
    else if (angle < min || angle > max) return {
        start: pos - size,
        end: pos
    };
    return {
        start: pos,
        end: pos + size
    };
}
function fitWithPointLabels(scale) {
    const orig = {
        l: scale.left + scale._padding.left,
        r: scale.right - scale._padding.right,
        t: scale.top + scale._padding.top,
        b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? (0, _helpersSegmentJs.P) / valueCount : 0;
    for(let i = 0; i < valueCount; i++){
        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
        padding[i] = opts.padding;
        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
        const plFont = (0, _helpersSegmentJs.a0)(opts.font);
        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
        labelSizes[i] = textSize;
        const angleRadians = (0, _helpersSegmentJs.ay)(scale.getIndexAngle(i) + additionalAngle);
        const angle = Math.round((0, _helpersSegmentJs.U)(angleRadians));
        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
        updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x = 0;
    let y = 0;
    if (hLimits.start < orig.l) {
        x = (orig.l - hLimits.start) / sin;
        limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
        x = (hLimits.end - orig.r) / sin;
        limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
        y = (orig.t - vLimits.start) / cos;
        limits.t = Math.min(limits.t, orig.t - y);
    } else if (vLimits.end > orig.b) {
        y = (vLimits.end - orig.b) / cos;
        limits.b = Math.max(limits.b, orig.b + y);
    }
}
function createPointLabelItem(scale, index, itemOpts) {
    const outerDistance = scale.drawingArea;
    const { extra, additionalAngle, padding, size } = itemOpts;
    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
    const angle = Math.round((0, _helpersSegmentJs.U)((0, _helpersSegmentJs.ay)(pointLabelPosition.angle + (0, _helpersSegmentJs.H))));
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    return {
        visible: true,
        x: pointLabelPosition.x,
        y,
        textAlign,
        left,
        top: y,
        right: left + size.w,
        bottom: y + size.h
    };
}
function isNotOverlapped(item, area) {
    if (!area) return true;
    const { left, top, right, bottom } = item;
    const apexesInArea = (0, _helpersSegmentJs.C)({
        x: left,
        y: top
    }, area) || (0, _helpersSegmentJs.C)({
        x: left,
        y: bottom
    }, area) || (0, _helpersSegmentJs.C)({
        x: right,
        y: top
    }, area) || (0, _helpersSegmentJs.C)({
        x: right,
        y: bottom
    }, area);
    return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const { centerPointLabels, display } = opts.pointLabels;
    const itemOpts = {
        extra: getTickBackdropHeight(opts) / 2,
        additionalAngle: centerPointLabels ? (0, _helpersSegmentJs.P) / valueCount : 0
    };
    let area;
    for(let i = 0; i < valueCount; i++){
        itemOpts.padding = padding[i];
        itemOpts.size = labelSizes[i];
        const item = createPointLabelItem(scale, i, itemOpts);
        items.push(item);
        if (display === "auto") {
            item.visible = isNotOverlapped(item, area);
            if (item.visible) area = item;
        }
    }
    return items;
}
function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) return "center";
    else if (angle < 180) return "left";
    return "right";
}
function leftForTextAlign(x, w, align) {
    if (align === "right") x -= w;
    else if (align === "center") x -= w / 2;
    return x;
}
function yForAngle(y, h, angle) {
    if (angle === 90 || angle === 270) y -= h / 2;
    else if (angle > 270 || angle < 90) y -= h;
    return y;
}
function drawPointLabelBox(ctx, opts, item) {
    const { left, top, right, bottom } = item;
    const { backdropColor } = opts;
    if (!(0, _helpersSegmentJs.k)(backdropColor)) {
        const borderRadius = (0, _helpersSegmentJs.aw)(opts.borderRadius);
        const padding = (0, _helpersSegmentJs.E)(opts.backdropPadding);
        ctx.fillStyle = backdropColor;
        const backdropLeft = left - padding.left;
        const backdropTop = top - padding.top;
        const backdropWidth = right - left + padding.width;
        const backdropHeight = bottom - top + padding.height;
        if (Object.values(borderRadius).some((v)=>v !== 0)) {
            ctx.beginPath();
            (0, _helpersSegmentJs.au)(ctx, {
                x: backdropLeft,
                y: backdropTop,
                w: backdropWidth,
                h: backdropHeight,
                radius: borderRadius
            });
            ctx.fill();
        } else ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
}
function drawPointLabels(scale, labelCount) {
    const { ctx, options: { pointLabels } } = scale;
    for(let i = labelCount - 1; i >= 0; i--){
        const item = scale._pointLabelItems[i];
        if (!item.visible) continue;
        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
        drawPointLabelBox(ctx, optsAtIndex, item);
        const plFont = (0, _helpersSegmentJs.a0)(optsAtIndex.font);
        const { x, y, textAlign } = item;
        (0, _helpersSegmentJs.Z)(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
            color: optsAtIndex.color,
            textAlign: textAlign,
            textBaseline: "middle"
        });
    }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx } = scale;
    if (circular) ctx.arc(scale.xCenter, scale.yCenter, radius, 0, (0, _helpersSegmentJs.T));
    else {
        let pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);
        for(let i = 1; i < labelCount; i++){
            pointPosition = scale.getPointPosition(i, radius);
            ctx.lineTo(pointPosition.x, pointPosition.y);
        }
    }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color || !lineWidth || radius < 0) return;
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
}
function createPointLabelContext(parent, index, label) {
    return (0, _helpersSegmentJs.j)(parent, {
        label,
        index,
        type: "pointLabel"
    });
}
class RadialLinearScale extends LinearScaleBase {
    static id = "radialLinear";
    static defaults = {
        display: true,
        animate: true,
        position: "chartArea",
        angleLines: {
            display: true,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0.0
        },
        grid: {
            circular: false
        },
        startAngle: 0,
        ticks: {
            showLabelBackdrop: true,
            callback: (0, _helpersSegmentJs.aL).formatters.numeric
        },
        pointLabels: {
            backdropColor: undefined,
            backdropPadding: 2,
            display: true,
            font: {
                size: 10
            },
            callback (label) {
                return label;
            },
            padding: 5,
            centerPointLabels: false
        }
    };
    static defaultRoutes = {
        "angleLines.color": "borderColor",
        "pointLabels.color": "color",
        "ticks.color": "color"
    };
    static descriptors = {
        angleLines: {
            _fallback: "grid"
        }
    };
    constructor(cfg){
        super(cfg);
        this.xCenter = undefined;
        this.yCenter = undefined;
        this.drawingArea = undefined;
        this._pointLabels = [];
        this._pointLabelItems = [];
    }
    setDimensions() {
        const padding = this._padding = (0, _helpersSegmentJs.E)(getTickBackdropHeight(this.options) / 2);
        const w = this.width = this.maxWidth - padding.width;
        const h = this.height = this.maxHeight - padding.height;
        this.xCenter = Math.floor(this.left + w / 2 + padding.left);
        this.yCenter = Math.floor(this.top + h / 2 + padding.top);
        this.drawingArea = Math.floor(Math.min(w, h) / 2);
    }
    determineDataLimits() {
        const { min, max } = this.getMinMax(false);
        this.min = (0, _helpersSegmentJs.g)(min) && !isNaN(min) ? min : 0;
        this.max = (0, _helpersSegmentJs.g)(max) && !isNaN(max) ? max : 0;
        this.handleTickRangeOptions();
    }
    computeTickLimit() {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
        this._pointLabels = this.getLabels().map((value, index)=>{
            const label = (0, _helpersSegmentJs.Q)(this.options.pointLabels.callback, [
                value,
                index
            ], this);
            return label || label === 0 ? label : "";
        }).filter((v, i)=>this.chart.getDataVisibility(i));
    }
    fit() {
        const opts = this.options;
        if (opts.display && opts.pointLabels.display) fitWithPointLabels(this);
        else this.setCenterPoint(0, 0, 0, 0);
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index) {
        const angleMultiplier = (0, _helpersSegmentJs.T) / (this._pointLabels.length || 1);
        const startAngle = this.options.startAngle || 0;
        return (0, _helpersSegmentJs.ay)(index * angleMultiplier + (0, _helpersSegmentJs.t)(startAngle));
    }
    getDistanceFromCenterForValue(value) {
        if ((0, _helpersSegmentJs.k)(value)) return NaN;
        const scalingFactor = this.drawingArea / (this.max - this.min);
        if (this.options.reverse) return (this.max - value) * scalingFactor;
        return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
        if ((0, _helpersSegmentJs.k)(distance)) return NaN;
        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index) {
        const pointLabels = this._pointLabels || [];
        if (index >= 0 && index < pointLabels.length) {
            const pointLabel = pointLabels[index];
            return createPointLabelContext(this.getContext(), index, pointLabel);
        }
    }
    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
        const angle = this.getIndexAngle(index) - (0, _helpersSegmentJs.H) + additionalAngle;
        return {
            x: Math.cos(angle) * distanceFromCenter + this.xCenter,
            y: Math.sin(angle) * distanceFromCenter + this.yCenter,
            angle
        };
    }
    getPointPositionForValue(index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index) {
        return this.getPointPositionForValue(index || 0, this.getBaseValue());
    }
    getPointLabelPosition(index) {
        const { left, top, right, bottom } = this._pointLabelItems[index];
        return {
            left,
            top,
            right,
            bottom
        };
    }
    drawBackground() {
        const { backgroundColor, grid: { circular } } = this.options;
        if (backgroundColor) {
            const ctx = this.ctx;
            ctx.save();
            ctx.beginPath();
            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
            ctx.closePath();
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
        }
    }
    drawGrid() {
        const ctx = this.ctx;
        const opts = this.options;
        const { angleLines, grid, border } = opts;
        const labelCount = this._pointLabels.length;
        let i, offset, position;
        if (opts.pointLabels.display) drawPointLabels(this, labelCount);
        if (grid.display) this.ticks.forEach((tick, index)=>{
            if (index !== 0) {
                offset = this.getDistanceFromCenterForValue(tick.value);
                const context = this.getContext(index);
                const optsAtIndex = grid.setContext(context);
                const optsAtIndexBorder = border.setContext(context);
                drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
            }
        });
        if (angleLines.display) {
            ctx.save();
            for(i = labelCount - 1; i >= 0; i--){
                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                const { color, lineWidth } = optsAtIndex;
                if (!lineWidth || !color) continue;
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color;
                ctx.setLineDash(optsAtIndex.borderDash);
                ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
                position = this.getPointPosition(i, offset);
                ctx.beginPath();
                ctx.moveTo(this.xCenter, this.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
            }
            ctx.restore();
        }
    }
    drawBorder() {}
    drawLabels() {
        const ctx = this.ctx;
        const opts = this.options;
        const tickOpts = opts.ticks;
        if (!tickOpts.display) return;
        const startAngle = this.getIndexAngle(0);
        let offset, width;
        ctx.save();
        ctx.translate(this.xCenter, this.yCenter);
        ctx.rotate(startAngle);
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        this.ticks.forEach((tick, index)=>{
            if (index === 0 && !opts.reverse) return;
            const optsAtIndex = tickOpts.setContext(this.getContext(index));
            const tickFont = (0, _helpersSegmentJs.a0)(optsAtIndex.font);
            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
            if (optsAtIndex.showLabelBackdrop) {
                ctx.font = tickFont.string;
                width = ctx.measureText(tick.label).width;
                ctx.fillStyle = optsAtIndex.backdropColor;
                const padding = (0, _helpersSegmentJs.E)(optsAtIndex.backdropPadding);
                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
            }
            (0, _helpersSegmentJs.Z)(ctx, tick.label, 0, -offset, tickFont, {
                color: optsAtIndex.color,
                strokeColor: optsAtIndex.textStrokeColor,
                strokeWidth: optsAtIndex.textStrokeWidth
            });
        });
        ctx.restore();
    }
    drawTitle() {}
}
const INTERVALS = {
    millisecond: {
        common: true,
        size: 1,
        steps: 1000
    },
    second: {
        common: true,
        size: 1000,
        steps: 60
    },
    minute: {
        common: true,
        size: 60000,
        steps: 60
    },
    hour: {
        common: true,
        size: 3600000,
        steps: 24
    },
    day: {
        common: true,
        size: 86400000,
        steps: 30
    },
    week: {
        common: false,
        size: 604800000,
        steps: 4
    },
    month: {
        common: true,
        size: 2.628e9,
        steps: 12
    },
    quarter: {
        common: false,
        size: 7.884e9,
        steps: 4
    },
    year: {
        common: true,
        size: 3.154e10
    }
};
const UNITS = /* #__PURE__ */ Object.keys(INTERVALS);
function sorter(a, b) {
    return a - b;
}
function parse(scale, input) {
    if ((0, _helpersSegmentJs.k)(input)) return null;
    const adapter = scale._adapter;
    const { parser, round, isoWeekday } = scale._parseOpts;
    let value = input;
    if (typeof parser === "function") value = parser(value);
    if (!(0, _helpersSegmentJs.g)(value)) value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
    if (value === null) return null;
    if (round) value = round === "week" && ((0, _helpersSegmentJs.x)(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round);
    return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    const ilen = UNITS.length;
    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){
        const interval = INTERVALS[UNITS[i]];
        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) return UNITS[i];
    }
    return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){
        const unit = UNITS[i];
        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) return unit;
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){
        if (INTERVALS[UNITS[i]].common) return UNITS[i];
    }
}
function addTick(ticks, time, timestamps) {
    if (!timestamps) ticks[time] = true;
    else if (timestamps.length) {
        const { lo, hi } = (0, _helpersSegmentJs.aP)(timestamps, time);
        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
        ticks[timestamp] = true;
    }
}
function setMajorTicks(scale, ticks, map, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index;
    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){
        index = map[major];
        if (index >= 0) ticks[index].major = true;
    }
    return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map = {};
    const ilen = values.length;
    let i, value;
    for(i = 0; i < ilen; ++i){
        value = values[i];
        map[value] = i;
        ticks.push({
            value,
            major: false
        });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
}
class TimeScale extends Scale {
    static id = "time";
    static defaults = {
        bounds: "data",
        adapters: {},
        time: {
            parser: false,
            unit: false,
            round: false,
            isoWeekday: false,
            minUnit: "millisecond",
            displayFormats: {}
        },
        ticks: {
            source: "auto",
            callback: false,
            major: {
                enabled: false
            }
        }
    };
    constructor(props){
        super(props);
        this._cache = {
            data: [],
            labels: [],
            all: []
        };
        this._unit = "day";
        this._majorUnit = undefined;
        this._offsets = {};
        this._normalized = false;
        this._parseOpts = undefined;
    }
    init(scaleOpts, opts = {}) {
        const time = scaleOpts.time || (scaleOpts.time = {});
        const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
        adapter.init(opts);
        (0, _helpersSegmentJs.ab)(time.displayFormats, adapter.formats());
        this._parseOpts = {
            parser: time.parser,
            round: time.round,
            isoWeekday: time.isoWeekday
        };
        super.init(scaleOpts);
        this._normalized = opts.normalized;
    }
    parse(raw, index) {
        if (raw === undefined) return null;
        return parse(this, raw);
    }
    beforeLayout() {
        super.beforeLayout();
        this._cache = {
            data: [],
            labels: [],
            all: []
        };
    }
    determineDataLimits() {
        const options = this.options;
        const adapter = this._adapter;
        const unit = options.time.unit || "day";
        let { min, max, minDefined, maxDefined } = this.getUserBounds();
        function _applyBounds(bounds) {
            if (!minDefined && !isNaN(bounds.min)) min = Math.min(min, bounds.min);
            if (!maxDefined && !isNaN(bounds.max)) max = Math.max(max, bounds.max);
        }
        if (!minDefined || !maxDefined) {
            _applyBounds(this._getLabelBounds());
            if (options.bounds !== "ticks" || options.ticks.source !== "labels") _applyBounds(this.getMinMax(false));
        }
        min = (0, _helpersSegmentJs.g)(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
        max = (0, _helpersSegmentJs.g)(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
        this.min = Math.min(min, max - 1);
        this.max = Math.max(min + 1, max);
    }
    _getLabelBounds() {
        const arr = this.getLabelTimestamps();
        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;
        if (arr.length) {
            min = arr[0];
            max = arr[arr.length - 1];
        }
        return {
            min,
            max
        };
    }
    buildTicks() {
        const options = this.options;
        const timeOpts = options.time;
        const tickOpts = options.ticks;
        const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
        if (options.bounds === "ticks" && timestamps.length) {
            this.min = this._userMin || timestamps[0];
            this.max = this._userMax || timestamps[timestamps.length - 1];
        }
        const min = this.min;
        const max = this.max;
        const ticks = (0, _helpersSegmentJs.aO)(timestamps, min, max);
        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
        this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? undefined : determineMajorUnit(this._unit);
        this.initOffsets(timestamps);
        if (options.reverse) ticks.reverse();
        return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
        if (this.options.offsetAfterAutoskip) this.initOffsets(this.ticks.map((tick)=>+tick.value));
    }
    initOffsets(timestamps = []) {
        let start = 0;
        let end = 0;
        let first, last;
        if (this.options.offset && timestamps.length) {
            first = this.getDecimalForValue(timestamps[0]);
            if (timestamps.length === 1) start = 1 - first;
            else start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
            if (timestamps.length === 1) end = last;
            else end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
        const limit = timestamps.length < 3 ? 0.5 : 0.25;
        start = (0, _helpersSegmentJs.S)(start, 0, limit);
        end = (0, _helpersSegmentJs.S)(end, 0, limit);
        this._offsets = {
            start,
            end,
            factor: 1 / (start + 1 + end)
        };
    }
    _generate() {
        const adapter = this._adapter;
        const min = this.min;
        const max = this.max;
        const options = this.options;
        const timeOpts = options.time;
        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
        const stepSize = (0, _helpersSegmentJs.v)(options.ticks.stepSize, 1);
        const weekday = minor === "week" ? timeOpts.isoWeekday : false;
        const hasWeekday = (0, _helpersSegmentJs.x)(weekday) || weekday === true;
        const ticks = {};
        let first = min;
        let time, count;
        if (hasWeekday) first = +adapter.startOf(first, "isoWeek", weekday);
        first = +adapter.startOf(first, hasWeekday ? "day" : minor);
        if (adapter.diff(max, min, minor) > 100000 * stepSize) throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
        const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++)addTick(ticks, time, timestamps);
        if (time === max || options.bounds === "ticks" || count === 1) addTick(ticks, time, timestamps);
        return Object.keys(ticks).sort(sorter).map((x)=>+x);
    }
    getLabelForValue(value) {
        const adapter = this._adapter;
        const timeOpts = this.options.time;
        if (timeOpts.tooltipFormat) return adapter.format(value, timeOpts.tooltipFormat);
        return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    format(value, format) {
        const options = this.options;
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const fmt = format || formats[unit];
        return this._adapter.format(value, fmt);
    }
    _tickFormatFunction(time, index, ticks, format) {
        const options = this.options;
        const formatter = options.ticks.callback;
        if (formatter) return (0, _helpersSegmentJs.Q)(formatter, [
            time,
            index,
            ticks
        ], this);
        const formats = options.time.displayFormats;
        const unit = this._unit;
        const majorUnit = this._majorUnit;
        const minorFormat = unit && formats[unit];
        const majorFormat = majorUnit && formats[majorUnit];
        const tick = ticks[index];
        const major = majorUnit && majorFormat && tick && tick.major;
        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    }
    generateTickLabels(ticks) {
        let i, ilen, tick;
        for(i = 0, ilen = ticks.length; i < ilen; ++i){
            tick = ticks[i];
            tick.label = this._tickFormatFunction(tick.value, i, ticks);
        }
    }
    getDecimalForValue(value) {
        return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
        const offsets = this._offsets;
        const pos = this.getDecimalForValue(value);
        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
        const offsets = this._offsets;
        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
        const ticksOpts = this.options.ticks;
        const tickLabelWidth = this.ctx.measureText(label).width;
        const angle = (0, _helpersSegmentJs.t)(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
        const cosRotation = Math.cos(angle);
        const sinRotation = Math.sin(angle);
        const tickFontSize = this._resolveTickFontOptions(0).size;
        return {
            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
        };
    }
    _getLabelCapacity(exampleTime) {
        const timeOpts = this.options.time;
        const displayFormats = timeOpts.displayFormats;
        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
            exampleTime
        ], this._majorUnit), format);
        const size = this._getLabelSize(exampleLabel);
        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
        return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
        let timestamps = this._cache.data || [];
        let i, ilen;
        if (timestamps.length) return timestamps;
        const metas = this.getMatchingVisibleMetas();
        if (this._normalized && metas.length) return this._cache.data = metas[0].controller.getAllParsedValues(this);
        for(i = 0, ilen = metas.length; i < ilen; ++i)timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
        return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
        const timestamps = this._cache.labels || [];
        let i, ilen;
        if (timestamps.length) return timestamps;
        const labels = this.getLabels();
        for(i = 0, ilen = labels.length; i < ilen; ++i)timestamps.push(parse(this, labels[i]));
        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
        return (0, _helpersSegmentJs._)(values.sort(sorter));
    }
}
function interpolate(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
        if (val >= table[lo].pos && val <= table[hi].pos) ({ lo, hi } = (0, _helpersSegmentJs.B)(table, "pos", val));
        ({ pos: prevSource, time: prevTarget } = table[lo]);
        ({ pos: nextSource, time: nextTarget } = table[hi]);
    } else {
        if (val >= table[lo].time && val <= table[hi].time) ({ lo, hi } = (0, _helpersSegmentJs.B)(table, "time", val));
        ({ time: prevSource, pos: prevTarget } = table[lo]);
        ({ time: nextSource, pos: nextTarget } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
    static id = "timeseries";
    static defaults = TimeScale.defaults;
    constructor(props){
        super(props);
        this._table = [];
        this._minPos = undefined;
        this._tableRange = undefined;
    }
    initOffsets() {
        const timestamps = this._getTimestampsForTable();
        const table = this._table = this.buildLookupTable(timestamps);
        this._minPos = interpolate(table, this.min);
        this._tableRange = interpolate(table, this.max) - this._minPos;
        super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
        const { min, max } = this;
        const items = [];
        const table = [];
        let i, ilen, prev, curr, next;
        for(i = 0, ilen = timestamps.length; i < ilen; ++i){
            curr = timestamps[i];
            if (curr >= min && curr <= max) items.push(curr);
        }
        if (items.length < 2) return [
            {
                time: min,
                pos: 0
            },
            {
                time: max,
                pos: 1
            }
        ];
        for(i = 0, ilen = items.length; i < ilen; ++i){
            next = items[i + 1];
            prev = items[i - 1];
            curr = items[i];
            if (Math.round((next + prev) / 2) !== curr) table.push({
                time: curr,
                pos: i / (ilen - 1)
            });
        }
        return table;
    }
    _generate() {
        const min = this.min;
        const max = this.max;
        let timestamps = super.getDataTimestamps();
        if (!timestamps.includes(min) || !timestamps.length) timestamps.splice(0, 0, min);
        if (!timestamps.includes(max) || timestamps.length === 1) timestamps.push(max);
        return timestamps.sort((a, b)=>a - b);
    }
    _getTimestampsForTable() {
        let timestamps = this._cache.all || [];
        if (timestamps.length) return timestamps;
        const data = this.getDataTimestamps();
        const label = this.getLabelTimestamps();
        if (data.length && label.length) timestamps = this.normalize(data.concat(label));
        else timestamps = data.length ? data : label;
        timestamps = this._cache.all = timestamps;
        return timestamps;
    }
    getDecimalForValue(value) {
        return (interpolate(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
        const offsets = this._offsets;
        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
    }
}
var scales = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    CategoryScale: CategoryScale,
    LinearScale: LinearScale,
    LogarithmicScale: LogarithmicScale,
    RadialLinearScale: RadialLinearScale,
    TimeScale: TimeScale,
    TimeSeriesScale: TimeSeriesScale
});
const registerables = [
    controllers,
    elements,
    plugins,
    scales
];

},{"./chunks/helpers.segment.js":"7oQuk","@kurkle/color":"2aojw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7oQuk":[function(require,module,exports) {
/*!
 * Chart.js v4.4.1
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "$", ()=>unclipArea);
parcelHelpers.export(exports, "A", ()=>_rlookupByKey);
parcelHelpers.export(exports, "B", ()=>_lookupByKey);
parcelHelpers.export(exports, "C", ()=>_isPointInArea);
parcelHelpers.export(exports, "D", ()=>getAngleFromPoint);
parcelHelpers.export(exports, "E", ()=>toPadding);
parcelHelpers.export(exports, "F", ()=>each);
parcelHelpers.export(exports, "G", ()=>getMaximumSize);
parcelHelpers.export(exports, "H", ()=>HALF_PI);
parcelHelpers.export(exports, "I", ()=>_getParentNode);
parcelHelpers.export(exports, "J", ()=>readUsedSize);
parcelHelpers.export(exports, "K", ()=>supportsEventListenerOptions);
parcelHelpers.export(exports, "L", ()=>throttled);
parcelHelpers.export(exports, "M", ()=>_isDomSupported);
parcelHelpers.export(exports, "N", ()=>_factorize);
parcelHelpers.export(exports, "O", ()=>finiteOrDefault);
parcelHelpers.export(exports, "P", ()=>PI);
parcelHelpers.export(exports, "Q", ()=>callback);
parcelHelpers.export(exports, "R", ()=>_addGrace);
parcelHelpers.export(exports, "S", ()=>_limitValue);
parcelHelpers.export(exports, "T", ()=>TAU);
parcelHelpers.export(exports, "U", ()=>toDegrees);
parcelHelpers.export(exports, "V", ()=>_measureText);
parcelHelpers.export(exports, "W", ()=>_int16Range);
parcelHelpers.export(exports, "X", ()=>_alignPixel);
parcelHelpers.export(exports, "Y", ()=>clipArea);
parcelHelpers.export(exports, "Z", ()=>renderText);
parcelHelpers.export(exports, "_", ()=>_arrayUnique);
parcelHelpers.export(exports, "a", ()=>resolve);
parcelHelpers.export(exports, "a$", ()=>fontString);
parcelHelpers.export(exports, "a0", ()=>toFont);
parcelHelpers.export(exports, "a1", ()=>_toLeftRightCenter);
parcelHelpers.export(exports, "a2", ()=>_alignStartEnd);
parcelHelpers.export(exports, "a3", ()=>overrides);
parcelHelpers.export(exports, "a4", ()=>merge);
parcelHelpers.export(exports, "a5", ()=>_capitalize);
parcelHelpers.export(exports, "a6", ()=>descriptors);
parcelHelpers.export(exports, "a7", ()=>isFunction);
parcelHelpers.export(exports, "a8", ()=>_attachContext);
parcelHelpers.export(exports, "a9", ()=>_createResolver);
parcelHelpers.export(exports, "aA", ()=>overrideTextDirection);
parcelHelpers.export(exports, "aB", ()=>_textX);
parcelHelpers.export(exports, "aC", ()=>restoreTextDirection);
parcelHelpers.export(exports, "aD", ()=>drawPointLegend);
parcelHelpers.export(exports, "aE", ()=>distanceBetweenPoints);
parcelHelpers.export(exports, "aF", ()=>noop);
parcelHelpers.export(exports, "aG", ()=>_setMinAndMaxByKey);
parcelHelpers.export(exports, "aH", ()=>niceNum);
parcelHelpers.export(exports, "aI", ()=>almostWhole);
parcelHelpers.export(exports, "aJ", ()=>almostEquals);
parcelHelpers.export(exports, "aK", ()=>_decimalPlaces);
parcelHelpers.export(exports, "aL", ()=>Ticks);
parcelHelpers.export(exports, "aM", ()=>log10);
parcelHelpers.export(exports, "aN", ()=>_longestText);
parcelHelpers.export(exports, "aO", ()=>_filterBetween);
parcelHelpers.export(exports, "aP", ()=>_lookup);
parcelHelpers.export(exports, "aQ", ()=>isPatternOrGradient);
parcelHelpers.export(exports, "aR", ()=>getHoverColor);
parcelHelpers.export(exports, "aS", ()=>clone);
parcelHelpers.export(exports, "aT", ()=>_merger);
parcelHelpers.export(exports, "aU", ()=>_mergerIf);
parcelHelpers.export(exports, "aV", ()=>_deprecated);
parcelHelpers.export(exports, "aW", ()=>_splitKey);
parcelHelpers.export(exports, "aX", ()=>toFontString);
parcelHelpers.export(exports, "aY", ()=>splineCurve);
parcelHelpers.export(exports, "aZ", ()=>splineCurveMonotone);
parcelHelpers.export(exports, "a_", ()=>getStyle);
parcelHelpers.export(exports, "aa", ()=>_descriptors);
parcelHelpers.export(exports, "ab", ()=>mergeIf);
parcelHelpers.export(exports, "ac", ()=>uid);
parcelHelpers.export(exports, "ad", ()=>debounce);
parcelHelpers.export(exports, "ae", ()=>retinaScale);
parcelHelpers.export(exports, "af", ()=>clearCanvas);
parcelHelpers.export(exports, "ag", ()=>setsEqual);
parcelHelpers.export(exports, "ah", ()=>_elementsEqual);
parcelHelpers.export(exports, "ai", ()=>_isClickEvent);
parcelHelpers.export(exports, "aj", ()=>_isBetween);
parcelHelpers.export(exports, "ak", ()=>_readValueToProps);
parcelHelpers.export(exports, "al", ()=>_updateBezierControlPoints);
parcelHelpers.export(exports, "am", ()=>_computeSegments);
parcelHelpers.export(exports, "an", ()=>_boundSegments);
parcelHelpers.export(exports, "ao", ()=>_steppedInterpolation);
parcelHelpers.export(exports, "ap", ()=>_bezierInterpolation);
parcelHelpers.export(exports, "aq", ()=>_pointInLine);
parcelHelpers.export(exports, "ar", ()=>_steppedLineTo);
parcelHelpers.export(exports, "as", ()=>_bezierCurveTo);
parcelHelpers.export(exports, "at", ()=>drawPoint);
parcelHelpers.export(exports, "au", ()=>addRoundedRectPath);
parcelHelpers.export(exports, "av", ()=>toTRBL);
parcelHelpers.export(exports, "aw", ()=>toTRBLCorners);
parcelHelpers.export(exports, "ax", ()=>_boundSegment);
parcelHelpers.export(exports, "ay", ()=>_normalizeAngle);
parcelHelpers.export(exports, "az", ()=>getRtlAdapter);
parcelHelpers.export(exports, "b", ()=>isArray);
parcelHelpers.export(exports, "b0", ()=>toLineHeight);
parcelHelpers.export(exports, "b1", ()=>PITAU);
parcelHelpers.export(exports, "b2", ()=>INFINITY);
parcelHelpers.export(exports, "b3", ()=>RAD_PER_DEG);
parcelHelpers.export(exports, "b4", ()=>QUARTER_PI);
parcelHelpers.export(exports, "b5", ()=>TWO_THIRDS_PI);
parcelHelpers.export(exports, "b6", ()=>_angleDiff);
parcelHelpers.export(exports, "c", ()=>color);
parcelHelpers.export(exports, "d", ()=>defaults);
parcelHelpers.export(exports, "e", ()=>effects);
parcelHelpers.export(exports, "f", ()=>resolveObjectKey);
parcelHelpers.export(exports, "g", ()=>isNumberFinite);
parcelHelpers.export(exports, "h", ()=>defined);
parcelHelpers.export(exports, "i", ()=>isObject);
parcelHelpers.export(exports, "j", ()=>createContext);
parcelHelpers.export(exports, "k", ()=>isNullOrUndef);
parcelHelpers.export(exports, "l", ()=>listenArrayEvents);
parcelHelpers.export(exports, "m", ()=>toPercentage);
parcelHelpers.export(exports, "n", ()=>toDimension);
parcelHelpers.export(exports, "o", ()=>formatNumber);
parcelHelpers.export(exports, "p", ()=>_angleBetween);
parcelHelpers.export(exports, "q", ()=>_getStartAndCountOfVisiblePoints);
parcelHelpers.export(exports, "r", ()=>requestAnimFrame);
parcelHelpers.export(exports, "s", ()=>sign);
parcelHelpers.export(exports, "t", ()=>toRadians);
parcelHelpers.export(exports, "u", ()=>unlistenArrayEvents);
parcelHelpers.export(exports, "v", ()=>valueOrDefault);
parcelHelpers.export(exports, "w", ()=>_scaleRangesChanged);
parcelHelpers.export(exports, "x", ()=>isNumber);
parcelHelpers.export(exports, "y", ()=>_parseObjectDataRadialScale);
parcelHelpers.export(exports, "z", ()=>getRelativePosition);
var _color = require("@kurkle/color");
/**
 * @namespace Chart.helpers
 */ /**
 * An empty function that can be used, for example, for optional callback.
 */ function noop() {
/* noop */ }
/**
 * Returns a unique id, sequentially generated from a global variable.
 */ const uid = (()=>{
    let id = 0;
    return ()=>id++;
})();
/**
 * Returns true if `value` is neither null nor undefined, else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */ function isNullOrUndef(value) {
    return value === null || typeof value === "undefined";
}
/**
 * Returns true if `value` is an array (including typed arrays), else returns false.
 * @param value - The value to test.
 * @function
 */ function isArray(value) {
    if (Array.isArray && Array.isArray(value)) return true;
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") return true;
    return false;
}
/**
 * Returns true if `value` is an object (excluding null), else returns false.
 * @param value - The value to test.
 * @since 2.7.0
 */ function isObject(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
/**
 * Returns true if `value` is a finite number, else returns false
 * @param value  - The value to test.
 */ function isNumberFinite(value) {
    return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
/**
 * Returns `value` if finite, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is not finite.
 */ function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
}
/**
 * Returns `value` if defined, else returns `defaultValue`.
 * @param value - The value to return if defined.
 * @param defaultValue - The value to return if `value` is undefined.
 */ function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
}
const toPercentage = (value, dimension)=>typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
const toDimension = (value, dimension)=>typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
/**
 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
 * @param fn - The function to call.
 * @param args - The arguments with which `fn` should be called.
 * @param [thisArg] - The value of `this` provided for the call to `fn`.
 */ function callback(fn, args, thisArg) {
    if (fn && typeof fn.call === "function") return fn.apply(thisArg, args);
}
function each(loopable, fn, thisArg, reverse) {
    let i, len, keys;
    if (isArray(loopable)) {
        len = loopable.length;
        if (reverse) for(i = len - 1; i >= 0; i--)fn.call(thisArg, loopable[i], i);
        else for(i = 0; i < len; i++)fn.call(thisArg, loopable[i], i);
    } else if (isObject(loopable)) {
        keys = Object.keys(loopable);
        len = keys.length;
        for(i = 0; i < len; i++)fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
}
/**
 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
 * @param a0 - The array to compare
 * @param a1 - The array to compare
 * @private
 */ function _elementsEqual(a0, a1) {
    let i, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) return false;
    for(i = 0, ilen = a0.length; i < ilen; ++i){
        v0 = a0[i];
        v1 = a1[i];
        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) return false;
    }
    return true;
}
/**
 * Returns a deep copy of `source` without keeping references on objects and arrays.
 * @param source - The value to clone.
 */ function clone(source) {
    if (isArray(source)) return source.map(clone);
    if (isObject(source)) {
        const target = Object.create(null);
        const keys = Object.keys(source);
        const klen = keys.length;
        let k = 0;
        for(; k < klen; ++k)target[keys[k]] = clone(source[keys[k]]);
        return target;
    }
    return source;
}
function isValidKey(key) {
    return [
        "__proto__",
        "prototype",
        "constructor"
    ].indexOf(key) === -1;
}
/**
 * The default merger when Chart.helpers.merge is called without merger option.
 * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
 * @private
 */ function _merger(key, target, source, options) {
    if (!isValidKey(key)) return;
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) // eslint-disable-next-line @typescript-eslint/no-use-before-define
    merge(tval, sval, options);
    else target[key] = clone(sval);
}
function merge(target, source, options) {
    const sources = isArray(source) ? source : [
        source
    ];
    const ilen = sources.length;
    if (!isObject(target)) return target;
    options = options || {};
    const merger = options.merger || _merger;
    let current;
    for(let i = 0; i < ilen; ++i){
        current = sources[i];
        if (!isObject(current)) continue;
        const keys = Object.keys(current);
        for(let k = 0, klen = keys.length; k < klen; ++k)merger(keys[k], target, current, options);
    }
    return target;
}
function mergeIf(target, source) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return merge(target, source, {
        merger: _mergerIf
    });
}
/**
 * Merges source[key] in target[key] only if target[key] is undefined.
 * @private
 */ function _mergerIf(key, target, source) {
    if (!isValidKey(key)) return;
    const tval = target[key];
    const sval = source[key];
    if (isObject(tval) && isObject(sval)) mergeIf(tval, sval);
    else if (!Object.prototype.hasOwnProperty.call(target, key)) target[key] = clone(sval);
}
/**
 * @private
 */ function _deprecated(scope, value, previous, current) {
    if (value !== undefined) console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
}
// resolveObjectKey resolver cache
const keyResolvers = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    "": (v)=>v,
    // default resolvers
    x: (o)=>o.x,
    y: (o)=>o.y
};
/**
 * @private
 */ function _splitKey(key) {
    const parts = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts){
        tmp += part;
        if (tmp.endsWith("\\")) tmp = tmp.slice(0, -1) + ".";
        else {
            keys.push(tmp);
            tmp = "";
        }
    }
    return keys;
}
function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj)=>{
        for (const k of keys){
            if (k === "") break;
            obj = obj && obj[k];
        }
        return obj;
    };
}
function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
}
/**
 * @private
 */ function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value)=>typeof value !== "undefined";
const isFunction = (value)=>typeof value === "function";
// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384
const setsEqual = (a, b)=>{
    if (a.size !== b.size) return false;
    for (const item of a){
        if (!b.has(item)) return false;
    }
    return true;
};
/**
 * @param e - The event
 * @private
 */ function _isClickEvent(e) {
    return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
/**
 * @alias Chart.helpers.math
 * @namespace
 */ const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function almostEquals(x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
}
/**
 * Implementation of the nice number algorithm used in determining where axis labels will go
 */ function niceNum(range) {
    const roundedRange = Math.round(range);
    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
    const niceRange = Math.pow(10, Math.floor(log10(range)));
    const fraction = range / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
}
/**
 * Returns an array of factors sorted from 1 to sqrt(value)
 * @private
 */ function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i;
    for(i = 1; i < sqrt; i++)if (value % i === 0) {
        result.push(i);
        result.push(value / i);
    }
    if (sqrt === (sqrt | 0)) result.push(sqrt);
    result.sort((a, b)=>a - b).pop();
    return result;
}
function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
    const rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
}
/**
 * @private
 */ function _setMinAndMaxByKey(array, target, property) {
    let i, ilen, value;
    for(i = 0, ilen = array.length; i < ilen; i++){
        value = array[i][property];
        if (!isNaN(value)) {
            target.min = Math.min(target.min, value);
            target.max = Math.max(target.max, value);
        }
    }
}
function toRadians(degrees) {
    return degrees * (PI / 180);
}
function toDegrees(radians) {
    return radians * (180 / PI);
}
/**
 * Returns the number of decimal places
 * i.e. the number of digits after the decimal point, of the value of this Number.
 * @param x - A number.
 * @returns The number of decimal places.
 * @private
 */ function _decimalPlaces(x) {
    if (!isNumberFinite(x)) return;
    let e = 1;
    let p = 0;
    while(Math.round(x * e) / e !== x){
        e *= 10;
        p++;
    }
    return p;
}
// Gets the angle from vertical upright to the point about a centre.
function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
    return {
        angle,
        distance: radialDistanceFromCenter
    };
}
function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
/**
 * Shortest distance between angles, in either direction.
 * @private
 */ function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
}
/**
 * Normalize angle to be between 0 and 2*PI
 * @private
 */ function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
}
/**
 * @private
 */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
    const a = _normalizeAngle(angle);
    const s = _normalizeAngle(start);
    const e = _normalizeAngle(end);
    const angleToStart = _normalizeAngle(s - a);
    const angleToEnd = _normalizeAngle(e - a);
    const startToAngle = _normalizeAngle(a - s);
    const endToAngle = _normalizeAngle(a - e);
    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
/**
 * Limit `value` between `min` and `max`
 * @param value
 * @param min
 * @param max
 * @private
 */ function _limitValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
/**
 * @param {number} value
 * @private
 */ function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
}
/**
 * @param value
 * @param start
 * @param end
 * @param [epsilon]
 * @private
 */ function _isBetween(value, start, end, epsilon = 1e-6) {
    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
    cmp = cmp || ((index)=>table[index] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while(hi - lo > 1){
        mid = lo + hi >> 1;
        if (cmp(mid)) lo = mid;
        else hi = mid;
    }
    return {
        lo,
        hi
    };
}
/**
 * Binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @param last - lookup last index
 * @private
 */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{
        const ti = table[index][key];
        return ti < value || ti === value && table[index + 1][key] === value;
    } : (index)=>table[index][key] < value);
/**
 * Reverse binary search
 * @param table - the table search. must be sorted!
 * @param key - property name for the value in each entry
 * @param value - value to find
 * @private
 */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);
/**
 * Return subset of `values` between `min` and `max` inclusive.
 * Values are assumed to be in sorted order.
 * @param values - sorted array of values
 * @param min - min value
 * @param max - max value
 */ function _filterBetween(values, min, max) {
    let start = 0;
    let end = values.length;
    while(start < end && values[start] < min)start++;
    while(end > start && values[end - 1] > max)end--;
    return start > 0 || end < values.length ? values.slice(start, end) : values;
}
const arrayEvents = [
    "push",
    "pop",
    "shift",
    "splice",
    "unshift"
];
function listenArrayEvents(array, listener) {
    if (array._chartjs) {
        array._chartjs.listeners.push(listener);
        return;
    }
    Object.defineProperty(array, "_chartjs", {
        configurable: true,
        enumerable: false,
        value: {
            listeners: [
                listener
            ]
        }
    });
    arrayEvents.forEach((key)=>{
        const method = "_onData" + _capitalize(key);
        const base = array[key];
        Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value (...args) {
                const res = base.apply(this, args);
                array._chartjs.listeners.forEach((object)=>{
                    if (typeof object[method] === "function") object[method](...args);
                });
                return res;
            }
        });
    });
}
function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) return;
    const listeners = stub.listeners;
    const index = listeners.indexOf(listener);
    if (index !== -1) listeners.splice(index, 1);
    if (listeners.length > 0) return;
    arrayEvents.forEach((key)=>{
        delete array[key];
    });
    delete array._chartjs;
}
/**
 * @param items
 */ function _arrayUnique(items) {
    const set = new Set(items);
    if (set.size === items.length) return items;
    return Array.from(set);
}
function fontString(pixelSize, fontStyle, fontFamily) {
    return fontStyle + " " + pixelSize + "px " + fontFamily;
}
/**
* Request animation polyfill
*/ const requestAnimFrame = function() {
    if (typeof window === "undefined") return function(callback) {
        return callback();
    };
    return window.requestAnimationFrame;
}();
/**
 * Throttles calling `fn` once per animation frame
 * Latest arguments are used on the actual call
 */ function throttled(fn, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function(...args) {
        // Save the args for use later
        argsToUse = args;
        if (!ticking) {
            ticking = true;
            requestAnimFrame.call(window, ()=>{
                ticking = false;
                fn.apply(thisArg, argsToUse);
            });
        }
    };
}
/**
 * Debounces calling `fn` for `delay` ms
 */ function debounce(fn, delay) {
    let timeout;
    return function(...args) {
        if (delay) {
            clearTimeout(timeout);
            timeout = setTimeout(fn, delay, args);
        } else fn.apply(this, args);
        return delay;
    };
}
/**
 * Converts 'start' to 'left', 'end' to 'right' and others to 'center'
 * @private
 */ const _toLeftRightCenter = (align)=>align === "start" ? "left" : align === "end" ? "right" : "center";
/**
 * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`
 * @private
 */ const _alignStartEnd = (align, start, end)=>align === "start" ? start : align === "end" ? end : (start + end) / 2;
/**
 * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`
 * @private
 */ const _textX = (align, left, right, rtl)=>{
    const check = rtl ? "left" : "right";
    return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
/**
 * Return start and count of visible points.
 * @private
 */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start = 0;
    let count = pointCount;
    if (meta._sorted) {
        const { iScale, _parsed } = meta;
        const axis = iScale.axis;
        const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
        if (minDefined) start = _limitValue(Math.min(_lookupByKey(_parsed, axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
        if (maxDefined) count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
        else count = pointCount - start;
    }
    return {
        start,
        count
    };
}
/**
 * Checks if the scale ranges have changed.
 * @param {object} meta - dataset meta.
 * @returns {boolean}
 * @private
 */ function _scaleRangesChanged(meta) {
    const { xScale, yScale, _scaleRanges } = meta;
    const newRanges = {
        xmin: xScale.min,
        xmax: xScale.max,
        ymin: yScale.min,
        ymax: yScale.max
    };
    if (!_scaleRanges) {
        meta._scaleRanges = newRanges;
        return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
}
const atEdge = (t)=>t === 0 || t === 1;
const elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
const elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
/**
 * Easing functions adapted from Robert Penner's easing equations.
 * @namespace Chart.helpers.easing.effects
 * @see http://www.robertpenner.com/easing/
 */ const effects = {
    linear: (t)=>t,
    easeInQuad: (t)=>t * t,
    easeOutQuad: (t)=>-t * (t - 2),
    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
    easeInCubic: (t)=>t * t * t,
    easeOutCubic: (t)=>(t -= 1) * t * t + 1,
    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
    easeInQuart: (t)=>t * t * t * t,
    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),
    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
    easeInQuint: (t)=>t * t * t * t * t,
    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,
    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,
    easeOutSine: (t)=>Math.sin(t * HALF_PI),
    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),
    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),
    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
    easeInOutElastic (t) {
        const s = 0.1125;
        const p = 0.45;
        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
    },
    easeInBack (t) {
        const s = 1.70158;
        return t * t * ((s + 1) * t - s);
    },
    easeOutBack (t) {
        const s = 1.70158;
        return (t -= 1) * t * ((s + 1) * t + s) + 1;
    },
    easeInOutBack (t) {
        let s = 1.70158;
        if ((t /= 0.5) < 1) return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    },
    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),
    easeOutBounce (t) {
        const m = 7.5625;
        const d = 2.75;
        if (t < 1 / d) return m * t * t;
        if (t < 2 / d) return m * (t -= 1.5 / d) * t + 0.75;
        if (t < 2.5 / d) return m * (t -= 2.25 / d) * t + 0.9375;
        return m * (t -= 2.625 / d) * t + 0.984375;
    },
    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
        const type = value.toString();
        return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
}
function color(value) {
    return isPatternOrGradient(value) ? value : new (0, _color.Color)(value);
}
function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new (0, _color.Color)(value).saturate(0.5).darken(0.1).hexString();
}
const numbers = [
    "x",
    "y",
    "borderWidth",
    "radius",
    "tension"
];
const colors = [
    "color",
    "borderColor",
    "backgroundColor"
];
function applyAnimationsDefaults(defaults) {
    defaults.set("animation", {
        delay: undefined,
        duration: 1000,
        easing: "easeOutQuart",
        fn: undefined,
        from: undefined,
        loop: undefined,
        to: undefined,
        type: undefined
    });
    defaults.describe("animation", {
        _fallback: false,
        _indexable: false,
        _scriptable: (name)=>name !== "onProgress" && name !== "onComplete" && name !== "fn"
    });
    defaults.set("animations", {
        colors: {
            type: "color",
            properties: colors
        },
        numbers: {
            type: "number",
            properties: numbers
        }
    });
    defaults.describe("animations", {
        _fallback: "animation"
    });
    defaults.set("transitions", {
        active: {
            animation: {
                duration: 400
            }
        },
        resize: {
            animation: {
                duration: 0
            }
        },
        show: {
            animations: {
                colors: {
                    from: "transparent"
                },
                visible: {
                    type: "boolean",
                    duration: 0
                }
            }
        },
        hide: {
            animations: {
                colors: {
                    to: "transparent"
                },
                visible: {
                    type: "boolean",
                    easing: "linear",
                    fn: (v)=>v | 0
                }
            }
        }
    });
}
function applyLayoutsDefaults(defaults) {
    defaults.set("layout", {
        autoPadding: true,
        padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }
    });
}
const intlCache = new Map();
function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
        formatter = new Intl.NumberFormat(locale, options);
        intlCache.set(cacheKey, formatter);
    }
    return formatter;
}
function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
}
const formatters = {
    values (value) {
        return isArray(value) ? value : "" + value;
    },
    numeric (tickValue, index, ticks) {
        if (tickValue === 0) return "0";
        const locale = this.chart.options.locale;
        let notation;
        let delta = tickValue;
        if (ticks.length > 1) {
            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
            if (maxTick < 1e-4 || maxTick > 1e+15) notation = "scientific";
            delta = calculateDelta(tickValue, ticks);
        }
        const logDelta = log10(Math.abs(delta));
        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
        const options = {
            notation,
            minimumFractionDigits: numDecimal,
            maximumFractionDigits: numDecimal
        };
        Object.assign(options, this.options.ticks.format);
        return formatNumber(tickValue, locale, options);
    },
    logarithmic (tickValue, index, ticks) {
        if (tickValue === 0) return "0";
        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
        if ([
            1,
            2,
            3,
            5,
            10,
            15
        ].includes(remain) || index > 0.8 * ticks.length) return formatters.numeric.call(this, tickValue, index, ticks);
        return "";
    }
};
function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) delta = tickValue - Math.floor(tickValue);
    return delta;
}
var Ticks = {
    formatters
};
function applyScaleDefaults(defaults) {
    defaults.set("scale", {
        display: true,
        offset: false,
        reverse: false,
        beginAtZero: false,
        bounds: "ticks",
        clip: true,
        grace: 0,
        grid: {
            display: true,
            lineWidth: 1,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: (_ctx, options)=>options.lineWidth,
            tickColor: (_ctx, options)=>options.color,
            offset: false
        },
        border: {
            display: true,
            dash: [],
            dashOffset: 0.0,
            width: 1
        },
        title: {
            display: false,
            text: "",
            padding: {
                top: 4,
                bottom: 4
            }
        },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: false,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
        }
    });
    defaults.route("scale.ticks", "color", "", "color");
    defaults.route("scale.grid", "color", "", "borderColor");
    defaults.route("scale.border", "color", "", "borderColor");
    defaults.route("scale.title", "color", "", "color");
    defaults.describe("scale", {
        _fallback: false,
        _scriptable: (name)=>!name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
        _indexable: (name)=>name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
    });
    defaults.describe("scales", {
        _fallback: "scale"
    });
    defaults.describe("scale.ticks", {
        _scriptable: (name)=>name !== "backdropPadding" && name !== "callback",
        _indexable: (name)=>name !== "backdropPadding"
    });
}
const overrides = Object.create(null);
const descriptors = Object.create(null);
function getScope$1(node, key) {
    if (!key) return node;
    const keys = key.split(".");
    for(let i = 0, n = keys.length; i < n; ++i){
        const k = keys[i];
        node = node[k] || (node[k] = Object.create(null));
    }
    return node;
}
function set(root, scope, values) {
    if (typeof scope === "string") return merge(getScope$1(root, scope), values);
    return merge(getScope$1(root, ""), scope);
}
class Defaults {
    constructor(_descriptors, _appliers){
        this.animation = undefined;
        this.backgroundColor = "rgba(0,0,0,0.1)";
        this.borderColor = "rgba(0,0,0,0.1)";
        this.color = "#666";
        this.datasets = {};
        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();
        this.elements = {};
        this.events = [
            "mousemove",
            "mouseout",
            "click",
            "touchstart",
            "touchmove"
        ];
        this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: "normal",
            lineHeight: 1.2,
            weight: null
        };
        this.hover = {};
        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);
        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);
        this.hoverColor = (ctx, options)=>getHoverColor(options.color);
        this.indexAxis = "x";
        this.interaction = {
            mode: "nearest",
            intersect: true,
            includeInvisible: false
        };
        this.maintainAspectRatio = true;
        this.onHover = null;
        this.onClick = null;
        this.parsing = true;
        this.plugins = {};
        this.responsive = true;
        this.scale = undefined;
        this.scales = {};
        this.showLine = true;
        this.drawActiveElementsOnTop = true;
        this.describe(_descriptors);
        this.apply(_appliers);
    }
    set(scope, values) {
        return set(this, scope, values);
    }
    get(scope) {
        return getScope$1(this, scope);
    }
    describe(scope, values) {
        return set(descriptors, scope, values);
    }
    override(scope, values) {
        return set(overrides, scope, values);
    }
    route(scope, name, targetScope, targetName) {
        const scopeObject = getScope$1(this, scope);
        const targetScopeObject = getScope$1(this, targetScope);
        const privateName = "_" + name;
        Object.defineProperties(scopeObject, {
            [privateName]: {
                value: scopeObject[name],
                writable: true
            },
            [name]: {
                enumerable: true,
                get () {
                    const local = this[privateName];
                    const target = targetScopeObject[targetName];
                    if (isObject(local)) return Object.assign({}, target, local);
                    return valueOrDefault(local, target);
                },
                set (value) {
                    this[privateName] = value;
                }
            }
        });
    }
    apply(appliers) {
        appliers.forEach((apply)=>apply(this));
    }
}
var defaults = /* #__PURE__ */ new Defaults({
    _scriptable: (name)=>!name.startsWith("on"),
    _indexable: (name)=>name !== "events",
    hover: {
        _fallback: "interaction"
    },
    interaction: {
        _scriptable: false,
        _indexable: false
    }
}, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
]);
/**
 * Converts the given font object into a CSS font string.
 * @param font - A font object.
 * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
 * @private
 */ function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) return null;
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
/**
 * @private
 */ function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
        textWidth = data[string] = ctx.measureText(string).width;
        gc.push(string);
    }
    if (textWidth > longest) longest = textWidth;
    return longest;
}
/**
 * @private
 */ // eslint-disable-next-line complexity
function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = cache.data = cache.data || {};
    let gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
        data = cache.data = {};
        gc = cache.garbageCollect = [];
        cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i, j, jlen, thing, nestedThing;
    for(i = 0; i < ilen; i++){
        thing = arrayOfThings[i];
        // Undefined strings and arrays should not be measured
        if (thing !== undefined && thing !== null && !isArray(thing)) longest = _measureText(ctx, data, gc, longest, thing);
        else if (isArray(thing)) // if it is an array lets measure each element
        // to do maybe simplify this function a bit so we can do this more recursively?
        for(j = 0, jlen = thing.length; j < jlen; j++){
            nestedThing = thing[j];
            // Undefined strings and arrays should not be measured
            if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
        for(i = 0; i < gcLen; i++)delete data[gc[i]];
        gc.splice(0, gcLen);
    }
    return longest;
}
/**
 * Returns the aligned pixel value to avoid anti-aliasing blur
 * @param chart - The chart instance.
 * @param pixel - A pixel value.
 * @param width - The width of the element.
 * @returns The aligned pixel value.
 * @private
 */ function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
/**
 * Clears the entire canvas.
 */ function clearCanvas(canvas, ctx) {
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    // canvas.width and canvas.height do not consider the canvas transform,
    // while clearRect does
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
}
function drawPoint(ctx, options, x, y) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    drawPointLegend(ctx, options, x, y, null);
}
// eslint-disable-next-line complexity
function drawPointLegend(ctx, options, x, y, w) {
    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
        type = style.toString();
        if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rad);
            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
            ctx.restore();
            return;
        }
    }
    if (isNaN(radius) || radius <= 0) return;
    ctx.beginPath();
    switch(style){
        // Default includes circle
        default:
            if (w) ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
            else ctx.arc(x, y, radius, 0, TAU);
            ctx.closePath();
            break;
        case "triangle":
            width = w ? w / 2 : radius;
            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;
        case "rectRounded":
            // NOTE: the rounded rect implementation changed to use `arc` instead of
            // `quadraticCurveTo` since it generates better results when rect is
            // almost a circle. 0.516 (instead of 0.5) produces results with visually
            // closer proportion to the previous impl and it is inscribed in the
            // circle with `radius`. For more details, see the following PRs:
            // https://github.com/chartjs/Chart.js/issues/5597
            // https://github.com/chartjs/Chart.js/issues/5858
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;
        case "rect":
            if (!rotation) {
                size = Math.SQRT1_2 * radius;
                width = w ? w / 2 : size;
                ctx.rect(x - width, y - size, 2 * width, 2 * size);
                break;
            }
            rad += QUARTER_PI;
        /* falls through */ case "rectRot":
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            ctx.closePath();
            break;
        case "crossRot":
            rad += QUARTER_PI;
        /* falls through */ case "cross":
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            break;
        case "star":
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            rad += QUARTER_PI;
            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
            ctx.moveTo(x - xOffsetW, y - yOffset);
            ctx.lineTo(x + xOffsetW, y + yOffset);
            ctx.moveTo(x + yOffsetW, y - xOffset);
            ctx.lineTo(x - yOffsetW, y + xOffset);
            break;
        case "line":
            xOffset = w ? w / 2 : Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;
        case "dash":
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
            break;
        case false:
            ctx.closePath();
            break;
    }
    ctx.fill();
    if (options.borderWidth > 0) ctx.stroke();
}
/**
 * Returns true if the point is inside the rectangle
 * @param point - The point to test
 * @param area - The rectangle
 * @param margin - allowed margin
 * @private
 */ function _isPointInArea(point, area, margin) {
    margin = margin || 0.5; // margin - default is to match rounded decimals
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
}
function unclipArea(ctx) {
    ctx.restore();
}
/**
 * @private
 */ function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) return ctx.lineTo(target.x, target.y);
    if (mode === "middle") {
        const midpoint = (previous.x + target.x) / 2.0;
        ctx.lineTo(midpoint, previous.y);
        ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip) ctx.lineTo(previous.x, target.y);
    else ctx.lineTo(target.x, previous.y);
    ctx.lineTo(target.x, target.y);
}
/**
 * @private
 */ function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) return ctx.lineTo(target.x, target.y);
    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
    if (opts.translation) ctx.translate(opts.translation[0], opts.translation[1]);
    if (!isNullOrUndef(opts.rotation)) ctx.rotate(opts.rotation);
    if (opts.color) ctx.fillStyle = opts.color;
    if (opts.textAlign) ctx.textAlign = opts.textAlign;
    if (opts.textBaseline) ctx.textBaseline = opts.textBaseline;
}
function decorateText(ctx, x, y, line, opts) {
    if (opts.strikethrough || opts.underline) {
        /**
     * Now that IE11 support has been dropped, we can use more
     * of the TextMetrics object. The actual bounding boxes
     * are unflagged in Chrome, Firefox, Edge, and Safari so they
     * can be safely used.
     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility
     */ const metrics = ctx.measureText(line);
        const left = x - metrics.actualBoundingBoxLeft;
        const right = x + metrics.actualBoundingBoxRight;
        const top = y - metrics.actualBoundingBoxAscent;
        const bottom = y + metrics.actualBoundingBoxDescent;
        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
        ctx.strokeStyle = ctx.fillStyle;
        ctx.beginPath();
        ctx.lineWidth = opts.decorationWidth || 2;
        ctx.moveTo(left, yDecoration);
        ctx.lineTo(right, yDecoration);
        ctx.stroke();
    }
}
function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
}
/**
 * Render text onto the canvas
 */ function renderText(ctx, text, x, y, font, opts = {}) {
    const lines = isArray(text) ? text : [
        text
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for(i = 0; i < lines.length; ++i){
        line = lines[i];
        if (opts.backdrop) drawBackdrop(ctx, opts.backdrop);
        if (stroke) {
            if (opts.strokeColor) ctx.strokeStyle = opts.strokeColor;
            if (!isNullOrUndef(opts.strokeWidth)) ctx.lineWidth = opts.strokeWidth;
            ctx.strokeText(line, x, y, opts.maxWidth);
        }
        ctx.fillText(line, x, y, opts.maxWidth);
        decorateText(ctx, x, y, line, opts);
        y += Number(font.lineHeight);
    }
    ctx.restore();
}
/**
 * Add a path of a rectangle with rounded corners to the current sub-path
 * @param ctx - Context
 * @param rect - Bounding rect
 */ function addRoundedRectPath(ctx, rect) {
    const { x, y, w, h, radius } = rect;
    // top left arc
    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
    // line from top left to bottom left
    ctx.lineTo(x, y + h - radius.bottomLeft);
    // bottom left arc
    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    // line from bottom left to bottom right
    ctx.lineTo(x + w - radius.bottomRight, y + h);
    // bottom right arc
    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    // line from bottom right to top right
    ctx.lineTo(x + w, y + radius.topRight);
    // top right arc
    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    // line from top right to top left
    ctx.lineTo(x + radius.topLeft, y);
}
const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
/**
 * @alias Chart.helpers.options
 * @namespace
 */ /**
 * Converts the given line height `value` in pixels for a specific font `size`.
 * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
 * @param size - The font size (in pixels) used to resolve relative `value`.
 * @returns The effective line height in pixels (size * 1.2 if value is invalid).
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
 * @since 2.7.0
 */ function toLineHeight(value, size) {
    const matches = ("" + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === "normal") return size * 1.2;
    value = +matches[2];
    switch(matches[3]){
        case "px":
            return value;
        case "%":
            value /= 100;
            break;
    }
    return size * value;
}
const numberOrZero = (v)=>+v || 0;
function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;
    for (const prop of keys)ret[prop] = numberOrZero(read(prop));
    return ret;
}
/**
 * Converts the given value into a TRBL object.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left)
 * @since 3.0.0
 */ function toTRBL(value) {
    return _readValueToProps(value, {
        top: "y",
        right: "x",
        bottom: "y",
        left: "x"
    });
}
/**
 * Converts the given value into a TRBL corners object (similar with css border-radius).
 * @param value - If a number, set the value to all TRBL corner components,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)
 * @since 3.0.0
 */ function toTRBLCorners(value) {
    return _readValueToProps(value, [
        "topLeft",
        "topRight",
        "bottomLeft",
        "bottomRight"
    ]);
}
/**
 * Converts the given value into a padding object with pre-computed width/height.
 * @param value - If a number, set the value to all TRBL component,
 *  else, if an object, use defined properties and sets undefined ones to 0.
 *  x / y are shorthands for same value for left/right and top/bottom.
 * @returns The padding values (top, right, bottom, left, width, height)
 * @since 2.7.0
 */ function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
}
/**
 * Parses font options and returns the font object.
 * @param options - A object that contains font options to be parsed.
 * @param fallback - A object that contains fallback font options.
 * @return The font object.
 * @private
 */ function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === "string") size = parseInt(size, 10);
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
        console.warn('Invalid font style specified: "' + style + '"');
        style = undefined;
    }
    const font = {
        family: valueOrDefault(options.family, fallback.family),
        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
        size,
        style,
        weight: valueOrDefault(options.weight, fallback.weight),
        string: ""
    };
    font.string = toFontString(font);
    return font;
}
/**
 * Evaluates the given `inputs` sequentially and returns the first defined value.
 * @param inputs - An array of values, falling back to the last value.
 * @param context - If defined and the current value is a function, the value
 * is called with `context` as first argument and the result becomes the new input.
 * @param index - If defined and the current value is an array, the value
 * at `index` become the new input.
 * @param info - object to return information about resolution in
 * @param info.cacheable - Will be set to `false` if option is not cacheable.
 * @since 2.7.0
 */ function resolve(inputs, context, index, info) {
    let cacheable = true;
    let i, ilen, value;
    for(i = 0, ilen = inputs.length; i < ilen; ++i){
        value = inputs[i];
        if (value === undefined) continue;
        if (context !== undefined && typeof value === "function") {
            value = value(context);
            cacheable = false;
        }
        if (index !== undefined && isArray(value)) {
            value = value[index % value.length];
            cacheable = false;
        }
        if (value !== undefined) {
            if (info && !cacheable) info.cacheable = false;
            return value;
        }
    }
}
/**
 * @param minmax
 * @param grace
 * @param beginAtZero
 * @private
 */ function _addGrace(minmax, grace, beginAtZero) {
    const { min, max } = minmax;
    const change = toDimension(grace, (max - min) / 2);
    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;
    return {
        min: keepZero(min, -Math.abs(change)),
        max: keepZero(max, change)
    };
}
function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
}
/**
 * Creates a Proxy for resolving raw values for options.
 * @param scopes - The option scopes to look for values, in resolution order
 * @param prefixes - The prefixes for values, in resolution order.
 * @param rootScopes - The root option scopes
 * @param fallback - Parent scopes fallback
 * @param getTarget - callback for getting the target for changed values
 * @returns Proxy
 * @private
 */ function _createResolver(scopes, prefixes = [
    ""
], rootScopes, fallback, getTarget = ()=>scopes[0]) {
    const finalRootScopes = rootScopes || scopes;
    if (typeof fallback === "undefined") fallback = _resolve("_fallback", scopes);
    const cache = {
        [Symbol.toStringTag]: "Object",
        _cacheable: true,
        _scopes: scopes,
        _rootScopes: finalRootScopes,
        _fallback: fallback,
        _getTarget: getTarget,
        override: (scope)=>_createResolver([
                scope,
                ...scopes
            ], prefixes, finalRootScopes, fallback)
    };
    return new Proxy(cache, {
        /**
     * A trap for the delete operator.
     */ deleteProperty (target, prop) {
            delete target[prop]; // remove from cache
            delete target._keys; // remove cached keys
            delete scopes[0][prop]; // remove from top level scope
            return true;
        },
        /**
     * A trap for getting property values.
     */ get (target, prop) {
            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));
        },
        /**
     * A trap for Object.getOwnPropertyDescriptor.
     * Also used by Object.hasOwnProperty.
     */ getOwnPropertyDescriptor (target, prop) {
            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
        },
        /**
     * A trap for Object.getPrototypeOf.
     */ getPrototypeOf () {
            return Reflect.getPrototypeOf(scopes[0]);
        },
        /**
     * A trap for the in operator.
     */ has (target, prop) {
            return getKeysFromAllScopes(target).includes(prop);
        },
        /**
     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
     */ ownKeys (target) {
            return getKeysFromAllScopes(target);
        },
        /**
     * A trap for setting property values.
     */ set (target, prop, value) {
            const storage = target._storage || (target._storage = getTarget());
            target[prop] = storage[prop] = value; // set to top level scope + cache
            delete target._keys; // remove cached keys
            return true;
        }
    });
}
/**
 * Returns an Proxy for resolving option values with context.
 * @param proxy - The Proxy returned by `_createResolver`
 * @param context - Context object for scriptable/indexable options
 * @param subProxy - The proxy provided for scriptable options
 * @param descriptorDefaults - Defaults for descriptors
 * @private
 */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
        _cacheable: false,
        _proxy: proxy,
        _context: context,
        _subProxy: subProxy,
        _stack: new Set(),
        _descriptors: _descriptors(proxy, descriptorDefaults),
        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),
        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
        /**
     * A trap for the delete operator.
     */ deleteProperty (target, prop) {
            delete target[prop]; // remove from cache
            delete proxy[prop]; // remove from proxy
            return true;
        },
        /**
     * A trap for getting property values.
     */ get (target, prop, receiver) {
            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));
        },
        /**
     * A trap for Object.getOwnPropertyDescriptor.
     * Also used by Object.hasOwnProperty.
     */ getOwnPropertyDescriptor (target, prop) {
            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
                enumerable: true,
                configurable: true
            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);
        },
        /**
     * A trap for Object.getPrototypeOf.
     */ getPrototypeOf () {
            return Reflect.getPrototypeOf(proxy);
        },
        /**
     * A trap for the in operator.
     */ has (target, prop) {
            return Reflect.has(proxy, prop);
        },
        /**
     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
     */ ownKeys () {
            return Reflect.ownKeys(proxy);
        },
        /**
     * A trap for setting property values.
     */ set (target, prop, value) {
            proxy[prop] = value; // set to proxy
            delete target[prop]; // remove from cache
            return true;
        }
    });
}
/**
 * @private
 */ function _descriptors(proxy, defaults = {
    scriptable: true,
    indexable: true
}) {
    const { _scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys } = proxy;
    return {
        allKeys: _allKeys,
        scriptable: _scriptable,
        indexable: _indexable,
        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,
        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable
    };
}
const readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value)=>isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve) {
    if (Object.prototype.hasOwnProperty.call(target, prop)) return target[prop];
    const value = resolve();
    // cache the resolved value
    target[prop] = value;
    return value;
}
function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;
    let value = _proxy[prop]; // resolve from proxy
    // resolve with context
    if (isFunction(value) && descriptors.isScriptable(prop)) value = _resolveScriptable(prop, value, target, receiver);
    if (isArray(value) && value.length) value = _resolveArray(prop, value, target, descriptors.isIndexable);
    if (needsSubResolver(prop, value)) // if the resolved value is an object, create a sub resolver for it
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
    return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    _stack.add(prop);
    let value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) // When scriptable option returns an object, create a resolver on that.
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    return value;
}
function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;
    if (typeof _context.index !== "undefined" && isIndexable(prop)) return value[_context.index % value.length];
    else if (isObject(value[0])) {
        // Array of objects, return array or resolvers
        const arr = value;
        const scopes = _proxy._scopes.filter((s)=>s !== arr);
        value = [];
        for (const item of arr){
            const resolver = createSubResolver(scopes, _proxy, prop, item);
            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
        }
    }
    return value;
}
function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent)=>key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : undefined;
function addScopes(set, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes){
        const scope = getScope(key, parent);
        if (scope) {
            set.add(scope);
            const fallback = resolveFallback(scope._fallback, key, value);
            if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) // When we reach the descriptor that defines a new _fallback, return that.
            // The fallback will resume to that new scope.
            return fallback;
        } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) // Fallback to `false` results to `false`, when falling back to different key.
        // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`
        return null;
    }
    return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
        ...parentScopes,
        ...rootScopes
    ];
    const set = new Set();
    set.add(value);
    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
    if (key === null) return false;
    if (typeof fallback !== "undefined" && fallback !== prop) {
        key = addScopesFromKey(set, allScopes, fallback, key, value);
        if (key === null) return false;
    }
    return _createResolver(Array.from(set), [
        ""
    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set, allScopes, key, fallback, item) {
    while(key)key = addScopes(set, allScopes, key, fallback, item);
    return key;
}
function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) parent[prop] = {};
    const target = parent[prop];
    if (isArray(target) && isObject(value)) // For array of objects, the object is used to store updated values
    return value;
    return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes){
        value = _resolve(readKey(prefix, prop), scopes);
        if (typeof value !== "undefined") return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
}
function _resolve(key, scopes) {
    for (const scope of scopes){
        if (!scope) continue;
        const value = scope[key];
        if (typeof value !== "undefined") return value;
    }
}
function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    return keys;
}
function resolveKeysFromAllScopes(scopes) {
    const set = new Set();
    for (const scope of scopes)for (const key of Object.keys(scope).filter((k)=>!k.startsWith("_")))set.add(key);
    return Array.from(set);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
    const { iScale } = meta;
    const { key = "r" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for(i = 0, ilen = count; i < ilen; ++i){
        index = i + start;
        item = data[index];
        parsed[i] = {
            r: iScale.parse(resolveObjectKey(item, key), index)
        };
    }
    return parsed;
}
const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];
const getValueAxis = (indexAxis)=>indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
    // Props to Rob Spencer at scaled innovation for his post on splining between points
    // http://scaledinnovation.com/analytics/splines/aboutSplines.html
    // This function must also respect "skipped" points
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    // If all points are the same, s01 & s02 will be inf
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t * s01; // scaling factor for triangle Ta
    const fb = t * s12;
    return {
        previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
        },
        next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
        }
    };
}
/**
 * Adjust tangents to ensure monotonic properties
 */ function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(let i = 0; i < pointsLen - 1; ++i){
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent || !pointAfter) continue;
        if (almostEquals(deltaK[i], 0, EPSILON)) {
            mK[i] = mK[i + 1] = 0;
            continue;
        }
        alphaK = mK[i] / deltaK[i];
        betaK = mK[i + 1] / deltaK[i];
        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
        if (squaredMagnitude <= 9) continue;
        tauK = 3 / Math.sqrt(squaredMagnitude);
        mK[i] = alphaK * tauK * deltaK[i];
        mK[i + 1] = betaK * tauK * deltaK[i];
    }
}
function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(let i = 0; i < pointsLen; ++i){
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) continue;
        const iPixel = pointCurrent[indexAxis];
        const vPixel = pointCurrent[valueAxis];
        if (pointBefore) {
            delta = (iPixel - pointBefore[indexAxis]) / 3;
            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
        }
        if (pointAfter) {
            delta = (pointAfter[indexAxis] - iPixel) / 3;
            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
        }
    }
}
/**
 * This function calculates Bézier control points in a similar way than |splineCurve|,
 * but preserves monotonicity of the provided data and ensures no local extremums are added
 * between the dataset discrete points due to the interpolation.
 * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
 */ function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    // Calculate slopes (deltaK) and initialize tangents (mK)
    let i, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for(i = 0; i < pointsLen; ++i){
        pointBefore = pointCurrent;
        pointCurrent = pointAfter;
        pointAfter = getPoint(points, i + 1);
        if (!pointCurrent) continue;
        if (pointAfter) {
            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0
            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
        }
        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
    return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
    let i, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for(i = 0, ilen = points.length; i < ilen; ++i){
        inAreaPrev = inArea;
        inArea = inAreaNext;
        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
        if (!inArea) continue;
        point = points[i];
        if (inAreaPrev) {
            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
        }
        if (inAreaNext) {
            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
        }
    }
}
/**
 * @private
 */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i, ilen, point, controlPoints;
    // Only consider points that are drawn in case the spanGaps option is used
    if (options.spanGaps) points = points.filter((pt)=>!pt.skip);
    if (options.cubicInterpolationMode === "monotone") splineCurveMonotone(points, indexAxis);
    else {
        let prev = loop ? points[points.length - 1] : points[0];
        for(i = 0, ilen = points.length; i < ilen; ++i){
            point = points[i];
            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
            point.cp1x = controlPoints.previous.x;
            point.cp1y = controlPoints.previous.y;
            point.cp2x = controlPoints.next.x;
            point.cp2y = controlPoints.next.y;
            prev = point;
        }
    }
    if (options.capBezierPoints) capBezierPoints(points, area);
}
/**
 * Note: typedefs are auto-exported, so use a made-up `dom` namespace where
 * necessary to avoid duplicates with `export * from './helpers`; see
 * https://github.com/microsoft/TypeScript/issues/46011
 * @typedef { import('../core/core.controller.js').default } dom.Chart
 * @typedef { import('../../types').ChartEvent } ChartEvent
 */ /**
 * @private
 */ function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
}
/**
 * @private
 */ function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") parent = parent.host;
    return parent;
}
/**
 * convert max-width/max-height values that may be percentages into a number
 * @private
 */ function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
        valueInPixels = parseInt(styleValue, 10);
        if (styleValue.indexOf("%") !== -1) // percentage * size in dimension
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    } else valueInPixels = styleValue;
    return valueInPixels;
}
const getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
    return getComputedStyle(el).getPropertyValue(property);
}
const positions = [
    "top",
    "right",
    "bottom",
    "left"
];
function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for(let i = 0; i < 4; i++){
        const pos = positions[i];
        result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
}
const useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);
/**
 * @param e
 * @param canvas
 * @returns Canvas position
 */ function getCanvasPosition(e, canvas) {
    const touches = e.touches;
    const source = touches && touches.length ? touches[0] : e;
    const { offsetX, offsetY } = source;
    let box = false;
    let x, y;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
        x = offsetX;
        y = offsetY;
    } else {
        const rect = canvas.getBoundingClientRect();
        x = source.clientX - rect.left;
        y = source.clientY - rect.top;
        box = true;
    }
    return {
        x,
        y,
        box
    };
}
/**
 * Gets an event's x, y coordinates, relative to the chart area
 * @param event
 * @param chart
 * @returns x and y coordinates of the event
 */ function getRelativePosition(event, chart) {
    if ("native" in event) return event;
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x, y, box } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    return {
        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
}
function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === undefined || height === undefined) {
        const container = _getParentNode(canvas);
        if (!container) {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
        } else {
            const rect = container.getBoundingClientRect(); // this is the border box of the container
            const containerStyle = getComputedStyle(container);
            const containerBorder = getPositionedStyle(containerStyle, "border", "width");
            const containerPadding = getPositionedStyle(containerStyle, "padding");
            width = rect.width - containerPadding.width - containerBorder.width;
            height = rect.height - containerPadding.height - containerBorder.height;
            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
        }
    }
    return {
        width,
        height,
        maxWidth: maxWidth || INFINITY,
        maxHeight: maxHeight || INFINITY
    };
}
const round1 = (v)=>Math.round(v * 10) / 10;
// eslint-disable-next-line complexity
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
        const borders = getPositionedStyle(style, "border", "width");
        const paddings = getPositionedStyle(style, "padding");
        width -= paddings.width + borders.width;
        height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) // https://github.com/chartjs/Chart.js/issues/4659
    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)
    height = round1(width / 2);
    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
        height = containerSize.height;
        width = round1(Math.floor(height * aspectRatio));
    }
    return {
        width,
        height
    };
}
/**
 * @param chart
 * @param forceRatio
 * @param forceStyle
 * @returns True if the canvas context size or transformation has changed.
 */ function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = Math.floor(chart.height);
    chart.width = Math.floor(chart.width);
    const canvas = chart.canvas;
    // If no style has been set on the canvas, the render size is used as display size,
    // making the chart visually bigger, so let's enforce it to the "correct" values.
    // See https://github.com/chartjs/Chart.js/issues/3575
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
        canvas.style.height = `${chart.height}px`;
        canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
        chart.currentDevicePixelRatio = pixelRatio;
        canvas.height = deviceHeight;
        canvas.width = deviceWidth;
        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        return true;
    }
    return false;
}
/**
 * Detects support for options object argument in addEventListener.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
 * @private
 */ const supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
        const options = {
            get passive () {
                passiveSupported = true;
                return false;
            }
        };
        if (_isDomSupported()) {
            window.addEventListener("test", null, options);
            window.removeEventListener("test", null, options);
        }
    } catch (e) {
    // continue regardless of error
    }
    return passiveSupported;
}();
/**
 * The "used" size is the final value of a dimension property after all calculations have
 * been performed. This method uses the computed style of `element` but returns undefined
 * if the computed style is not expressed in pixels. That can happen in some cases where
 * `element` has a size relative to its parent and this last one is not yet displayed,
 * for example because of `display: none` on a parent node.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 * @returns Size in pixels or undefined if unknown.
 */ function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : undefined;
}
/**
 * @private
 */ function _pointInLine(p1, p2, t, mode) {
    return {
        x: p1.x + t * (p2.x - p1.x),
        y: p1.y + t * (p2.y - p1.y)
    };
}
/**
 * @private
 */ function _steppedInterpolation(p1, p2, t, mode) {
    return {
        x: p1.x + t * (p2.x - p1.x),
        y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
    };
}
/**
 * @private
 */ function _bezierInterpolation(p1, p2, t, mode) {
    const cp1 = {
        x: p1.cp2x,
        y: p1.cp2y
    };
    const cp2 = {
        x: p2.cp1x,
        y: p2.cp1y
    };
    const a = _pointInLine(p1, cp1, t);
    const b = _pointInLine(cp1, cp2, t);
    const c = _pointInLine(cp2, p2, t);
    const d = _pointInLine(a, b, t);
    const e = _pointInLine(b, c, t);
    return _pointInLine(d, e, t);
}
const getRightToLeftAdapter = function(rectX, width) {
    return {
        x (x) {
            return rectX + rectX + width - x;
        },
        setWidth (w) {
            width = w;
        },
        textAlign (align) {
            if (align === "center") return align;
            return align === "right" ? "left" : "right";
        },
        xPlus (x, value) {
            return x - value;
        },
        leftForLtr (x, itemWidth) {
            return x - itemWidth;
        }
    };
};
const getLeftToRightAdapter = function() {
    return {
        x (x) {
            return x;
        },
        setWidth (w) {},
        textAlign (align) {
            return align;
        },
        xPlus (x, value) {
            return x + value;
        },
        leftForLtr (x, _itemWidth) {
            return x;
        }
    };
};
function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === "ltr" || direction === "rtl") {
        style = ctx.canvas.style;
        original = [
            style.getPropertyValue("direction"),
            style.getPropertyPriority("direction")
        ];
        style.setProperty("direction", direction, "important");
        ctx.prevTextDirection = original;
    }
}
function restoreTextDirection(ctx, original) {
    if (original !== undefined) {
        delete ctx.prevTextDirection;
        ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
}
function propertyFn(property) {
    if (property === "angle") return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
    };
    return {
        between: _isBetween,
        compare: (a, b)=>a - b,
        normalize: (x)=>x
    };
}
function normalizeSegment({ start, end, count, loop, style }) {
    return {
        start: start % count,
        end: end % count,
        loop: loop && (end - start + 1) % count === 0,
        style
    };
}
function getSegment(segment, points, bounds) {
    const { property, start: startBound, end: endBound } = bounds;
    const { between, normalize } = propertyFn(property);
    const count = points.length;
    let { start, end, loop } = segment;
    let i, ilen;
    if (loop) {
        start += count;
        end += count;
        for(i = 0, ilen = count; i < ilen; ++i){
            if (!between(normalize(points[start % count][property]), startBound, endBound)) break;
            start--;
            end--;
        }
        start %= count;
        end %= count;
    }
    if (end < start) end += count;
    return {
        start,
        end,
        loop,
        style: segment.style
    };
}
function _boundSegment(segment, points, bounds) {
    if (!bounds) return [
        segment
    ];
    const { property, start: startBound, end: endBound } = bounds;
    const count = points.length;
    const { compare, between, normalize } = propertyFn(property);
    const { start, end, loop, style } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = ()=>inside || startIsBefore();
    const shouldStop = ()=>!inside || endIsBefore();
    for(let i = start, prev = start; i <= end; ++i){
        point = points[i % count];
        if (point.skip) continue;
        value = normalize(point[property]);
        if (value === prevValue) continue;
        inside = between(value, startBound, endBound);
        if (subStart === null && shouldStart()) subStart = compare(value, startBound) === 0 ? i : prev;
        if (subStart !== null && shouldStop()) {
            result.push(normalizeSegment({
                start: subStart,
                end: i,
                loop,
                count,
                style
            }));
            subStart = null;
        }
        prev = i;
        prevValue = value;
    }
    if (subStart !== null) result.push(normalizeSegment({
        start: subStart,
        end,
        loop,
        count,
        style
    }));
    return result;
}
function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for(let i = 0; i < segments.length; i++){
        const sub = _boundSegment(segments[i], line.points, bounds);
        if (sub.length) result.push(...sub);
    }
    return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
    let start = 0;
    let end = count - 1;
    if (loop && !spanGaps) while(start < count && !points[start].skip)start++;
    while(start < count && points[start].skip)start++;
    start %= count;
    if (loop) end += start;
    while(end > start && points[end % count].skip)end--;
    end %= count;
    return {
        start,
        end
    };
}
function solidSegments(points, start, max, loop) {
    const count = points.length;
    const result = [];
    let last = start;
    let prev = points[start];
    let end;
    for(end = start + 1; end <= max; ++end){
        const cur = points[end % count];
        if (cur.skip || cur.stop) {
            if (!prev.skip) {
                loop = false;
                result.push({
                    start: start % count,
                    end: (end - 1) % count,
                    loop
                });
                start = last = cur.stop ? end : null;
            }
        } else {
            last = end;
            if (prev.skip) start = end;
        }
        prev = cur;
    }
    if (last !== null) result.push({
        start: start % count,
        end: last % count,
        loop
    });
    return result;
}
function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) return [];
    const loop = !!line._loop;
    const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) return splitByStyles(line, [
        {
            start,
            end,
            loop
        }
    ], points, segmentOptions);
    const max = end < start ? end + count : end;
    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) return segments;
    return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start = segments[0].start;
    let i = start;
    function addStyle(s, e, l, st) {
        const dir = spanGaps ? -1 : 1;
        if (s === e) return;
        s += count;
        while(points[s % count].skip)s -= dir;
        while(points[e % count].skip)e += dir;
        if (s % count !== e % count) {
            result.push({
                start: s % count,
                end: e % count,
                loop: l,
                style: st
            });
            prevStyle = st;
            start = e % count;
        }
    }
    for (const segment of segments){
        start = spanGaps ? start : segment.start;
        let prev = points[start % count];
        let style;
        for(i = start + 1; i <= segment.end; i++){
            const pt = points[i % count];
            style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                type: "segment",
                p0: prev,
                p1: pt,
                p0DataIndex: (i - 1) % count,
                p1DataIndex: i % count,
                datasetIndex
            })));
            if (styleChanged(style, prevStyle)) addStyle(start, i - 1, segment.loop, prevStyle);
            prev = pt;
            prevStyle = style;
        }
        if (start < i - 1) addStyle(start, i - 1, segment.loop, prevStyle);
    }
    return result;
}
function readStyle(options) {
    return {
        backgroundColor: options.backgroundColor,
        borderCapStyle: options.borderCapStyle,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderJoinStyle: options.borderJoinStyle,
        borderWidth: options.borderWidth,
        borderColor: options.borderColor
    };
}
function styleChanged(style, prevStyle) {
    if (!prevStyle) return false;
    const cache = [];
    const replacer = function(key, value) {
        if (!isPatternOrGradient(value)) return value;
        if (!cache.includes(value)) cache.push(value);
        return cache.indexOf(value);
    };
    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}

},{"@kurkle/color":"2aojw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2aojw":[function(require,module,exports) {
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Color", ()=>Color);
parcelHelpers.export(exports, "b2n", ()=>b2n);
parcelHelpers.export(exports, "b2p", ()=>b2p);
parcelHelpers.export(exports, "default", ()=>index_esm);
parcelHelpers.export(exports, "hexParse", ()=>hexParse);
parcelHelpers.export(exports, "hexString", ()=>hexString);
parcelHelpers.export(exports, "hsl2rgb", ()=>hsl2rgb);
parcelHelpers.export(exports, "hslString", ()=>hslString);
parcelHelpers.export(exports, "hsv2rgb", ()=>hsv2rgb);
parcelHelpers.export(exports, "hueParse", ()=>hueParse);
parcelHelpers.export(exports, "hwb2rgb", ()=>hwb2rgb);
parcelHelpers.export(exports, "lim", ()=>lim);
parcelHelpers.export(exports, "n2b", ()=>n2b);
parcelHelpers.export(exports, "n2p", ()=>n2p);
parcelHelpers.export(exports, "nameParse", ()=>nameParse);
parcelHelpers.export(exports, "p2b", ()=>p2b);
parcelHelpers.export(exports, "rgb2hsl", ()=>rgb2hsl);
parcelHelpers.export(exports, "rgbParse", ()=>rgbParse);
parcelHelpers.export(exports, "rgbString", ()=>rgbString);
parcelHelpers.export(exports, "rotate", ()=>rotate);
parcelHelpers.export(exports, "round", ()=>round);
function round(v) {
    return v + 0.5 | 0;
}
const lim = (v, l, h)=>Math.max(Math.min(v, h), l);
function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
}
function b2p(v) {
    return lim(round(v / 2.55), 0, 100);
}
function n2b(v) {
    return lim(round(v * 255), 0, 255);
}
function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
    return lim(round(v * 100), 0, 100);
}
const map$1 = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
};
const hex = [
    ..."0123456789ABCDEF"
];
const h1 = (b)=>hex[b & 0xF];
const h2 = (b)=>hex[(b & 0xF0) >> 4] + hex[b & 0xF];
const eq = (b)=>(b & 0xF0) >> 4 === (b & 0xF);
const isShort = (v)=>eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
        if (len === 4 || len === 5) ret = {
            r: 255 & map$1[str[1]] * 17,
            g: 255 & map$1[str[2]] * 17,
            b: 255 & map$1[str[3]] * 17,
            a: len === 5 ? map$1[str[4]] * 17 : 255
        };
        else if (len === 7 || len === 9) ret = {
            r: map$1[str[1]] << 4 | map$1[str[2]],
            g: map$1[str[3]] << 4 | map$1[str[4]],
            b: map$1[str[5]] << 4 | map$1[str[6]],
            a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
    }
    return ret;
}
const alpha = (a, f)=>a < 255 ? f(a) : "";
function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : undefined;
}
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
    const a = s * Math.min(l, 1 - l);
    const f = (n, k = (n + h / 30) % 12)=>l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [
        f(0),
        f(8),
        f(4)
    ];
}
function hsv2rgbn(h, s, v) {
    const f = (n, k = (n + h / 60) % 6)=>v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    return [
        f(5),
        f(3),
        f(1)
    ];
}
function hwb2rgbn(h, w, b) {
    const rgb = hsl2rgbn(h, 1, 0.5);
    let i;
    if (w + b > 1) {
        i = 1 / (w + b);
        w *= i;
        b *= i;
    }
    for(i = 0; i < 3; i++){
        rgb[i] *= 1 - w - b;
        rgb[i] += w;
    }
    return rgb;
}
function hueValue(r, g, b, d, max) {
    if (r === max) return (g - b) / d + (g < b ? 6 : 0);
    if (g === max) return (b - r) / d + 2;
    return (r - g) / d + 4;
}
function rgb2hsl(v) {
    const range = 255;
    const r = v.r / range;
    const g = v.g / range;
    const b = v.b / range;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;
    let h, s, d;
    if (max !== min) {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = hueValue(r, g, b, d, max);
        h = h * 60 + 0.5;
    }
    return [
        h | 0,
        s || 0,
        l
    ];
}
function calln(f, a, b, c) {
    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l) {
    return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
    return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
    return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
    return (h % 360 + 360) % 360;
}
function hueParse(str) {
    const m = HUE_RE.exec(str);
    let a = 255;
    let v;
    if (!m) return;
    if (m[5] !== v) a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
    const h = hue(+m[2]);
    const p1 = +m[3] / 100;
    const p2 = +m[4] / 100;
    if (m[1] === "hwb") v = hwb2rgb(h, p1, p2);
    else if (m[1] === "hsv") v = hsv2rgb(h, p1, p2);
    else v = hsl2rgb(h, p1, p2);
    return {
        r: v[0],
        g: v[1],
        b: v[2],
        a: a
    };
}
function rotate(v, deg) {
    var h = rgb2hsl(v);
    h[0] = hue(h[0] + deg);
    h = hsl2rgb(h);
    v.r = h[0];
    v.g = h[1];
    v.b = h[2];
}
function hslString(v) {
    if (!v) return;
    const a = rgb2hsl(v);
    const h = a[0];
    const s = n2p(a[1]);
    const l = n2p(a[2]);
    return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}
const map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
};
const names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
};
function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i, j, k, ok, nk;
    for(i = 0; i < keys.length; i++){
        ok = nk = keys[i];
        for(j = 0; j < tkeys.length; j++){
            k = tkeys[j];
            nk = nk.replace(k, map[k]);
        }
        k = parseInt(names$1[ok], 16);
        unpacked[nk] = [
            k >> 16 & 0xFF,
            k >> 8 & 0xFF,
            k & 0xFF
        ];
    }
    return unpacked;
}
let names;
function nameParse(str) {
    if (!names) {
        names = unpack();
        names.transparent = [
            0,
            0,
            0,
            0
        ];
    }
    const a = names[str.toLowerCase()];
    return a && {
        r: a[0],
        g: a[1],
        b: a[2],
        a: a.length === 4 ? a[3] : 255
    };
}
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
    const m = RGB_RE.exec(str);
    let a = 255;
    let r, g, b;
    if (!m) return;
    if (m[7] !== r) {
        const v = +m[7];
        a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
    }
    r = +m[1];
    g = +m[3];
    b = +m[5];
    r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
    g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
    return {
        r: r,
        g: g,
        b: b,
        a: a
    };
}
function rgbString(v) {
    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
const to = (v)=>v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;
const from = (v)=>v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
    const r = from(b2n(rgb1.r));
    const g = from(b2n(rgb1.g));
    const b = from(b2n(rgb1.b));
    return {
        r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
        g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
        b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
        a: rgb1.a + t * (rgb2.a - rgb1.a)
    };
}
function modHSL(v, i, ratio) {
    if (v) {
        let tmp = rgb2hsl(v);
        tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
        tmp = hsl2rgb(tmp);
        v.r = tmp[0];
        v.g = tmp[1];
        v.b = tmp[2];
    }
}
function clone(v, proto) {
    return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
    var v = {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    if (Array.isArray(input)) {
        if (input.length >= 3) {
            v = {
                r: input[0],
                g: input[1],
                b: input[2],
                a: 255
            };
            if (input.length > 3) v.a = n2b(input[3]);
        }
    } else {
        v = clone(input, {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        });
        v.a = n2b(v.a);
    }
    return v;
}
function functionParse(str) {
    if (str.charAt(0) === "r") return rgbParse(str);
    return hueParse(str);
}
class Color {
    constructor(input){
        if (input instanceof Color) return input;
        const type = typeof input;
        let v;
        if (type === "object") v = fromObject(input);
        else if (type === "string") v = hexParse(input) || nameParse(input) || functionParse(input);
        this._rgb = v;
        this._valid = !!v;
    }
    get valid() {
        return this._valid;
    }
    get rgb() {
        var v = clone(this._rgb);
        if (v) v.a = b2n(v.a);
        return v;
    }
    set rgb(obj) {
        this._rgb = fromObject(obj);
    }
    rgbString() {
        return this._valid ? rgbString(this._rgb) : undefined;
    }
    hexString() {
        return this._valid ? hexString(this._rgb) : undefined;
    }
    hslString() {
        return this._valid ? hslString(this._rgb) : undefined;
    }
    mix(color, weight) {
        if (color) {
            const c1 = this.rgb;
            const c2 = color.rgb;
            let w2;
            const p = weight === w2 ? 0.5 : weight;
            const w = 2 * p - 1;
            const a = c1.a - c2.a;
            const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
            w2 = 1 - w1;
            c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
            c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
            c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
            c1.a = p * c1.a + (1 - p) * c2.a;
            this.rgb = c1;
        }
        return this;
    }
    interpolate(color, t) {
        if (color) this._rgb = interpolate(this._rgb, color._rgb, t);
        return this;
    }
    clone() {
        return new Color(this.rgb);
    }
    alpha(a) {
        this._rgb.a = n2b(a);
        return this;
    }
    clearer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 - ratio;
        return this;
    }
    greyscale() {
        const rgb = this._rgb;
        const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
        rgb.r = rgb.g = rgb.b = val;
        return this;
    }
    opaquer(ratio) {
        const rgb = this._rgb;
        rgb.a *= 1 + ratio;
        return this;
    }
    negate() {
        const v = this._rgb;
        v.r = 255 - v.r;
        v.g = 255 - v.g;
        v.b = 255 - v.b;
        return this;
    }
    lighten(ratio) {
        modHSL(this._rgb, 2, ratio);
        return this;
    }
    darken(ratio) {
        modHSL(this._rgb, 2, -ratio);
        return this;
    }
    saturate(ratio) {
        modHSL(this._rgb, 1, ratio);
        return this;
    }
    desaturate(ratio) {
        modHSL(this._rgb, 1, -ratio);
        return this;
    }
    rotate(deg) {
        rotate(this._rgb, deg);
        return this;
    }
}
function index_esm(input) {
    return new Color(input);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dU215":[function(require,module,exports) {
"use strict";
var _index = require("bb476f479aec785f");
Object.keys(_index).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index[key];
        }
    });
});
var _index2 = require("f3c55fba68737491");
Object.keys(_index2).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index2[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index2[key];
        }
    });
});
var _index3 = require("4e06aa5c5a66ee79");
Object.keys(_index3).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index3[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index3[key];
        }
    });
});
var _index4 = require("320136604150f517");
Object.keys(_index4).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index4[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index4[key];
        }
    });
});
var _index5 = require("9bfe5668fe1279fd");
Object.keys(_index5).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index5[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index5[key];
        }
    });
});
var _index6 = require("8a5f15f49ef72b46");
Object.keys(_index6).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index6[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index6[key];
        }
    });
});
var _index7 = require("ad78344e087d5dce");
Object.keys(_index7).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index7[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index7[key];
        }
    });
});
var _index8 = require("c4f5940a947b78c");
Object.keys(_index8).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index8[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index8[key];
        }
    });
});
var _index9 = require("f66bb3ce3ddb423a");
Object.keys(_index9).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index9[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index9[key];
        }
    });
});
var _index10 = require("cf2ce1177f6f3085");
Object.keys(_index10).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index10[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index10[key];
        }
    });
});
var _index11 = require("ff27f5c5e825f426");
Object.keys(_index11).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index11[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index11[key];
        }
    });
});
var _index12 = require("9692908b0d3e69f3");
Object.keys(_index12).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index12[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index12[key];
        }
    });
});
var _index13 = require("c07b6490d53540ef");
Object.keys(_index13).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index13[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index13[key];
        }
    });
});
var _index14 = require("33ecb1182a4f61bc");
Object.keys(_index14).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index14[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index14[key];
        }
    });
});
var _index15 = require("eb6c645c302c3877");
Object.keys(_index15).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index15[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index15[key];
        }
    });
});
var _index16 = require("96a422b0dac4a654");
Object.keys(_index16).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index16[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index16[key];
        }
    });
});
var _index17 = require("41bd5ae6bd5c566d");
Object.keys(_index17).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index17[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index17[key];
        }
    });
});
var _index18 = require("1b492f1d94521a5d");
Object.keys(_index18).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index18[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index18[key];
        }
    });
});
var _index19 = require("c13fe358d89ecd81");
Object.keys(_index19).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index19[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index19[key];
        }
    });
});
var _index20 = require("d42674a0b7bfc434");
Object.keys(_index20).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index20[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index20[key];
        }
    });
});
var _index21 = require("fbdc79daa81b87b6");
Object.keys(_index21).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index21[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index21[key];
        }
    });
});
var _index22 = require("c2badf5a2b5ed454");
Object.keys(_index22).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index22[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index22[key];
        }
    });
});
var _index23 = require("9fd007b982125b9a");
Object.keys(_index23).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index23[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index23[key];
        }
    });
});
var _index24 = require("b695668577e1e7cb");
Object.keys(_index24).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index24[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index24[key];
        }
    });
});
var _index25 = require("6b399f6303d57295");
Object.keys(_index25).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index25[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index25[key];
        }
    });
});
var _index26 = require("6a61a2a843b91654");
Object.keys(_index26).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index26[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index26[key];
        }
    });
});
var _index27 = require("60b631dcb2f037ca");
Object.keys(_index27).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index27[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index27[key];
        }
    });
});
var _index28 = require("2ed27a2d4a3c6872");
Object.keys(_index28).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index28[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index28[key];
        }
    });
});
var _index29 = require("41d2eb1d2381e8a");
Object.keys(_index29).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index29[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index29[key];
        }
    });
});
var _index30 = require("c599317e8caae438");
Object.keys(_index30).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index30[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index30[key];
        }
    });
});
var _index31 = require("3b135e2b9118d1b");
Object.keys(_index31).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index31[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index31[key];
        }
    });
});
var _index32 = require("241ef3acf8caa33a");
Object.keys(_index32).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index32[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index32[key];
        }
    });
});
var _index33 = require("b76109f782422508");
Object.keys(_index33).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index33[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index33[key];
        }
    });
});
var _index34 = require("30e8f5ceefb905b2");
Object.keys(_index34).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index34[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index34[key];
        }
    });
});
var _index35 = require("20867c3d025aff9");
Object.keys(_index35).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index35[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index35[key];
        }
    });
});
var _index36 = require("366b2e75db11947a");
Object.keys(_index36).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index36[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index36[key];
        }
    });
});
var _index37 = require("4582c2f25445c44b");
Object.keys(_index37).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index37[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index37[key];
        }
    });
});
var _index38 = require("55c0b2733cdea4d1");
Object.keys(_index38).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index38[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index38[key];
        }
    });
});
var _index39 = require("74ff6cf808a390db");
Object.keys(_index39).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index39[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index39[key];
        }
    });
});
var _index40 = require("81c3475ead0f5b5a");
Object.keys(_index40).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index40[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index40[key];
        }
    });
});
var _index41 = require("cd10d76a84c94920");
Object.keys(_index41).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index41[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index41[key];
        }
    });
});
var _index42 = require("b58b90c359ac3c03");
Object.keys(_index42).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index42[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index42[key];
        }
    });
});
var _index43 = require("bcedf2167bbb0925");
Object.keys(_index43).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index43[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index43[key];
        }
    });
});
var _index44 = require("dd98d2de70848b38");
Object.keys(_index44).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index44[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index44[key];
        }
    });
});
var _index45 = require("e137338bdb2b9c68");
Object.keys(_index45).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index45[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index45[key];
        }
    });
});
var _index46 = require("d7d2b7f0a9f716a8");
Object.keys(_index46).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index46[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index46[key];
        }
    });
});
var _index47 = require("83b612a607feb7af");
Object.keys(_index47).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index47[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index47[key];
        }
    });
});
var _index48 = require("68777f2c425fee5d");
Object.keys(_index48).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index48[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index48[key];
        }
    });
});
var _index49 = require("5fe5471d81c79da6");
Object.keys(_index49).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index49[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index49[key];
        }
    });
});
var _index50 = require("c2cf95d448d96fcc");
Object.keys(_index50).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index50[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index50[key];
        }
    });
});
var _index51 = require("bdeffae0b4080a1e");
Object.keys(_index51).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index51[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index51[key];
        }
    });
});
var _index52 = require("b0814d5ce39f52b5");
Object.keys(_index52).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index52[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index52[key];
        }
    });
});
var _index53 = require("38c2fd7b5ab40bf0");
Object.keys(_index53).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index53[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index53[key];
        }
    });
});
var _index54 = require("216f5a0b7789e14");
Object.keys(_index54).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index54[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index54[key];
        }
    });
});
var _index55 = require("b3e5b40e0fbb1d44");
Object.keys(_index55).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index55[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index55[key];
        }
    });
});
var _index56 = require("e989ece2a2757bd2");
Object.keys(_index56).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index56[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index56[key];
        }
    });
});
var _index57 = require("610e7dd2284f5781");
Object.keys(_index57).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index57[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index57[key];
        }
    });
});
var _index58 = require("aee49e17aca40e68");
Object.keys(_index58).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index58[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index58[key];
        }
    });
});
var _index59 = require("ba659abbcc4b60fe");
Object.keys(_index59).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index59[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index59[key];
        }
    });
});
var _index60 = require("cc3f9c4f9c787ea6");
Object.keys(_index60).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index60[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index60[key];
        }
    });
});
var _index61 = require("40192b29822dee38");
Object.keys(_index61).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index61[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index61[key];
        }
    });
});
var _index62 = require("87e1741b0e0137ea");
Object.keys(_index62).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index62[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index62[key];
        }
    });
});
var _index63 = require("d634ea72aef4c86e");
Object.keys(_index63).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index63[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index63[key];
        }
    });
});
var _index64 = require("665bea9ec101ae55");
Object.keys(_index64).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index64[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index64[key];
        }
    });
});
var _index65 = require("4c745f864149cfd3");
Object.keys(_index65).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index65[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index65[key];
        }
    });
});
var _index66 = require("59e6129eee3b016c");
Object.keys(_index66).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index66[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index66[key];
        }
    });
});
var _index67 = require("88f236b6a61f4122");
Object.keys(_index67).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index67[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index67[key];
        }
    });
});
var _index68 = require("33f9f2f6d62dc6cc");
Object.keys(_index68).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index68[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index68[key];
        }
    });
});
var _index69 = require("5e181004291889f8");
Object.keys(_index69).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index69[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index69[key];
        }
    });
});
var _index70 = require("de24191615ebbb80");
Object.keys(_index70).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index70[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index70[key];
        }
    });
});
var _index71 = require("d63e27bbb84952ec");
Object.keys(_index71).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index71[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index71[key];
        }
    });
});
var _index72 = require("c2012a9ded2a05e4");
Object.keys(_index72).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index72[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index72[key];
        }
    });
});
var _index73 = require("6f70aef5356bf042");
Object.keys(_index73).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index73[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index73[key];
        }
    });
});
var _index74 = require("3fea09df6269258d");
Object.keys(_index74).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index74[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index74[key];
        }
    });
});
var _index75 = require("cf95b5833c75a113");
Object.keys(_index75).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index75[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index75[key];
        }
    });
});
var _index76 = require("198ca05f7c43d0c0");
Object.keys(_index76).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index76[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index76[key];
        }
    });
});
var _index77 = require("2a7b78bbeb9ac279");
Object.keys(_index77).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index77[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index77[key];
        }
    });
});
var _index78 = require("81ea02ff9efa6f86");
Object.keys(_index78).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index78[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index78[key];
        }
    });
});
var _index79 = require("129a78908bb8985b");
Object.keys(_index79).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index79[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index79[key];
        }
    });
});
var _index80 = require("f3c08909629e1f03");
Object.keys(_index80).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index80[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index80[key];
        }
    });
});
var _index81 = require("f78c22b2c30c3be8");
Object.keys(_index81).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index81[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index81[key];
        }
    });
});
var _index82 = require("885f4bbed816b7f7");
Object.keys(_index82).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index82[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index82[key];
        }
    });
});
var _index83 = require("72d271579509d098");
Object.keys(_index83).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index83[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index83[key];
        }
    });
});
var _index84 = require("dee4e1ab9bdde628");
Object.keys(_index84).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index84[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index84[key];
        }
    });
});
var _index85 = require("571218393678880d");
Object.keys(_index85).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index85[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index85[key];
        }
    });
});
var _index86 = require("2835d5a51730a5b3");
Object.keys(_index86).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index86[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index86[key];
        }
    });
});
var _index87 = require("3741eee35491c087");
Object.keys(_index87).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index87[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index87[key];
        }
    });
});
var _index88 = require("e92428f0f5974b5a");
Object.keys(_index88).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index88[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index88[key];
        }
    });
});
var _index89 = require("8523677aaea2cb20");
Object.keys(_index89).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index89[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index89[key];
        }
    });
});
var _index90 = require("22812cfff632fba0");
Object.keys(_index90).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index90[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index90[key];
        }
    });
});
var _index91 = require("a84bbb9e49250d10");
Object.keys(_index91).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index91[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index91[key];
        }
    });
});
var _index92 = require("ce1a93769edb9f74");
Object.keys(_index92).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index92[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index92[key];
        }
    });
});
var _index93 = require("c29e8ab5eeb7d4c0");
Object.keys(_index93).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index93[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index93[key];
        }
    });
});
var _index94 = require("417a881dca9183b4");
Object.keys(_index94).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index94[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index94[key];
        }
    });
});
var _index95 = require("ed18152d44e54a88");
Object.keys(_index95).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index95[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index95[key];
        }
    });
});
var _index96 = require("5ad8718b8ffbdc8");
Object.keys(_index96).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index96[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index96[key];
        }
    });
});
var _index97 = require("4885f3e1b4265446");
Object.keys(_index97).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index97[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index97[key];
        }
    });
});
var _index98 = require("21dc31ac6a839f01");
Object.keys(_index98).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index98[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index98[key];
        }
    });
});
var _index99 = require("ed69673c611caf3c");
Object.keys(_index99).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index99[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index99[key];
        }
    });
});
var _index100 = require("9a619fbde7ef4e46");
Object.keys(_index100).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index100[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index100[key];
        }
    });
});
var _index101 = require("5b4ec1d4ed18e2a5");
Object.keys(_index101).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index101[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index101[key];
        }
    });
});
var _index102 = require("ea293604faa53290");
Object.keys(_index102).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index102[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index102[key];
        }
    });
});
var _index103 = require("b884dd139cae152f");
Object.keys(_index103).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index103[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index103[key];
        }
    });
});
var _index104 = require("4c3ab9f336a7d51a");
Object.keys(_index104).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index104[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index104[key];
        }
    });
});
var _index105 = require("653e45499ad5f194");
Object.keys(_index105).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index105[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index105[key];
        }
    });
});
var _index106 = require("7ac77dc0818e9e94");
Object.keys(_index106).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index106[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index106[key];
        }
    });
});
var _index107 = require("9ebf799edec0800d");
Object.keys(_index107).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index107[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index107[key];
        }
    });
});
var _index108 = require("e9dba9b7ca1e9602");
Object.keys(_index108).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index108[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index108[key];
        }
    });
});
var _index109 = require("457b792b8a5c77fb");
Object.keys(_index109).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index109[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index109[key];
        }
    });
});
var _index110 = require("f0cf225cf98c3e8f");
Object.keys(_index110).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index110[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index110[key];
        }
    });
});
var _index111 = require("bf7e1cb6a8774a05");
Object.keys(_index111).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index111[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index111[key];
        }
    });
});
var _index112 = require("d5aea1feeaf1adbf");
Object.keys(_index112).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index112[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index112[key];
        }
    });
});
var _index113 = require("48e6ab9d727b91c9");
Object.keys(_index113).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index113[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index113[key];
        }
    });
});
var _index114 = require("c79cfd58c43d1fa4");
Object.keys(_index114).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index114[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index114[key];
        }
    });
});
var _index115 = require("c728316595f95974");
Object.keys(_index115).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index115[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index115[key];
        }
    });
});
var _index116 = require("2caa1112ba1b4508");
Object.keys(_index116).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index116[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index116[key];
        }
    });
});
var _index117 = require("9d5c85b5b30fda8b");
Object.keys(_index117).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index117[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index117[key];
        }
    });
});
var _index118 = require("c46fa1cec26cd22a");
Object.keys(_index118).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index118[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index118[key];
        }
    });
});
var _index119 = require("6c707c0047f553ac");
Object.keys(_index119).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index119[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index119[key];
        }
    });
});
var _index120 = require("b71a70253afe0556");
Object.keys(_index120).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index120[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index120[key];
        }
    });
});
var _index121 = require("e2f24260bdfcee8f");
Object.keys(_index121).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index121[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index121[key];
        }
    });
});
var _index122 = require("be2bf5e6a74e2283");
Object.keys(_index122).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index122[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index122[key];
        }
    });
});
var _index123 = require("e93db27a94ecd3d3");
Object.keys(_index123).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index123[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index123[key];
        }
    });
});
var _index124 = require("2aefde7c3914abfe");
Object.keys(_index124).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index124[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index124[key];
        }
    });
});
var _index125 = require("56b4c8eeea06f054");
Object.keys(_index125).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index125[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index125[key];
        }
    });
});
var _index126 = require("6449dde00b2f822c");
Object.keys(_index126).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index126[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index126[key];
        }
    });
});
var _index127 = require("467aa549567ca48");
Object.keys(_index127).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index127[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index127[key];
        }
    });
});
var _index128 = require("b3c68b9632f5847f");
Object.keys(_index128).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index128[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index128[key];
        }
    });
});
var _index129 = require("af086aa9222e7e7a");
Object.keys(_index129).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index129[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index129[key];
        }
    });
});
var _index130 = require("e5fdfd39e6fba6e7");
Object.keys(_index130).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index130[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index130[key];
        }
    });
});
var _index131 = require("abbe493c9dd29207");
Object.keys(_index131).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index131[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index131[key];
        }
    });
});
var _index132 = require("a5aa9970fda729b7");
Object.keys(_index132).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index132[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index132[key];
        }
    });
});
var _index133 = require("c06c3eadb4cdf4e3");
Object.keys(_index133).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index133[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index133[key];
        }
    });
});
var _index134 = require("cdc71995959dfbfa");
Object.keys(_index134).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index134[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index134[key];
        }
    });
});
var _index135 = require("4a9a53e9af17ff6f");
Object.keys(_index135).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index135[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index135[key];
        }
    });
});
var _index136 = require("59f886b13821bc45");
Object.keys(_index136).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index136[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index136[key];
        }
    });
});
var _index137 = require("f34570d87ce571d9");
Object.keys(_index137).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index137[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index137[key];
        }
    });
});
var _index138 = require("d33f52ea22bb7fd3");
Object.keys(_index138).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index138[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index138[key];
        }
    });
});
var _index139 = require("16489881fdd5bbdf");
Object.keys(_index139).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index139[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index139[key];
        }
    });
});
var _index140 = require("61b14f40f6d2e486");
Object.keys(_index140).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index140[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index140[key];
        }
    });
});
var _index141 = require("9aa6cb940f916d0a");
Object.keys(_index141).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index141[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index141[key];
        }
    });
});
var _index142 = require("b7eef910ecfacb18");
Object.keys(_index142).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index142[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index142[key];
        }
    });
});
var _index143 = require("686832f61553fbb3");
Object.keys(_index143).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index143[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index143[key];
        }
    });
});
var _index144 = require("86e637d32ee5d263");
Object.keys(_index144).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index144[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index144[key];
        }
    });
});
var _index145 = require("830824c7146bc058");
Object.keys(_index145).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index145[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index145[key];
        }
    });
});
var _index146 = require("4f0836001f7c5048");
Object.keys(_index146).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index146[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index146[key];
        }
    });
});
var _index147 = require("4d73f01e07ece752");
Object.keys(_index147).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index147[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index147[key];
        }
    });
});
var _index148 = require("423b6331ffa3e5d2");
Object.keys(_index148).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index148[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index148[key];
        }
    });
});
var _index149 = require("f9514135275b73a4");
Object.keys(_index149).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index149[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index149[key];
        }
    });
});
var _index150 = require("d2f2611a87dcb9e3");
Object.keys(_index150).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index150[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index150[key];
        }
    });
});
var _index151 = require("16575fe82c6eaba");
Object.keys(_index151).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index151[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index151[key];
        }
    });
});
var _index152 = require("123fc514f9f01a00");
Object.keys(_index152).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index152[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index152[key];
        }
    });
});
var _index153 = require("c86bcf67d45e9435");
Object.keys(_index153).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index153[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index153[key];
        }
    });
});
var _index154 = require("4821ca0dd2872a0f");
Object.keys(_index154).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index154[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index154[key];
        }
    });
});
var _index155 = require("85eb0bf7985aa70e");
Object.keys(_index155).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index155[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index155[key];
        }
    });
});
var _index156 = require("1a237db8f40f7128");
Object.keys(_index156).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index156[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index156[key];
        }
    });
});
var _index157 = require("806f1afed957366e");
Object.keys(_index157).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index157[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index157[key];
        }
    });
});
var _index158 = require("cad35743a000cb4");
Object.keys(_index158).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index158[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index158[key];
        }
    });
});
var _index159 = require("115f361c6735a6c0");
Object.keys(_index159).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index159[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index159[key];
        }
    });
});
var _index160 = require("80e94a4a0e176a8");
Object.keys(_index160).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index160[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index160[key];
        }
    });
});
var _index161 = require("780d37322e411839");
Object.keys(_index161).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index161[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index161[key];
        }
    });
});
var _index162 = require("7c96227bbd2ac57c");
Object.keys(_index162).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index162[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index162[key];
        }
    });
});
var _index163 = require("a60de3990361ba17");
Object.keys(_index163).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index163[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index163[key];
        }
    });
});
var _index164 = require("67038e2323e63ea9");
Object.keys(_index164).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index164[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index164[key];
        }
    });
});
var _index165 = require("f369bf768ced1809");
Object.keys(_index165).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index165[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index165[key];
        }
    });
});
var _index166 = require("8df5570f1a67899f");
Object.keys(_index166).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index166[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index166[key];
        }
    });
});
var _index167 = require("8be23c536e634067");
Object.keys(_index167).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index167[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index167[key];
        }
    });
});
var _index168 = require("970ab91418234ff6");
Object.keys(_index168).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index168[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index168[key];
        }
    });
});
var _index169 = require("bb6bd04224221f0f");
Object.keys(_index169).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index169[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index169[key];
        }
    });
});
var _index170 = require("83bc3c8b247c95ac");
Object.keys(_index170).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index170[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index170[key];
        }
    });
});
var _index171 = require("1b896d69ba284cd1");
Object.keys(_index171).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index171[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index171[key];
        }
    });
});
var _index172 = require("9e825321a9eac99d");
Object.keys(_index172).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index172[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index172[key];
        }
    });
});
var _index173 = require("e12f32189f9896fa");
Object.keys(_index173).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index173[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index173[key];
        }
    });
});
var _index174 = require("7679dd63eccebad1");
Object.keys(_index174).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index174[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index174[key];
        }
    });
});
var _index175 = require("a0e3c9611b9bf96c");
Object.keys(_index175).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index175[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index175[key];
        }
    });
});
var _index176 = require("eb624ca985ff10d8");
Object.keys(_index176).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index176[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index176[key];
        }
    });
});
var _index177 = require("b2b165aa2a86d7f0");
Object.keys(_index177).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index177[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index177[key];
        }
    });
});
var _index178 = require("caabce449eab8dd");
Object.keys(_index178).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index178[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index178[key];
        }
    });
});
var _index179 = require("5d1dd7f0f23ee603");
Object.keys(_index179).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index179[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index179[key];
        }
    });
});
var _index180 = require("647dcd5d2203f0b0");
Object.keys(_index180).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index180[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index180[key];
        }
    });
});
var _index181 = require("9cb02b8edba87fd");
Object.keys(_index181).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index181[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index181[key];
        }
    });
});
var _index182 = require("c3ed91fb195d875a");
Object.keys(_index182).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index182[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index182[key];
        }
    });
});
var _index183 = require("2c295112993dd62f");
Object.keys(_index183).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index183[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index183[key];
        }
    });
});
var _index184 = require("af1893c4359270d5");
Object.keys(_index184).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index184[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index184[key];
        }
    });
});
var _index185 = require("28e3998e2ecca01f");
Object.keys(_index185).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index185[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index185[key];
        }
    });
});
var _index186 = require("be774b00f21988d3");
Object.keys(_index186).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index186[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index186[key];
        }
    });
});
var _index187 = require("8b434ff09ce37dea");
Object.keys(_index187).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index187[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index187[key];
        }
    });
});
var _index188 = require("78a9f3780d7e41b8");
Object.keys(_index188).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index188[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index188[key];
        }
    });
});
var _index189 = require("fec986856a29d9dc");
Object.keys(_index189).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index189[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index189[key];
        }
    });
});
var _index190 = require("7fcca35af7611279");
Object.keys(_index190).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index190[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index190[key];
        }
    });
});
var _index191 = require("bc1b64da9d20b354");
Object.keys(_index191).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index191[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index191[key];
        }
    });
});
var _index192 = require("5ad4c5c7cdd2014a");
Object.keys(_index192).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index192[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index192[key];
        }
    });
});
var _index193 = require("9ba9585d1f939198");
Object.keys(_index193).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index193[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index193[key];
        }
    });
});
var _index194 = require("8dd9270e196da68a");
Object.keys(_index194).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index194[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index194[key];
        }
    });
});
var _index195 = require("26bfd84a78d86013");
Object.keys(_index195).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index195[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index195[key];
        }
    });
});
var _index196 = require("c7cc615446e6a2b7");
Object.keys(_index196).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index196[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index196[key];
        }
    });
});
var _index197 = require("21a79e95083ca1bc");
Object.keys(_index197).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index197[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index197[key];
        }
    });
});
var _index198 = require("20bbccaad70d3b36");
Object.keys(_index198).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index198[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index198[key];
        }
    });
});
var _index199 = require("1304f66658492899");
Object.keys(_index199).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index199[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index199[key];
        }
    });
});
var _index200 = require("e669135196dbe120");
Object.keys(_index200).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index200[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index200[key];
        }
    });
});
var _index201 = require("96e5466dc057addb");
Object.keys(_index201).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index201[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index201[key];
        }
    });
});
var _index202 = require("6511e433e11f2be4");
Object.keys(_index202).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index202[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index202[key];
        }
    });
});
var _index203 = require("f11dd2e4ce9106eb");
Object.keys(_index203).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index203[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index203[key];
        }
    });
});
var _index204 = require("d813fb5db6a646f6");
Object.keys(_index204).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index204[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index204[key];
        }
    });
});
var _index205 = require("f7134e17cdb98335");
Object.keys(_index205).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index205[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index205[key];
        }
    });
});
var _index206 = require("906e60f1e1a30c6a");
Object.keys(_index206).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index206[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index206[key];
        }
    });
});
var _index207 = require("8e42dbcd2222435d");
Object.keys(_index207).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index207[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index207[key];
        }
    });
});
var _index208 = require("3d08c235c5a0918");
Object.keys(_index208).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index208[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index208[key];
        }
    });
});
var _index209 = require("9ca3f5ebe5cbf2ef");
Object.keys(_index209).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index209[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index209[key];
        }
    });
});
var _index210 = require("9e076e569f3df020");
Object.keys(_index210).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index210[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index210[key];
        }
    });
});
var _index211 = require("997eaaf3105209be");
Object.keys(_index211).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index211[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index211[key];
        }
    });
});
var _index212 = require("5feb840f1bdd9cea");
Object.keys(_index212).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index212[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index212[key];
        }
    });
});
var _index213 = require("4437c29e1991dd08");
Object.keys(_index213).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index213[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index213[key];
        }
    });
});
var _index214 = require("faf9e1483266d8c5");
Object.keys(_index214).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index214[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index214[key];
        }
    });
});
var _index215 = require("894218cc13b5a21e");
Object.keys(_index215).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index215[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index215[key];
        }
    });
});
var _index216 = require("1ab522cddd985641");
Object.keys(_index216).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index216[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index216[key];
        }
    });
});
var _index217 = require("e30c032c55913541");
Object.keys(_index217).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index217[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index217[key];
        }
    });
});
var _index218 = require("d12684f12c863ead");
Object.keys(_index218).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index218[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index218[key];
        }
    });
});
var _index219 = require("e7e3ba1aec4ed01d");
Object.keys(_index219).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index219[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index219[key];
        }
    });
});
var _index220 = require("52ec6c389627d10b");
Object.keys(_index220).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index220[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index220[key];
        }
    });
});
var _index221 = require("8258136654b5f10e");
Object.keys(_index221).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index221[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index221[key];
        }
    });
});
var _index222 = require("b4177823b3e8302d");
Object.keys(_index222).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index222[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index222[key];
        }
    });
});
var _index223 = require("9960d9863cc3055e");
Object.keys(_index223).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index223[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index223[key];
        }
    });
});
var _index224 = require("e3c43ee26dfbcec1");
Object.keys(_index224).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index224[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index224[key];
        }
    });
});
var _index225 = require("73e772cf695ca2bb");
Object.keys(_index225).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index225[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index225[key];
        }
    });
});
var _index226 = require("ef2b183f3fde724e");
Object.keys(_index226).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index226[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index226[key];
        }
    });
});
var _index227 = require("15060203358a57e");
Object.keys(_index227).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index227[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index227[key];
        }
    });
});
var _index228 = require("67ef3ff6e2b76b4c");
Object.keys(_index228).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index228[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index228[key];
        }
    });
});
var _index229 = require("79880219f6de9c2a");
Object.keys(_index229).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index229[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index229[key];
        }
    });
});
var _index230 = require("b9bc07a05bbf8619");
Object.keys(_index230).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index230[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index230[key];
        }
    });
});
var _index231 = require("197104af79cd3bb0");
Object.keys(_index231).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index231[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index231[key];
        }
    });
});
var _index232 = require("30c7b44047d79a40");
Object.keys(_index232).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index232[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index232[key];
        }
    });
});
var _index233 = require("4285b426652f1063");
Object.keys(_index233).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index233[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index233[key];
        }
    });
});
var _index234 = require("11e1793b54905752");
Object.keys(_index234).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index234[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index234[key];
        }
    });
});
var _index235 = require("f5ad81df1b2e131c");
Object.keys(_index235).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index235[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index235[key];
        }
    });
});
var _index236 = require("f4f39753d3eb2c2");
Object.keys(_index236).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index236[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index236[key];
        }
    });
});
var _index237 = require("1562caa8174a1717");
Object.keys(_index237).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index237[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index237[key];
        }
    });
});
var _index238 = require("eea6fed85cd926ef");
Object.keys(_index238).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index238[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index238[key];
        }
    });
});
var _index239 = require("1285ad23358fbca7");
Object.keys(_index239).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index239[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index239[key];
        }
    });
});
var _index240 = require("4dba10434b646fa2");
Object.keys(_index240).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index240[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index240[key];
        }
    });
});
var _index241 = require("9a984f4c52af48f5");
Object.keys(_index241).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index241[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index241[key];
        }
    });
});
var _index242 = require("7e2283ebcb15c962");
Object.keys(_index242).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index242[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index242[key];
        }
    });
});
var _index243 = require("37dd3086962550e1");
Object.keys(_index243).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (key in exports && exports[key] === _index243[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _index243[key];
        }
    });
});

},{"bb476f479aec785f":"hboah","f3c55fba68737491":"475kI","4e06aa5c5a66ee79":"fL4dR","320136604150f517":"hzidA","9bfe5668fe1279fd":"eZQAV","8a5f15f49ef72b46":"03zTk","ad78344e087d5dce":"7jsut","c4f5940a947b78c":"alxIr","f66bb3ce3ddb423a":"jW81o","cf2ce1177f6f3085":"1jCRu","ff27f5c5e825f426":"6sRN6","9692908b0d3e69f3":"3IQD4","c07b6490d53540ef":"aub5m","33ecb1182a4f61bc":"3tdAJ","eb6c645c302c3877":"g75Mq","96a422b0dac4a654":"5V5JV","41bd5ae6bd5c566d":"fgd9M","1b492f1d94521a5d":"38snE","c13fe358d89ecd81":"hNMdA","d42674a0b7bfc434":"jR9nm","fbdc79daa81b87b6":"cJL23","c2badf5a2b5ed454":"dvya7","9fd007b982125b9a":"1uuCg","b695668577e1e7cb":"5Kgvn","6b399f6303d57295":"21Qeg","6a61a2a843b91654":"kWjSX","60b631dcb2f037ca":"iWbGJ","2ed27a2d4a3c6872":"e0VtU","41d2eb1d2381e8a":"fJoFi","c599317e8caae438":"jnteW","3b135e2b9118d1b":"5PiM9","241ef3acf8caa33a":"jkwjj","b76109f782422508":"Z5oWO","30e8f5ceefb905b2":"i3gFX","20867c3d025aff9":"eSams","366b2e75db11947a":"3IvxJ","4582c2f25445c44b":"cy0mL","55c0b2733cdea4d1":"iFe68","74ff6cf808a390db":"g7D5W","81c3475ead0f5b5a":"kwHze","cd10d76a84c94920":"4V6M8","b58b90c359ac3c03":"i1Z2B","bcedf2167bbb0925":"aOi8Z","dd98d2de70848b38":"99wly","e137338bdb2b9c68":"5ViHa","d7d2b7f0a9f716a8":"51lqU","83b612a607feb7af":"deCgd","68777f2c425fee5d":"015Lr","5fe5471d81c79da6":"jtO7f","c2cf95d448d96fcc":"c7ju7","bdeffae0b4080a1e":"fGjDI","b0814d5ce39f52b5":"5qyrI","38c2fd7b5ab40bf0":"etxH3","216f5a0b7789e14":"jOlnb","b3e5b40e0fbb1d44":"kcCWM","e989ece2a2757bd2":"jhz7T","610e7dd2284f5781":"c9wPr","aee49e17aca40e68":"ab76B","ba659abbcc4b60fe":"9sHeD","cc3f9c4f9c787ea6":"3Ot4h","40192b29822dee38":"gmxYT","87e1741b0e0137ea":"7ud3X","d634ea72aef4c86e":"eeV53","665bea9ec101ae55":"aBg6Q","4c745f864149cfd3":"7aKP6","59e6129eee3b016c":"eLZ5b","88f236b6a61f4122":"4IPnK","33f9f2f6d62dc6cc":"03dpp","5e181004291889f8":"7QewX","de24191615ebbb80":"eOZFo","d63e27bbb84952ec":"6ZrQ5","c2012a9ded2a05e4":"4C2Wr","6f70aef5356bf042":"4iRjv","3fea09df6269258d":"3VMIL","cf95b5833c75a113":"4kcMW","198ca05f7c43d0c0":"5yhYa","2a7b78bbeb9ac279":"esFEi","81ea02ff9efa6f86":"lR8Io","129a78908bb8985b":"iS77p","f3c08909629e1f03":"f28wB","f78c22b2c30c3be8":"t2HDN","885f4bbed816b7f7":"fAxdh","72d271579509d098":"kRfdi","dee4e1ab9bdde628":"9d1Pg","571218393678880d":"fNkwc","2835d5a51730a5b3":"jWChc","3741eee35491c087":"gwH0c","e92428f0f5974b5a":"2axfx","8523677aaea2cb20":"jzd1E","22812cfff632fba0":"kio1B","a84bbb9e49250d10":"C2P0L","ce1a93769edb9f74":"cr73f","c29e8ab5eeb7d4c0":"22KCI","417a881dca9183b4":"2lNv1","ed18152d44e54a88":"hP8NA","5ad8718b8ffbdc8":"1zHej","4885f3e1b4265446":"S6fio","21dc31ac6a839f01":"7odmH","ed69673c611caf3c":"fqTdg","9a619fbde7ef4e46":"glolq","5b4ec1d4ed18e2a5":"1t8KQ","ea293604faa53290":"3agDO","b884dd139cae152f":"l9tWS","4c3ab9f336a7d51a":"iZrN8","653e45499ad5f194":"bpzaD","7ac77dc0818e9e94":"6yh4g","9ebf799edec0800d":"4dv0v","e9dba9b7ca1e9602":"2ogSo","457b792b8a5c77fb":"6AV3j","f0cf225cf98c3e8f":"c3MYB","bf7e1cb6a8774a05":"jqhPh","d5aea1feeaf1adbf":"9cexO","48e6ab9d727b91c9":"dyMIP","c79cfd58c43d1fa4":"jzcyi","c728316595f95974":"a6qf1","2caa1112ba1b4508":"9dpYu","9d5c85b5b30fda8b":"5jn07","c46fa1cec26cd22a":"dnyZz","6c707c0047f553ac":"8FUr6","b71a70253afe0556":"8QzC7","e2f24260bdfcee8f":"7FjQf","be2bf5e6a74e2283":"jSzvL","e93db27a94ecd3d3":"jri8s","2aefde7c3914abfe":"bat4E","56b4c8eeea06f054":"7whBx","6449dde00b2f822c":"1d9cq","467aa549567ca48":"fJJ3M","b3c68b9632f5847f":"j88au","af086aa9222e7e7a":"16SmB","e5fdfd39e6fba6e7":"jkjxd","abbe493c9dd29207":"c8KBS","a5aa9970fda729b7":"8cq2h","c06c3eadb4cdf4e3":"bUS6W","cdc71995959dfbfa":"4X4G2","4a9a53e9af17ff6f":"3IALF","59f886b13821bc45":"efMjU","f34570d87ce571d9":"7x5Jl","d33f52ea22bb7fd3":"d4Gae","16489881fdd5bbdf":"clx4b","61b14f40f6d2e486":"bMtqV","9aa6cb940f916d0a":"kwI0m","b7eef910ecfacb18":"7J3Q2","686832f61553fbb3":"2brVA","86e637d32ee5d263":"azgGe","830824c7146bc058":"gbOJY","4f0836001f7c5048":"fo6X0","4d73f01e07ece752":"hvqeH","423b6331ffa3e5d2":"lsZyH","f9514135275b73a4":"8fQcQ","d2f2611a87dcb9e3":"4SSWt","16575fe82c6eaba":"8aCUT","123fc514f9f01a00":"jW013","c86bcf67d45e9435":"lVD0G","4821ca0dd2872a0f":"ccmoZ","85eb0bf7985aa70e":"hFSne","1a237db8f40f7128":"9VAZa","806f1afed957366e":"kU9pl","cad35743a000cb4":"hWZFG","115f361c6735a6c0":"lzjRb","80e94a4a0e176a8":"jMfmL","780d37322e411839":"enzjB","7c96227bbd2ac57c":"jqSZU","a60de3990361ba17":"gP0ns","67038e2323e63ea9":"g79VA","f369bf768ced1809":"inDwO","8df5570f1a67899f":"4Wxgd","8be23c536e634067":"gHdRE","970ab91418234ff6":"5rxTb","bb6bd04224221f0f":"8JvSy","83bc3c8b247c95ac":"7LrAi","1b896d69ba284cd1":"1YO5g","9e825321a9eac99d":"gnebd","e12f32189f9896fa":"29SYN","7679dd63eccebad1":"atse6","a0e3c9611b9bf96c":"02uJh","eb624ca985ff10d8":"j2uXA","b2b165aa2a86d7f0":"gNLjl","caabce449eab8dd":"jsVo7","5d1dd7f0f23ee603":"45sna","647dcd5d2203f0b0":"aTT5c","9cb02b8edba87fd":"gIu7S","c3ed91fb195d875a":"kcslc","2c295112993dd62f":"hsMzT","af1893c4359270d5":"cNh8t","28e3998e2ecca01f":"9mDjN","be774b00f21988d3":"h1oS7","8b434ff09ce37dea":"f0xQR","78a9f3780d7e41b8":"h2o9r","fec986856a29d9dc":"62942","7fcca35af7611279":"1YDXi","bc1b64da9d20b354":"yIjPa","5ad4c5c7cdd2014a":"60YWC","9ba9585d1f939198":"7wRiH","8dd9270e196da68a":"4BYNm","26bfd84a78d86013":"detLY","c7cc615446e6a2b7":"7QCQN","21a79e95083ca1bc":"8KclM","20bbccaad70d3b36":"2QTST","1304f66658492899":"a7APw","e669135196dbe120":"hs8xy","96e5466dc057addb":"6YGAL","6511e433e11f2be4":"R19sp","f11dd2e4ce9106eb":"1EFb6","d813fb5db6a646f6":"7JQAX","f7134e17cdb98335":"5S4Rm","906e60f1e1a30c6a":"1U8F7","8e42dbcd2222435d":"E9tFo","3d08c235c5a0918":"3XINN","9ca3f5ebe5cbf2ef":"kcJtI","9e076e569f3df020":"4hEJG","997eaaf3105209be":"iJAa5","5feb840f1bdd9cea":"lmg97","4437c29e1991dd08":"30rTC","faf9e1483266d8c5":"iF0wL","894218cc13b5a21e":"eTm1l","1ab522cddd985641":"5zVrK","e30c032c55913541":"1cHoB","d12684f12c863ead":"ipmWI","e7e3ba1aec4ed01d":"7GNYs","52ec6c389627d10b":"cMsqy","8258136654b5f10e":"04Svu","b4177823b3e8302d":"dDDvv","9960d9863cc3055e":"diTjA","e3c43ee26dfbcec1":"cnrH3","73e772cf695ca2bb":"dAxue","ef2b183f3fde724e":"bFznd","15060203358a57e":"7oOvu","67ef3ff6e2b76b4c":"3dD7a","79880219f6de9c2a":"jVGj5","b9bc07a05bbf8619":"gF8jx","197104af79cd3bb0":"22JNI","30c7b44047d79a40":"jPKrE","4285b426652f1063":"bQpwZ","11e1793b54905752":"7ieGr","f5ad81df1b2e131c":"cvB1W","f4f39753d3eb2c2":"20wf8","1562caa8174a1717":"jmZa1","eea6fed85cd926ef":"actWA","1285ad23358fbca7":"4DdgS","4dba10434b646fa2":"6D2CR","9a984f4c52af48f5":"gWLQa","7e2283ebcb15c962":"dD3ep","37dd3086962550e1":"di2PR"}],"hboah":[function(require,module,exports) {
"use strict";
exports.add = add;
var _index = require("925991985175af2c");
var _index2 = require("13114f43603b9058");
var _index3 = require("84ab99a1072aba1a");
var _index4 = require("3067be390b31b3e6");
/**
 * @name add
 * @category Common Helpers
 * @summary Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.
 *
 * @description
 * Add the specified years, months, weeks, days, hours, minutes and seconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be added.
 *
 * | Key            | Description                        |
 * |----------------|------------------------------------|
 * | years          | Amount of years to be added        |
 * | months         | Amount of months to be added       |
 * | weeks          | Amount of weeks to be added        |
 * | days           | Amount of days to be added         |
 * | hours          | Amount of hours to be added        |
 * | minutes        | Amount of minutes to be added      |
 * | seconds        | Amount of seconds to be added      |
 *
 * All values default to 0
 *
 * @returns The new date with the seconds added
 *
 * @example
 * // Add the following duration to 1 September 2014, 10:19:50
 * const result = add(new Date(2014, 8, 1, 10, 19, 50), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,\\-7
 *   minutes: 9,
 *   seconds: 30,
 * })
 * //=> Thu Jun 15 2017 15:29:20
 */ function add(date, duration) {
    const { years = 0, months = 0, weeks = 0, days = 0, hours = 0, minutes = 0, seconds = 0 } = duration;
    // Add years and months
    const _date = (0, _index4.toDate)(date);
    const dateWithMonths = months || years ? (0, _index2.addMonths)(_date, months + years * 12) : _date;
    // Add weeks and days
    const dateWithDays = days || weeks ? (0, _index.addDays)(dateWithMonths, days + weeks * 7) : dateWithMonths;
    // Add days, hours, minutes and seconds
    const minutesToAdd = minutes + hours * 60;
    const secondsToAdd = seconds + minutesToAdd * 60;
    const msToAdd = secondsToAdd * 1000;
    const finalDate = (0, _index3.constructFrom)(date, dateWithDays.getTime() + msToAdd);
    return finalDate;
}

},{"925991985175af2c":"fL4dR","13114f43603b9058":"alxIr","84ab99a1072aba1a":"hNMdA","3067be390b31b3e6":"actWA"}],"fL4dR":[function(require,module,exports) {
"use strict";
exports.addDays = addDays;
var _index = require("2cd967972a296ad9");
var _index2 = require("f0e78f9c0d91f156");
/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of days to be added.
 *
 * @returns The new date with the days added
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */ function addDays(date, amount) {
    const _date = (0, _index.toDate)(date);
    if (isNaN(amount)) return (0, _index2.constructFrom)(date, NaN);
    if (!amount) // If 0 days, no-op to avoid changing times in the hour before end of DST
    return _date;
    _date.setDate(_date.getDate() + amount);
    return _date;
}

},{"2cd967972a296ad9":"actWA","f0e78f9c0d91f156":"hNMdA"}],"actWA":[function(require,module,exports) {
"use strict";
exports.toDate = toDate;
/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param argument - The value to convert
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */ function toDate(argument) {
    const argStr = Object.prototype.toString.call(argument);
    // Clone the date
    if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new argument.constructor(+argument);
    else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") // TODO: Can we get rid of as?
    return new Date(argument);
    else // TODO: Can we get rid of as?
    return new Date(NaN);
}

},{}],"hNMdA":[function(require,module,exports) {
"use strict";
exports.constructFrom = constructFrom;
/**
 * @name constructFrom
 * @category Generic Helpers
 * @summary Constructs a date using the reference date and the value
 *
 * @description
 * The function constructs a new date using the constructor from the reference
 * date and the given value. It helps to build generic functions that accept
 * date extensions.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The reference date to take constructor from
 * @param value - The value to create the date
 *
 * @returns Date initialized using the given date and value
 *
 * @example
 * import { constructFrom } from 'date-fns'
 *
 * // A function that clones a date preserving the original type
 * function cloneDate<DateType extends Date(date: DateType): DateType {
 *   return constructFrom(
 *     date, // Use contrustor from the given date
 *     date.getTime() // Use the date value to create a new date
 *   )
 * }
 */ function constructFrom(date, value) {
    if (date instanceof Date) return new date.constructor(value);
    else return new Date(value);
}

},{}],"alxIr":[function(require,module,exports) {
"use strict";
exports.addMonths = addMonths;
var _index = require("5742eeee77c6c4dd");
var _index2 = require("79294aad06ee37dd");
/**
 * @name addMonths
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of months to be added.
 *
 * @returns The new date with the months added
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * const result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 *
 * // Add one month to 30 January 2023:
 * const result = addMonths(new Date(2023, 0, 30), 1)
 * //=> Tue Feb 28 2023 00:00:00
 */ function addMonths(date, amount) {
    const _date = (0, _index.toDate)(date);
    if (isNaN(amount)) return (0, _index2.constructFrom)(date, NaN);
    if (!amount) // If 0 months, no-op to avoid changing times in the hour before end of DST
    return _date;
    const dayOfMonth = _date.getDate();
    // The JS Date object supports date math by accepting out-of-bounds values for
    // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
    // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
    // want except that dates will wrap around the end of a month, meaning that
    // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
    // we'll default to the end of the desired month by adding 1 to the desired
    // month and using a date of 0 to back up one day to the end of the desired
    // month.
    const endOfDesiredMonth = (0, _index2.constructFrom)(date, _date.getTime());
    endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
    const daysInMonth = endOfDesiredMonth.getDate();
    if (dayOfMonth >= daysInMonth) // If we're already at the end of the month, then this is the correct date
    // and we're done.
    return endOfDesiredMonth;
    else {
        // Otherwise, we now know that setting the original day-of-month value won't
        // cause an overflow, so set the desired day-of-month. Note that we can't
        // just set the date of `endOfDesiredMonth` because that object may have had
        // its time changed in the unusual case where where a DST transition was on
        // the last day of the month and its local time was in the hour skipped or
        // repeated next to a DST transition.  So we use `date` instead which is
        // guaranteed to still have the original time.
        _date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
        return _date;
    }
}

},{"5742eeee77c6c4dd":"actWA","79294aad06ee37dd":"hNMdA"}],"475kI":[function(require,module,exports) {
"use strict";
exports.addBusinessDays = addBusinessDays;
var _index = require("c4290ece85b498c3");
var _index2 = require("db98b25fdeb6f59b");
var _index3 = require("e08f244f63c0b506");
var _index4 = require("a4930da9d9021f2e");
var _index5 = require("475b8d7f409bcfa3");
/**
 * @name addBusinessDays
 * @category Date Extension Helpers
 * @summary Add the specified number of business days (mon - fri) to the given date.
 *
 * @description
 * Add the specified number of business days (mon - fri) to the given date, ignoring weekends.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of business days to be added.
 *
 * @returns The new date with the business days added
 *
 * @example
 * // Add 10 business days to 1 September 2014:
 * const result = addBusinessDays(new Date(2014, 8, 1), 10)
 * //=> Mon Sep 15 2014 00:00:00 (skipped weekend days)
 */ function addBusinessDays(date, amount) {
    const _date = (0, _index5.toDate)(date);
    const startedOnWeekend = (0, _index4.isWeekend)(_date);
    if (isNaN(amount)) return (0, _index.constructFrom)(date, NaN);
    const hours = _date.getHours();
    const sign = amount < 0 ? -1 : 1;
    const fullWeeks = Math.trunc(amount / 5);
    _date.setDate(_date.getDate() + fullWeeks * 7);
    // Get remaining days not part of a full week
    let restDays = Math.abs(amount % 5);
    // Loops over remaining days
    while(restDays > 0){
        _date.setDate(_date.getDate() + sign);
        if (!(0, _index4.isWeekend)(_date)) restDays -= 1;
    }
    // If the date is a weekend day and we reduce a dividable of
    // 5 from it, we land on a weekend date.
    // To counter this, we add days accordingly to land on the next business day
    if (startedOnWeekend && (0, _index4.isWeekend)(_date) && amount !== 0) {
        // If we're reducing days, we want to add days until we land on a weekday
        // If we're adding days we want to reduce days until we land on a weekday
        if ((0, _index2.isSaturday)(_date)) _date.setDate(_date.getDate() + (sign < 0 ? 2 : -1));
        if ((0, _index3.isSunday)(_date)) _date.setDate(_date.getDate() + (sign < 0 ? 1 : -2));
    }
    // Restore hours to avoid DST lag
    _date.setHours(hours);
    return _date;
}

},{"c4290ece85b498c3":"hNMdA","db98b25fdeb6f59b":"c8KBS","e08f244f63c0b506":"8cq2h","a4930da9d9021f2e":"hvqeH","475b8d7f409bcfa3":"actWA"}],"c8KBS":[function(require,module,exports) {
"use strict";
exports.isSaturday = isSaturday;
var _index = require("e530b4cdc312cd61");
/**
 * @name isSaturday
 * @category Weekday Helpers
 * @summary Is the given date Saturday?
 *
 * @description
 * Is the given date Saturday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Saturday
 *
 * @example
 * // Is 27 September 2014 Saturday?
 * const result = isSaturday(new Date(2014, 8, 27))
 * //=> true
 */ function isSaturday(date) {
    return (0, _index.toDate)(date).getDay() === 6;
}

},{"e530b4cdc312cd61":"actWA"}],"8cq2h":[function(require,module,exports) {
"use strict";
exports.isSunday = isSunday;
var _index = require("ae830739b06efde4");
/**
 * @name isSunday
 * @category Weekday Helpers
 * @summary Is the given date Sunday?
 *
 * @description
 * Is the given date Sunday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Sunday
 *
 * @example
 * // Is 21 September 2014 Sunday?
 * const result = isSunday(new Date(2014, 8, 21))
 * //=> true
 */ function isSunday(date) {
    return (0, _index.toDate)(date).getDay() === 0;
}

},{"ae830739b06efde4":"actWA"}],"hvqeH":[function(require,module,exports) {
"use strict";
exports.isWeekend = isWeekend;
var _index = require("c698b70ee71dfca6");
/**
 * @name isWeekend
 * @category Weekday Helpers
 * @summary Does the given date fall on a weekend?
 *
 * @description
 * Does the given date fall on a weekend?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date falls on a weekend
 *
 * @example
 * // Does 5 October 2014 fall on a weekend?
 * const result = isWeekend(new Date(2014, 9, 5))
 * //=> true
 */ function isWeekend(date) {
    const day = (0, _index.toDate)(date).getDay();
    return day === 0 || day === 6;
}

},{"c698b70ee71dfca6":"actWA"}],"hzidA":[function(require,module,exports) {
"use strict";
exports.addHours = addHours;
var _index = require("1def4ce2cbf2b5a4");
var _index2 = require("c47db39c292847b5");
/**
 * @name addHours
 * @category Hour Helpers
 * @summary Add the specified number of hours to the given date.
 *
 * @description
 * Add the specified number of hours to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of hours to be added.
 *
 * @returns The new date with the hours added
 *
 * @example
 * // Add 2 hours to 10 July 2014 23:00:00:
 * const result = addHours(new Date(2014, 6, 10, 23, 0), 2)
 * //=> Fri Jul 11 2014 01:00:00
 */ function addHours(date, amount) {
    return (0, _index.addMilliseconds)(date, amount * _index2.millisecondsInHour);
}

},{"1def4ce2cbf2b5a4":"03zTk","c47db39c292847b5":"1vXXw"}],"03zTk":[function(require,module,exports) {
"use strict";
exports.addMilliseconds = addMilliseconds;
var _index = require("701ad4371d122310");
var _index2 = require("fd3355012d608a81");
/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of milliseconds to be added.
 *
 * @returns The new date with the milliseconds added
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */ function addMilliseconds(date, amount) {
    const timestamp = +(0, _index.toDate)(date);
    return (0, _index2.constructFrom)(date, timestamp + amount);
}

},{"701ad4371d122310":"actWA","fd3355012d608a81":"hNMdA"}],"1vXXw":[function(require,module,exports) {
"use strict";
exports.secondsInYear = exports.secondsInWeek = exports.secondsInQuarter = exports.secondsInMonth = exports.secondsInMinute = exports.secondsInHour = exports.secondsInDay = exports.quartersInYear = exports.monthsInYear = exports.monthsInQuarter = exports.minutesInYear = exports.minutesInMonth = exports.minutesInHour = exports.minutesInDay = exports.minTime = exports.millisecondsInWeek = exports.millisecondsInSecond = exports.millisecondsInMinute = exports.millisecondsInHour = exports.millisecondsInDay = exports.maxTime = exports.daysInYear = exports.daysInWeek = void 0; /**
 * @module constants
 * @summary Useful constants
 * @description
 * Collection of useful date constants.
 *
 * The constants could be imported from `date-fns/constants`:
 *
 * ```ts
 * import { maxTime, minTime } from "date-fns/constants";
 *
 * function isAllowedTime(time) {
 *   return time <= maxTime && time >= minTime;
 * }
 * ```
 */ 
/**
 * @constant
 * @name daysInWeek
 * @summary Days in 1 week.
 */ const daysInWeek = exports.daysInWeek = 7;
/**
 * @constant
 * @name daysInYear
 * @summary Days in 1 year.
 *
 * @description
 * How many days in a year.
 *
 * One years equals 365.2425 days according to the formula:
 *
 * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
 * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
 */ const daysInYear = exports.daysInYear = 365.2425;
/**
 * @constant
 * @name maxTime
 * @summary Maximum allowed time.
 *
 * @example
 * import { maxTime } from "date-fns/constants";
 *
 * const isValid = 8640000000000001 <= maxTime;
 * //=> false
 *
 * new Date(8640000000000001);
 * //=> Invalid Date
 */ const maxTime = exports.maxTime = Math.pow(10, 8) * 86400000;
/**
 * @constant
 * @name minTime
 * @summary Minimum allowed time.
 *
 * @example
 * import { minTime } from "date-fns/constants";
 *
 * const isValid = -8640000000000001 >= minTime;
 * //=> false
 *
 * new Date(-8640000000000001)
 * //=> Invalid Date
 */ const minTime = exports.minTime = -maxTime;
/**
 * @constant
 * @name millisecondsInWeek
 * @summary Milliseconds in 1 week.
 */ const millisecondsInWeek = exports.millisecondsInWeek = 604800000;
/**
 * @constant
 * @name millisecondsInDay
 * @summary Milliseconds in 1 day.
 */ const millisecondsInDay = exports.millisecondsInDay = 86400000;
/**
 * @constant
 * @name millisecondsInMinute
 * @summary Milliseconds in 1 minute
 */ const millisecondsInMinute = exports.millisecondsInMinute = 60000;
/**
 * @constant
 * @name millisecondsInHour
 * @summary Milliseconds in 1 hour
 */ const millisecondsInHour = exports.millisecondsInHour = 3600000;
/**
 * @constant
 * @name millisecondsInSecond
 * @summary Milliseconds in 1 second
 */ const millisecondsInSecond = exports.millisecondsInSecond = 1000;
/**
 * @constant
 * @name minutesInYear
 * @summary Minutes in 1 year.
 */ const minutesInYear = exports.minutesInYear = 525600;
/**
 * @constant
 * @name minutesInMonth
 * @summary Minutes in 1 month.
 */ const minutesInMonth = exports.minutesInMonth = 43200;
/**
 * @constant
 * @name minutesInDay
 * @summary Minutes in 1 day.
 */ const minutesInDay = exports.minutesInDay = 1440;
/**
 * @constant
 * @name minutesInHour
 * @summary Minutes in 1 hour.
 */ const minutesInHour = exports.minutesInHour = 60;
/**
 * @constant
 * @name monthsInQuarter
 * @summary Months in 1 quarter.
 */ const monthsInQuarter = exports.monthsInQuarter = 3;
/**
 * @constant
 * @name monthsInYear
 * @summary Months in 1 year.
 */ const monthsInYear = exports.monthsInYear = 12;
/**
 * @constant
 * @name quartersInYear
 * @summary Quarters in 1 year
 */ const quartersInYear = exports.quartersInYear = 4;
/**
 * @constant
 * @name secondsInHour
 * @summary Seconds in 1 hour.
 */ const secondsInHour = exports.secondsInHour = 3600;
/**
 * @constant
 * @name secondsInMinute
 * @summary Seconds in 1 minute.
 */ const secondsInMinute = exports.secondsInMinute = 60;
/**
 * @constant
 * @name secondsInDay
 * @summary Seconds in 1 day.
 */ const secondsInDay = exports.secondsInDay = secondsInHour * 24;
/**
 * @constant
 * @name secondsInWeek
 * @summary Seconds in 1 week.
 */ const secondsInWeek = exports.secondsInWeek = secondsInDay * 7;
/**
 * @constant
 * @name secondsInYear
 * @summary Seconds in 1 year.
 */ const secondsInYear = exports.secondsInYear = secondsInDay * daysInYear;
/**
 * @constant
 * @name secondsInMonth
 * @summary Seconds in 1 month
 */ const secondsInMonth = exports.secondsInMonth = secondsInYear / 12;
/**
 * @constant
 * @name secondsInQuarter
 * @summary Seconds in 1 quarter.
 */ const secondsInQuarter = exports.secondsInQuarter = secondsInMonth * 3;

},{}],"eZQAV":[function(require,module,exports) {
"use strict";
exports.addISOWeekYears = addISOWeekYears;
var _index = require("240e5aec3c416c15");
var _index2 = require("39a8cd644c826899");
/**
 * @name addISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Add the specified number of ISO week-numbering years to the given date.
 *
 * @description
 * Add the specified number of ISO week-numbering years to the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of ISO week-numbering years to be added.
 *
 * @returns The new date with the ISO week-numbering years added
 *
 * @example
 * // Add 5 ISO week-numbering years to 2 July 2010:
 * const result = addISOWeekYears(new Date(2010, 6, 2), 5)
 * //=> Fri Jn 26 2015 00:00:00
 */ function addISOWeekYears(date, amount) {
    return (0, _index2.setISOWeekYear)(date, (0, _index.getISOWeekYear)(date) + amount);
}

},{"240e5aec3c416c15":"jWChc","39a8cd644c826899":"R19sp"}],"jWChc":[function(require,module,exports) {
"use strict";
exports.getISOWeekYear = getISOWeekYear;
var _index = require("931ddb1ed96783e");
var _index2 = require("657e416c92daae6d");
var _index3 = require("df657aff16d6d4b4");
/**
 * @name getISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the ISO week-numbering year of the given date.
 *
 * @description
 * Get the ISO week-numbering year of the given date,
 * which always starts 3 days before the year's first Thursday.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The ISO week-numbering year
 *
 * @example
 * // Which ISO-week numbering year is 2 January 2005?
 * const result = getISOWeekYear(new Date(2005, 0, 2))
 * //=> 2004
 */ function getISOWeekYear(date) {
    const _date = (0, _index3.toDate)(date);
    const year = _date.getFullYear();
    const fourthOfJanuaryOfNextYear = (0, _index.constructFrom)(date, 0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = (0, _index2.startOfISOWeek)(fourthOfJanuaryOfNextYear);
    const fourthOfJanuaryOfThisYear = (0, _index.constructFrom)(date, 0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = (0, _index2.startOfISOWeek)(fourthOfJanuaryOfThisYear);
    if (_date.getTime() >= startOfNextYear.getTime()) return year + 1;
    else if (_date.getTime() >= startOfThisYear.getTime()) return year;
    else return year - 1;
}

},{"931ddb1ed96783e":"hNMdA","657e416c92daae6d":"iF0wL","df657aff16d6d4b4":"actWA"}],"iF0wL":[function(require,module,exports) {
"use strict";
exports.startOfISOWeek = startOfISOWeek;
var _index = require("af053f1a0e32a5c7");
/**
 * @name startOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the start of an ISO week for the given date.
 *
 * @description
 * Return the start of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of an ISO week
 *
 * @example
 * // The start of an ISO week for 2 September 2014 11:55:00:
 * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */ function startOfISOWeek(date) {
    return (0, _index.startOfWeek)(date, {
        weekStartsOn: 1
    });
}

},{"af053f1a0e32a5c7":"dDDvv"}],"dDDvv":[function(require,module,exports) {
"use strict";
exports.startOfWeek = startOfWeek;
var _index = require("55694623f1e86518");
var _index2 = require("95f2b89022ff2bba");
/**
 * The {@link startOfWeek} function options.
 */ /**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */ function startOfWeek(date, options) {
    const defaultOptions = (0, _index2.getDefaultOptions)();
    const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions.weekStartsOn ?? defaultOptions.locale?.options?.weekStartsOn ?? 0;
    const _date = (0, _index.toDate)(date);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    _date.setDate(_date.getDate() - diff);
    _date.setHours(0, 0, 0, 0);
    return _date;
}

},{"55694623f1e86518":"actWA","95f2b89022ff2bba":"98fau"}],"98fau":[function(require,module,exports) {
"use strict";
exports.getDefaultOptions = getDefaultOptions;
exports.setDefaultOptions = setDefaultOptions;
let defaultOptions = {};
function getDefaultOptions() {
    return defaultOptions;
}
function setDefaultOptions(newOptions) {
    defaultOptions = newOptions;
}

},{}],"R19sp":[function(require,module,exports) {
"use strict";
exports.setISOWeekYear = setISOWeekYear;
var _index = require("b4cc3bf7048ec0f8");
var _index2 = require("63c89f9c4541591a");
var _index3 = require("1aea00dad6bb8db7");
var _index4 = require("e36603a772a1edcb");
/**
 * @name setISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Set the ISO week-numbering year to the given date.
 *
 * @description
 * Set the ISO week-numbering year to the given date,
 * saving the week number and the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param weekYear - The ISO week-numbering year of the new date
 *
 * @returns The new date with the ISO week-numbering year set
 *
 * @example
 * // Set ISO week-numbering year 2007 to 29 December 2008:
 * const result = setISOWeekYear(new Date(2008, 11, 29), 2007)
 * //=> Mon Jan 01 2007 00:00:00
 */ function setISOWeekYear(date, weekYear) {
    let _date = (0, _index4.toDate)(date);
    const diff = (0, _index2.differenceInCalendarDays)(_date, (0, _index3.startOfISOWeekYear)(_date));
    const fourthOfJanuary = (0, _index.constructFrom)(date, 0);
    fourthOfJanuary.setFullYear(weekYear, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    _date = (0, _index3.startOfISOWeekYear)(fourthOfJanuary);
    _date.setDate(_date.getDate() + diff);
    return _date;
}

},{"b4cc3bf7048ec0f8":"hNMdA","63c89f9c4541591a":"dvya7","1aea00dad6bb8db7":"eTm1l","e36603a772a1edcb":"actWA"}],"dvya7":[function(require,module,exports) {
"use strict";
exports.differenceInCalendarDays = differenceInCalendarDays;
var _index = require("1d847bb4e92f7cd2");
var _index2 = require("7c9c2b23ec3dd965");
var _index3 = require("b0f56dce4f1af165");
/**
 * @name differenceInCalendarDays
 * @category Day Helpers
 * @summary Get the number of calendar days between the given dates.
 *
 * @description
 * Get the number of calendar days between the given dates. This means that the times are removed
 * from the dates and then the difference in days is calculated.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of calendar days
 *
 * @example
 * // How many calendar days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInCalendarDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 366
 * // How many calendar days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInCalendarDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 1
 */ function differenceInCalendarDays(dateLeft, dateRight) {
    const startOfDayLeft = (0, _index2.startOfDay)(dateLeft);
    const startOfDayRight = (0, _index2.startOfDay)(dateRight);
    const timestampLeft = startOfDayLeft.getTime() - (0, _index3.getTimezoneOffsetInMilliseconds)(startOfDayLeft);
    const timestampRight = startOfDayRight.getTime() - (0, _index3.getTimezoneOffsetInMilliseconds)(startOfDayRight);
    // Round the number of days to the nearest integer
    // because the number of milliseconds in a day is not constant
    // (e.g. it's different in the day of the daylight saving time clock shift)
    return Math.round((timestampLeft - timestampRight) / _index.millisecondsInDay);
}

},{"1d847bb4e92f7cd2":"1vXXw","7c9c2b23ec3dd965":"iJAa5","b0f56dce4f1af165":"ke6Rl"}],"iJAa5":[function(require,module,exports) {
"use strict";
exports.startOfDay = startOfDay;
var _index = require("b2c84f6728c789fd");
/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a day
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */ function startOfDay(date) {
    const _date = (0, _index.toDate)(date);
    _date.setHours(0, 0, 0, 0);
    return _date;
}

},{"b2c84f6728c789fd":"actWA"}],"ke6Rl":[function(require,module,exports) {
"use strict";
exports.getTimezoneOffsetInMilliseconds = getTimezoneOffsetInMilliseconds; /**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */ 
function getTimezoneOffsetInMilliseconds(date) {
    const utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
    utcDate.setUTCFullYear(date.getFullYear());
    return date.getTime() - utcDate.getTime();
}

},{}],"eTm1l":[function(require,module,exports) {
"use strict";
exports.startOfISOWeekYear = startOfISOWeekYear;
var _index = require("a94c8ed604a9d595");
var _index2 = require("2ab3fd1ace85020d");
var _index3 = require("3de294871cd3bca4");
/**
 * @name startOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the start of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the start of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of an ISO week-numbering year
 *
 * @example
 * // The start of an ISO week-numbering year for 2 July 2005:
 * const result = startOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Mon Jan 03 2005 00:00:00
 */ function startOfISOWeekYear(date) {
    const year = (0, _index.getISOWeekYear)(date);
    const fourthOfJanuary = (0, _index3.constructFrom)(date, 0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    return (0, _index2.startOfISOWeek)(fourthOfJanuary);
}

},{"a94c8ed604a9d595":"jWChc","2ab3fd1ace85020d":"iF0wL","3de294871cd3bca4":"hNMdA"}],"7jsut":[function(require,module,exports) {
"use strict";
exports.addMinutes = addMinutes;
var _index = require("66ff9833f2a7265d");
var _index2 = require("1657f0b8a8702e8e");
/**
 * @name addMinutes
 * @category Minute Helpers
 * @summary Add the specified number of minutes to the given date.
 *
 * @description
 * Add the specified number of minutes to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of minutes to be added.
 *
 * @returns The new date with the minutes added
 *
 * @example
 * // Add 30 minutes to 10 July 2014 12:00:00:
 * const result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 12:30:00
 */ function addMinutes(date, amount) {
    return (0, _index.addMilliseconds)(date, amount * _index2.millisecondsInMinute);
}

},{"66ff9833f2a7265d":"03zTk","1657f0b8a8702e8e":"1vXXw"}],"jW81o":[function(require,module,exports) {
"use strict";
exports.addQuarters = addQuarters;
var _index = require("26f66aa2af34ef45");
/**
 * @name addQuarters
 * @category Quarter Helpers
 * @summary Add the specified number of year quarters to the given date.
 *
 * @description
 * Add the specified number of year quarters to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of quarters to be added.
 *
 * @returns The new date with the quarters added
 *
 * @example
 * // Add 1 quarter to 1 September 2014:
 * const result = addQuarters(new Date(2014, 8, 1), 1)
 * //=> Mon Dec 01 2014 00:00:00
 */ function addQuarters(date, amount) {
    const months = amount * 3;
    return (0, _index.addMonths)(date, months);
}

},{"26f66aa2af34ef45":"alxIr"}],"1jCRu":[function(require,module,exports) {
"use strict";
exports.addSeconds = addSeconds;
var _index = require("7442afe167e053cc");
/**
 * @name addSeconds
 * @category Second Helpers
 * @summary Add the specified number of seconds to the given date.
 *
 * @description
 * Add the specified number of seconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of seconds to be added.
 *
 * @returns The new date with the seconds added
 *
 * @example
 * // Add 30 seconds to 10 July 2014 12:45:00:
 * const result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:45:30
 */ function addSeconds(date, amount) {
    return (0, _index.addMilliseconds)(date, amount * 1000);
}

},{"7442afe167e053cc":"03zTk"}],"6sRN6":[function(require,module,exports) {
"use strict";
exports.addWeeks = addWeeks;
var _index = require("bdd905550c7c5ab9");
/**
 * @name addWeeks
 * @category Week Helpers
 * @summary Add the specified number of weeks to the given date.
 *
 * @description
 * Add the specified number of week to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of weeks to be added.
 *
 * @returns The new date with the weeks added
 *
 * @example
 * // Add 4 weeks to 1 September 2014:
 * const result = addWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Sep 29 2014 00:00:00
 */ function addWeeks(date, amount) {
    const days = amount * 7;
    return (0, _index.addDays)(date, days);
}

},{"bdd905550c7c5ab9":"fL4dR"}],"3IQD4":[function(require,module,exports) {
"use strict";
exports.addYears = addYears;
var _index = require("23e70a355800add9");
/**
 * @name addYears
 * @category Year Helpers
 * @summary Add the specified number of years to the given date.
 *
 * @description
 * Add the specified number of years to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of years to be added.
 *
 * @returns The new date with the years added
 *
 * @example
 * // Add 5 years to 1 September 2014:
 * const result = addYears(new Date(2014, 8, 1), 5)
 * //=> Sun Sep 01 2019 00:00:00
 */ function addYears(date, amount) {
    return (0, _index.addMonths)(date, amount * 12);
}

},{"23e70a355800add9":"alxIr"}],"aub5m":[function(require,module,exports) {
"use strict";
exports.areIntervalsOverlapping = areIntervalsOverlapping;
var _index = require("2d76e30bb886efa");
/**
 * The {@link areIntervalsOverlapping} function options.
 */ /**
 * @name areIntervalsOverlapping
 * @category Interval Helpers
 * @summary Is the given time interval overlapping with another time interval?
 *
 * @description
 * Is the given time interval overlapping with another time interval? Adjacent intervals do not count as overlapping unless `inclusive` is set to `true`.
 *
 * @param intervalLeft - The first interval to compare.
 * @param intervalRight - The second interval to compare.
 * @param options - The object with options
 *
 * @returns Whether the time intervals are overlapping
 *
 * @example
 * // For overlapping time intervals:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }
 * )
 * //=> true
 *
 * @example
 * // For non-overlapping time intervals:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }
 * )
 * //=> false
 *
 * @example
 * // For adjacent time intervals:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 30) }
 * )
 * //=> false
 *
 * @example
 * // Using the inclusive option:
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) }
 * )
 * //=> false
 *
 * @example
 * areIntervalsOverlapping(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 20), end: new Date(2014, 0, 24) },
 *   { inclusive: true }
 * )
 * //=> true
 */ function areIntervalsOverlapping(intervalLeft, intervalRight, options) {
    const [leftStartTime, leftEndTime] = [
        +(0, _index.toDate)(intervalLeft.start),
        +(0, _index.toDate)(intervalLeft.end)
    ].sort((a, b)=>a - b);
    const [rightStartTime, rightEndTime] = [
        +(0, _index.toDate)(intervalRight.start),
        +(0, _index.toDate)(intervalRight.end)
    ].sort((a, b)=>a - b);
    if (options?.inclusive) return leftStartTime <= rightEndTime && rightStartTime <= leftEndTime;
    return leftStartTime < rightEndTime && rightStartTime < leftEndTime;
}

},{"2d76e30bb886efa":"actWA"}],"3tdAJ":[function(require,module,exports) {
"use strict";
exports.clamp = clamp;
var _index = require("8d0762524d7d24c3");
var _index2 = require("9daecf252ffff30");
/**
 * @name clamp
 * @category Interval Helpers
 * @summary Return a date bounded by the start and the end of the given interval
 *
 * @description
 * Clamps a date to the lower bound with the start of the interval and the upper
 * bound with the end of the interval.
 *
 * - When the date is less than the start of the interval, the start is returned.
 * - When the date is greater than the end of the interval, the end is returned.
 * - Otherwise the date is returned.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be bounded
 * @param interval - The interval to bound to
 *
 * @returns The date bounded by the start and the end of the interval
 *
 * @example
 * // What is Mar, 21, 2021 bounded to an interval starting at Mar, 22, 2021 and ending at Apr, 01, 2021
 * const result = clamp(new Date(2021, 2, 21), {
 *   start: new Date(2021, 2, 22),
 *   end: new Date(2021, 3, 1),
 * })
 * //=> Mon Mar 22 2021 00:00:00
 */ function clamp(date, interval) {
    return (0, _index2.min)([
        (0, _index.max)([
            date,
            interval.start
        ]),
        interval.end
    ]);
}

},{"8d0762524d7d24c3":"hWZFG","9daecf252ffff30":"gP0ns"}],"hWZFG":[function(require,module,exports) {
"use strict";
exports.max = max;
var _index = require("f9ba4fa55e935c4f");
/**
 * @name max
 * @category Common Helpers
 * @summary Return the latest of the given dates.
 *
 * @description
 * Return the latest of the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dates - The dates to compare
 *
 * @returns The latest of the dates
 *
 * @example
 * // Which of these dates is the latest?
 * const result = max([
 *   new Date(1989, 6, 10),
 *   new Date(1987, 1, 11),
 *   new Date(1995, 6, 2),
 *   new Date(1990, 0, 1)
 * ])
 * //=> Sun Jul 02 1995 00:00:00
 */ function max(dates) {
    let result;
    dates.forEach(function(dirtyDate) {
        const currentDate = (0, _index.toDate)(dirtyDate);
        if (result === undefined || result < currentDate || isNaN(Number(currentDate))) result = currentDate;
    });
    return result || new Date(NaN);
}

},{"f9ba4fa55e935c4f":"actWA"}],"gP0ns":[function(require,module,exports) {
"use strict";
exports.min = min;
var _index = require("940af7ed75f79352");
/**
 * @name min
 * @category Common Helpers
 * @summary Returns the earliest of the given dates.
 *
 * @description
 * Returns the earliest of the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dates - The dates to compare
 *
 * @returns The earliest of the dates
 *
 * @example
 * // Which of these dates is the earliest?
 * const result = min([
 *   new Date(1989, 6, 10),
 *   new Date(1987, 1, 11),
 *   new Date(1995, 6, 2),
 *   new Date(1990, 0, 1)
 * ])
 * //=> Wed Feb 11 1987 00:00:00
 */ function min(dates) {
    let result;
    dates.forEach((dirtyDate)=>{
        const date = (0, _index.toDate)(dirtyDate);
        if (!result || result > date || isNaN(+date)) result = date;
    });
    return result || new Date(NaN);
}

},{"940af7ed75f79352":"actWA"}],"g75Mq":[function(require,module,exports) {
"use strict";
exports.closestIndexTo = closestIndexTo;
var _index = require("3196192380086bd1");
/**
 * @name closestIndexTo
 * @category Common Helpers
 * @summary Return an index of the closest date from the array comparing to the given date.
 *
 * @description
 * Return an index of the closest date from the array comparing to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateToCompare - The date to compare with
 * @param dates - The array to search
 *
 * @returns An index of the date closest to the given date or undefined if no valid value is given
 *
 * @example
 * // Which date is closer to 6 September 2015?
 * const dateToCompare = new Date(2015, 8, 6)
 * const datesArray = [
 *   new Date(2015, 0, 1),
 *   new Date(2016, 0, 1),
 *   new Date(2017, 0, 1)
 * ]
 * const result = closestIndexTo(dateToCompare, datesArray)
 * //=> 1
 */ function closestIndexTo(dateToCompare, dates) {
    const date = (0, _index.toDate)(dateToCompare);
    if (isNaN(Number(date))) return NaN;
    const timeToCompare = date.getTime();
    let result;
    let minDistance;
    dates.forEach(function(dirtyDate, index) {
        const currentDate = (0, _index.toDate)(dirtyDate);
        if (isNaN(Number(currentDate))) {
            result = NaN;
            minDistance = NaN;
            return;
        }
        const distance = Math.abs(timeToCompare - currentDate.getTime());
        if (result == null || distance < minDistance) {
            result = index;
            minDistance = distance;
        }
    });
    return result;
}

},{"3196192380086bd1":"actWA"}],"5V5JV":[function(require,module,exports) {
"use strict";
exports.closestTo = closestTo;
var _index = require("2129694b6ecff958");
var _index2 = require("f52f0bbca64b2801");
/**
 * @name closestTo
 * @category Common Helpers
 * @summary Return a date from the array closest to the given date.
 *
 * @description
 * Return a date from the array closest to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateToCompare - The date to compare with
 * @param dates - The array to search
 *
 * @returns The date from the array closest to the given date or undefined if no valid value is given
 *
 * @example
 * // Which date is closer to 6 September 2015: 1 January 2000 or 1 January 2030?
 * const dateToCompare = new Date(2015, 8, 6)
 * const result = closestTo(dateToCompare, [
 *   new Date(2000, 0, 1),
 *   new Date(2030, 0, 1)
 * ])
 * //=> Tue Jan 01 2030 00:00:00
 */ function closestTo(dateToCompare, dates) {
    const date = (0, _index2.toDate)(dateToCompare);
    if (isNaN(Number(date))) return (0, _index.constructFrom)(dateToCompare, NaN);
    const timeToCompare = date.getTime();
    let result;
    let minDistance;
    dates.forEach((dirtyDate)=>{
        const currentDate = (0, _index2.toDate)(dirtyDate);
        if (isNaN(Number(currentDate))) {
            result = (0, _index.constructFrom)(dateToCompare, NaN);
            minDistance = NaN;
            return;
        }
        const distance = Math.abs(timeToCompare - currentDate.getTime());
        if (result == null || distance < minDistance) {
            result = currentDate;
            minDistance = distance;
        }
    });
    return result;
}

},{"2129694b6ecff958":"hNMdA","f52f0bbca64b2801":"actWA"}],"fgd9M":[function(require,module,exports) {
"use strict";
exports.compareAsc = compareAsc;
var _index = require("77d3d08d6b71c9bb");
/**
 * @name compareAsc
 * @category Common Helpers
 * @summary Compare the two dates and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return 1 if the first date is after the second,
 * -1 if the first date is before the second or 0 if dates are equal.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to compare
 * @param dateRight - The second date to compare
 *
 * @returns The result of the comparison
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989:
 * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
 * //=> -1
 *
 * @example
 * // Sort the array of dates:
 * const result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareAsc)
 * //=> [
 * //   Wed Feb 11 1987 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Sun Jul 02 1995 00:00:00
 * // ]
 */ function compareAsc(dateLeft, dateRight) {
    const _dateLeft = (0, _index.toDate)(dateLeft);
    const _dateRight = (0, _index.toDate)(dateRight);
    const diff = _dateLeft.getTime() - _dateRight.getTime();
    if (diff < 0) return -1;
    else if (diff > 0) return 1;
    else return diff;
}

},{"77d3d08d6b71c9bb":"actWA"}],"38snE":[function(require,module,exports) {
"use strict";
exports.compareDesc = compareDesc;
var _index = require("989301f18cf866f6");
/**
 * @name compareDesc
 * @category Common Helpers
 * @summary Compare the two dates reverse chronologically and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return -1 if the first date is after the second,
 * 1 if the first date is before the second or 0 if dates are equal.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to compare
 * @param dateRight - The second date to compare
 *
 * @returns The result of the comparison
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989 reverse chronologically:
 * const result = compareDesc(new Date(1987, 1, 11), new Date(1989, 6, 10))
 * //=> 1
 *
 * @example
 * // Sort the array of dates in reverse chronological order:
 * const result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareDesc)
 * //=> [
 * //   Sun Jul 02 1995 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Wed Feb 11 1987 00:00:00
 * // ]
 */ function compareDesc(dateLeft, dateRight) {
    const _dateLeft = (0, _index.toDate)(dateLeft);
    const _dateRight = (0, _index.toDate)(dateRight);
    const diff = _dateLeft.getTime() - _dateRight.getTime();
    if (diff > 0) return -1;
    else if (diff < 0) return 1;
    else return diff;
}

},{"989301f18cf866f6":"actWA"}],"jR9nm":[function(require,module,exports) {
"use strict";
exports.daysToWeeks = daysToWeeks;
var _index = require("458db80672ef81c4");
/**
 * @name daysToWeeks
 * @category Conversion Helpers
 * @summary Convert days to weeks.
 *
 * @description
 * Convert a number of days to a full number of weeks.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param days - The number of days to be converted
 *
 * @returns The number of days converted in weeks
 *
 * @example
 * // Convert 14 days to weeks:
 * const result = daysToWeeks(14)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = daysToWeeks(13)
 * //=> 1
 */ function daysToWeeks(days) {
    const weeks = days / _index.daysInWeek;
    return Math.floor(weeks);
}

},{"458db80672ef81c4":"1vXXw"}],"cJL23":[function(require,module,exports) {
"use strict";
exports.differenceInBusinessDays = differenceInBusinessDays;
var _index = require("ea3fe27b701c003c");
var _index2 = require("6f3a4a6076f75f84");
var _index3 = require("812333c7aacd1559");
var _index4 = require("d81b0b3e475edc9a");
var _index5 = require("a08b9b6aa91d4ca8");
var _index6 = require("14560170b9ef0dc7");
/**
 * @name differenceInBusinessDays
 * @category Day Helpers
 * @summary Get the number of business days between the given dates.
 *
 * @description
 * Get the number of business day periods between the given dates.
 * Business days being days that arent in the weekend.
 * Like `differenceInCalendarDays`, the function removes the times from
 * the dates before calculating the difference.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of business days
 *
 * @example
 * // How many business days are between
 * // 10 January 2014 and 20 July 2014?
 * const result = differenceInBusinessDays(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 0, 10)
 * )
 * //=> 136
 *
 * // How many business days are between
 * // 30 November 2021 and 1 November 2021?
 * const result = differenceInBusinessDays(
 *   new Date(2021, 10, 30),
 *   new Date(2021, 10, 1)
 * )
 * //=> 21
 *
 * // How many business days are between
 * // 1 November 2021 and 1 December 2021?
 * const result = differenceInBusinessDays(
 *   new Date(2021, 10, 1),
 *   new Date(2021, 11, 1)
 * )
 * //=> -22
 *
 * // How many business days are between
 * // 1 November 2021 and 1 November 2021 ?
 * const result = differenceInBusinessDays(
 *   new Date(2021, 10, 1),
 *   new Date(2021, 10, 1)
 * )
 * //=> 0
 */ function differenceInBusinessDays(dateLeft, dateRight) {
    const _dateLeft = (0, _index6.toDate)(dateLeft);
    let _dateRight = (0, _index6.toDate)(dateRight);
    if (!(0, _index4.isValid)(_dateLeft) || !(0, _index4.isValid)(_dateRight)) return NaN;
    const calendarDifference = (0, _index2.differenceInCalendarDays)(_dateLeft, _dateRight);
    const sign = calendarDifference < 0 ? -1 : 1;
    const weeks = Math.trunc(calendarDifference / 7);
    let result = weeks * 5;
    _dateRight = (0, _index.addDays)(_dateRight, weeks * 7);
    // the loop below will run at most 6 times to account for the remaining days that don't makeup a full week
    while(!(0, _index3.isSameDay)(_dateLeft, _dateRight)){
        // sign is used to account for both negative and positive differences
        result += (0, _index5.isWeekend)(_dateRight) ? 0 : sign;
        _dateRight = (0, _index.addDays)(_dateRight, sign);
    }
    // Prevent negative zero
    return result === 0 ? 0 : result;
}

},{"ea3fe27b701c003c":"fL4dR","6f3a4a6076f75f84":"dvya7","812333c7aacd1559":"7FjQf","d81b0b3e475edc9a":"gbOJY","a08b9b6aa91d4ca8":"hvqeH","14560170b9ef0dc7":"actWA"}],"7FjQf":[function(require,module,exports) {
"use strict";
exports.isSameDay = isSameDay;
var _index = require("404d3af83c6a3510");
/**
 * @name isSameDay
 * @category Day Helpers
 * @summary Are the given dates in the same day (and year and month)?
 *
 * @description
 * Are the given dates in the same day (and year and month)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check

 * @returns The dates are in the same day (and year and month)
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
 * //=> true
 *
 * @example
 * // Are 4 September and 4 October in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
 * //=> false
 *
 * @example
 * // Are 4 September, 2014 and 4 September, 2015 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
 * //=> false
 */ function isSameDay(dateLeft, dateRight) {
    const dateLeftStartOfDay = (0, _index.startOfDay)(dateLeft);
    const dateRightStartOfDay = (0, _index.startOfDay)(dateRight);
    return +dateLeftStartOfDay === +dateRightStartOfDay;
}

},{"404d3af83c6a3510":"iJAa5"}],"gbOJY":[function(require,module,exports) {
"use strict";
exports.isValid = isValid;
var _index = require("187bc6a11beb8cf7");
var _index2 = require("fd0d651c7906f3f7");
/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate](https://date-fns.org/docs/toDate)
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is valid
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */ function isValid(date) {
    if (!(0, _index.isDate)(date) && typeof date !== "number") return false;
    const _date = (0, _index2.toDate)(date);
    return !isNaN(Number(_date));
}

},{"187bc6a11beb8cf7":"c3MYB","fd0d651c7906f3f7":"actWA"}],"c3MYB":[function(require,module,exports) {
"use strict";
exports.isDate = isDate; /**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param value - The value to check
 *
 * @returns True if the given value is a date
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */ 
function isDate(value) {
    return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

},{}],"1uuCg":[function(require,module,exports) {
"use strict";
exports.differenceInCalendarISOWeekYears = differenceInCalendarISOWeekYears;
var _index = require("4eb2262692255916");
/**
 * @name differenceInCalendarISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the number of calendar ISO week-numbering years between the given dates.
 *
 * @description
 * Get the number of calendar ISO week-numbering years between the given dates.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of calendar ISO week-numbering years
 *
 * @example
 * // How many calendar ISO week-numbering years are 1 January 2010 and 1 January 2012?
 * const result = differenceInCalendarISOWeekYears(
 *   new Date(2012, 0, 1),
 *   new Date(2010, 0, 1)
 * )
 * //=> 2
 */ function differenceInCalendarISOWeekYears(dateLeft, dateRight) {
    return (0, _index.getISOWeekYear)(dateLeft) - (0, _index.getISOWeekYear)(dateRight);
}

},{"4eb2262692255916":"jWChc"}],"5Kgvn":[function(require,module,exports) {
"use strict";
exports.differenceInCalendarISOWeeks = differenceInCalendarISOWeeks;
var _index = require("e8e10057c2841ad2");
var _index2 = require("76e957d25fb54854");
var _index3 = require("28419d92c5150a1");
/**
 * @name differenceInCalendarISOWeeks
 * @category ISO Week Helpers
 * @summary Get the number of calendar ISO weeks between the given dates.
 *
 * @description
 * Get the number of calendar ISO weeks between the given dates.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of calendar ISO weeks
 *
 * @example
 * // How many calendar ISO weeks are between 6 July 2014 and 21 July 2014?
 * const result = differenceInCalendarISOWeeks(
 *   new Date(2014, 6, 21),
 *   new Date(2014, 6, 6)
 * )
 * //=> 3
 */ function differenceInCalendarISOWeeks(dateLeft, dateRight) {
    const startOfISOWeekLeft = (0, _index2.startOfISOWeek)(dateLeft);
    const startOfISOWeekRight = (0, _index2.startOfISOWeek)(dateRight);
    const timestampLeft = startOfISOWeekLeft.getTime() - (0, _index3.getTimezoneOffsetInMilliseconds)(startOfISOWeekLeft);
    const timestampRight = startOfISOWeekRight.getTime() - (0, _index3.getTimezoneOffsetInMilliseconds)(startOfISOWeekRight);
    // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round((timestampLeft - timestampRight) / _index.millisecondsInWeek);
}

},{"e8e10057c2841ad2":"1vXXw","76e957d25fb54854":"iF0wL","28419d92c5150a1":"ke6Rl"}],"21Qeg":[function(require,module,exports) {
"use strict";
exports.differenceInCalendarMonths = differenceInCalendarMonths;
var _index = require("34e2e1517bca82c6");
/**
 * @name differenceInCalendarMonths
 * @category Month Helpers
 * @summary Get the number of calendar months between the given dates.
 *
 * @description
 * Get the number of calendar months between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of calendar months
 *
 * @example
 * // How many calendar months are between 31 January 2014 and 1 September 2014?
 * const result = differenceInCalendarMonths(
 *   new Date(2014, 8, 1),
 *   new Date(2014, 0, 31)
 * )
 * //=> 8
 */ function differenceInCalendarMonths(dateLeft, dateRight) {
    const _dateLeft = (0, _index.toDate)(dateLeft);
    const _dateRight = (0, _index.toDate)(dateRight);
    const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
    const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();
    return yearDiff * 12 + monthDiff;
}

},{"34e2e1517bca82c6":"actWA"}],"kWjSX":[function(require,module,exports) {
"use strict";
exports.differenceInCalendarQuarters = differenceInCalendarQuarters;
var _index = require("12f69708f4660b9e");
var _index2 = require("58e123be031d7c1");
/**
 * @name differenceInCalendarQuarters
 * @category Quarter Helpers
 * @summary Get the number of calendar quarters between the given dates.
 *
 * @description
 * Get the number of calendar quarters between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date

 * @returns The number of calendar quarters
 *
 * @example
 * // How many calendar quarters are between 31 December 2013 and 2 July 2014?
 * const result = differenceInCalendarQuarters(
 *   new Date(2014, 6, 2),
 *   new Date(2013, 11, 31)
 * )
 * //=> 3
 */ function differenceInCalendarQuarters(dateLeft, dateRight) {
    const _dateLeft = (0, _index2.toDate)(dateLeft);
    const _dateRight = (0, _index2.toDate)(dateRight);
    const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
    const quarterDiff = (0, _index.getQuarter)(_dateLeft) - (0, _index.getQuarter)(_dateRight);
    return yearDiff * 4 + quarterDiff;
}

},{"12f69708f4660b9e":"cr73f","58e123be031d7c1":"actWA"}],"cr73f":[function(require,module,exports) {
"use strict";
exports.getQuarter = getQuarter;
var _index = require("ad58fc3c2407157b");
/**
 * @name getQuarter
 * @category Quarter Helpers
 * @summary Get the year quarter of the given date.
 *
 * @description
 * Get the year quarter of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The quarter
 *
 * @example
 * // Which quarter is 2 July 2014?
 * const result = getQuarter(new Date(2014, 6, 2))
 * //=> 3
 */ function getQuarter(date) {
    const _date = (0, _index.toDate)(date);
    const quarter = Math.floor(_date.getMonth() / 3) + 1;
    return quarter;
}

},{"ad58fc3c2407157b":"actWA"}],"iWbGJ":[function(require,module,exports) {
"use strict";
exports.differenceInCalendarWeeks = differenceInCalendarWeeks;
var _index = require("979fbac2b02bbe0b");
var _index2 = require("902483a1e2e2edee");
var _index3 = require("2df47d81bbcabf9b");
/**
 * The {@link differenceInCalendarWeeks} function options.
 */ /**
 * @name differenceInCalendarWeeks
 * @category Week Helpers
 * @summary Get the number of calendar weeks between the given dates.
 *
 * @description
 * Get the number of calendar weeks between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of calendar weeks
 *
 * @example
 * // How many calendar weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInCalendarWeeks(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 6, 5)
 * )
 * //=> 3
 *
 * @example
 * // If the week starts on Monday,
 * // how many calendar weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInCalendarWeeks(
 *   new Date(2014, 6, 20),
 *   new Date(2014, 6, 5),
 *   { weekStartsOn: 1 }
 * )
 * //=> 2
 */ function differenceInCalendarWeeks(dateLeft, dateRight, options) {
    const startOfWeekLeft = (0, _index2.startOfWeek)(dateLeft, options);
    const startOfWeekRight = (0, _index2.startOfWeek)(dateRight, options);
    const timestampLeft = startOfWeekLeft.getTime() - (0, _index3.getTimezoneOffsetInMilliseconds)(startOfWeekLeft);
    const timestampRight = startOfWeekRight.getTime() - (0, _index3.getTimezoneOffsetInMilliseconds)(startOfWeekRight);
    // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round((timestampLeft - timestampRight) / _index.millisecondsInWeek);
}

},{"979fbac2b02bbe0b":"1vXXw","902483a1e2e2edee":"dDDvv","2df47d81bbcabf9b":"ke6Rl"}],"e0VtU":[function(require,module,exports) {
"use strict";
exports.differenceInCalendarYears = differenceInCalendarYears;
var _index = require("9559183fd654047");
/**
 * @name differenceInCalendarYears
 * @category Year Helpers
 * @summary Get the number of calendar years between the given dates.
 *
 * @description
 * Get the number of calendar years between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date

 * @returns The number of calendar years
 *
 * @example
 * // How many calendar years are between 31 December 2013 and 11 February 2015?
 * const result = differenceInCalendarYears(
 *   new Date(2015, 1, 11),
 *   new Date(2013, 11, 31)
 * )
 * //=> 2
 */ function differenceInCalendarYears(dateLeft, dateRight) {
    const _dateLeft = (0, _index.toDate)(dateLeft);
    const _dateRight = (0, _index.toDate)(dateRight);
    return _dateLeft.getFullYear() - _dateRight.getFullYear();
}

},{"9559183fd654047":"actWA"}],"fJoFi":[function(require,module,exports) {
"use strict";
exports.differenceInDays = differenceInDays;
var _index = require("5c37c887163a278c");
var _index2 = require("9efbb8d3712b0f85");
/**
 * @name differenceInDays
 * @category Day Helpers
 * @summary Get the number of full days between the given dates.
 *
 * @description
 * Get the number of full day periods between two dates. Fractional days are
 * truncated towards zero.
 *
 * One "full day" is the distance between a local time in one day to the same
 * local time on the next or previous day. A full day can sometimes be less than
 * or more than 24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 24-hour periods, use this instead:
 * `Math.floor(differenceInHours(dateLeft, dateRight)/24)|0`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of full days according to the local timezone
 *
 * @example
 * // How many full days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * const result = differenceInDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 365
 *
 * @example
 * // How many full days are between
 * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
 * const result = differenceInDays(
 *   new Date(2011, 6, 3, 0, 1),
 *   new Date(2011, 6, 2, 23, 59)
 * )
 * //=> 0
 *
 * @example
 * // How many full days are between
 * // 1 March 2020 0:00 and 1 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 92 days, even in
 * // time zones where DST starts and the
 * // period has only 92*24-1 hours.
 * const result = differenceInDays(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 1)
 * )
 * //=> 92
 */ function differenceInDays(dateLeft, dateRight) {
    const _dateLeft = (0, _index2.toDate)(dateLeft);
    const _dateRight = (0, _index2.toDate)(dateRight);
    const sign = compareLocalAsc(_dateLeft, _dateRight);
    const difference = Math.abs((0, _index.differenceInCalendarDays)(_dateLeft, _dateRight));
    _dateLeft.setDate(_dateLeft.getDate() - sign * difference);
    // Math.abs(diff in full days - diff in calendar days) === 1 if last calendar day is not full
    // If so, result must be decreased by 1 in absolute value
    const isLastDayNotFull = Number(compareLocalAsc(_dateLeft, _dateRight) === -sign);
    const result = sign * (difference - isLastDayNotFull);
    // Prevent negative zero
    return result === 0 ? 0 : result;
}
// Like `compareAsc` but uses local time not UTC, which is needed
// for accurate equality comparisons of UTC timestamps that end up
// having the same representation in local time, e.g. one hour before
// DST ends vs. the instant that DST ends.
function compareLocalAsc(dateLeft, dateRight) {
    const diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
    if (diff < 0) return -1;
    else if (diff > 0) return 1;
    else return diff;
}

},{"5c37c887163a278c":"dvya7","9efbb8d3712b0f85":"actWA"}],"jnteW":[function(require,module,exports) {
"use strict";
exports.differenceInHours = differenceInHours;
var _index = require("4dd5860fb0431182");
var _index2 = require("56aaea21c2c2ca02");
var _index3 = require("e5398dd549d98ad7");
/**
 * The {@link differenceInHours} function options.
 */ /**
 * @name differenceInHours
 * @category Hour Helpers
 * @summary Get the number of hours between the given dates.
 *
 * @description
 * Get the number of hours between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of hours
 *
 * @example
 * // How many hours are between 2 July 2014 06:50:00 and 2 July 2014 19:00:00?
 * const result = differenceInHours(
 *   new Date(2014, 6, 2, 19, 0),
 *   new Date(2014, 6, 2, 6, 50)
 * )
 * //=> 12
 */ function differenceInHours(dateLeft, dateRight, options) {
    const diff = (0, _index3.differenceInMilliseconds)(dateLeft, dateRight) / _index2.millisecondsInHour;
    return (0, _index.getRoundingMethod)(options?.roundingMethod)(diff);
}

},{"4dd5860fb0431182":"1ipL6","56aaea21c2c2ca02":"1vXXw","e5398dd549d98ad7":"jkwjj"}],"1ipL6":[function(require,module,exports) {
"use strict";
exports.getRoundingMethod = getRoundingMethod;
function getRoundingMethod(method) {
    return method ? Math[method] : Math.trunc;
}

},{}],"jkwjj":[function(require,module,exports) {
"use strict";
exports.differenceInMilliseconds = differenceInMilliseconds;
var _index = require("8ec07446db1e8840");
/**
 * @name differenceInMilliseconds
 * @category Millisecond Helpers
 * @summary Get the number of milliseconds between the given dates.
 *
 * @description
 * Get the number of milliseconds between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of milliseconds
 *
 * @example
 * // How many milliseconds are between
 * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
 * const result = differenceInMilliseconds(
 *   new Date(2014, 6, 2, 12, 30, 21, 700),
 *   new Date(2014, 6, 2, 12, 30, 20, 600)
 * )
 * //=> 1100
 */ function differenceInMilliseconds(dateLeft, dateRight) {
    return (0, _index.toDate)(dateLeft).getTime() - (0, _index.toDate)(dateRight).getTime();
}

},{"8ec07446db1e8840":"actWA"}],"5PiM9":[function(require,module,exports) {
"use strict";
exports.differenceInISOWeekYears = differenceInISOWeekYears;
var _index = require("3478a3b03bc559c3");
var _index2 = require("217c0aa6a88937bf");
var _index3 = require("f385e83eefe5d06b");
var _index4 = require("7ed50186937b4ccf");
/**
 * @name differenceInISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the number of full ISO week-numbering years between the given dates.
 *
 * @description
 * Get the number of full ISO week-numbering years between the given dates.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of full ISO week-numbering years
 *
 * @example
 * // How many full ISO week-numbering years are between 1 January 2010 and 1 January 2012?
 * const result = differenceInISOWeekYears(
 *   new Date(2012, 0, 1),
 *   new Date(2010, 0, 1)
 * )
 * //=> 1
 */ function differenceInISOWeekYears(dateLeft, dateRight) {
    let _dateLeft = (0, _index4.toDate)(dateLeft);
    const _dateRight = (0, _index4.toDate)(dateRight);
    const sign = (0, _index.compareAsc)(_dateLeft, _dateRight);
    const difference = Math.abs((0, _index2.differenceInCalendarISOWeekYears)(_dateLeft, _dateRight));
    _dateLeft = (0, _index3.subISOWeekYears)(_dateLeft, sign * difference);
    // Math.abs(diff in full ISO years - diff in calendar ISO years) === 1
    // if last calendar ISO year is not full
    // If so, result must be decreased by 1 in absolute value
    const isLastISOWeekYearNotFull = Number((0, _index.compareAsc)(_dateLeft, _dateRight) === -sign);
    const result = sign * (difference - isLastISOWeekYearNotFull);
    // Prevent negative zero
    return result === 0 ? 0 : result;
}

},{"3478a3b03bc559c3":"fgd9M","217c0aa6a88937bf":"1uuCg","f385e83eefe5d06b":"gF8jx","7ed50186937b4ccf":"actWA"}],"gF8jx":[function(require,module,exports) {
"use strict";
exports.subISOWeekYears = subISOWeekYears;
var _index = require("3905690fe6f022ae");
/**
 * @name subISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Subtract the specified number of ISO week-numbering years from the given date.
 *
 * @description
 * Subtract the specified number of ISO week-numbering years from the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of ISO week-numbering years to be subtracted.
 *
 * @returns The new date with the ISO week-numbering years subtracted
 *
 * @example
 * // Subtract 5 ISO week-numbering years from 1 September 2014:
 * const result = subISOWeekYears(new Date(2014, 8, 1), 5)
 * //=> Mon Aug 31 2009 00:00:00
 */ function subISOWeekYears(date, amount) {
    return (0, _index.addISOWeekYears)(date, -amount);
}

},{"3905690fe6f022ae":"eZQAV"}],"Z5oWO":[function(require,module,exports) {
"use strict";
exports.differenceInMinutes = differenceInMinutes;
var _index = require("28ce40c001fe7733");
var _index2 = require("4d59f4904ce4a6bf");
var _index3 = require("5cff05241f86c567");
/**
 * The {@link differenceInMinutes} function options.
 */ /**
 * @name differenceInMinutes
 * @category Minute Helpers
 * @summary Get the number of minutes between the given dates.
 *
 * @description
 * Get the signed number of full (rounded towards 0) minutes between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of minutes
 *
 * @example
 * // How many minutes are between 2 July 2014 12:07:59 and 2 July 2014 12:20:00?
 * const result = differenceInMinutes(
 *   new Date(2014, 6, 2, 12, 20, 0),
 *   new Date(2014, 6, 2, 12, 7, 59)
 * )
 * //=> 12
 *
 * @example
 * // How many minutes are between 10:01:59 and 10:00:00
 * const result = differenceInMinutes(
 *   new Date(2000, 0, 1, 10, 0, 0),
 *   new Date(2000, 0, 1, 10, 1, 59)
 * )
 * //=> -1
 */ function differenceInMinutes(dateLeft, dateRight, options) {
    const diff = (0, _index3.differenceInMilliseconds)(dateLeft, dateRight) / _index2.millisecondsInMinute;
    return (0, _index.getRoundingMethod)(options?.roundingMethod)(diff);
}

},{"28ce40c001fe7733":"1ipL6","4d59f4904ce4a6bf":"1vXXw","5cff05241f86c567":"jkwjj"}],"i3gFX":[function(require,module,exports) {
"use strict";
exports.differenceInMonths = differenceInMonths;
var _index = require("838b792ca9e8e9a9");
var _index2 = require("7cbbd162b316b88f");
var _index3 = require("7b8f4dc46ede6d38");
var _index4 = require("ea5c11a925493689");
/**
 * @name differenceInMonths
 * @category Month Helpers
 * @summary Get the number of full months between the given dates.
 *
 * @description
 * Get the number of full months between the given dates using trunc as a default rounding method.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of full months
 *
 * @example
 * // How many full months are between 31 January 2014 and 1 September 2014?
 * const result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))
 * //=> 7
 */ function differenceInMonths(dateLeft, dateRight) {
    const _dateLeft = (0, _index4.toDate)(dateLeft);
    const _dateRight = (0, _index4.toDate)(dateRight);
    const sign = (0, _index.compareAsc)(_dateLeft, _dateRight);
    const difference = Math.abs((0, _index2.differenceInCalendarMonths)(_dateLeft, _dateRight));
    let result;
    // Check for the difference of less than month
    if (difference < 1) result = 0;
    else {
        if (_dateLeft.getMonth() === 1 && _dateLeft.getDate() > 27) // This will check if the date is end of Feb and assign a higher end of month date
        // to compare it with Jan
        _dateLeft.setDate(30);
        _dateLeft.setMonth(_dateLeft.getMonth() - sign * difference);
        // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
        // If so, result must be decreased by 1 in absolute value
        let isLastMonthNotFull = (0, _index.compareAsc)(_dateLeft, _dateRight) === -sign;
        // Check for cases of one full calendar month
        if ((0, _index3.isLastDayOfMonth)((0, _index4.toDate)(dateLeft)) && difference === 1 && (0, _index.compareAsc)(dateLeft, _dateRight) === 1) isLastMonthNotFull = false;
        result = sign * (difference - Number(isLastMonthNotFull));
    }
    // Prevent negative zero
    return result === 0 ? 0 : result;
}

},{"838b792ca9e8e9a9":"fgd9M","7cbbd162b316b88f":"21Qeg","7b8f4dc46ede6d38":"9dpYu","ea5c11a925493689":"actWA"}],"9dpYu":[function(require,module,exports) {
"use strict";
exports.isLastDayOfMonth = isLastDayOfMonth;
var _index = require("585928d6294ab972");
var _index2 = require("9da618b70e7537e6");
var _index3 = require("3d052479f78fcd0a");
/**
 * @name isLastDayOfMonth
 * @category Month Helpers
 * @summary Is the given date the last day of a month?
 *
 * @description
 * Is the given date the last day of a month?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check

 * @returns The date is the last day of a month
 *
 * @example
 * // Is 28 February 2014 the last day of a month?
 * const result = isLastDayOfMonth(new Date(2014, 1, 28))
 * //=> true
 */ function isLastDayOfMonth(date) {
    const _date = (0, _index3.toDate)(date);
    return +(0, _index.endOfDay)(_date) === +(0, _index2.endOfMonth)(_date);
}

},{"585928d6294ab972":"jtO7f","9da618b70e7537e6":"kcCWM","3d052479f78fcd0a":"actWA"}],"jtO7f":[function(require,module,exports) {
"use strict";
exports.endOfDay = endOfDay;
var _index = require("9462caeddacab7ba");
/**
 * @name endOfDay
 * @category Day Helpers
 * @summary Return the end of a day for the given date.
 *
 * @description
 * Return the end of a day for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a day
 *
 * @example
 * // The end of a day for 2 September 2014 11:55:00:
 * const result = endOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 23:59:59.999
 */ function endOfDay(date) {
    const _date = (0, _index.toDate)(date);
    _date.setHours(23, 59, 59, 999);
    return _date;
}

},{"9462caeddacab7ba":"actWA"}],"kcCWM":[function(require,module,exports) {
"use strict";
exports.endOfMonth = endOfMonth;
var _index = require("4700e89a3c2bdc3a");
/**
 * @name endOfMonth
 * @category Month Helpers
 * @summary Return the end of a month for the given date.
 *
 * @description
 * Return the end of a month for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a month
 *
 * @example
 * // The end of a month for 2 September 2014 11:55:00:
 * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */ function endOfMonth(date) {
    const _date = (0, _index.toDate)(date);
    const month = _date.getMonth();
    _date.setFullYear(_date.getFullYear(), month + 1, 0);
    _date.setHours(23, 59, 59, 999);
    return _date;
}

},{"4700e89a3c2bdc3a":"actWA"}],"eSams":[function(require,module,exports) {
"use strict";
exports.differenceInQuarters = differenceInQuarters;
var _index = require("ea003389a7c0a0c7");
var _index2 = require("65b8c31c2449132c");
/**
 * The {@link differenceInQuarters} function options.
 */ /**
 * @name differenceInQuarters
 * @category Quarter Helpers
 * @summary Get the number of quarters between the given dates.
 *
 * @description
 * Get the number of quarters between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of full quarters
 *
 * @example
 * // How many full quarters are between 31 December 2013 and 2 July 2014?
 * const result = differenceInQuarters(new Date(2014, 6, 2), new Date(2013, 11, 31))
 * //=> 2
 */ function differenceInQuarters(dateLeft, dateRight, options) {
    const diff = (0, _index2.differenceInMonths)(dateLeft, dateRight) / 3;
    return (0, _index.getRoundingMethod)(options?.roundingMethod)(diff);
}

},{"ea003389a7c0a0c7":"1ipL6","65b8c31c2449132c":"i3gFX"}],"3IvxJ":[function(require,module,exports) {
"use strict";
exports.differenceInSeconds = differenceInSeconds;
var _index = require("bc308401ae80fd9e");
var _index2 = require("15eb048bf635cf19");
/**
 * The {@link differenceInSeconds} function options.
 */ /**
 * @name differenceInSeconds
 * @category Second Helpers
 * @summary Get the number of seconds between the given dates.
 *
 * @description
 * Get the number of seconds between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options.
 *
 * @returns The number of seconds
 *
 * @example
 * // How many seconds are between
 * // 2 July 2014 12:30:07.999 and 2 July 2014 12:30:20.000?
 * const result = differenceInSeconds(
 *   new Date(2014, 6, 2, 12, 30, 20, 0),
 *   new Date(2014, 6, 2, 12, 30, 7, 999)
 * )
 * //=> 12
 */ function differenceInSeconds(dateLeft, dateRight, options) {
    const diff = (0, _index2.differenceInMilliseconds)(dateLeft, dateRight) / 1000;
    return (0, _index.getRoundingMethod)(options?.roundingMethod)(diff);
}

},{"bc308401ae80fd9e":"1ipL6","15eb048bf635cf19":"jkwjj"}],"cy0mL":[function(require,module,exports) {
"use strict";
exports.differenceInWeeks = differenceInWeeks;
var _index = require("1fd69438a343960a");
var _index2 = require("739c69993ece4a2d");
/**
 * The {@link differenceInWeeks} function options.
 */ /**
 * @name differenceInWeeks
 * @category Week Helpers
 * @summary Get the number of full weeks between the given dates.
 *
 * @description
 * Get the number of full weeks between two dates. Fractional weeks are
 * truncated towards zero by default.
 *
 * One "full week" is the distance between a local time in one day to the same
 * local time 7 days earlier or later. A full week can sometimes be less than
 * or more than 7*24 hours if a daylight savings change happens between two dates.
 *
 * To ignore DST and only measure exact 7*24-hour periods, use this instead:
 * `Math.floor(differenceInHours(dateLeft, dateRight)/(7*24))|0`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 * @param options - An object with options
 *
 * @returns The number of full weeks
 *
 * @example
 * // How many full weeks are between 5 July 2014 and 20 July 2014?
 * const result = differenceInWeeks(new Date(2014, 6, 20), new Date(2014, 6, 5))
 * //=> 2
 *
 * @example
 * // How many full weeks are between
 * // 1 March 2020 0:00 and 6 June 2020 0:00 ?
 * // Note: because local time is used, the
 * // result will always be 8 weeks (54 days),
 * // even if DST starts and the period has
 * // only 54*24-1 hours.
 * const result = differenceInWeeks(
 *   new Date(2020, 5, 1),
 *   new Date(2020, 2, 6)
 * )
 * //=> 8
 */ function differenceInWeeks(dateLeft, dateRight, options) {
    const diff = (0, _index2.differenceInDays)(dateLeft, dateRight) / 7;
    return (0, _index.getRoundingMethod)(options?.roundingMethod)(diff);
}

},{"1fd69438a343960a":"1ipL6","739c69993ece4a2d":"fJoFi"}],"iFe68":[function(require,module,exports) {
"use strict";
exports.differenceInYears = differenceInYears;
var _index = require("26f69a00c42ae289");
var _index2 = require("a2b02090236814dd");
var _index3 = require("4c5b5f2534904213");
/**
 * @name differenceInYears
 * @category Year Helpers
 * @summary Get the number of full years between the given dates.
 *
 * @description
 * Get the number of full years between the given dates.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The later date
 * @param dateRight - The earlier date
 *
 * @returns The number of full years
 *
 * @example
 * // How many full years are between 31 December 2013 and 11 February 2015?
 * const result = differenceInYears(new Date(2015, 1, 11), new Date(2013, 11, 31))
 * //=> 1
 */ function differenceInYears(dateLeft, dateRight) {
    const _dateLeft = (0, _index3.toDate)(dateLeft);
    const _dateRight = (0, _index3.toDate)(dateRight);
    const sign = (0, _index.compareAsc)(_dateLeft, _dateRight);
    const difference = Math.abs((0, _index2.differenceInCalendarYears)(_dateLeft, _dateRight));
    // Set both dates to a valid leap year for accurate comparison when dealing
    // with leap days
    _dateLeft.setFullYear(1584);
    _dateRight.setFullYear(1584);
    // Math.abs(diff in full years - diff in calendar years) === 1 if last calendar year is not full
    // If so, result must be decreased by 1 in absolute value
    const isLastYearNotFull = (0, _index.compareAsc)(_dateLeft, _dateRight) === -sign;
    const result = sign * (difference - +isLastYearNotFull);
    // Prevent negative zero
    return result === 0 ? 0 : result;
}

},{"26f69a00c42ae289":"fgd9M","a2b02090236814dd":"e0VtU","4c5b5f2534904213":"actWA"}],"g7D5W":[function(require,module,exports) {
"use strict";
exports.eachDayOfInterval = eachDayOfInterval;
var _index = require("294c3ba44409e4b5");
/**
 * The {@link eachDayOfInterval} function options.
 */ /**
 * @name eachDayOfInterval
 * @category Interval Helpers
 * @summary Return the array of dates within the specified time interval.
 *
 * @description
 * Return the array of dates within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 * @param options - An object with options.
 *
 * @returns The array with starts of days from the day of the interval start to the day of the interval end
 *
 * @example
 * // Each day between 6 October 2014 and 10 October 2014:
 * const result = eachDayOfInterval({
 *   start: new Date(2014, 9, 6),
 *   end: new Date(2014, 9, 10)
 * })
 * //=> [
 * //   Mon Oct 06 2014 00:00:00,
 * //   Tue Oct 07 2014 00:00:00,
 * //   Wed Oct 08 2014 00:00:00,
 * //   Thu Oct 09 2014 00:00:00,
 * //   Fri Oct 10 2014 00:00:00
 * // ]
 */ function eachDayOfInterval(interval, options) {
    const startDate = (0, _index.toDate)(interval.start);
    const endDate = (0, _index.toDate)(interval.end);
    let reversed = +startDate > +endDate;
    const endTime = reversed ? +startDate : +endDate;
    const currentDate = reversed ? endDate : startDate;
    currentDate.setHours(0, 0, 0, 0);
    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
        step = -step;
        reversed = !reversed;
    }
    const dates = [];
    while(+currentDate <= endTime){
        dates.push((0, _index.toDate)(currentDate));
        currentDate.setDate(currentDate.getDate() + step);
        currentDate.setHours(0, 0, 0, 0);
    }
    return reversed ? dates.reverse() : dates;
}

},{"294c3ba44409e4b5":"actWA"}],"kwHze":[function(require,module,exports) {
"use strict";
exports.eachHourOfInterval = eachHourOfInterval;
var _index = require("3e3d97bee6e54fec");
var _index2 = require("70a05b1edbc49f28");
/**
 * The {@link eachHourOfInterval} function options.
 */ /**
 * @name eachHourOfInterval
 * @category Interval Helpers
 * @summary Return the array of hours within the specified time interval.
 *
 * @description
 * Return the array of hours within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 * @param options - An object with options.
 *
 * @returns The array with starts of hours from the hour of the interval start to the hour of the interval end
 *
 * @example
 * // Each hour between 6 October 2014, 12:00 and 6 October 2014, 15:00
 * const result = eachHourOfInterval({
 *   start: new Date(2014, 9, 6, 12),
 *   end: new Date(2014, 9, 6, 15)
 * })
 * //=> [
 * //   Mon Oct 06 2014 12:00:00,
 * //   Mon Oct 06 2014 13:00:00,
 * //   Mon Oct 06 2014 14:00:00,
 * //   Mon Oct 06 2014 15:00:00
 * // ]
 */ function eachHourOfInterval(interval, options) {
    const startDate = (0, _index2.toDate)(interval.start);
    const endDate = (0, _index2.toDate)(interval.end);
    let reversed = +startDate > +endDate;
    const endTime = reversed ? +startDate : +endDate;
    let currentDate = reversed ? endDate : startDate;
    currentDate.setMinutes(0, 0, 0);
    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
        step = -step;
        reversed = !reversed;
    }
    const dates = [];
    while(+currentDate <= endTime){
        dates.push((0, _index2.toDate)(currentDate));
        currentDate = (0, _index.addHours)(currentDate, step);
    }
    return reversed ? dates.reverse() : dates;
}

},{"3e3d97bee6e54fec":"hzidA","70a05b1edbc49f28":"actWA"}],"4V6M8":[function(require,module,exports) {
"use strict";
exports.eachMinuteOfInterval = eachMinuteOfInterval;
var _index = require("e92d00e5a4dade3b");
var _index2 = require("ecbbda7f50f7aaff");
var _index3 = require("92ed5a1225d7a241");
/**
 * The {@link eachMinuteOfInterval} function options.
 */ /**
 * @name eachMinuteOfInterval
 * @category Interval Helpers
 * @summary Return the array of minutes within the specified time interval.
 *
 * @description
 * Returns the array of minutes within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 * @param options - An object with options.
 *
 * @returns The array with starts of minutes from the minute of the interval start to the minute of the interval end
 *
 * @example
 * // Each minute between 14 October 2020, 13:00 and 14 October 2020, 13:03
 * const result = eachMinuteOfInterval({
 *   start: new Date(2014, 9, 14, 13),
 *   end: new Date(2014, 9, 14, 13, 3)
 * })
 * //=> [
 * //   Wed Oct 14 2014 13:00:00,
 * //   Wed Oct 14 2014 13:01:00,
 * //   Wed Oct 14 2014 13:02:00,
 * //   Wed Oct 14 2014 13:03:00
 * // ]
 */ function eachMinuteOfInterval(interval, options) {
    const startDate = (0, _index2.startOfMinute)((0, _index3.toDate)(interval.start));
    const endDate = (0, _index3.toDate)(interval.end);
    let reversed = +startDate > +endDate;
    const endTime = reversed ? +startDate : +endDate;
    let currentDate = reversed ? endDate : startDate;
    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
        step = -step;
        reversed = !reversed;
    }
    const dates = [];
    while(+currentDate <= endTime){
        dates.push((0, _index3.toDate)(currentDate));
        currentDate = (0, _index.addMinutes)(currentDate, step);
    }
    return reversed ? dates.reverse() : dates;
}

},{"e92d00e5a4dade3b":"7jsut","ecbbda7f50f7aaff":"5zVrK","92ed5a1225d7a241":"actWA"}],"5zVrK":[function(require,module,exports) {
"use strict";
exports.startOfMinute = startOfMinute;
var _index = require("91f08d20edca7d8a");
/**
 * @name startOfMinute
 * @category Minute Helpers
 * @summary Return the start of a minute for the given date.
 *
 * @description
 * Return the start of a minute for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a minute
 *
 * @example
 * // The start of a minute for 1 December 2014 22:15:45.400:
 * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:00
 */ function startOfMinute(date) {
    const _date = (0, _index.toDate)(date);
    _date.setSeconds(0, 0);
    return _date;
}

},{"91f08d20edca7d8a":"actWA"}],"i1Z2B":[function(require,module,exports) {
"use strict";
exports.eachMonthOfInterval = eachMonthOfInterval;
var _index = require("3ff5dc84667641c0");
/**
 * The {@link eachMonthOfInterval} function options.
 */ /**
 * @name eachMonthOfInterval
 * @category Interval Helpers
 * @summary Return the array of months within the specified time interval.
 *
 * @description
 * Return the array of months within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval
 *
 * @returns The array with starts of months from the month of the interval start to the month of the interval end
 *
 * @example
 * // Each month between 6 February 2014 and 10 August 2014:
 * const result = eachMonthOfInterval({
 *   start: new Date(2014, 1, 6),
 *   end: new Date(2014, 7, 10)
 * })
 * //=> [
 * //   Sat Feb 01 2014 00:00:00,
 * //   Sat Mar 01 2014 00:00:00,
 * //   Tue Apr 01 2014 00:00:00,
 * //   Thu May 01 2014 00:00:00,
 * //   Sun Jun 01 2014 00:00:00,
 * //   Tue Jul 01 2014 00:00:00,
 * //   Fri Aug 01 2014 00:00:00
 * // ]
 */ function eachMonthOfInterval(interval, options) {
    const startDate = (0, _index.toDate)(interval.start);
    const endDate = (0, _index.toDate)(interval.end);
    let reversed = +startDate > +endDate;
    const endTime = reversed ? +startDate : +endDate;
    const currentDate = reversed ? endDate : startDate;
    currentDate.setHours(0, 0, 0, 0);
    currentDate.setDate(1);
    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
        step = -step;
        reversed = !reversed;
    }
    const dates = [];
    while(+currentDate <= endTime){
        dates.push((0, _index.toDate)(currentDate));
        currentDate.setMonth(currentDate.getMonth() + step);
    }
    return reversed ? dates.reverse() : dates;
}

},{"3ff5dc84667641c0":"actWA"}],"aOi8Z":[function(require,module,exports) {
"use strict";
exports.eachQuarterOfInterval = eachQuarterOfInterval;
var _index = require("6cdb36513da4cc03");
var _index2 = require("a8f22af48dc25121");
var _index3 = require("8c1f502027539eb2");
/**
 * The {@link eachQuarterOfInterval} function options.
 */ /**
 * @name eachQuarterOfInterval
 * @category Interval Helpers
 * @summary Return the array of quarters within the specified time interval.
 *
 * @description
 * Return the array of quarters within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval
 *
 * @returns The array with starts of quarters from the quarter of the interval start to the quarter of the interval end
 *
 * @example
 * // Each quarter within interval 6 February 2014 - 10 August 2014:
 * const result = eachQuarterOfInterval({
 *   start: new Date(2014, 1, 6),
 *   end: new Date(2014, 7, 10)
 * })
 * //=> [
 * //   Wed Jan 01 2014 00:00:00,
 * //   Tue Apr 01 2014 00:00:00,
 * //   Tue Jul 01 2014 00:00:00,
 * // ]
 */ function eachQuarterOfInterval(interval, options) {
    const startDate = (0, _index3.toDate)(interval.start);
    const endDate = (0, _index3.toDate)(interval.end);
    let reversed = +startDate > +endDate;
    const endTime = reversed ? +(0, _index2.startOfQuarter)(startDate) : +(0, _index2.startOfQuarter)(endDate);
    let currentDate = reversed ? (0, _index2.startOfQuarter)(endDate) : (0, _index2.startOfQuarter)(startDate);
    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
        step = -step;
        reversed = !reversed;
    }
    const dates = [];
    while(+currentDate <= endTime){
        dates.push((0, _index3.toDate)(currentDate));
        currentDate = (0, _index.addQuarters)(currentDate, step);
    }
    return reversed ? dates.reverse() : dates;
}

},{"6cdb36513da4cc03":"jW81o","a8f22af48dc25121":"ipmWI","8c1f502027539eb2":"actWA"}],"ipmWI":[function(require,module,exports) {
"use strict";
exports.startOfQuarter = startOfQuarter;
var _index = require("e81484efabf21f26");
/**
 * @name startOfQuarter
 * @category Quarter Helpers
 * @summary Return the start of a year quarter for the given date.
 *
 * @description
 * Return the start of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a quarter
 *
 * @example
 * // The start of a quarter for 2 September 2014 11:55:00:
 * const result = startOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Jul 01 2014 00:00:00
 */ function startOfQuarter(date) {
    const _date = (0, _index.toDate)(date);
    const currentMonth = _date.getMonth();
    const month = currentMonth - currentMonth % 3;
    _date.setMonth(month, 1);
    _date.setHours(0, 0, 0, 0);
    return _date;
}

},{"e81484efabf21f26":"actWA"}],"99wly":[function(require,module,exports) {
"use strict";
exports.eachWeekOfInterval = eachWeekOfInterval;
var _index = require("6e26efbcc307cb14");
var _index2 = require("244cdaa33af9b640");
var _index3 = require("bd21daa7da65e0eb");
/**
 * The {@link eachWeekOfInterval} function options.
 */ /**
 * @name eachWeekOfInterval
 * @category Interval Helpers
 * @summary Return the array of weeks within the specified time interval.
 *
 * @description
 * Return the array of weeks within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 * @param options - An object with options.
 *
 * @returns The array with starts of weeks from the week of the interval start to the week of the interval end
 *
 * @example
 * // Each week within interval 6 October 2014 - 23 November 2014:
 * const result = eachWeekOfInterval({
 *   start: new Date(2014, 9, 6),
 *   end: new Date(2014, 10, 23)
 * })
 * //=> [
 * //   Sun Oct 05 2014 00:00:00,
 * //   Sun Oct 12 2014 00:00:00,
 * //   Sun Oct 19 2014 00:00:00,
 * //   Sun Oct 26 2014 00:00:00,
 * //   Sun Nov 02 2014 00:00:00,
 * //   Sun Nov 09 2014 00:00:00,
 * //   Sun Nov 16 2014 00:00:00,
 * //   Sun Nov 23 2014 00:00:00
 * // ]
 */ function eachWeekOfInterval(interval, options) {
    const startDate = (0, _index3.toDate)(interval.start);
    const endDate = (0, _index3.toDate)(interval.end);
    let reversed = +startDate > +endDate;
    const startDateWeek = reversed ? (0, _index2.startOfWeek)(endDate, options) : (0, _index2.startOfWeek)(startDate, options);
    const endDateWeek = reversed ? (0, _index2.startOfWeek)(startDate, options) : (0, _index2.startOfWeek)(endDate, options);
    // Some timezones switch DST at midnight, making start of day unreliable in these timezones, 3pm is a safe bet
    startDateWeek.setHours(15);
    endDateWeek.setHours(15);
    const endTime = +endDateWeek.getTime();
    let currentDate = startDateWeek;
    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
        step = -step;
        reversed = !reversed;
    }
    const dates = [];
    while(+currentDate <= endTime){
        currentDate.setHours(0);
        dates.push((0, _index3.toDate)(currentDate));
        currentDate = (0, _index.addWeeks)(currentDate, step);
        currentDate.setHours(15);
    }
    return reversed ? dates.reverse() : dates;
}

},{"6e26efbcc307cb14":"6sRN6","244cdaa33af9b640":"dDDvv","bd21daa7da65e0eb":"actWA"}],"5ViHa":[function(require,module,exports) {
"use strict";
exports.eachWeekendOfInterval = eachWeekendOfInterval;
var _index = require("56a8ee095115973a");
var _index2 = require("311a5485dd7798b7");
/**
 * @name eachWeekendOfInterval
 * @category Interval Helpers
 * @summary List all the Saturdays and Sundays in the given date interval.
 *
 * @description
 * Get all the Saturdays and Sundays in the given date interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The given interval
 *
 * @returns An array containing all the Saturdays and Sundays
 *
 * @example
 * // Lists all Saturdays and Sundays in the given date interval
 * const result = eachWeekendOfInterval({
 *   start: new Date(2018, 8, 17),
 *   end: new Date(2018, 8, 30)
 * })
 * //=> [
 * //   Sat Sep 22 2018 00:00:00,
 * //   Sun Sep 23 2018 00:00:00,
 * //   Sat Sep 29 2018 00:00:00,
 * //   Sun Sep 30 2018 00:00:00
 * // ]
 */ function eachWeekendOfInterval(interval) {
    const dateInterval = (0, _index.eachDayOfInterval)(interval);
    const weekends = [];
    let index = 0;
    while(index < dateInterval.length){
        const date = dateInterval[index++];
        if ((0, _index2.isWeekend)(date)) weekends.push(date);
    }
    return weekends;
}

},{"56a8ee095115973a":"g7D5W","311a5485dd7798b7":"hvqeH"}],"51lqU":[function(require,module,exports) {
"use strict";
exports.eachWeekendOfMonth = eachWeekendOfMonth;
var _index = require("d5fe08dd964c485c");
var _index2 = require("433b8f5e15395dd7");
var _index3 = require("c93c981052c9ccef");
/**
 * @name eachWeekendOfMonth
 * @category Month Helpers
 * @summary List all the Saturdays and Sundays in the given month.
 *
 * @description
 * Get all the Saturdays and Sundays in the given month.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given month
 *
 * @returns An array containing all the Saturdays and Sundays
 *
 * @example
 * // Lists all Saturdays and Sundays in the given month
 * const result = eachWeekendOfMonth(new Date(2022, 1, 1))
 * //=> [
 * //   Sat Feb 05 2022 00:00:00,
 * //   Sun Feb 06 2022 00:00:00,
 * //   Sat Feb 12 2022 00:00:00,
 * //   Sun Feb 13 2022 00:00:00,
 * //   Sat Feb 19 2022 00:00:00,
 * //   Sun Feb 20 2022 00:00:00,
 * //   Sat Feb 26 2022 00:00:00,
 * //   Sun Feb 27 2022 00:00:00
 * // ]
 */ function eachWeekendOfMonth(date) {
    const start = (0, _index3.startOfMonth)(date);
    const end = (0, _index2.endOfMonth)(date);
    return (0, _index.eachWeekendOfInterval)({
        start,
        end
    });
}

},{"d5fe08dd964c485c":"5ViHa","433b8f5e15395dd7":"kcCWM","c93c981052c9ccef":"1cHoB"}],"1cHoB":[function(require,module,exports) {
"use strict";
exports.startOfMonth = startOfMonth;
var _index = require("9b1ec7fb57278771");
/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a month
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */ function startOfMonth(date) {
    const _date = (0, _index.toDate)(date);
    _date.setDate(1);
    _date.setHours(0, 0, 0, 0);
    return _date;
}

},{"9b1ec7fb57278771":"actWA"}],"deCgd":[function(require,module,exports) {
"use strict";
exports.eachWeekendOfYear = eachWeekendOfYear;
var _index = require("feb8e300bcf7957");
var _index2 = require("1449183f6fb1902a");
var _index3 = require("ab03b55fc28aacde");
/**
 * @name eachWeekendOfYear
 * @category Year Helpers
 * @summary List all the Saturdays and Sundays in the year.
 *
 * @description
 * Get all the Saturdays and Sundays in the year.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given year
 *
 * @returns An array containing all the Saturdays and Sundays
 *
 * @example
 * // Lists all Saturdays and Sundays in the year
 * const result = eachWeekendOfYear(new Date(2020, 1, 1))
 * //=> [
 * //   Sat Jan 03 2020 00:00:00,
 * //   Sun Jan 04 2020 00:00:00,
 * //   ...
 * //   Sun Dec 27 2020 00:00:00
 * // ]
 * ]
 */ function eachWeekendOfYear(date) {
    const start = (0, _index3.startOfYear)(date);
    const end = (0, _index2.endOfYear)(date);
    return (0, _index.eachWeekendOfInterval)({
        start,
        end
    });
}

},{"feb8e300bcf7957":"5ViHa","1449183f6fb1902a":"gmxYT","ab03b55fc28aacde":"cnrH3"}],"gmxYT":[function(require,module,exports) {
"use strict";
exports.endOfYear = endOfYear;
var _index = require("bae33049518de779");
/**
 * @name endOfYear
 * @category Year Helpers
 * @summary Return the end of a year for the given date.
 *
 * @description
 * Return the end of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a year
 *
 * @example
 * // The end of a year for 2 September 2014 11:55:00:
 * const result = endOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Dec 31 2014 23:59:59.999
 */ function endOfYear(date) {
    const _date = (0, _index.toDate)(date);
    const year = _date.getFullYear();
    _date.setFullYear(year + 1, 0, 0);
    _date.setHours(23, 59, 59, 999);
    return _date;
}

},{"bae33049518de779":"actWA"}],"cnrH3":[function(require,module,exports) {
"use strict";
exports.startOfYear = startOfYear;
var _index = require("29a7a92b30a86c8c");
var _index2 = require("151cc5db30a5792f");
/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a year
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */ function startOfYear(date) {
    const cleanDate = (0, _index.toDate)(date);
    const _date = (0, _index2.constructFrom)(date, 0);
    _date.setFullYear(cleanDate.getFullYear(), 0, 1);
    _date.setHours(0, 0, 0, 0);
    return _date;
}

},{"29a7a92b30a86c8c":"actWA","151cc5db30a5792f":"hNMdA"}],"015Lr":[function(require,module,exports) {
"use strict";
exports.eachYearOfInterval = eachYearOfInterval;
var _index = require("ce43d0e962faaa1c");
/**
 * The {@link eachYearOfInterval} function options.
 */ /**
 * @name eachYearOfInterval
 * @category Interval Helpers
 * @summary Return the array of yearly timestamps within the specified time interval.
 *
 * @description
 * Return the array of yearly timestamps within the specified time interval.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval.
 *
 * @returns The array with starts of yearly timestamps from the month of the interval start to the month of the interval end
 *
 * @example
 * // Each year between 6 February 2014 and 10 August 2017:
 * const result = eachYearOfInterval({
 *   start: new Date(2014, 1, 6),
 *   end: new Date(2017, 7, 10)
 * })
 * //=> [
 * //   Wed Jan 01 2014 00:00:00,
 * //   Thu Jan 01 2015 00:00:00,
 * //   Fri Jan 01 2016 00:00:00,
 * //   Sun Jan 01 2017 00:00:00
 * // ]
 */ function eachYearOfInterval(interval, options) {
    const startDate = (0, _index.toDate)(interval.start);
    const endDate = (0, _index.toDate)(interval.end);
    let reversed = +startDate > +endDate;
    const endTime = reversed ? +startDate : +endDate;
    const currentDate = reversed ? endDate : startDate;
    currentDate.setHours(0, 0, 0, 0);
    currentDate.setMonth(0, 1);
    let step = options?.step ?? 1;
    if (!step) return [];
    if (step < 0) {
        step = -step;
        reversed = !reversed;
    }
    const dates = [];
    while(+currentDate <= endTime){
        dates.push((0, _index.toDate)(currentDate));
        currentDate.setFullYear(currentDate.getFullYear() + step);
    }
    return reversed ? dates.reverse() : dates;
}

},{"ce43d0e962faaa1c":"actWA"}],"c7ju7":[function(require,module,exports) {
"use strict";
exports.endOfDecade = endOfDecade;
var _index = require("c3f314059e7ed45");
/**
 * @name endOfDecade
 * @category Decade Helpers
 * @summary Return the end of a decade for the given date.
 *
 * @description
 * Return the end of a decade for the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a decade
 *
 * @example
 * // The end of a decade for 12 May 1984 00:00:00:
 * const result = endOfDecade(new Date(1984, 4, 12, 00, 00, 00))
 * //=> Dec 31 1989 23:59:59.999
 */ function endOfDecade(date) {
    const _date = (0, _index.toDate)(date);
    const year = _date.getFullYear();
    const decade = 9 + Math.floor(year / 10) * 10;
    _date.setFullYear(decade, 11, 31);
    _date.setHours(23, 59, 59, 999);
    return _date;
}

},{"c3f314059e7ed45":"actWA"}],"fGjDI":[function(require,module,exports) {
"use strict";
exports.endOfHour = endOfHour;
var _index = require("559b27e6bd32f67a");
/**
 * @name endOfHour
 * @category Hour Helpers
 * @summary Return the end of an hour for the given date.
 *
 * @description
 * Return the end of an hour for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of an hour
 *
 * @example
 * // The end of an hour for 2 September 2014 11:55:00:
 * const result = endOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:59:59.999
 */ function endOfHour(date) {
    const _date = (0, _index.toDate)(date);
    _date.setMinutes(59, 59, 999);
    return _date;
}

},{"559b27e6bd32f67a":"actWA"}],"5qyrI":[function(require,module,exports) {
"use strict";
exports.endOfISOWeek = endOfISOWeek;
var _index = require("32a570bab666f4f0");
/**
 * @name endOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the end of an ISO week for the given date.
 *
 * @description
 * Return the end of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of an ISO week
 *
 * @example
 * // The end of an ISO week for 2 September 2014 11:55:00:
 * const result = endOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Sep 07 2014 23:59:59.999
 */ function endOfISOWeek(date) {
    return (0, _index.endOfWeek)(date, {
        weekStartsOn: 1
    });
}

},{"32a570bab666f4f0":"3Ot4h"}],"3Ot4h":[function(require,module,exports) {
"use strict";
exports.endOfWeek = endOfWeek;
var _index = require("874b81e8096fd15b");
var _index2 = require("54c51a8f0276b53b");
/**
 * The {@link endOfWeek} function options.
 */ /**
 * @name endOfWeek
 * @category Week Helpers
 * @summary Return the end of a week for the given date.
 *
 * @description
 * Return the end of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The end of a week
 *
 * @example
 * // The end of a week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sat Sep 06 2014 23:59:59.999
 *
 * @example
 * // If the week starts on Monday, the end of the week for 2 September 2014 11:55:00:
 * const result = endOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 23:59:59.999
 */ function endOfWeek(date, options) {
    const defaultOptions = (0, _index2.getDefaultOptions)();
    const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions.weekStartsOn ?? defaultOptions.locale?.options?.weekStartsOn ?? 0;
    const _date = (0, _index.toDate)(date);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
    _date.setDate(_date.getDate() + diff);
    _date.setHours(23, 59, 59, 999);
    return _date;
}

},{"874b81e8096fd15b":"actWA","54c51a8f0276b53b":"98fau"}],"etxH3":[function(require,module,exports) {
"use strict";
exports.endOfISOWeekYear = endOfISOWeekYear;
var _index = require("fff5ebc46b4d3047");
var _index2 = require("1f630f53841125bd");
var _index3 = require("9bb8122951a915c3");
/**
 * @name endOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the end of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the end of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of an ISO week-numbering year
 *
 * @example
 * // The end of an ISO week-numbering year for 2 July 2005:
 * const result = endOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Sun Jan 01 2006 23:59:59.999
 */ function endOfISOWeekYear(date) {
    const year = (0, _index.getISOWeekYear)(date);
    const fourthOfJanuaryOfNextYear = (0, _index3.constructFrom)(date, 0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    const _date = (0, _index2.startOfISOWeek)(fourthOfJanuaryOfNextYear);
    _date.setMilliseconds(_date.getMilliseconds() - 1);
    return _date;
}

},{"fff5ebc46b4d3047":"jWChc","1f630f53841125bd":"iF0wL","9bb8122951a915c3":"hNMdA"}],"jOlnb":[function(require,module,exports) {
"use strict";
exports.endOfMinute = endOfMinute;
var _index = require("61e892816ba65f75");
/**
 * @name endOfMinute
 * @category Minute Helpers
 * @summary Return the end of a minute for the given date.
 *
 * @description
 * Return the end of a minute for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a minute
 *
 * @example
 * // The end of a minute for 1 December 2014 22:15:45.400:
 * const result = endOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:59.999
 */ function endOfMinute(date) {
    const _date = (0, _index.toDate)(date);
    _date.setSeconds(59, 999);
    return _date;
}

},{"61e892816ba65f75":"actWA"}],"jhz7T":[function(require,module,exports) {
"use strict";
exports.endOfQuarter = endOfQuarter;
var _index = require("e4975d708a66315a");
/**
 * @name endOfQuarter
 * @category Quarter Helpers
 * @summary Return the end of a year quarter for the given date.
 *
 * @description
 * Return the end of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a quarter
 *
 * @example
 * // The end of a quarter for 2 September 2014 11:55:00:
 * const result = endOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */ function endOfQuarter(date) {
    const _date = (0, _index.toDate)(date);
    const currentMonth = _date.getMonth();
    const month = currentMonth - currentMonth % 3 + 3;
    _date.setMonth(month, 0);
    _date.setHours(23, 59, 59, 999);
    return _date;
}

},{"e4975d708a66315a":"actWA"}],"c9wPr":[function(require,module,exports) {
"use strict";
exports.endOfSecond = endOfSecond;
var _index = require("abb2bf07f4049174");
/**
 * @name endOfSecond
 * @category Second Helpers
 * @summary Return the end of a second for the given date.
 *
 * @description
 * Return the end of a second for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of a second
 *
 * @example
 * // The end of a second for 1 December 2014 22:15:45.400:
 * const result = endOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:45.999
 */ function endOfSecond(date) {
    const _date = (0, _index.toDate)(date);
    _date.setMilliseconds(999);
    return _date;
}

},{"abb2bf07f4049174":"actWA"}],"ab76B":[function(require,module,exports) {
"use strict";
exports.endOfToday = endOfToday;
var _index = require("4e7ecedb2c691b21");
/**
 * @name endOfToday
 * @category Day Helpers
 * @summary Return the end of today.
 * @pure false
 *
 * @description
 * Return the end of today.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @returns The end of today
 *
 * @example
 * // If today is 6 October 2014:
 * const result = endOfToday()
 * //=> Mon Oct 6 2014 23:59:59.999
 */ function endOfToday() {
    return (0, _index.endOfDay)(Date.now());
}

},{"4e7ecedb2c691b21":"jtO7f"}],"9sHeD":[function(require,module,exports) {
"use strict";
exports.endOfTomorrow = endOfTomorrow; /**
 * @name endOfTomorrow
 * @category Day Helpers
 * @summary Return the end of tomorrow.
 * @pure false
 *
 * @description
 * Return the end of tomorrow.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @returns The end of tomorrow
 *
 * @example
 * // If today is 6 October 2014:
 * const result = endOfTomorrow()
 * //=> Tue Oct 7 2014 23:59:59.999
 */ 
function endOfTomorrow() {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth();
    const day = now.getDate();
    const date = new Date(0);
    date.setFullYear(year, month, day + 1);
    date.setHours(23, 59, 59, 999);
    return date;
}

},{}],"7ud3X":[function(require,module,exports) {
"use strict";
exports.endOfYesterday = endOfYesterday; /**
 * @name endOfYesterday
 * @category Day Helpers
 * @summary Return the end of yesterday.
 * @pure false
 *
 * @description
 * Return the end of yesterday.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @returns The end of yesterday
 *
 * @example
 * // If today is 6 October 2014:
 * const result = endOfYesterday()
 * //=> Sun Oct 5 2014 23:59:59.999
 */ 
function endOfYesterday() {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth();
    const day = now.getDate();
    const date = new Date(0);
    date.setFullYear(year, month, day - 1);
    date.setHours(23, 59, 59, 999);
    return date;
}

},{}],"eeV53":[function(require,module,exports) {
"use strict";
exports.format = format;
Object.defineProperty(exports, "formatters", {
    enumerable: true,
    get: function() {
        return _index5.formatters;
    }
});
Object.defineProperty(exports, "longFormatters", {
    enumerable: true,
    get: function() {
        return _index6.longFormatters;
    }
});
var _index = require("8d66a13aebf60df9");
var _index2 = require("3b5edf3c2ddf1d76");
var _index3 = require("7a797645e41ea2c2");
var _index4 = require("2ed033e42fc5189d");
var _index5 = require("e1935e40361258cf");
var _index6 = require("c46187c282bdd45");
var _index7 = require("7528fb990c5ee731");
// Rexports of internal for libraries to use.
// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874
// This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * The {@link format} function options.
 */ /**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear](https://date-fns.org/docs/getISOWeekYear)
 *    and [getWeekYear](https://date-fns.org/docs/getWeekYear)).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param format - The string of tokens
 * @param options - An object with options
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 * @throws `options.locale` must contain `localize` property
 * @throws `options.locale` must contain `formatLong` property
 * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */ function format(date, formatStr, options) {
    const defaultOptions = (0, _index4.getDefaultOptions)();
    const locale = options?.locale ?? defaultOptions.locale ?? _index3.defaultLocale;
    const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions.firstWeekContainsDate ?? defaultOptions.locale?.options?.firstWeekContainsDate ?? 1;
    const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions.weekStartsOn ?? defaultOptions.locale?.options?.weekStartsOn ?? 0;
    const originalDate = (0, _index2.toDate)(date);
    if (!(0, _index.isValid)(originalDate)) throw new RangeError("Invalid time value");
    const formatterOptions = {
        firstWeekContainsDate: firstWeekContainsDate,
        weekStartsOn: weekStartsOn,
        locale: locale,
        _originalDate: originalDate
    };
    const result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
        const firstCharacter = substring[0];
        if (firstCharacter === "p" || firstCharacter === "P") {
            const longFormatter = _index6.longFormatters[firstCharacter];
            return longFormatter(substring, locale.formatLong);
        }
        return substring;
    }).join("").match(formattingTokensRegExp).map(function(substring) {
        // Replace two single quote characters with one single quote character
        if (substring === "''") return "'";
        const firstCharacter = substring[0];
        if (firstCharacter === "'") return cleanEscapedString(substring);
        const formatter = _index5.formatters[firstCharacter];
        if (formatter) {
            if (!options?.useAdditionalWeekYearTokens && (0, _index7.isProtectedWeekYearToken)(substring)) (0, _index7.warnOrThrowProtectedError)(substring, formatStr, String(date));
            if (!options?.useAdditionalDayOfYearTokens && (0, _index7.isProtectedDayOfYearToken)(substring)) (0, _index7.warnOrThrowProtectedError)(substring, formatStr, String(date));
            return formatter(originalDate, substring, locale.localize, formatterOptions);
        }
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        return substring;
    }).join("");
    return result;
}
function cleanEscapedString(input) {
    const matched = input.match(escapedStringRegExp);
    if (!matched) return input;
    return matched[1].replace(doubleQuoteRegExp, "'");
}

},{"8d66a13aebf60df9":"gbOJY","3b5edf3c2ddf1d76":"actWA","7a797645e41ea2c2":"iG9h0","2ed033e42fc5189d":"98fau","e1935e40361258cf":"zOLvM","c46187c282bdd45":"jsbdH","7528fb990c5ee731":"dFKqd"}],"iG9h0":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "defaultLocale", {
    enumerable: true,
    get: function() {
        return _index.enUS;
    }
});
var _index = require("537dc8c80b85612c");

},{"537dc8c80b85612c":"haY68"}],"haY68":[function(require,module,exports) {
"use strict";
exports.enUS = void 0;
var _index = require("479d03a18c245c3e");
var _index2 = require("b9e3c763ad65c41a");
var _index3 = require("6451586d149703ed");
var _index4 = require("cbddf07e540dd382");
var _index5 = require("3002f8fbc231e7a1");
/**
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp](https://github.com/kossnocorp)
 * @author Lesha Koss [@leshakoss](https://github.com/leshakoss)
 */ const enUS = exports.enUS = {
    code: "en-US",
    formatDistance: _index.formatDistance,
    formatLong: _index2.formatLong,
    formatRelative: _index3.formatRelative,
    localize: _index4.localize,
    match: _index5.match,
    options: {
        weekStartsOn: 0 /* Sunday */ ,
        firstWeekContainsDate: 1
    }
};

},{"479d03a18c245c3e":"9Lz1e","b9e3c763ad65c41a":"c2f1i","6451586d149703ed":"6KKLO","cbddf07e540dd382":"ldfCO","3002f8fbc231e7a1":"c3v7R"}],"9Lz1e":[function(require,module,exports) {
"use strict";
exports.formatDistance = void 0;
const formatDistanceLocale = {
    lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
    },
    xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
    },
    xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
    },
    aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
    },
    xHours: {
        one: "1 hour",
        other: "{{count}} hours"
    },
    xDays: {
        one: "1 day",
        other: "{{count}} days"
    },
    aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
    },
    xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
    },
    aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
    },
    xMonths: {
        one: "1 month",
        other: "{{count}} months"
    },
    aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
    },
    xYears: {
        one: "1 year",
        other: "{{count}} years"
    },
    overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
    },
    almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
    }
};
const formatDistance = (token, count, options)=>{
    let result;
    const tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") result = tokenValue;
    else if (count === 1) result = tokenValue.one;
    else result = tokenValue.other.replace("{{count}}", count.toString());
    if (options?.addSuffix) {
        if (options.comparison && options.comparison > 0) return "in " + result;
        else return result + " ago";
    }
    return result;
};
exports.formatDistance = formatDistance;

},{}],"c2f1i":[function(require,module,exports) {
"use strict";
exports.formatLong = void 0;
var _index = require("4800af73d892e7a");
const dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
};
const timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
};
const dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
};
const formatLong = exports.formatLong = {
    date: (0, _index.buildFormatLongFn)({
        formats: dateFormats,
        defaultWidth: "full"
    }),
    time: (0, _index.buildFormatLongFn)({
        formats: timeFormats,
        defaultWidth: "full"
    }),
    dateTime: (0, _index.buildFormatLongFn)({
        formats: dateTimeFormats,
        defaultWidth: "full"
    })
};

},{"4800af73d892e7a":"6OYyu"}],"6OYyu":[function(require,module,exports) {
"use strict";
exports.buildFormatLongFn = buildFormatLongFn;
function buildFormatLongFn(args) {
    return (options = {})=>{
        // TODO: Remove String()
        const width = options.width ? String(options.width) : args.defaultWidth;
        const format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
    };
}

},{}],"6KKLO":[function(require,module,exports) {
"use strict";
exports.formatRelative = void 0;
const formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
};
const formatRelative = (token, _date, _baseDate, _options)=>formatRelativeLocale[token];
exports.formatRelative = formatRelative;

},{}],"ldfCO":[function(require,module,exports) {
"use strict";
exports.localize = void 0;
var _index = require("78e7236a2f110627");
const eraValues = {
    narrow: [
        "B",
        "A"
    ],
    abbreviated: [
        "BC",
        "AD"
    ],
    wide: [
        "Before Christ",
        "Anno Domini"
    ]
};
const quarterValues = {
    narrow: [
        "1",
        "2",
        "3",
        "4"
    ],
    abbreviated: [
        "Q1",
        "Q2",
        "Q3",
        "Q4"
    ],
    wide: [
        "1st quarter",
        "2nd quarter",
        "3rd quarter",
        "4th quarter"
    ]
};
// Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.
const monthValues = {
    narrow: [
        "J",
        "F",
        "M",
        "A",
        "M",
        "J",
        "J",
        "A",
        "S",
        "O",
        "N",
        "D"
    ],
    abbreviated: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
    ],
    wide: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
    ]
};
const dayValues = {
    narrow: [
        "S",
        "M",
        "T",
        "W",
        "T",
        "F",
        "S"
    ],
    short: [
        "Su",
        "Mo",
        "Tu",
        "We",
        "Th",
        "Fr",
        "Sa"
    ],
    abbreviated: [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
    ],
    wide: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
    ]
};
const dayPeriodValues = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    }
};
const formattingDayPeriodValues = {
    narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    },
    wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
    }
};
const ordinalNumber = (dirtyNumber, _options)=>{
    const number = Number(dirtyNumber);
    // If ordinal numbers depend on context, for example,
    // if they are different for different grammatical genders,
    // use `options.unit`.
    //
    // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
    // 'day', 'hour', 'minute', 'second'.
    const rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) switch(rem100 % 10){
        case 1:
            return number + "st";
        case 2:
            return number + "nd";
        case 3:
            return number + "rd";
    }
    return number + "th";
};
const localize = exports.localize = {
    ordinalNumber,
    era: (0, _index.buildLocalizeFn)({
        values: eraValues,
        defaultWidth: "wide"
    }),
    quarter: (0, _index.buildLocalizeFn)({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: (quarter)=>quarter - 1
    }),
    month: (0, _index.buildLocalizeFn)({
        values: monthValues,
        defaultWidth: "wide"
    }),
    day: (0, _index.buildLocalizeFn)({
        values: dayValues,
        defaultWidth: "wide"
    }),
    dayPeriod: (0, _index.buildLocalizeFn)({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
    })
};

},{"78e7236a2f110627":"fGq1u"}],"fGq1u":[function(require,module,exports) {
"use strict";
exports.buildLocalizeFn = buildLocalizeFn; /* eslint-disable no-unused-vars */ 
/**
 * The localize function argument callback which allows to convert raw value to
 * the actual type.
 *
 * @param value - The value to convert
 *
 * @returns The converted value
 */ /**
 * The map of localized values for each width.
 */ /**
 * The index type of the locale unit value. It types conversion of units of
 * values that don't start at 0 (i.e. quarters).
 */ /**
 * Converts the unit value to the tuple of values.
 */ /**
 * The tuple of localized era values. The first element represents BC,
 * the second element represents AD.
 */ /**
 * The tuple of localized quarter values. The first element represents Q1.
 */ /**
 * The tuple of localized day values. The first element represents Sunday.
 */ /**
 * The tuple of localized month values. The first element represents January.
 */ function buildLocalizeFn(args) {
    return (value, options)=>{
        const context = options?.context ? String(options.context) : "standalone";
        let valuesArray;
        if (context === "formatting" && args.formattingValues) {
            const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
            const width = options?.width ? String(options.width) : defaultWidth;
            valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
            const defaultWidth = args.defaultWidth;
            const width = options?.width ? String(options.width) : args.defaultWidth;
            valuesArray = args.values[width] || args.values[defaultWidth];
        }
        const index = args.argumentCallback ? args.argumentCallback(value) : value;
        // @ts-expect-error - For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
        return valuesArray[index];
    };
}

},{}],"c3v7R":[function(require,module,exports) {
"use strict";
exports.match = void 0;
var _index = require("befc9b9f4e6afb32");
var _index2 = require("be7528ef34a1226");
const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns = {
    any: [
        /^b/i,
        /^(a|c)/i
    ]
};
const matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns = {
    any: [
        /1/i,
        /2/i,
        /3/i,
        /4/i
    ]
};
const matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
const matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns = {
    narrow: [
        /^s/i,
        /^m/i,
        /^t/i,
        /^w/i,
        /^t/i,
        /^f/i,
        /^s/i
    ],
    any: [
        /^su/i,
        /^m/i,
        /^tu/i,
        /^w/i,
        /^th/i,
        /^f/i,
        /^sa/i
    ]
};
const matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
};
const match = exports.match = {
    ordinalNumber: (0, _index2.buildMatchPatternFn)({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: (value)=>parseInt(value, 10)
    }),
    era: (0, _index.buildMatchFn)({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
    }),
    quarter: (0, _index.buildMatchFn)({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: (index)=>index + 1
    }),
    month: (0, _index.buildMatchFn)({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
    }),
    day: (0, _index.buildMatchFn)({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
    }),
    dayPeriod: (0, _index.buildMatchFn)({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
    })
};

},{"befc9b9f4e6afb32":"15lWd","be7528ef34a1226":"kWqg8"}],"15lWd":[function(require,module,exports) {
"use strict";
exports.buildMatchFn = buildMatchFn;
function buildMatchFn(args) {
    return (string, options = {})=>{
        const width = options.width;
        const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        const matchResult = string.match(matchPattern);
        if (!matchResult) return null;
        const matchedString = matchResult[0];
        const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern)=>pattern.test(matchedString)) : findKey(parsePatterns, (pattern)=>pattern.test(matchedString));
        let value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? options.valueCallback(value) : value;
        const rest = string.slice(matchedString.length);
        return {
            value,
            rest
        };
    };
}
function findKey(object, predicate) {
    for(const key in object){
        if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) return key;
    }
    return undefined;
}
function findIndex(array, predicate) {
    for(let key = 0; key < array.length; key++){
        if (predicate(array[key])) return key;
    }
    return undefined;
}

},{}],"kWqg8":[function(require,module,exports) {
"use strict";
exports.buildMatchPatternFn = buildMatchPatternFn;
function buildMatchPatternFn(args) {
    return (string, options = {})=>{
        const matchResult = string.match(args.matchPattern);
        if (!matchResult) return null;
        const matchedString = matchResult[0];
        const parseResult = string.match(args.parsePattern);
        if (!parseResult) return null;
        let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        value = options.valueCallback ? options.valueCallback(value) : value;
        const rest = string.slice(matchedString.length);
        return {
            value,
            rest
        };
    };
}

},{}],"zOLvM":[function(require,module,exports) {
"use strict";
exports.formatters = void 0;
var _index = require("2b70b701cccd48ba");
var _index2 = require("ce71b00fa268a334");
var _index3 = require("be1f4bd5db98fc0b");
var _index4 = require("4d35ee8b95213cb2");
var _index5 = require("31a9b5233efbdb74");
var _index6 = require("c78164dd4be2dfdf");
var _index7 = require("c129443cf4e77b69");
const dayPeriodEnum = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
};
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */ const formatters = exports.formatters = {
    // Era
    G: function(date, token, localize) {
        const era = date.getFullYear() > 0 ? 1 : 0;
        switch(token){
            // AD, BC
            case "G":
            case "GG":
            case "GGG":
                return localize.era(era, {
                    width: "abbreviated"
                });
            // A, B
            case "GGGGG":
                return localize.era(era, {
                    width: "narrow"
                });
            // Anno Domini, Before Christ
            case "GGGG":
            default:
                return localize.era(era, {
                    width: "wide"
                });
        }
    },
    // Year
    y: function(date, token, localize) {
        // Ordinal number
        if (token === "yo") {
            const signedYear = date.getFullYear();
            // Returns 1 for 1 BC (which is year 0 in JavaScript)
            const year = signedYear > 0 ? signedYear : 1 - signedYear;
            return localize.ordinalNumber(year, {
                unit: "year"
            });
        }
        return _index7.lightFormatters.y(date, token);
    },
    // Local week-numbering year
    Y: function(date, token, localize, options) {
        const signedWeekYear = (0, _index5.getWeekYear)(date, options);
        // Returns 1 for 1 BC (which is year 0 in JavaScript)
        const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
        // Two digit year
        if (token === "YY") {
            const twoDigitYear = weekYear % 100;
            return (0, _index6.addLeadingZeros)(twoDigitYear, 2);
        }
        // Ordinal number
        if (token === "Yo") return localize.ordinalNumber(weekYear, {
            unit: "year"
        });
        // Padding
        return (0, _index6.addLeadingZeros)(weekYear, token.length);
    },
    // ISO week-numbering year
    R: function(date, token) {
        const isoWeekYear = (0, _index3.getISOWeekYear)(date);
        // Padding
        return (0, _index6.addLeadingZeros)(isoWeekYear, token.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function(date, token) {
        const year = date.getFullYear();
        return (0, _index6.addLeadingZeros)(year, token.length);
    },
    // Quarter
    Q: function(date, token, localize) {
        const quarter = Math.ceil((date.getMonth() + 1) / 3);
        switch(token){
            // 1, 2, 3, 4
            case "Q":
                return String(quarter);
            // 01, 02, 03, 04
            case "QQ":
                return (0, _index6.addLeadingZeros)(quarter, 2);
            // 1st, 2nd, 3rd, 4th
            case "Qo":
                return localize.ordinalNumber(quarter, {
                    unit: "quarter"
                });
            // Q1, Q2, Q3, Q4
            case "QQQ":
                return localize.quarter(quarter, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // 1, 2, 3, 4 (narrow quarter; could be not numerical)
            case "QQQQQ":
                return localize.quarter(quarter, {
                    width: "narrow",
                    context: "formatting"
                });
            // 1st quarter, 2nd quarter, ...
            case "QQQQ":
            default:
                return localize.quarter(quarter, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Stand-alone quarter
    q: function(date, token, localize) {
        const quarter = Math.ceil((date.getMonth() + 1) / 3);
        switch(token){
            // 1, 2, 3, 4
            case "q":
                return String(quarter);
            // 01, 02, 03, 04
            case "qq":
                return (0, _index6.addLeadingZeros)(quarter, 2);
            // 1st, 2nd, 3rd, 4th
            case "qo":
                return localize.ordinalNumber(quarter, {
                    unit: "quarter"
                });
            // Q1, Q2, Q3, Q4
            case "qqq":
                return localize.quarter(quarter, {
                    width: "abbreviated",
                    context: "standalone"
                });
            // 1, 2, 3, 4 (narrow quarter; could be not numerical)
            case "qqqqq":
                return localize.quarter(quarter, {
                    width: "narrow",
                    context: "standalone"
                });
            // 1st quarter, 2nd quarter, ...
            case "qqqq":
            default:
                return localize.quarter(quarter, {
                    width: "wide",
                    context: "standalone"
                });
        }
    },
    // Month
    M: function(date, token, localize) {
        const month = date.getMonth();
        switch(token){
            case "M":
            case "MM":
                return _index7.lightFormatters.M(date, token);
            // 1st, 2nd, ..., 12th
            case "Mo":
                return localize.ordinalNumber(month + 1, {
                    unit: "month"
                });
            // Jan, Feb, ..., Dec
            case "MMM":
                return localize.month(month, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // J, F, ..., D
            case "MMMMM":
                return localize.month(month, {
                    width: "narrow",
                    context: "formatting"
                });
            // January, February, ..., December
            case "MMMM":
            default:
                return localize.month(month, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Stand-alone month
    L: function(date, token, localize) {
        const month = date.getMonth();
        switch(token){
            // 1, 2, ..., 12
            case "L":
                return String(month + 1);
            // 01, 02, ..., 12
            case "LL":
                return (0, _index6.addLeadingZeros)(month + 1, 2);
            // 1st, 2nd, ..., 12th
            case "Lo":
                return localize.ordinalNumber(month + 1, {
                    unit: "month"
                });
            // Jan, Feb, ..., Dec
            case "LLL":
                return localize.month(month, {
                    width: "abbreviated",
                    context: "standalone"
                });
            // J, F, ..., D
            case "LLLLL":
                return localize.month(month, {
                    width: "narrow",
                    context: "standalone"
                });
            // January, February, ..., December
            case "LLLL":
            default:
                return localize.month(month, {
                    width: "wide",
                    context: "standalone"
                });
        }
    },
    // Local week of year
    w: function(date, token, localize, options) {
        const week = (0, _index4.getWeek)(date, options);
        if (token === "wo") return localize.ordinalNumber(week, {
            unit: "week"
        });
        return (0, _index6.addLeadingZeros)(week, token.length);
    },
    // ISO week of year
    I: function(date, token, localize) {
        const isoWeek = (0, _index2.getISOWeek)(date);
        if (token === "Io") return localize.ordinalNumber(isoWeek, {
            unit: "week"
        });
        return (0, _index6.addLeadingZeros)(isoWeek, token.length);
    },
    // Day of the month
    d: function(date, token, localize) {
        if (token === "do") return localize.ordinalNumber(date.getDate(), {
            unit: "date"
        });
        return _index7.lightFormatters.d(date, token);
    },
    // Day of year
    D: function(date, token, localize) {
        const dayOfYear = (0, _index.getDayOfYear)(date);
        if (token === "Do") return localize.ordinalNumber(dayOfYear, {
            unit: "dayOfYear"
        });
        return (0, _index6.addLeadingZeros)(dayOfYear, token.length);
    },
    // Day of week
    E: function(date, token, localize) {
        const dayOfWeek = date.getDay();
        switch(token){
            // Tue
            case "E":
            case "EE":
            case "EEE":
                return localize.day(dayOfWeek, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // T
            case "EEEEE":
                return localize.day(dayOfWeek, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tu
            case "EEEEEE":
                return localize.day(dayOfWeek, {
                    width: "short",
                    context: "formatting"
                });
            // Tuesday
            case "EEEE":
            default:
                return localize.day(dayOfWeek, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Local day of week
    e: function(date, token, localize, options) {
        const dayOfWeek = date.getDay();
        const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch(token){
            // Numerical value (Nth day of week with current locale or weekStartsOn)
            case "e":
                return String(localDayOfWeek);
            // Padded numerical value
            case "ee":
                return (0, _index6.addLeadingZeros)(localDayOfWeek, 2);
            // 1st, 2nd, ..., 7th
            case "eo":
                return localize.ordinalNumber(localDayOfWeek, {
                    unit: "day"
                });
            case "eee":
                return localize.day(dayOfWeek, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // T
            case "eeeee":
                return localize.day(dayOfWeek, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tu
            case "eeeeee":
                return localize.day(dayOfWeek, {
                    width: "short",
                    context: "formatting"
                });
            // Tuesday
            case "eeee":
            default:
                return localize.day(dayOfWeek, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Stand-alone local day of week
    c: function(date, token, localize, options) {
        const dayOfWeek = date.getDay();
        const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch(token){
            // Numerical value (same as in `e`)
            case "c":
                return String(localDayOfWeek);
            // Padded numerical value
            case "cc":
                return (0, _index6.addLeadingZeros)(localDayOfWeek, token.length);
            // 1st, 2nd, ..., 7th
            case "co":
                return localize.ordinalNumber(localDayOfWeek, {
                    unit: "day"
                });
            case "ccc":
                return localize.day(dayOfWeek, {
                    width: "abbreviated",
                    context: "standalone"
                });
            // T
            case "ccccc":
                return localize.day(dayOfWeek, {
                    width: "narrow",
                    context: "standalone"
                });
            // Tu
            case "cccccc":
                return localize.day(dayOfWeek, {
                    width: "short",
                    context: "standalone"
                });
            // Tuesday
            case "cccc":
            default:
                return localize.day(dayOfWeek, {
                    width: "wide",
                    context: "standalone"
                });
        }
    },
    // ISO day of week
    i: function(date, token, localize) {
        const dayOfWeek = date.getDay();
        const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch(token){
            // 2
            case "i":
                return String(isoDayOfWeek);
            // 02
            case "ii":
                return (0, _index6.addLeadingZeros)(isoDayOfWeek, token.length);
            // 2nd
            case "io":
                return localize.ordinalNumber(isoDayOfWeek, {
                    unit: "day"
                });
            // Tue
            case "iii":
                return localize.day(dayOfWeek, {
                    width: "abbreviated",
                    context: "formatting"
                });
            // T
            case "iiiii":
                return localize.day(dayOfWeek, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tu
            case "iiiiii":
                return localize.day(dayOfWeek, {
                    width: "short",
                    context: "formatting"
                });
            // Tuesday
            case "iiii":
            default:
                return localize.day(dayOfWeek, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // AM or PM
    a: function(date, token, localize) {
        const hours = date.getHours();
        const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch(token){
            case "a":
            case "aa":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "aaa":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                }).toLowerCase();
            case "aaaaa":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "narrow",
                    context: "formatting"
                });
            case "aaaa":
            default:
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // AM, PM, midnight, noon
    b: function(date, token, localize) {
        const hours = date.getHours();
        let dayPeriodEnumValue;
        if (hours === 12) dayPeriodEnumValue = dayPeriodEnum.noon;
        else if (hours === 0) dayPeriodEnumValue = dayPeriodEnum.midnight;
        else dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch(token){
            case "b":
            case "bb":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "bbb":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                }).toLowerCase();
            case "bbbbb":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "narrow",
                    context: "formatting"
                });
            case "bbbb":
            default:
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function(date, token, localize) {
        const hours = date.getHours();
        let dayPeriodEnumValue;
        if (hours >= 17) dayPeriodEnumValue = dayPeriodEnum.evening;
        else if (hours >= 12) dayPeriodEnumValue = dayPeriodEnum.afternoon;
        else if (hours >= 4) dayPeriodEnumValue = dayPeriodEnum.morning;
        else dayPeriodEnumValue = dayPeriodEnum.night;
        switch(token){
            case "B":
            case "BB":
            case "BBB":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "abbreviated",
                    context: "formatting"
                });
            case "BBBBB":
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "narrow",
                    context: "formatting"
                });
            case "BBBB":
            default:
                return localize.dayPeriod(dayPeriodEnumValue, {
                    width: "wide",
                    context: "formatting"
                });
        }
    },
    // Hour [1-12]
    h: function(date, token, localize) {
        if (token === "ho") {
            let hours = date.getHours() % 12;
            if (hours === 0) hours = 12;
            return localize.ordinalNumber(hours, {
                unit: "hour"
            });
        }
        return _index7.lightFormatters.h(date, token);
    },
    // Hour [0-23]
    H: function(date, token, localize) {
        if (token === "Ho") return localize.ordinalNumber(date.getHours(), {
            unit: "hour"
        });
        return _index7.lightFormatters.H(date, token);
    },
    // Hour [0-11]
    K: function(date, token, localize) {
        const hours = date.getHours() % 12;
        if (token === "Ko") return localize.ordinalNumber(hours, {
            unit: "hour"
        });
        return (0, _index6.addLeadingZeros)(hours, token.length);
    },
    // Hour [1-24]
    k: function(date, token, localize) {
        let hours = date.getHours();
        if (hours === 0) hours = 24;
        if (token === "ko") return localize.ordinalNumber(hours, {
            unit: "hour"
        });
        return (0, _index6.addLeadingZeros)(hours, token.length);
    },
    // Minute
    m: function(date, token, localize) {
        if (token === "mo") return localize.ordinalNumber(date.getMinutes(), {
            unit: "minute"
        });
        return _index7.lightFormatters.m(date, token);
    },
    // Second
    s: function(date, token, localize) {
        if (token === "so") return localize.ordinalNumber(date.getSeconds(), {
            unit: "second"
        });
        return _index7.lightFormatters.s(date, token);
    },
    // Fraction of second
    S: function(date, token) {
        return _index7.lightFormatters.S(date, token);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function(date, token, _localize, options) {
        const originalDate = options._originalDate || date;
        const timezoneOffset = originalDate.getTimezoneOffset();
        if (timezoneOffset === 0) return "Z";
        switch(token){
            // Hours and optional minutes
            case "X":
                return formatTimezoneWithOptionalMinutes(timezoneOffset);
            // Hours, minutes and optional seconds without `:` delimiter
            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
            // so this token always has the same output as `XX`
            case "XXXX":
            case "XX":
                return formatTimezone(timezoneOffset);
            // Hours, minutes and optional seconds with `:` delimiter
            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
            // so this token always has the same output as `XXX`
            case "XXXXX":
            case "XXX":
            default:
                return formatTimezone(timezoneOffset, ":");
        }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function(date, token, _localize, options) {
        const originalDate = options._originalDate || date;
        const timezoneOffset = originalDate.getTimezoneOffset();
        switch(token){
            // Hours and optional minutes
            case "x":
                return formatTimezoneWithOptionalMinutes(timezoneOffset);
            // Hours, minutes and optional seconds without `:` delimiter
            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
            // so this token always has the same output as `xx`
            case "xxxx":
            case "xx":
                return formatTimezone(timezoneOffset);
            // Hours, minutes and optional seconds with `:` delimiter
            // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
            // so this token always has the same output as `xxx`
            case "xxxxx":
            case "xxx":
            default:
                return formatTimezone(timezoneOffset, ":");
        }
    },
    // Timezone (GMT)
    O: function(date, token, _localize, options) {
        const originalDate = options._originalDate || date;
        const timezoneOffset = originalDate.getTimezoneOffset();
        switch(token){
            // Short
            case "O":
            case "OO":
            case "OOO":
                return "GMT" + formatTimezoneShort(timezoneOffset, ":");
            // Long
            case "OOOO":
            default:
                return "GMT" + formatTimezone(timezoneOffset, ":");
        }
    },
    // Timezone (specific non-location)
    z: function(date, token, _localize, options) {
        const originalDate = options._originalDate || date;
        const timezoneOffset = originalDate.getTimezoneOffset();
        switch(token){
            // Short
            case "z":
            case "zz":
            case "zzz":
                return "GMT" + formatTimezoneShort(timezoneOffset, ":");
            // Long
            case "zzzz":
            default:
                return "GMT" + formatTimezone(timezoneOffset, ":");
        }
    },
    // Seconds timestamp
    t: function(date, token, _localize, options) {
        const originalDate = options._originalDate || date;
        const timestamp = Math.floor(originalDate.getTime() / 1000);
        return (0, _index6.addLeadingZeros)(timestamp, token.length);
    },
    // Milliseconds timestamp
    T: function(date, token, _localize, options) {
        const originalDate = options._originalDate || date;
        const timestamp = originalDate.getTime();
        return (0, _index6.addLeadingZeros)(timestamp, token.length);
    }
};
function formatTimezoneShort(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = Math.floor(absOffset / 60);
    const minutes = absOffset % 60;
    if (minutes === 0) return sign + String(hours);
    return sign + String(hours) + delimiter + (0, _index6.addLeadingZeros)(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, delimiter) {
    if (offset % 60 === 0) {
        const sign = offset > 0 ? "-" : "+";
        return sign + (0, _index6.addLeadingZeros)(Math.abs(offset) / 60, 2);
    }
    return formatTimezone(offset, delimiter);
}
function formatTimezone(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = (0, _index6.addLeadingZeros)(Math.floor(absOffset / 60), 2);
    const minutes = (0, _index6.addLeadingZeros)(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
}

},{"2b70b701cccd48ba":"lR8Io","ce71b00fa268a334":"fNkwc","be1f4bd5db98fc0b":"jWChc","4d35ee8b95213cb2":"1zHej","31a9b5233efbdb74":"7odmH","c78164dd4be2dfdf":"jcCHs","c129443cf4e77b69":"bOcKP"}],"lR8Io":[function(require,module,exports) {
"use strict";
exports.getDayOfYear = getDayOfYear;
var _index = require("e4c17eecd713ff7a");
var _index2 = require("984c12d93b064944");
var _index3 = require("92e9542334495a7a");
/**
 * @name getDayOfYear
 * @category Day Helpers
 * @summary Get the day of the year of the given date.
 *
 * @description
 * Get the day of the year of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The day of year
 *
 * @example
 * // Which day of the year is 2 July 2014?
 * const result = getDayOfYear(new Date(2014, 6, 2))
 * //=> 183
 */ function getDayOfYear(date) {
    const _date = (0, _index3.toDate)(date);
    const diff = (0, _index.differenceInCalendarDays)(_date, (0, _index2.startOfYear)(_date));
    const dayOfYear = diff + 1;
    return dayOfYear;
}

},{"e4c17eecd713ff7a":"dvya7","984c12d93b064944":"cnrH3","92e9542334495a7a":"actWA"}],"fNkwc":[function(require,module,exports) {
"use strict";
exports.getISOWeek = getISOWeek;
var _index = require("dd6520a678bb82fc");
var _index2 = require("4086029c683d4450");
var _index3 = require("5ae2977ff2643258");
var _index4 = require("e810a780c889259");
/**
 * @name getISOWeek
 * @category ISO Week Helpers
 * @summary Get the ISO week of the given date.
 *
 * @description
 * Get the ISO week of the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The ISO week
 *
 * @example
 * // Which week of the ISO-week numbering year is 2 January 2005?
 * const result = getISOWeek(new Date(2005, 0, 2))
 * //=> 53
 */ function getISOWeek(date) {
    const _date = (0, _index4.toDate)(date);
    const diff = (0, _index2.startOfISOWeek)(_date).getTime() - (0, _index3.startOfISOWeekYear)(_date).getTime();
    // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / _index.millisecondsInWeek) + 1;
}

},{"dd6520a678bb82fc":"1vXXw","4086029c683d4450":"iF0wL","5ae2977ff2643258":"eTm1l","e810a780c889259":"actWA"}],"1zHej":[function(require,module,exports) {
"use strict";
exports.getWeek = getWeek;
var _index = require("800ec1a6edc498ae");
var _index2 = require("5469df090b94480b");
var _index3 = require("28ef936dfd692f02");
var _index4 = require("9206fd6ff40c35c");
/**
 * The {@link getWeek} function options.
 */ /**
 * @name getWeek
 * @category Week Helpers
 * @summary Get the local week index of the given date.
 *
 * @description
 * Get the local week index of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options
 *
 * @returns The week
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005 with default options?
 * const result = getWeek(new Date(2005, 0, 2))
 * //=> 2
 *
 * @example
 * // Which week of the local week numbering year is 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January?
 * const result = getWeek(new Date(2005, 0, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> 53
 */ function getWeek(date, options) {
    const _date = (0, _index4.toDate)(date);
    const diff = (0, _index2.startOfWeek)(_date, options).getTime() - (0, _index3.startOfWeekYear)(_date, options).getTime();
    // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / _index.millisecondsInWeek) + 1;
}

},{"800ec1a6edc498ae":"1vXXw","5469df090b94480b":"dDDvv","28ef936dfd692f02":"diTjA","9206fd6ff40c35c":"actWA"}],"diTjA":[function(require,module,exports) {
"use strict";
exports.startOfWeekYear = startOfWeekYear;
var _index = require("14264660eed87479");
var _index2 = require("ed79bb16479293f4");
var _index3 = require("6d62705f140db78b");
var _index4 = require("81264b991a2a077c");
/**
 * The {@link startOfWeekYear} function options.
 */ /**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week-numbering year
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * const result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */ function startOfWeekYear(date, options) {
    const defaultOptions = (0, _index4.getDefaultOptions)();
    const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions.firstWeekContainsDate ?? defaultOptions.locale?.options?.firstWeekContainsDate ?? 1;
    const year = (0, _index2.getWeekYear)(date, options);
    const firstWeek = (0, _index.constructFrom)(date, 0);
    firstWeek.setFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    const _date = (0, _index3.startOfWeek)(firstWeek, options);
    return _date;
}

},{"14264660eed87479":"hNMdA","ed79bb16479293f4":"7odmH","6d62705f140db78b":"dDDvv","81264b991a2a077c":"98fau"}],"7odmH":[function(require,module,exports) {
"use strict";
exports.getWeekYear = getWeekYear;
var _index = require("49bcd86a127941a3");
var _index2 = require("e4e186ff29cb44fa");
var _index3 = require("639f7e4c63562544");
var _index4 = require("cda7b6367e92badd");
/**
 * The {@link getWeekYear} function options.
 */ /**
 * @name getWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Get the local week-numbering year of the given date.
 *
 * @description
 * Get the local week-numbering year of the given date.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The local week-numbering year
 *
 * @example
 * // Which week numbering year is 26 December 2004 with the default settings?
 * const result = getWeekYear(new Date(2004, 11, 26))
 * //=> 2005
 *
 * @example
 * // Which week numbering year is 26 December 2004 if week starts on Saturday?
 * const result = getWeekYear(new Date(2004, 11, 26), { weekStartsOn: 6 })
 * //=> 2004
 *
 * @example
 * // Which week numbering year is 26 December 2004 if the first week contains 4 January?
 * const result = getWeekYear(new Date(2004, 11, 26), { firstWeekContainsDate: 4 })
 * //=> 2004
 */ function getWeekYear(date, options) {
    const _date = (0, _index3.toDate)(date);
    const year = _date.getFullYear();
    const defaultOptions = (0, _index4.getDefaultOptions)();
    const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions.firstWeekContainsDate ?? defaultOptions.locale?.options?.firstWeekContainsDate ?? 1;
    const firstWeekOfNextYear = (0, _index.constructFrom)(date, 0);
    firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = (0, _index2.startOfWeek)(firstWeekOfNextYear, options);
    const firstWeekOfThisYear = (0, _index.constructFrom)(date, 0);
    firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = (0, _index2.startOfWeek)(firstWeekOfThisYear, options);
    if (_date.getTime() >= startOfNextYear.getTime()) return year + 1;
    else if (_date.getTime() >= startOfThisYear.getTime()) return year;
    else return year - 1;
}

},{"49bcd86a127941a3":"hNMdA","e4e186ff29cb44fa":"dDDvv","639f7e4c63562544":"actWA","cda7b6367e92badd":"98fau"}],"jcCHs":[function(require,module,exports) {
"use strict";
exports.addLeadingZeros = addLeadingZeros;
function addLeadingZeros(number, targetLength) {
    const sign = number < 0 ? "-" : "";
    const output = Math.abs(number).toString().padStart(targetLength, "0");
    return sign + output;
}

},{}],"bOcKP":[function(require,module,exports) {
"use strict";
exports.lightFormatters = void 0;
var _index = require("90a72a8e36ccc405");
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */ const lightFormatters = exports.lightFormatters = {
    // Year
    y (date, token) {
        // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
        // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
        // |----------|-------|----|-------|-------|-------|
        // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
        // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
        // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
        // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
        // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
        const signedYear = date.getFullYear();
        // Returns 1 for 1 BC (which is year 0 in JavaScript)
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return (0, _index.addLeadingZeros)(token === "yy" ? year % 100 : year, token.length);
    },
    // Month
    M (date, token) {
        const month = date.getMonth();
        return token === "M" ? String(month + 1) : (0, _index.addLeadingZeros)(month + 1, 2);
    },
    // Day of the month
    d (date, token) {
        return (0, _index.addLeadingZeros)(date.getDate(), token.length);
    },
    // AM or PM
    a (date, token) {
        const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
        switch(token){
            case "a":
            case "aa":
                return dayPeriodEnumValue.toUpperCase();
            case "aaa":
                return dayPeriodEnumValue;
            case "aaaaa":
                return dayPeriodEnumValue[0];
            case "aaaa":
            default:
                return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
        }
    },
    // Hour [1-12]
    h (date, token) {
        return (0, _index.addLeadingZeros)(date.getHours() % 12 || 12, token.length);
    },
    // Hour [0-23]
    H (date, token) {
        return (0, _index.addLeadingZeros)(date.getHours(), token.length);
    },
    // Minute
    m (date, token) {
        return (0, _index.addLeadingZeros)(date.getMinutes(), token.length);
    },
    // Second
    s (date, token) {
        return (0, _index.addLeadingZeros)(date.getSeconds(), token.length);
    },
    // Fraction of second
    S (date, token) {
        const numberOfDigits = token.length;
        const milliseconds = date.getMilliseconds();
        const fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
        return (0, _index.addLeadingZeros)(fractionalSeconds, token.length);
    }
};

},{"90a72a8e36ccc405":"jcCHs"}],"jsbdH":[function(require,module,exports) {
"use strict";
exports.longFormatters = void 0;
const dateLongFormatter = (pattern, formatLong)=>{
    switch(pattern){
        case "P":
            return formatLong.date({
                width: "short"
            });
        case "PP":
            return formatLong.date({
                width: "medium"
            });
        case "PPP":
            return formatLong.date({
                width: "long"
            });
        case "PPPP":
        default:
            return formatLong.date({
                width: "full"
            });
    }
};
const timeLongFormatter = (pattern, formatLong)=>{
    switch(pattern){
        case "p":
            return formatLong.time({
                width: "short"
            });
        case "pp":
            return formatLong.time({
                width: "medium"
            });
        case "ppp":
            return formatLong.time({
                width: "long"
            });
        case "pppp":
        default:
            return formatLong.time({
                width: "full"
            });
    }
};
const dateTimeLongFormatter = (pattern, formatLong)=>{
    const matchResult = pattern.match(/(P+)(p+)?/) || [];
    const datePattern = matchResult[1];
    const timePattern = matchResult[2];
    if (!timePattern) return dateLongFormatter(pattern, formatLong);
    let dateTimeFormat;
    switch(datePattern){
        case "P":
            dateTimeFormat = formatLong.dateTime({
                width: "short"
            });
            break;
        case "PP":
            dateTimeFormat = formatLong.dateTime({
                width: "medium"
            });
            break;
        case "PPP":
            dateTimeFormat = formatLong.dateTime({
                width: "long"
            });
            break;
        case "PPPP":
        default:
            dateTimeFormat = formatLong.dateTime({
                width: "full"
            });
            break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong)).replace("{{time}}", timeLongFormatter(timePattern, formatLong));
};
const longFormatters = exports.longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
};

},{}],"dFKqd":[function(require,module,exports) {
"use strict";
exports.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
exports.isProtectedWeekYearToken = isProtectedWeekYearToken;
exports.warnOrThrowProtectedError = warnOrThrowProtectedError;
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;
const throwTokens = [
    "D",
    "DD",
    "YY",
    "YYYY"
];
function isProtectedDayOfYearToken(token) {
    return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
    return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format, input) {
    const _message = message(token, format, input);
    console.warn(_message);
    if (throwTokens.includes(token)) throw new RangeError(_message);
}
function message(token, format, input) {
    const subject = token[0] === "Y" ? "years" : "days of the month";
    return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}

},{}],"aBg6Q":[function(require,module,exports) {
"use strict";
exports.formatDistance = formatDistance;
var _index = require("76afd985fbd5e2f0");
var _index2 = require("21024a7a0ba671b5");
var _index3 = require("6be099d87c2941d5");
var _index4 = require("db428a4e351bfe8c");
var _index5 = require("e25628e46d5fa234");
var _index6 = require("25e8a16723332367");
var _index7 = require("e890155e5b3527ab");
var _index8 = require("a60baec803ff2cf8");
/**
 * The {@link formatDistance} function options.
 */ /**
 * @name formatDistance
 * @category Common Helpers
 * @summary Return the distance between the given dates in words.
 *
 * @description
 * Return the distance between the given dates in words.
 *
 * | Distance between dates                                            | Result              |
 * |-------------------------------------------------------------------|---------------------|
 * | 0 ... 30 secs                                                     | less than a minute  |
 * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
 * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
 * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
 * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
 * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
 * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
 * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
 * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
 * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
 * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
 * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
 * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
 * | N yrs ... N yrs 3 months                                          | about N years       |
 * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
 * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
 *
 * With `options.includeSeconds == true`:
 * | Distance between dates | Result               |
 * |------------------------|----------------------|
 * | 0 secs ... 5 secs      | less than 5 seconds  |
 * | 5 secs ... 10 secs     | less than 10 seconds |
 * | 10 secs ... 20 secs    | less than 20 seconds |
 * | 20 secs ... 40 secs    | half a minute        |
 * | 40 secs ... 60 secs    | less than a minute   |
 * | 60 secs ... 90 secs    | 1 minute             |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date
 * @param baseDate - The date to compare with
 * @param options - An object with options
 *
 * @returns The distance in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `baseDate` must not be Invalid Date
 * @throws `options.locale` must contain `formatDistance` property
 *
 * @example
 * // What is the distance between 2 July 2014 and 1 January 2015?
 * const result = formatDistance(new Date(2014, 6, 2), new Date(2015, 0, 1))
 * //=> '6 months'
 *
 * @example
 * // What is the distance between 1 January 2015 00:00:15
 * // and 1 January 2015 00:00:00, including seconds?
 * const result = formatDistance(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   new Date(2015, 0, 1, 0, 0, 0),
 *   { includeSeconds: true }
 * )
 * //=> 'less than 20 seconds'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, with a suffix?
 * const result = formatDistance(new Date(2015, 0, 1), new Date(2016, 0, 1), {
 *   addSuffix: true
 * })
 * //=> 'about 1 year ago'
 *
 * @example
 * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = formatDistance(new Date(2016, 7, 1), new Date(2015, 0, 1), {
 *   locale: eoLocale
 * })
 * //=> 'pli ol 1 jaro'
 */ function formatDistance(date, baseDate, options) {
    const defaultOptions = (0, _index7.getDefaultOptions)();
    const locale = options?.locale ?? defaultOptions.locale ?? _index6.defaultLocale;
    const minutesInAlmostTwoDays = 2520;
    const comparison = (0, _index.compareAsc)(date, baseDate);
    if (isNaN(comparison)) throw new RangeError("Invalid time value");
    const localizeOptions = Object.assign({}, options, {
        addSuffix: options?.addSuffix,
        comparison: comparison
    });
    let dateLeft;
    let dateRight;
    if (comparison > 0) {
        dateLeft = (0, _index5.toDate)(baseDate);
        dateRight = (0, _index5.toDate)(date);
    } else {
        dateLeft = (0, _index5.toDate)(date);
        dateRight = (0, _index5.toDate)(baseDate);
    }
    const seconds = (0, _index4.differenceInSeconds)(dateRight, dateLeft);
    const offsetInSeconds = ((0, _index8.getTimezoneOffsetInMilliseconds)(dateRight) - (0, _index8.getTimezoneOffsetInMilliseconds)(dateLeft)) / 1000;
    const minutes = Math.round((seconds - offsetInSeconds) / 60);
    let months;
    // 0 up to 2 mins
    if (minutes < 2) {
        if (options?.includeSeconds) {
            if (seconds < 5) return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
            else if (seconds < 10) return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
            else if (seconds < 20) return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
            else if (seconds < 40) return locale.formatDistance("halfAMinute", 0, localizeOptions);
            else if (seconds < 60) return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
            else return locale.formatDistance("xMinutes", 1, localizeOptions);
        } else {
            if (minutes === 0) return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
            else return locale.formatDistance("xMinutes", minutes, localizeOptions);
        }
    } else if (minutes < 45) return locale.formatDistance("xMinutes", minutes, localizeOptions);
    else if (minutes < 90) return locale.formatDistance("aboutXHours", 1, localizeOptions);
    else if (minutes < _index2.minutesInDay) {
        const hours = Math.round(minutes / 60);
        return locale.formatDistance("aboutXHours", hours, localizeOptions);
    // 1 day up to 1.75 days
    } else if (minutes < minutesInAlmostTwoDays) return locale.formatDistance("xDays", 1, localizeOptions);
    else if (minutes < _index2.minutesInMonth) {
        const days = Math.round(minutes / _index2.minutesInDay);
        return locale.formatDistance("xDays", days, localizeOptions);
    // 1 month up to 2 months
    } else if (minutes < _index2.minutesInMonth * 2) {
        months = Math.round(minutes / _index2.minutesInMonth);
        return locale.formatDistance("aboutXMonths", months, localizeOptions);
    }
    months = (0, _index3.differenceInMonths)(dateRight, dateLeft);
    // 2 months up to 12 months
    if (months < 12) {
        const nearestMonth = Math.round(minutes / _index2.minutesInMonth);
        return locale.formatDistance("xMonths", nearestMonth, localizeOptions);
    // 1 year up to max Date
    } else {
        const monthsSinceStartOfYear = months % 12;
        const years = Math.floor(months / 12);
        // N years up to 1 years 3 months
        if (monthsSinceStartOfYear < 3) return locale.formatDistance("aboutXYears", years, localizeOptions);
        else if (monthsSinceStartOfYear < 9) return locale.formatDistance("overXYears", years, localizeOptions);
        else return locale.formatDistance("almostXYears", years + 1, localizeOptions);
    }
}

},{"76afd985fbd5e2f0":"fgd9M","21024a7a0ba671b5":"1vXXw","6be099d87c2941d5":"i3gFX","db428a4e351bfe8c":"3IvxJ","e25628e46d5fa234":"actWA","25e8a16723332367":"iG9h0","e890155e5b3527ab":"98fau","a60baec803ff2cf8":"ke6Rl"}],"7aKP6":[function(require,module,exports) {
"use strict";
exports.formatDistanceStrict = formatDistanceStrict;
var _index = require("77731e5dbddcf175");
var _index2 = require("20f92626a7750d09");
var _index3 = require("d0708329596583b6");
var _index4 = require("e63395a7a1926bcc");
var _index5 = require("ecf31216a9de7ed1");
var _index6 = require("be3762b050b26a12");
var _index7 = require("cda5e80a9a45c076");
/**
 * The {@link formatDistanceStrict} function options.
 */ /**
 * The unit used to format the distance in {@link formatDistanceStrict}.
 */ /**
 * @name formatDistanceStrict
 * @category Common Helpers
 * @summary Return the distance between the given dates in words.
 *
 * @description
 * Return the distance between the given dates in words, using strict units.
 * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
 * 'less than' and the like.
 *
 * | Distance between dates | Result              |
 * |------------------------|---------------------|
 * | 0 ... 59 secs          | [0..59] seconds     |
 * | 1 ... 59 mins          | [1..59] minutes     |
 * | 1 ... 23 hrs           | [1..23] hours       |
 * | 1 ... 29 days          | [1..29] days        |
 * | 1 ... 11 months        | [1..11] months      |
 * | 1 ... N years          | [1..N]  years       |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date
 * @param baseDate - The date to compare with
 * @param options - An object with options
 *
 * @returns The distance in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `baseDate` must not be Invalid Date
 * @throws `options.unit` must be 'second', 'minute', 'hour', 'day', 'month' or 'year'
 * @throws `options.locale` must contain `formatDistance` property
 *
 * @example
 * // What is the distance between 2 July 2014 and 1 January 2015?
 * const result = formatDistanceStrict(new Date(2014, 6, 2), new Date(2015, 0, 2))
 * //=> '6 months'
 *
 * @example
 * // What is the distance between 1 January 2015 00:00:15
 * // and 1 January 2015 00:00:00?
 * const result = formatDistanceStrict(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   new Date(2015, 0, 1, 0, 0, 0)
 * )
 * //=> '15 seconds'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, with a suffix?
 * const result = formatDistanceStrict(new Date(2015, 0, 1), new Date(2016, 0, 1), {
 *   addSuffix: true
 * })
 * //=> '1 year ago'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, in minutes?
 * const result = formatDistanceStrict(new Date(2016, 0, 1), new Date(2015, 0, 1), {
 *   unit: 'minute'
 * })
 * //=> '525600 minutes'
 *
 * @example
 * // What is the distance from 1 January 2015
 * // to 28 January 2015, in months, rounded up?
 * const result = formatDistanceStrict(new Date(2015, 0, 28), new Date(2015, 0, 1), {
 *   unit: 'month',
 *   roundingMethod: 'ceil'
 * })
 * //=> '1 month'
 *
 * @example
 * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = formatDistanceStrict(new Date(2016, 7, 1), new Date(2015, 0, 1), {
 *   locale: eoLocale
 * })
 * //=> '1 jaro'
 */ function formatDistanceStrict(date, baseDate, options) {
    const defaultOptions = (0, _index2.getDefaultOptions)();
    const locale = options?.locale ?? defaultOptions.locale ?? _index.defaultLocale;
    const comparison = (0, _index5.compareAsc)(date, baseDate);
    if (isNaN(comparison)) throw new RangeError("Invalid time value");
    const localizeOptions = Object.assign({}, options, {
        addSuffix: options?.addSuffix,
        comparison: comparison
    });
    let dateLeft;
    let dateRight;
    if (comparison > 0) {
        dateLeft = (0, _index7.toDate)(baseDate);
        dateRight = (0, _index7.toDate)(date);
    } else {
        dateLeft = (0, _index7.toDate)(date);
        dateRight = (0, _index7.toDate)(baseDate);
    }
    const roundingMethod = (0, _index3.getRoundingMethod)(options?.roundingMethod ?? "round");
    const milliseconds = dateRight.getTime() - dateLeft.getTime();
    const minutes = milliseconds / _index6.millisecondsInMinute;
    const timezoneOffset = (0, _index4.getTimezoneOffsetInMilliseconds)(dateRight) - (0, _index4.getTimezoneOffsetInMilliseconds)(dateLeft);
    // Use DST-normalized difference in minutes for years, months and days;
    // use regular difference in minutes for hours, minutes and seconds.
    const dstNormalizedMinutes = (milliseconds - timezoneOffset) / _index6.millisecondsInMinute;
    const defaultUnit = options?.unit;
    let unit;
    if (!defaultUnit) {
        if (minutes < 1) unit = "second";
        else if (minutes < 60) unit = "minute";
        else if (minutes < _index6.minutesInDay) unit = "hour";
        else if (dstNormalizedMinutes < _index6.minutesInMonth) unit = "day";
        else if (dstNormalizedMinutes < _index6.minutesInYear) unit = "month";
        else unit = "year";
    } else unit = defaultUnit;
    // 0 up to 60 seconds
    if (unit === "second") {
        const seconds = roundingMethod(milliseconds / 1000);
        return locale.formatDistance("xSeconds", seconds, localizeOptions);
    // 1 up to 60 mins
    } else if (unit === "minute") {
        const roundedMinutes = roundingMethod(minutes);
        return locale.formatDistance("xMinutes", roundedMinutes, localizeOptions);
    // 1 up to 24 hours
    } else if (unit === "hour") {
        const hours = roundingMethod(minutes / 60);
        return locale.formatDistance("xHours", hours, localizeOptions);
    // 1 up to 30 days
    } else if (unit === "day") {
        const days = roundingMethod(dstNormalizedMinutes / _index6.minutesInDay);
        return locale.formatDistance("xDays", days, localizeOptions);
    // 1 up to 12 months
    } else if (unit === "month") {
        const months = roundingMethod(dstNormalizedMinutes / _index6.minutesInMonth);
        return months === 12 && defaultUnit !== "month" ? locale.formatDistance("xYears", 1, localizeOptions) : locale.formatDistance("xMonths", months, localizeOptions);
    // 1 year up to max Date
    } else {
        const years = roundingMethod(dstNormalizedMinutes / _index6.minutesInYear);
        return locale.formatDistance("xYears", years, localizeOptions);
    }
}

},{"77731e5dbddcf175":"iG9h0","20f92626a7750d09":"98fau","d0708329596583b6":"1ipL6","e63395a7a1926bcc":"ke6Rl","ecf31216a9de7ed1":"fgd9M","be3762b050b26a12":"1vXXw","cda5e80a9a45c076":"actWA"}],"eLZ5b":[function(require,module,exports) {
"use strict";
exports.formatDistanceToNow = formatDistanceToNow;
var _index = require("b74aefd5706bbd8c");
/**
 * The {@link formatDistanceToNow} function options.
 */ /**
 * @name formatDistanceToNow
 * @category Common Helpers
 * @summary Return the distance between the given date and now in words.
 * @pure false
 *
 * @description
 * Return the distance between the given date and now in words.
 *
 * | Distance to now                                                   | Result              |
 * |-------------------------------------------------------------------|---------------------|
 * | 0 ... 30 secs                                                     | less than a minute  |
 * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
 * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
 * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
 * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
 * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
 * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
 * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
 * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
 * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
 * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
 * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
 * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
 * | N yrs ... N yrs 3 months                                          | about N years       |
 * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
 * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
 *
 * With `options.includeSeconds == true`:
 * | Distance to now     | Result               |
 * |---------------------|----------------------|
 * | 0 secs ... 5 secs   | less than 5 seconds  |
 * | 5 secs ... 10 secs  | less than 10 seconds |
 * | 10 secs ... 20 secs | less than 20 seconds |
 * | 20 secs ... 40 secs | half a minute        |
 * | 40 secs ... 60 secs | less than a minute   |
 * | 60 secs ... 90 secs | 1 minute             |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - The object with options
 *
 * @returns The distance in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `options.locale` must contain `formatDistance` property
 *
 * @example
 * // If today is 1 January 2015, what is the distance to 2 July 2014?
 * const result = formatDistanceToNow(
 *   new Date(2014, 6, 2)
 * )
 * //=> '6 months'
 *
 * @example
 * // If now is 1 January 2015 00:00:00,
 * // what is the distance to 1 January 2015 00:00:15, including seconds?
 * const result = formatDistanceToNow(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   {includeSeconds: true}
 * )
 * //=> 'less than 20 seconds'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 January 2016, with a suffix?
 * const result = formatDistanceToNow(
 *   new Date(2016, 0, 1),
 *   {addSuffix: true}
 * )
 * //=> 'in about 1 year'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 August 2016 in Esperanto?
 * const eoLocale = require('date-fns/locale/eo')
 * const result = formatDistanceToNow(
 *   new Date(2016, 7, 1),
 *   {locale: eoLocale}
 * )
 * //=> 'pli ol 1 jaro'
 */ function formatDistanceToNow(date, options) {
    return (0, _index.formatDistance)(date, Date.now(), options);
}

},{"b74aefd5706bbd8c":"aBg6Q"}],"4IPnK":[function(require,module,exports) {
"use strict";
exports.formatDistanceToNowStrict = formatDistanceToNowStrict;
var _index = require("36ce334c2c1ca0b8");
/**
 * The {@link formatDistanceToNowStrict} function options.
 */ /**
 * @name formatDistanceToNowStrict
 * @category Common Helpers
 * @summary Return the distance between the given date and now in words.
 * @pure false
 *
 * @description
 * Return the distance between the given dates in words, using strict units.
 * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
 * 'less than' and the like.
 *
 * | Distance between dates | Result              |
 * |------------------------|---------------------|
 * | 0 ... 59 secs          | [0..59] seconds     |
 * | 1 ... 59 mins          | [1..59] minutes     |
 * | 1 ... 23 hrs           | [1..23] hours       |
 * | 1 ... 29 days          | [1..29] days        |
 * | 1 ... 11 months        | [1..11] months      |
 * | 1 ... N years          | [1..N]  years       |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The distance in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `options.locale` must contain `formatDistance` property
 *
 * @example
 * // If today is 1 January 2015, what is the distance to 2 July 2014?
 * const result = formatDistanceToNowStrict(
 *   new Date(2014, 6, 2)
 * )
 * //=> '6 months'
 *
 * @example
 * // If now is 1 January 2015 00:00:00,
 * // what is the distance to 1 January 2015 00:00:15, including seconds?
 * const result = formatDistanceToNowStrict(
 *   new Date(2015, 0, 1, 0, 0, 15)
 * )
 * //=> '15 seconds'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 January 2016, with a suffix?
 * const result = formatDistanceToNowStrict(
 *   new Date(2016, 0, 1),
 *   {addSuffix: true}
 * )
 * //=> 'in 1 year'
 *
 * @example
 * // If today is 28 January 2015,
 * // what is the distance to 1 January 2015, in months, rounded up??
 * const result = formatDistanceToNowStrict(new Date(2015, 0, 1), {
 *   unit: 'month',
 *   roundingMethod: 'ceil'
 * })
 * //=> '1 month'
 *
 * @example
 * // If today is 1 January 2015,
 * // what is the distance to 1 January 2016 in Esperanto?
 * const eoLocale = require('date-fns/locale/eo')
 * const result = formatDistanceToNowStrict(
 *   new Date(2016, 0, 1),
 *   {locale: eoLocale}
 * )
 * //=> '1 jaro'
 */ function formatDistanceToNowStrict(date, options) {
    return (0, _index.formatDistanceStrict)(date, Date.now(), options);
}

},{"36ce334c2c1ca0b8":"7aKP6"}],"03dpp":[function(require,module,exports) {
"use strict";
exports.formatDuration = formatDuration;
var _index = require("865c4fe9be22610");
var _index2 = require("4f29b112438dcac0");
/**
 * The {@link formatDuration} function options.
 */ const defaultFormat = [
    "years",
    "months",
    "weeks",
    "days",
    "hours",
    "minutes",
    "seconds"
];
/**
 * @name formatDuration
 * @category Common Helpers
 * @summary Formats a duration in human-readable format
 *
 * @description
 * Return human-readable duration string i.e. "9 months 2 days"
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param duration - The duration to format
 * @param options - An object with options.
 *
 * @returns The formatted date string
 *
 * @example
 * // Format full duration
 * formatDuration({
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30
 * })
 * //=> '2 years 9 months 1 week 7 days 5 hours 9 minutes 30 seconds'
 *
 * @example
 * // Format partial duration
 * formatDuration({ months: 9, days: 2 })
 * //=> '9 months 2 days'
 *
 * @example
 * // Customize the format
 * formatDuration(
 *   {
 *     years: 2,
 *     months: 9,
 *     weeks: 1,
 *     days: 7,
 *     hours: 5,
 *     minutes: 9,
 *     seconds: 30
 *   },
 *   { format: ['months', 'weeks'] }
 * ) === '9 months 1 week'
 *
 * @example
 * // Customize the zeros presence
 * formatDuration({ years: 0, months: 9 })
 * //=> '9 months'
 * formatDuration({ years: 0, months: 9 }, { zero: true })
 * //=> '0 years 9 months'
 *
 * @example
 * // Customize the delimiter
 * formatDuration({ years: 2, months: 9, weeks: 3 }, { delimiter: ', ' })
 * //=> '2 years, 9 months, 3 weeks'
 */ function formatDuration(duration, options) {
    const defaultOptions = (0, _index2.getDefaultOptions)();
    const locale = options?.locale ?? defaultOptions.locale ?? _index.defaultLocale;
    const format = options?.format ?? defaultFormat;
    const zero = options?.zero ?? false;
    const delimiter = options?.delimiter ?? " ";
    if (!locale.formatDistance) return "";
    const result = format.reduce((acc, unit)=>{
        const token = `x${unit.replace(/(^.)/, (m)=>m.toUpperCase())}`;
        const value = duration[unit];
        if (value !== undefined && (zero || duration[unit])) return acc.concat(locale.formatDistance(token, value));
        return acc;
    }, []).join(delimiter);
    return result;
}

},{"865c4fe9be22610":"iG9h0","4f29b112438dcac0":"98fau"}],"7QewX":[function(require,module,exports) {
"use strict";
exports.formatISO = formatISO;
var _index = require("6a44435540cefeea");
var _index2 = require("50b1943fc9f4c38");
/**
 * The {@link formatISO} function options.
 */ /**
 * @name formatISO
 * @category Common Helpers
 * @summary Format the date according to the ISO 8601 standard (https://support.sas.com/documentation/cdl/en/lrdict/64316/HTML/default/viewer.htm#a003169814.htm).
 *
 * @description
 * Return the formatted date string in ISO 8601 format. Options may be passed to control the parts and notations of the date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options.
 *
 * @returns The formatted date string (in loca.l time zone)
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18T19:00:52Z'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601, short format (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
 * //=> '20190918T190052'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, date only:
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
 * //=> '2019-09-18'
 *
 * @example
 * // Represent 18 September 2019 in ISO 8601 format, time only (local time zone is UTC):
 * const result = formatISO(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
 * //=> '19:00:52Z'
 */ function formatISO(date, options) {
    const _date = (0, _index.toDate)(date);
    if (isNaN(_date.getTime())) throw new RangeError("Invalid time value");
    const format = options?.format ?? "extended";
    const representation = options?.representation ?? "complete";
    let result = "";
    let tzOffset = "";
    const dateDelimiter = format === "extended" ? "-" : "";
    const timeDelimiter = format === "extended" ? ":" : "";
    // Representation is either 'date' or 'complete'
    if (representation !== "time") {
        const day = (0, _index2.addLeadingZeros)(_date.getDate(), 2);
        const month = (0, _index2.addLeadingZeros)(_date.getMonth() + 1, 2);
        const year = (0, _index2.addLeadingZeros)(_date.getFullYear(), 4);
        // yyyyMMdd or yyyy-MM-dd.
        result = `${year}${dateDelimiter}${month}${dateDelimiter}${day}`;
    }
    // Representation is either 'time' or 'complete'
    if (representation !== "date") {
        // Add the timezone.
        const offset = _date.getTimezoneOffset();
        if (offset !== 0) {
            const absoluteOffset = Math.abs(offset);
            const hourOffset = (0, _index2.addLeadingZeros)(Math.floor(absoluteOffset / 60), 2);
            const minuteOffset = (0, _index2.addLeadingZeros)(absoluteOffset % 60, 2);
            // If less than 0, the sign is +, because it is ahead of time.
            const sign = offset < 0 ? "+" : "-";
            tzOffset = `${sign}${hourOffset}:${minuteOffset}`;
        } else tzOffset = "Z";
        const hour = (0, _index2.addLeadingZeros)(_date.getHours(), 2);
        const minute = (0, _index2.addLeadingZeros)(_date.getMinutes(), 2);
        const second = (0, _index2.addLeadingZeros)(_date.getSeconds(), 2);
        // If there's also date, separate it with time with 'T'
        const separator = result === "" ? "" : "T";
        // Creates a time string consisting of hour, minute, and second, separated by delimiters, if defined.
        const time = [
            hour,
            minute,
            second
        ].join(timeDelimiter);
        // HHmmss or HH:mm:ss.
        result = `${result}${separator}${time}${tzOffset}`;
    }
    return result;
}

},{"6a44435540cefeea":"actWA","50b1943fc9f4c38":"jcCHs"}],"eOZFo":[function(require,module,exports) {
"use strict";
exports.formatISO9075 = formatISO9075;
var _index = require("a53ff821fbf3766b");
var _index2 = require("7f4ae1d55b255987");
var _index3 = require("73a14fcf70d50fb2");
/**
 * The {@link formatISO9075} function options.
 */ /**
 * @name formatISO9075
 * @category Common Helpers
 * @summary Format the date according to the ISO 9075 standard (https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_get-format).
 *
 * @description
 * Return the formatted date string in ISO 9075 format. Options may be passed to control the parts and notations of the date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options.
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075 format:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18 19:00:52'
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075, short format:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { format: 'basic' })
 * //=> '20190918 190052'
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075 format, date only:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { representation: 'date' })
 * //=> '2019-09-18'
 *
 * @example
 * // Represent 18 September 2019 in ISO 9075 format, time only:
 * const result = formatISO9075(new Date(2019, 8, 18, 19, 0, 52), { representation: 'time' })
 * //=> '19:00:52'
 */ function formatISO9075(date, options) {
    const _date = (0, _index2.toDate)(date);
    if (!(0, _index.isValid)(_date)) throw new RangeError("Invalid time value");
    const format = options?.format ?? "extended";
    const representation = options?.representation ?? "complete";
    let result = "";
    const dateDelimiter = format === "extended" ? "-" : "";
    const timeDelimiter = format === "extended" ? ":" : "";
    // Representation is either 'date' or 'complete'
    if (representation !== "time") {
        const day = (0, _index3.addLeadingZeros)(_date.getDate(), 2);
        const month = (0, _index3.addLeadingZeros)(_date.getMonth() + 1, 2);
        const year = (0, _index3.addLeadingZeros)(_date.getFullYear(), 4);
        // yyyyMMdd or yyyy-MM-dd.
        result = `${year}${dateDelimiter}${month}${dateDelimiter}${day}`;
    }
    // Representation is either 'time' or 'complete'
    if (representation !== "date") {
        const hour = (0, _index3.addLeadingZeros)(_date.getHours(), 2);
        const minute = (0, _index3.addLeadingZeros)(_date.getMinutes(), 2);
        const second = (0, _index3.addLeadingZeros)(_date.getSeconds(), 2);
        // If there's also date, separate it with time with a space
        const separator = result === "" ? "" : " ";
        // HHmmss or HH:mm:ss.
        result = `${result}${separator}${hour}${timeDelimiter}${minute}${timeDelimiter}${second}`;
    }
    return result;
}

},{"a53ff821fbf3766b":"gbOJY","7f4ae1d55b255987":"actWA","73a14fcf70d50fb2":"jcCHs"}],"6ZrQ5":[function(require,module,exports) {
"use strict";
exports.formatISODuration = formatISODuration;
/**
 * @name formatISODuration
 * @category Common Helpers
 * @summary Format a duration object according as ISO 8601 duration string
 *
 * @description
 * Format a duration object according to the ISO 8601 duration standard (https://www.digi.com/resources/documentation/digidocs//90001488-13/reference/r_iso_8601_duration_format.htm)
 *
 * @param duration - The duration to format
 *
 * @returns The ISO 8601 duration string
 *
 * @example
 * // Format the given duration as ISO 8601 string
 * const result = formatISODuration({
 *   years: 39,
 *   months: 2,
 *   days: 20,
 *   hours: 7,
 *   minutes: 5,
 *   seconds: 0
 * })
 * //=> 'P39Y2M20DT0H0M0S'
 */ function formatISODuration(duration) {
    const { years = 0, months = 0, days = 0, hours = 0, minutes = 0, seconds = 0 } = duration;
    return `P${years}Y${months}M${days}DT${hours}H${minutes}M${seconds}S`;
}

},{}],"4C2Wr":[function(require,module,exports) {
"use strict";
exports.formatRFC3339 = formatRFC3339;
var _index = require("9301294447d1f95b");
var _index2 = require("40b9430b575cdc41");
var _index3 = require("de42c97ba518f921");
/**
 * The {@link formatRFC3339} function options.
 */ /**
 * @name formatRFC3339
 * @category Common Helpers
 * @summary Format the date according to the RFC 3339 standard (https://tools.ietf.org/html/rfc3339#section-5.6).
 *
 * @description
 * Return the formatted date string in RFC 3339 format. Options may be passed to control the parts and notations of the date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options.
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 18 September 2019 in RFC 3339 format:
 * formatRFC3339(new Date(2019, 8, 18, 19, 0, 52))
 * //=> '2019-09-18T19:00:52Z'
 *
 * @example
 * // Represent 18 September 2019 in RFC 3339 format, 3 digits of second fraction
 * formatRFC3339(new Date(2019, 8, 18, 19, 0, 52, 234), {
 *   fractionDigits: 3
 * })
 * //=> '2019-09-18T19:00:52.234Z'
 */ function formatRFC3339(date, options) {
    const _date = (0, _index2.toDate)(date);
    if (!(0, _index.isValid)(_date)) throw new RangeError("Invalid time value");
    const fractionDigits = options?.fractionDigits ?? 0;
    const day = (0, _index3.addLeadingZeros)(_date.getDate(), 2);
    const month = (0, _index3.addLeadingZeros)(_date.getMonth() + 1, 2);
    const year = _date.getFullYear();
    const hour = (0, _index3.addLeadingZeros)(_date.getHours(), 2);
    const minute = (0, _index3.addLeadingZeros)(_date.getMinutes(), 2);
    const second = (0, _index3.addLeadingZeros)(_date.getSeconds(), 2);
    let fractionalSecond = "";
    if (fractionDigits > 0) {
        const milliseconds = _date.getMilliseconds();
        const fractionalSeconds = Math.floor(milliseconds * Math.pow(10, fractionDigits - 3));
        fractionalSecond = "." + (0, _index3.addLeadingZeros)(fractionalSeconds, fractionDigits);
    }
    let offset = "";
    const tzOffset = _date.getTimezoneOffset();
    if (tzOffset !== 0) {
        const absoluteOffset = Math.abs(tzOffset);
        const hourOffset = (0, _index3.addLeadingZeros)(Math.trunc(absoluteOffset / 60), 2);
        const minuteOffset = (0, _index3.addLeadingZeros)(absoluteOffset % 60, 2);
        // If less than 0, the sign is +, because it is ahead of time.
        const sign = tzOffset < 0 ? "+" : "-";
        offset = `${sign}${hourOffset}:${minuteOffset}`;
    } else offset = "Z";
    return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}${offset}`;
}

},{"9301294447d1f95b":"gbOJY","40b9430b575cdc41":"actWA","de42c97ba518f921":"jcCHs"}],"4iRjv":[function(require,module,exports) {
"use strict";
exports.formatRFC7231 = formatRFC7231;
var _index = require("80159fbf1f8ee7a1");
var _index2 = require("8dc509179adf5406");
var _index3 = require("aca1dc202b36cc1a");
const days = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
];
const months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
];
/**
 * @name formatRFC7231
 * @category Common Helpers
 * @summary Format the date according to the RFC 7231 standard (https://tools.ietf.org/html/rfc7231#section-7.1.1.1).
 *
 * @description
 * Return the formatted date string in RFC 7231 format.
 * The result will always be in UTC timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 18 September 2019 in RFC 7231 format:
 * const result = formatRFC7231(new Date(2019, 8, 18, 19, 0, 52))
 * //=> 'Wed, 18 Sep 2019 19:00:52 GMT'
 */ function formatRFC7231(date) {
    const _date = (0, _index2.toDate)(date);
    if (!(0, _index.isValid)(_date)) throw new RangeError("Invalid time value");
    const dayName = days[_date.getUTCDay()];
    const dayOfMonth = (0, _index3.addLeadingZeros)(_date.getUTCDate(), 2);
    const monthName = months[_date.getUTCMonth()];
    const year = _date.getUTCFullYear();
    const hour = (0, _index3.addLeadingZeros)(_date.getUTCHours(), 2);
    const minute = (0, _index3.addLeadingZeros)(_date.getUTCMinutes(), 2);
    const second = (0, _index3.addLeadingZeros)(_date.getUTCSeconds(), 2);
    // Result variables.
    return `${dayName}, ${dayOfMonth} ${monthName} ${year} ${hour}:${minute}:${second} GMT`;
}

},{"80159fbf1f8ee7a1":"gbOJY","8dc509179adf5406":"actWA","aca1dc202b36cc1a":"jcCHs"}],"3VMIL":[function(require,module,exports) {
"use strict";
exports.formatRelative = formatRelative;
var _index = require("3409df3deaea49ab");
var _index2 = require("96f9b723c8a0b63d");
var _index3 = require("13fa994e827979d5");
var _index4 = require("6aa8aa7a8956e8a1");
var _index5 = require("673378ca2fd31ed4");
/**
 * The {@link formatRelative} function options.
 */ /**
 * @name formatRelative
 * @category Common Helpers
 * @summary Represent the date in words relative to the given base date.
 *
 * @description
 * Represent the date in words relative to the given base date.
 *
 * | Distance to the base date | Result                    |
 * |---------------------------|---------------------------|
 * | Previous 6 days           | last Sunday at 04:30 AM   |
 * | Last day                  | yesterday at 04:30 AM     |
 * | Same day                  | today at 04:30 AM         |
 * | Next day                  | tomorrow at 04:30 AM      |
 * | Next 6 days               | Sunday at 04:30 AM        |
 * | Other                     | 12/31/2017                |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 * @param baseDate - The date to compare with
 * @param options - An object with options
 *
 * @returns The date in words
 *
 * @throws `date` must not be Invalid Date
 * @throws `baseDate` must not be Invalid Date
 * @throws `options.locale` must contain `localize` property
 * @throws `options.locale` must contain `formatLong` property
 * @throws `options.locale` must contain `formatRelative` property
 *
 * @example
 * // Represent the date of 6 days ago in words relative to the given base date. In this example, today is Wednesday
 * const result = formatRelative(subDays(new Date(), 6), new Date())
 * //=> "last Thursday at 12:45 AM"
 */ function formatRelative(date, baseDate, options) {
    const _date = (0, _index3.toDate)(date);
    const _baseDate = (0, _index3.toDate)(baseDate);
    const defaultOptions = (0, _index5.getDefaultOptions)();
    const locale = options?.locale ?? defaultOptions.locale ?? _index4.defaultLocale;
    const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions.weekStartsOn ?? defaultOptions.locale?.options?.weekStartsOn ?? 0;
    const diff = (0, _index.differenceInCalendarDays)(_date, _baseDate);
    if (isNaN(diff)) throw new RangeError("Invalid time value");
    let token;
    if (diff < -6) token = "other";
    else if (diff < -1) token = "lastWeek";
    else if (diff < 0) token = "yesterday";
    else if (diff < 1) token = "today";
    else if (diff < 2) token = "tomorrow";
    else if (diff < 7) token = "nextWeek";
    else token = "other";
    const formatStr = locale.formatRelative(token, _date, _baseDate, {
        locale,
        weekStartsOn
    });
    return (0, _index2.format)(_date, formatStr, {
        locale,
        weekStartsOn
    });
}

},{"3409df3deaea49ab":"dvya7","96f9b723c8a0b63d":"eeV53","13fa994e827979d5":"actWA","6aa8aa7a8956e8a1":"iG9h0","673378ca2fd31ed4":"98fau"}],"4kcMW":[function(require,module,exports) {
"use strict";
exports.fromUnixTime = fromUnixTime;
var _index = require("b17c73af583a5f1e");
/**
 * @name fromUnixTime
 * @category Timestamp Helpers
 * @summary Create a date from a Unix timestamp.
 *
 * @description
 * Create a date from a Unix timestamp (in seconds). Decimal values will be discarded.
 *
 * @param unixTime - The given Unix timestamp (in seconds)
 *
 * @returns The date
 *
 * @example
 * // Create the date 29 February 2012 11:45:05:
 * const result = fromUnixTime(1330515905)
 * //=> Wed Feb 29 2012 11:45:05
 */ function fromUnixTime(unixTime) {
    return (0, _index.toDate)(unixTime * 1000);
}

},{"b17c73af583a5f1e":"actWA"}],"5yhYa":[function(require,module,exports) {
"use strict";
exports.getDate = getDate;
var _index = require("99a30b597441916f");
/**
 * @name getDate
 * @category Day Helpers
 * @summary Get the day of the month of the given date.
 *
 * @description
 * Get the day of the month of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The day of month
 *
 * @example
 * // Which day of the month is 29 February 2012?
 * const result = getDate(new Date(2012, 1, 29))
 * //=> 29
 */ function getDate(date) {
    const _date = (0, _index.toDate)(date);
    const dayOfMonth = _date.getDate();
    return dayOfMonth;
}

},{"99a30b597441916f":"actWA"}],"esFEi":[function(require,module,exports) {
"use strict";
exports.getDay = getDay;
var _index = require("74108f6e7f604e0c");
/**
 * @name getDay
 * @category Weekday Helpers
 * @summary Get the day of the week of the given date.
 *
 * @description
 * Get the day of the week of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The day of week, 0 represents Sunday
 *
 * @example
 * // Which day of the week is 29 February 2012?
 * const result = getDay(new Date(2012, 1, 29))
 * //=> 3
 */ function getDay(date) {
    const _date = (0, _index.toDate)(date);
    const day = _date.getDay();
    return day;
}

},{"74108f6e7f604e0c":"actWA"}],"iS77p":[function(require,module,exports) {
"use strict";
exports.getDaysInMonth = getDaysInMonth;
var _index = require("ce5d8149ab8c0adb");
var _index2 = require("160593c36b918fdc");
/**
 * @name getDaysInMonth
 * @category Month Helpers
 * @summary Get the number of days in a month of the given date.
 *
 * @description
 * Get the number of days in a month of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The number of days in a month
 *
 * @example
 * // How many days are in February 2000?
 * const result = getDaysInMonth(new Date(2000, 1))
 * //=> 29
 */ function getDaysInMonth(date) {
    const _date = (0, _index.toDate)(date);
    const year = _date.getFullYear();
    const monthIndex = _date.getMonth();
    const lastDayOfMonth = (0, _index2.constructFrom)(date, 0);
    lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
    lastDayOfMonth.setHours(0, 0, 0, 0);
    return lastDayOfMonth.getDate();
}

},{"ce5d8149ab8c0adb":"actWA","160593c36b918fdc":"hNMdA"}],"f28wB":[function(require,module,exports) {
"use strict";
exports.getDaysInYear = getDaysInYear;
var _index = require("275eab46cb701105");
var _index2 = require("f6dcd98ceb3f89a0");
/**
 * @name getDaysInYear
 * @category Year Helpers
 * @summary Get the number of days in a year of the given date.
 *
 * @description
 * Get the number of days in a year of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The number of days in a year
 *
 * @example
 * // How many days are in 2012?
 * const result = getDaysInYear(new Date(2012, 0, 1))
 * //=> 366
 */ function getDaysInYear(date) {
    const _date = (0, _index2.toDate)(date);
    if (String(new Date(_date)) === "Invalid Date") return NaN;
    return (0, _index.isLeapYear)(_date) ? 366 : 365;
}

},{"275eab46cb701105":"5jn07","f6dcd98ceb3f89a0":"actWA"}],"5jn07":[function(require,module,exports) {
"use strict";
exports.isLeapYear = isLeapYear;
var _index = require("1f2cd80e6083cd69");
/**
 * @name isLeapYear
 * @category Year Helpers
 * @summary Is the given date in the leap year?
 *
 * @description
 * Is the given date in the leap year?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in the leap year
 *
 * @example
 * // Is 1 September 2012 in the leap year?
 * const result = isLeapYear(new Date(2012, 8, 1))
 * //=> true
 */ function isLeapYear(date) {
    const _date = (0, _index.toDate)(date);
    const year = _date.getFullYear();
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

},{"1f2cd80e6083cd69":"actWA"}],"t2HDN":[function(require,module,exports) {
"use strict";
exports.getDecade = getDecade;
var _index = require("fe74f1dab16aabfd");
/**
 * @name getDecade
 * @category Decade Helpers
 * @summary Get the decade of the given date.
 *
 * @description
 * Get the decade of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The year of decade
 *
 * @example
 * // Which decade belongs 27 November 1942?
 * const result = getDecade(new Date(1942, 10, 27))
 * //=> 1940
 */ function getDecade(date) {
    const _date = (0, _index.toDate)(date);
    const year = _date.getFullYear();
    const decade = Math.floor(year / 10) * 10;
    return decade;
}

},{"fe74f1dab16aabfd":"actWA"}],"fAxdh":[function(require,module,exports) {
"use strict";
exports.getDefaultOptions = getDefaultOptions;
var _index = require("4c8d0c918921978e");
/**
 * @name getDefaultOptions
 * @category Common Helpers
 * @summary Get default options.
 * @pure false
 *
 * @description
 * Returns an object that contains defaults for
 * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
 * arguments for all functions.
 *
 * You can change these with [setDefaultOptions](https://date-fns.org/docs/setDefaultOptions).
 *
 * @returns The default options
 *
 * @example
 * const result = getDefaultOptions()
 * //=> {}
 *
 * @example
 * setDefaultOptions({ weekStarsOn: 1, firstWeekContainsDate: 4 })
 * const result = getDefaultOptions()
 * //=> { weekStarsOn: 1, firstWeekContainsDate: 4 }
 */ function getDefaultOptions() {
    return Object.assign({}, (0, _index.getDefaultOptions)());
}

},{"4c8d0c918921978e":"98fau"}],"kRfdi":[function(require,module,exports) {
"use strict";
exports.getHours = getHours;
var _index = require("dd6beddad3762c0e");
/**
 * @name getHours
 * @category Hour Helpers
 * @summary Get the hours of the given date.
 *
 * @description
 * Get the hours of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The hours
 *
 * @example
 * // Get the hours of 29 February 2012 11:45:00:
 * const result = getHours(new Date(2012, 1, 29, 11, 45))
 * //=> 11
 */ function getHours(date) {
    const _date = (0, _index.toDate)(date);
    const hours = _date.getHours();
    return hours;
}

},{"dd6beddad3762c0e":"actWA"}],"9d1Pg":[function(require,module,exports) {
"use strict";
exports.getISODay = getISODay;
var _index = require("cc4dec4ab039fecc");
/**
 * @name getISODay
 * @category Weekday Helpers
 * @summary Get the day of the ISO week of the given date.
 *
 * @description
 * Get the day of the ISO week of the given date,
 * which is 7 for Sunday, 1 for Monday etc.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The day of ISO week
 *
 * @example
 * // Which day of the ISO week is 26 February 2012?
 * const result = getISODay(new Date(2012, 1, 26))
 * //=> 7
 */ function getISODay(date) {
    const _date = (0, _index.toDate)(date);
    let day = _date.getDay();
    if (day === 0) day = 7;
    return day;
}

},{"cc4dec4ab039fecc":"actWA"}],"gwH0c":[function(require,module,exports) {
"use strict";
exports.getISOWeeksInYear = getISOWeeksInYear;
var _index = require("90fb06e2d0d5907e");
var _index2 = require("7e506b16fa621cd5");
var _index3 = require("bc85126805d4e6dd");
/**
 * @name getISOWeeksInYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the number of weeks in an ISO week-numbering year of the given date.
 *
 * @description
 * Get the number of weeks in an ISO week-numbering year of the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The number of ISO weeks in a year
 *
 * @example
 * // How many weeks are in ISO week-numbering year 2015?
 * const result = getISOWeeksInYear(new Date(2015, 1, 11))
 * //=> 53
 */ function getISOWeeksInYear(date) {
    const thisYear = (0, _index3.startOfISOWeekYear)(date);
    const nextYear = (0, _index3.startOfISOWeekYear)((0, _index.addWeeks)(thisYear, 60));
    const diff = nextYear.valueOf() - thisYear.valueOf();
    // Round the number of weeks to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / _index2.millisecondsInWeek);
}

},{"90fb06e2d0d5907e":"6sRN6","7e506b16fa621cd5":"1vXXw","bc85126805d4e6dd":"eTm1l"}],"2axfx":[function(require,module,exports) {
"use strict";
exports.getMilliseconds = getMilliseconds;
var _index = require("d90c57ddf052ab34");
/**
 * @name getMilliseconds
 * @category Millisecond Helpers
 * @summary Get the milliseconds of the given date.
 *
 * @description
 * Get the milliseconds of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The milliseconds
 *
 * @example
 * // Get the milliseconds of 29 February 2012 11:45:05.123:
 * const result = getMilliseconds(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 123
 */ function getMilliseconds(date) {
    const _date = (0, _index.toDate)(date);
    const milliseconds = _date.getMilliseconds();
    return milliseconds;
}

},{"d90c57ddf052ab34":"actWA"}],"jzd1E":[function(require,module,exports) {
"use strict";
exports.getMinutes = getMinutes;
var _index = require("942a2ec019737ce6");
/**
 * @name getMinutes
 * @category Minute Helpers
 * @summary Get the minutes of the given date.
 *
 * @description
 * Get the minutes of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The minutes
 *
 * @example
 * // Get the minutes of 29 February 2012 11:45:05:
 * const result = getMinutes(new Date(2012, 1, 29, 11, 45, 5))
 * //=> 45
 */ function getMinutes(date) {
    const _date = (0, _index.toDate)(date);
    const minutes = _date.getMinutes();
    return minutes;
}

},{"942a2ec019737ce6":"actWA"}],"kio1B":[function(require,module,exports) {
"use strict";
exports.getMonth = getMonth;
var _index = require("72421b25c2b051d4");
/**
 * @name getMonth
 * @category Month Helpers
 * @summary Get the month of the given date.
 *
 * @description
 * Get the month of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The month
 *
 * @example
 * // Which month is 29 February 2012?
 * const result = getMonth(new Date(2012, 1, 29))
 * //=> 1
 */ function getMonth(date) {
    const _date = (0, _index.toDate)(date);
    const month = _date.getMonth();
    return month;
}

},{"72421b25c2b051d4":"actWA"}],"C2P0L":[function(require,module,exports) {
"use strict";
exports.getOverlappingDaysInIntervals = getOverlappingDaysInIntervals;
var _index = require("1bb45ca582d62a30");
var _index2 = require("557defd14b7a5bdb");
/**
 * @name getOverlappingDaysInIntervals
 * @category Interval Helpers
 * @summary Get the number of days that overlap in two time intervals
 *
 * @description
 * Get the number of days that overlap in two time intervals
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param intervalLeft - The first interval to compare.
 * @param intervalRight - The second interval to compare.
 *
 * @returns The number of days that overlap in two time intervals
 *
 * @example
 * // For overlapping time intervals adds 1 for each started overlapping day:
 * getOverlappingDaysInIntervals(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 17), end: new Date(2014, 0, 21) }
 * )
 * //=> 3
 *
 * @example
 * // For non-overlapping time intervals returns 0:
 * getOverlappingDaysInIntervals(
 *   { start: new Date(2014, 0, 10), end: new Date(2014, 0, 20) },
 *   { start: new Date(2014, 0, 21), end: new Date(2014, 0, 22) }
 * )
 * //=> 0
 */ function getOverlappingDaysInIntervals(intervalLeft, intervalRight) {
    const [leftStartTime, leftEndTime] = [
        +(0, _index2.toDate)(intervalLeft.start),
        +(0, _index2.toDate)(intervalLeft.end)
    ].sort();
    const [rightStartTime, rightEndTime] = [
        +(0, _index2.toDate)(intervalRight.start),
        +(0, _index2.toDate)(intervalRight.end)
    ].sort();
    const isOverlapping = leftStartTime < rightEndTime && rightStartTime < leftEndTime;
    if (!isOverlapping) return 0;
    const overlapStartDate = rightStartTime < leftStartTime ? leftStartTime : rightStartTime;
    const overlapEndDate = rightEndTime > leftEndTime ? leftEndTime : rightEndTime;
    const differenceInMs = overlapEndDate - overlapStartDate;
    return Math.ceil(differenceInMs / _index.millisecondsInDay);
}

},{"1bb45ca582d62a30":"1vXXw","557defd14b7a5bdb":"actWA"}],"22KCI":[function(require,module,exports) {
"use strict";
exports.getSeconds = getSeconds;
var _index = require("66e87215fb77615b");
/**
 * @name getSeconds
 * @category Second Helpers
 * @summary Get the seconds of the given date.
 *
 * @description
 * Get the seconds of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The seconds
 *
 * @example
 * // Get the seconds of 29 February 2012 11:45:05.123:
 * const result = getSeconds(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 5
 */ function getSeconds(date) {
    const _date = (0, _index.toDate)(date);
    const seconds = _date.getSeconds();
    return seconds;
}

},{"66e87215fb77615b":"actWA"}],"2lNv1":[function(require,module,exports) {
"use strict";
exports.getTime = getTime;
var _index = require("cdbfeffb1be44bad");
/**
 * @name getTime
 * @category Timestamp Helpers
 * @summary Get the milliseconds timestamp of the given date.
 *
 * @description
 * Get the milliseconds timestamp of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The timestamp
 *
 * @example
 * // Get the timestamp of 29 February 2012 11:45:05.123:
 * const result = getTime(new Date(2012, 1, 29, 11, 45, 5, 123))
 * //=> 1330515905123
 */ function getTime(date) {
    const _date = (0, _index.toDate)(date);
    const timestamp = _date.getTime();
    return timestamp;
}

},{"cdbfeffb1be44bad":"actWA"}],"hP8NA":[function(require,module,exports) {
"use strict";
exports.getUnixTime = getUnixTime;
var _index = require("a48ce3df4775de1f");
/**
 * @name getUnixTime
 * @category Timestamp Helpers
 * @summary Get the seconds timestamp of the given date.
 *
 * @description
 * Get the seconds timestamp of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The timestamp
 *
 * @example
 * // Get the timestamp of 29 February 2012 11:45:05 CET:
 * const result = getUnixTime(new Date(2012, 1, 29, 11, 45, 5))
 * //=> 1330512305
 */ function getUnixTime(date) {
    return Math.floor((0, _index.getTime)(date) / 1000);
}

},{"a48ce3df4775de1f":"2lNv1"}],"S6fio":[function(require,module,exports) {
"use strict";
exports.getWeekOfMonth = getWeekOfMonth;
var _index = require("e2f130fc886de9f1");
var _index2 = require("39bc8949ab4ed662");
var _index3 = require("8a37fb28123e5296");
var _index4 = require("53ea69d655b52576");
/**
 * The {@link getWeekOfMonth} function options.
 */ /**
 * @name getWeekOfMonth
 * @category Week Helpers
 * @summary Get the week of the month of the given date.
 *
 * @description
 * Get the week of the month of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The week of month
 *
 * @example
 * // Which week of the month is 9 November 2017?
 * const result = getWeekOfMonth(new Date(2017, 10, 9))
 * //=> 2
 */ function getWeekOfMonth(date, options) {
    const defaultOptions = (0, _index4.getDefaultOptions)();
    const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions.weekStartsOn ?? defaultOptions.locale?.options?.weekStartsOn ?? 0;
    const currentDayOfMonth = (0, _index.getDate)(date);
    if (isNaN(currentDayOfMonth)) return NaN;
    const startWeekDay = (0, _index2.getDay)((0, _index3.startOfMonth)(date));
    let lastDayOfFirstWeek = weekStartsOn - startWeekDay;
    if (lastDayOfFirstWeek <= 0) lastDayOfFirstWeek += 7;
    const remainingDaysAfterFirstWeek = currentDayOfMonth - lastDayOfFirstWeek;
    return Math.ceil(remainingDaysAfterFirstWeek / 7) + 1;
}

},{"e2f130fc886de9f1":"5yhYa","39bc8949ab4ed662":"esFEi","8a37fb28123e5296":"1cHoB","53ea69d655b52576":"98fau"}],"fqTdg":[function(require,module,exports) {
"use strict";
exports.getWeeksInMonth = getWeeksInMonth;
var _index = require("2093bc780dc07818");
var _index2 = require("72a2b06dbcb4c199");
var _index3 = require("2b3482d506165a82");
/**
 * The {@link getWeeksInMonth} function options.
 */ /**
 * @name getWeeksInMonth
 * @category Week Helpers
 * @summary Get the number of calendar weeks a month spans.
 *
 * @description
 * Get the number of calendar weeks the month in the given date spans.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 * @param options - An object with options.
 *
 * @returns The number of calendar weeks
 *
 * @example
 * // How many calendar weeks does February 2015 span?
 * const result = getWeeksInMonth(new Date(2015, 1, 8))
 * //=> 4
 *
 * @example
 * // If the week starts on Monday,
 * // how many calendar weeks does July 2017 span?
 * const result = getWeeksInMonth(new Date(2017, 6, 5), { weekStartsOn: 1 })
 * //=> 6
 */ function getWeeksInMonth(date, options) {
    return (0, _index.differenceInCalendarWeeks)((0, _index2.lastDayOfMonth)(date), (0, _index3.startOfMonth)(date), options) + 1;
}

},{"2093bc780dc07818":"iWbGJ","72a2b06dbcb4c199":"lVD0G","2b3482d506165a82":"1cHoB"}],"lVD0G":[function(require,module,exports) {
"use strict";
exports.lastDayOfMonth = lastDayOfMonth;
var _index = require("ab42a2c6a54cb32e");
/**
 * @name lastDayOfMonth
 * @category Month Helpers
 * @summary Return the last day of a month for the given date.
 *
 * @description
 * Return the last day of a month for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of a month
 *
 * @example
 * // The last day of a month for 2 September 2014 11:55:00:
 * const result = lastDayOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 00:00:00
 */ function lastDayOfMonth(date) {
    const _date = (0, _index.toDate)(date);
    const month = _date.getMonth();
    _date.setFullYear(_date.getFullYear(), month + 1, 0);
    _date.setHours(0, 0, 0, 0);
    return _date;
}

},{"ab42a2c6a54cb32e":"actWA"}],"glolq":[function(require,module,exports) {
"use strict";
exports.getYear = getYear;
var _index = require("3a87a8c7949402ce");
/**
 * @name getYear
 * @category Year Helpers
 * @summary Get the year of the given date.
 *
 * @description
 * Get the year of the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The given date
 *
 * @returns The year
 *
 * @example
 * // Which year is 2 July 2014?
 * const result = getYear(new Date(2014, 6, 2))
 * //=> 2014
 */ function getYear(date) {
    return (0, _index.toDate)(date).getFullYear();
}

},{"3a87a8c7949402ce":"actWA"}],"1t8KQ":[function(require,module,exports) {
"use strict";
exports.hoursToMilliseconds = hoursToMilliseconds;
var _index = require("c6a2f11605eee1dc");
/**
 * @name hoursToMilliseconds
 * @category  Conversion Helpers
 * @summary Convert hours to milliseconds.
 *
 * @description
 * Convert a number of hours to a full number of milliseconds.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param hours - number of hours to be converted
 *
 * @returns The number of hours converted to milliseconds
 *
 * @example
 * // Convert 2 hours to milliseconds:
 * const result = hoursToMilliseconds(2)
 * //=> 7200000
 */ function hoursToMilliseconds(hours) {
    return Math.floor(hours * _index.millisecondsInHour);
}

},{"c6a2f11605eee1dc":"1vXXw"}],"3agDO":[function(require,module,exports) {
"use strict";
exports.hoursToMinutes = hoursToMinutes;
var _index = require("7806bd4b7c008d33");
/**
 * @name hoursToMinutes
 * @category Conversion Helpers
 * @summary Convert hours to minutes.
 *
 * @description
 * Convert a number of hours to a full number of minutes.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param hours - number of hours to be converted
 *
 * @returns The number of hours converted in minutes
 *
 * @example
 * // Convert 2 hours to minutes:
 * const result = hoursToMinutes(2)
 * //=> 120
 */ function hoursToMinutes(hours) {
    return Math.floor(hours * _index.minutesInHour);
}

},{"7806bd4b7c008d33":"1vXXw"}],"l9tWS":[function(require,module,exports) {
"use strict";
exports.hoursToSeconds = hoursToSeconds;
var _index = require("d13f2ce94270497");
/**
 * @name hoursToSeconds
 * @category Conversion Helpers
 * @summary Convert hours to seconds.
 *
 * @description
 * Convert a number of hours to a full number of seconds.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param hours - The number of hours to be converted
 *
 * @returns The number of hours converted in seconds
 *
 * @example
 * // Convert 2 hours to seconds:
 * const result = hoursToSeconds(2)
 * //=> 7200
 */ function hoursToSeconds(hours) {
    return Math.floor(hours * _index.secondsInHour);
}

},{"d13f2ce94270497":"1vXXw"}],"iZrN8":[function(require,module,exports) {
"use strict";
exports.interval = interval;
var _index = require("1d1e2184a95f4bcb");
/**
 * The {@link interval} function options.
 */ /**
 * @name interval
 * @category Interval Helpers
 * @summary Creates an interval object and validates its values.
 *
 * @description
 * Creates a normalized interval object and validates its values. If the interval is invalid, an exception is thrown.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param start - The start of the interval.
 * @param end - The end of the interval.
 * @param options - The options object.
 *
 * @throws `Start date is invalid` when `start` is invalid.
 * @throws `End date is invalid` when `end` is invalid.
 * @throws `End date must be after start date` when end is before `start` and `options.assertPositive` is true.
 *
 * @returns The normalized and validated interval object.
 */ function interval(start, end, options) {
    const _start = (0, _index.toDate)(start);
    if (isNaN(+_start)) throw new TypeError("Start date is invalid");
    const _end = (0, _index.toDate)(end);
    if (isNaN(+_end)) throw new TypeError("End date is invalid");
    if (options?.assertPositive && +_start > +_end) throw new TypeError("End date must be after start date");
    return {
        start: _start,
        end: _end
    };
}

},{"1d1e2184a95f4bcb":"actWA"}],"bpzaD":[function(require,module,exports) {
"use strict";
exports.intervalToDuration = intervalToDuration;
var _index = require("827ba40197711f17");
var _index2 = require("4670c3e5153a14f1");
var _index3 = require("4d89cf2304eec01b");
var _index4 = require("d4fa01e7bdf0d261");
var _index5 = require("c9ddd1dcdae84b00");
var _index6 = require("d480aeea2ed64577");
var _index7 = require("6a7ba40260a23b60");
var _index8 = require("b3b1015ee5b239ef");
/**
 * @name intervalToDuration
 * @category Common Helpers
 * @summary Convert interval to duration
 *
 * @description
 * Convert a interval object to a duration object.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param interval - The interval to convert to duration
 *
 * @returns The duration object
 *
 * @example
 * // Get the duration between January 15, 1929 and April 4, 1968.
 * intervalToDuration({
 *   start: new Date(1929, 0, 15, 12, 0, 0),
 *   end: new Date(1968, 3, 4, 19, 5, 0)
 * })
 * // => { years: 39, months: 2, days: 20, hours: 7, minutes: 5, seconds: 0 }
 */ function intervalToDuration(interval) {
    const start = (0, _index8.toDate)(interval.start);
    const end = (0, _index8.toDate)(interval.end);
    const duration = {};
    const years = (0, _index7.differenceInYears)(end, start);
    if (years) duration.years = years;
    const remainingMonths = (0, _index.add)(start, {
        years: duration.years
    });
    const months = (0, _index5.differenceInMonths)(end, remainingMonths);
    if (months) duration.months = months;
    const remainingDays = (0, _index.add)(remainingMonths, {
        months: duration.months
    });
    const days = (0, _index2.differenceInDays)(end, remainingDays);
    if (days) duration.days = days;
    const remainingHours = (0, _index.add)(remainingDays, {
        days: duration.days
    });
    const hours = (0, _index3.differenceInHours)(end, remainingHours);
    if (hours) duration.hours = hours;
    const remainingMinutes = (0, _index.add)(remainingHours, {
        hours: duration.hours
    });
    const minutes = (0, _index4.differenceInMinutes)(end, remainingMinutes);
    if (minutes) duration.minutes = minutes;
    const remainingSeconds = (0, _index.add)(remainingMinutes, {
        minutes: duration.minutes
    });
    const seconds = (0, _index6.differenceInSeconds)(end, remainingSeconds);
    if (seconds) duration.seconds = seconds;
    return duration;
}

},{"827ba40197711f17":"hboah","4670c3e5153a14f1":"fJoFi","4d89cf2304eec01b":"jnteW","d4fa01e7bdf0d261":"Z5oWO","c9ddd1dcdae84b00":"i3gFX","d480aeea2ed64577":"3IvxJ","6a7ba40260a23b60":"iFe68","b3b1015ee5b239ef":"actWA"}],"6yh4g":[function(require,module,exports) {
"use strict";
exports.intlFormat = intlFormat;
var _index = require("d534639a573fc6cf");
/**
 * The locale string (see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument).
 */ /**
 * The format options (see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat#options)
 */ /**
 * The locale options.
 */ /**
 * @name intlFormat
 * @category Common Helpers
 * @summary Format the date with Intl.DateTimeFormat (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat).
 *
 * @description
 * Return the formatted date string in the given format.
 * The method uses [`Intl.DateTimeFormat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat) inside.
 * formatOptions are the same as [`Intl.DateTimeFormat` options](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat#using_options)
 *
 * > ⚠️ Please note that before Node version 13.0.0, only the locale data for en-US is available by default.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 10 October 2019 in middle-endian format:
 * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456))
 * //=> 10/4/2019
 */ /**
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 * @param localeOptions - An object with locale
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 10 October 2019 in Korean.
 * // Convert the date with locale's options.
 * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456), {
 *   locale: 'ko-KR',
 * })
 * //=> 2019. 10. 4.
 */ /**
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 * @param formatOptions - The format options
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 10 October 2019.
 * // Convert the date with format's options.
 * const result = intlFormat.default(new Date(2019, 9, 4, 12, 30, 13, 456), {
 *   year: 'numeric',
 *   month: 'numeric',
 *   day: 'numeric',
 *   hour: 'numeric',
 * })
 * //=> 10/4/2019, 12 PM
 */ /**
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to format
 * @param formatOptions - The format options
 * @param localeOptions - An object with locale
 *
 * @returns The formatted date string
 *
 * @throws `date` must not be Invalid Date
 *
 * @example
 * // Represent 10 October 2019 in German.
 * // Convert the date with format's options and locale's options.
 * const result = intlFormat(new Date(2019, 9, 4, 12, 30, 13, 456), {
 *   weekday: 'long',
 *   year: 'numeric',
 *   month: 'long',
 *   day: 'numeric',
 * }, {
 *   locale: 'de-DE',
 * })
 * //=> Freitag, 4. Oktober 2019
 */ function intlFormat(date, formatOrLocale, localeOptions) {
    let formatOptions;
    if (isFormatOptions(formatOrLocale)) formatOptions = formatOrLocale;
    else localeOptions = formatOrLocale;
    return new Intl.DateTimeFormat(localeOptions?.locale, formatOptions).format((0, _index.toDate)(date));
}
function isFormatOptions(opts) {
    return opts !== undefined && !("locale" in opts);
}

},{"d534639a573fc6cf":"actWA"}],"4dv0v":[function(require,module,exports) {
"use strict";
exports.intlFormatDistance = intlFormatDistance;
var _index = require("f683b56d8b54d7c3");
var _index2 = require("935f9cc6c5a9a358");
var _index3 = require("8a2925b448856fe2");
var _index4 = require("84a299c3d0590753");
var _index5 = require("b9bc0426e6224e82");
var _index6 = require("6742121b375dc4be");
var _index7 = require("c9619d002a71b38f");
var _index8 = require("15fe69ea99c7609f");
var _index9 = require("a52b9b370f1cb48f");
var _index10 = require("6058b1ebc4f00c8b");
/**
 * The {@link intlFormatDistance} function options.
 */ /**
 * The unit used to format the distance in {@link intlFormatDistance}.
 */ /**
 * @name intlFormatDistance
 * @category Common Helpers
 * @summary Formats distance between two dates in a human-readable format
 * @description
 * The function calculates the difference between two dates and formats it as a human-readable string.
 *
 * The function will pick the most appropriate unit depending on the distance between dates. For example, if the distance is a few hours, it might return `x hours`. If the distance is a few months, it might return `x months`.
 *
 * You can also specify a unit to force using it regardless of the distance to get a result like `123456 hours`.
 *
 * See the table below for the unit picking logic:
 *
 * | Distance between dates | Result (past)  | Result (future) |
 * | ---------------------- | -------------- | --------------- |
 * | 0 seconds              | now            | now             |
 * | 1-59 seconds           | X seconds ago  | in X seconds    |
 * | 1-59 minutes           | X minutes ago  | in X minutes    |
 * | 1-23 hours             | X hours ago    | in X hours      |
 * | 1 day                  | yesterday      | tomorrow        |
 * | 2-6 days               | X days ago     | in X days       |
 * | 7 days                 | last week      | next week       |
 * | 8 days-1 month         | X weeks ago    | in X weeks      |
 * | 1 month                | last month     | next month      |
 * | 2-3 months             | X months ago   | in X months     |
 * | 1 quarter              | last quarter   | next quarter    |
 * | 2-3 quarters           | X quarters ago | in X quarters   |
 * | 1 year                 | last year      | next year       |
 * | 2+ years               | X years ago    | in X years      |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date
 * @param baseDate - The date to compare with.
 * @param options - An object with options.
 * See MDN for details [Locale identification and negotiation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locale_identification_and_negotiation)
 * The narrow one could be similar to the short one for some locales.
 *
 * @returns The distance in words according to language-sensitive relative time formatting.
 *
 * @throws `date` must not be Invalid Date
 * @throws `baseDate` must not be Invalid Date
 * @throws `options.unit` must not be invalid Unit
 * @throws `options.locale` must not be invalid locale
 * @throws `options.localeMatcher` must not be invalid localeMatcher
 * @throws `options.numeric` must not be invalid numeric
 * @throws `options.style` must not be invalid style
 *
 * @example
 * // What is the distance between the dates when the fist date is after the second?
 * intlFormatDistance(
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   new Date(1986, 3, 4, 10, 30, 0)
 * )
 * //=> 'in 1 hour'
 *
 * // What is the distance between the dates when the fist date is before the second?
 * intlFormatDistance(
 *   new Date(1986, 3, 4, 10, 30, 0),
 *   new Date(1986, 3, 4, 11, 30, 0)
 * )
 * //=> '1 hour ago'
 *
 * @example
 * // Use the unit option to force the function to output the result in quarters. Without setting it, the example would return "next year"
 * intlFormatDistance(
 *   new Date(1987, 6, 4, 10, 30, 0),
 *   new Date(1986, 3, 4, 10, 30, 0),
 *   { unit: 'quarter' }
 * )
 * //=> 'in 5 quarters'
 *
 * @example
 * // Use the locale option to get the result in Spanish. Without setting it, the example would return "in 1 hour".
 * intlFormatDistance(
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   new Date(1986, 3, 4, 10, 30, 0),
 *   { locale: 'es' }
 * )
 * //=> 'dentro de 1 hora'
 *
 * @example
 * // Use the numeric option to force the function to use numeric values. Without setting it, the example would return "tomorrow".
 * intlFormatDistance(
 *   new Date(1986, 3, 5, 11, 30, 0),
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   { numeric: 'always' }
 * )
 * //=> 'in 1 day'
 *
 * @example
 * // Use the style option to force the function to use short values. Without setting it, the example would return "in 2 years".
 * intlFormatDistance(
 *   new Date(1988, 3, 4, 11, 30, 0),
 *   new Date(1986, 3, 4, 11, 30, 0),
 *   { style: 'short' }
 * )
 * //=> 'in 2 yr'
 */ function intlFormatDistance(date, baseDate, options) {
    let value = 0;
    let unit;
    const dateLeft = (0, _index10.toDate)(date);
    const dateRight = (0, _index10.toDate)(baseDate);
    if (!options?.unit) {
        // Get the unit based on diffInSeconds calculations if no unit is specified
        const diffInSeconds = (0, _index9.differenceInSeconds)(dateLeft, dateRight); // The smallest unit
        if (Math.abs(diffInSeconds) < _index.secondsInMinute) {
            value = (0, _index9.differenceInSeconds)(dateLeft, dateRight);
            unit = "second";
        } else if (Math.abs(diffInSeconds) < _index.secondsInHour) {
            value = (0, _index8.differenceInMinutes)(dateLeft, dateRight);
            unit = "minute";
        } else if (Math.abs(diffInSeconds) < _index.secondsInDay && Math.abs((0, _index2.differenceInCalendarDays)(dateLeft, dateRight)) < 1) {
            value = (0, _index7.differenceInHours)(dateLeft, dateRight);
            unit = "hour";
        } else if (Math.abs(diffInSeconds) < _index.secondsInWeek && (value = (0, _index2.differenceInCalendarDays)(dateLeft, dateRight)) && Math.abs(value) < 7) unit = "day";
        else if (Math.abs(diffInSeconds) < _index.secondsInMonth) {
            value = (0, _index5.differenceInCalendarWeeks)(dateLeft, dateRight);
            unit = "week";
        } else if (Math.abs(diffInSeconds) < _index.secondsInQuarter) {
            value = (0, _index3.differenceInCalendarMonths)(dateLeft, dateRight);
            unit = "month";
        } else if (Math.abs(diffInSeconds) < _index.secondsInYear) {
            if ((0, _index4.differenceInCalendarQuarters)(dateLeft, dateRight) < 4) {
                // To filter out cases that are less than a year but match 4 quarters
                value = (0, _index4.differenceInCalendarQuarters)(dateLeft, dateRight);
                unit = "quarter";
            } else {
                value = (0, _index6.differenceInCalendarYears)(dateLeft, dateRight);
                unit = "year";
            }
        } else {
            value = (0, _index6.differenceInCalendarYears)(dateLeft, dateRight);
            unit = "year";
        }
    } else {
        // Get the value if unit is specified
        unit = options?.unit;
        if (unit === "second") value = (0, _index9.differenceInSeconds)(dateLeft, dateRight);
        else if (unit === "minute") value = (0, _index8.differenceInMinutes)(dateLeft, dateRight);
        else if (unit === "hour") value = (0, _index7.differenceInHours)(dateLeft, dateRight);
        else if (unit === "day") value = (0, _index2.differenceInCalendarDays)(dateLeft, dateRight);
        else if (unit === "week") value = (0, _index5.differenceInCalendarWeeks)(dateLeft, dateRight);
        else if (unit === "month") value = (0, _index3.differenceInCalendarMonths)(dateLeft, dateRight);
        else if (unit === "quarter") value = (0, _index4.differenceInCalendarQuarters)(dateLeft, dateRight);
        else if (unit === "year") value = (0, _index6.differenceInCalendarYears)(dateLeft, dateRight);
    }
    const rtf = new Intl.RelativeTimeFormat(options?.locale, {
        localeMatcher: options?.localeMatcher,
        numeric: options?.numeric || "auto",
        style: options?.style
    });
    return rtf.format(value, unit);
}

},{"f683b56d8b54d7c3":"1vXXw","935f9cc6c5a9a358":"dvya7","8a2925b448856fe2":"21Qeg","84a299c3d0590753":"kWjSX","b9bc0426e6224e82":"iWbGJ","6742121b375dc4be":"e0VtU","c9619d002a71b38f":"jnteW","15fe69ea99c7609f":"Z5oWO","a52b9b370f1cb48f":"3IvxJ","6058b1ebc4f00c8b":"actWA"}],"2ogSo":[function(require,module,exports) {
"use strict";
exports.isAfter = isAfter;
var _index = require("d53a6d6418b9cc58");
/**
 * @name isAfter
 * @category Common Helpers
 * @summary Is the first date after the second one?
 *
 * @description
 * Is the first date after the second one?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date that should be after the other one to return true
 * @param dateToCompare - The date to compare with
 *
 * @returns The first date is after the second date
 *
 * @example
 * // Is 10 July 1989 after 11 February 1987?
 * const result = isAfter(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> true
 */ function isAfter(date, dateToCompare) {
    const _date = (0, _index.toDate)(date);
    const _dateToCompare = (0, _index.toDate)(dateToCompare);
    return _date.getTime() > _dateToCompare.getTime();
}

},{"d53a6d6418b9cc58":"actWA"}],"6AV3j":[function(require,module,exports) {
"use strict";
exports.isBefore = isBefore;
var _index = require("29711cec40df889c");
/**
 * @name isBefore
 * @category Common Helpers
 * @summary Is the first date before the second one?
 *
 * @description
 * Is the first date before the second one?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date that should be before the other one to return true
 * @param dateToCompare - The date to compare with
 *
 * @returns The first date is before the second date
 *
 * @example
 * // Is 10 July 1989 before 11 February 1987?
 * const result = isBefore(new Date(1989, 6, 10), new Date(1987, 1, 11))
 * //=> false
 */ function isBefore(date, dateToCompare) {
    const _date = (0, _index.toDate)(date);
    const _dateToCompare = (0, _index.toDate)(dateToCompare);
    return +_date < +_dateToCompare;
}

},{"29711cec40df889c":"actWA"}],"jqhPh":[function(require,module,exports) {
"use strict";
exports.isEqual = isEqual;
var _index = require("b079eb760d97c297");
/**
 * @name isEqual
 * @category Common Helpers
 * @summary Are the given dates equal?
 *
 * @description
 * Are the given dates equal?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to compare
 * @param dateRight - The second date to compare
 *
 * @returns The dates are equal
 *
 * @example
 * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
 * const result = isEqual(
 *   new Date(2014, 6, 2, 6, 30, 45, 0),
 *   new Date(2014, 6, 2, 6, 30, 45, 500)
 * )
 * //=> false
 */ function isEqual(leftDate, rightDate) {
    const _dateLeft = (0, _index.toDate)(leftDate);
    const _dateRight = (0, _index.toDate)(rightDate);
    return +_dateLeft === +_dateRight;
}

},{"b079eb760d97c297":"actWA"}],"9cexO":[function(require,module,exports) {
"use strict";
exports.isExists = isExists; /**
 * @name isExists
 * @category Common Helpers
 * @summary Is the given date exists?
 *
 * @description
 * Checks if the given arguments convert to an existing date.
 *
 * @param year - The year of the date to check
 * @param month - The month of the date to check
 * @param day - The day of the date to check
 *
 * @returns `true` if the date exists
 *
 * @example
 * // For the valid date:
 * const result = isExists(2018, 0, 31)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isExists(2018, 1, 31)
 * //=> false
 */ 
function isExists(year, month, day) {
    const date = new Date(year, month, day);
    return date.getFullYear() === year && date.getMonth() === month && date.getDate() === day;
}

},{}],"dyMIP":[function(require,module,exports) {
"use strict";
exports.isFirstDayOfMonth = isFirstDayOfMonth;
var _index = require("e6a2c200e0f3bb19");
/**
 * @name isFirstDayOfMonth
 * @category Month Helpers
 * @summary Is the given date the first day of a month?
 *
 * @description
 * Is the given date the first day of a month?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check

 * @returns The date is the first day of a month
 *
 * @example
 * // Is 1 September 2014 the first day of a month?
 * const result = isFirstDayOfMonth(new Date(2014, 8, 1))
 * //=> true
 */ function isFirstDayOfMonth(date) {
    return (0, _index.toDate)(date).getDate() === 1;
}

},{"e6a2c200e0f3bb19":"actWA"}],"jzcyi":[function(require,module,exports) {
"use strict";
exports.isFriday = isFriday;
var _index = require("a962d5285978468b");
/**
 * @name isFriday
 * @category Weekday Helpers
 * @summary Is the given date Friday?
 *
 * @description
 * Is the given date Friday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Friday
 *
 * @example
 * // Is 26 September 2014 Friday?
 * const result = isFriday(new Date(2014, 8, 26))
 * //=> true
 */ function isFriday(date) {
    return (0, _index.toDate)(date).getDay() === 5;
}

},{"a962d5285978468b":"actWA"}],"a6qf1":[function(require,module,exports) {
"use strict";
exports.isFuture = isFuture;
var _index = require("d167b947956d32f");
/**
 * @name isFuture
 * @category Common Helpers
 * @summary Is the given date in the future?
 * @pure false
 *
 * @description
 * Is the given date in the future?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in the future
 *
 * @example
 * // If today is 6 October 2014, is 31 December 2014 in the future?
 * const result = isFuture(new Date(2014, 11, 31))
 * //=> true
 */ function isFuture(date) {
    return +(0, _index.toDate)(date) > Date.now();
}

},{"d167b947956d32f":"actWA"}],"dnyZz":[function(require,module,exports) {
"use strict";
exports.isMatch = isMatch;
var _index = require("ce558029b0f6cdc9");
var _index2 = require("20451a1a433763e7");
/**
 * The {@link isMatch} function options.
 */ /**
 * @name isMatch
 * @category Common Helpers
 * @summary validates the date string against given formats
 *
 * @description
 * Return the true if given date is string correct against the given format else
 * will return false.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * isMatch('23 AM', 'HH a')
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Su            | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Su            |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `isMatch` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `isMatch` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `isMatch` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `isMatch('50', 'yy') //=> true`
 *
 *    `isMatch('75', 'yy') //=> true`
 *
 *    while `uu` will use the year as is:
 *
 *    `isMatch('50', 'uu') //=> true`
 *
 *    `isMatch('75', 'uu') //=> true`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear](https://date-fns.org/docs/setISOWeekYear)
 *    and [setWeekYear](https://date-fns.org/docs/setWeekYear)).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be checked in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are matched (e.g. when matching string 'January 1st' without a year),
 * the values will be taken from today's using `new Date()` date which works as a context of parsing.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateStr - The date string to verify
 * @param format - The string of tokens
 * @param options - An object with options.
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @returns Is format string a match for date string?
 *
 * @throws `options.locale` must contain `match` property
 * @throws use `yyyy` instead of `YYYY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `yy` instead of `YY` for formatting years; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `d` instead of `D` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `dd` instead of `DD` for formatting days of the month; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * // Match 11 February 2014 from middle-endian format:
 * const result = isMatch('02/11/2014', 'MM/dd/yyyy')
 * //=> true
 *
 * @example
 * // Match 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * const result = isMatch('28-a de februaro', "do 'de' MMMM", {
 *   locale: eo
 * })
 * //=> true
 */ function isMatch(dateStr, formatStr, options) {
    return (0, _index.isValid)((0, _index2.parse)(dateStr, formatStr, new Date(), options));
}

},{"ce558029b0f6cdc9":"gbOJY","20451a1a433763e7":"gNLjl"}],"gNLjl":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "longFormatters", {
    enumerable: true,
    get: function() {
        return _index5.longFormatters;
    }
});
exports.parse = parse;
Object.defineProperty(exports, "parsers", {
    enumerable: true,
    get: function() {
        return _index7.parsers;
    }
});
var _index = require("c53acb33da1787e9");
var _index2 = require("137ba7b89008c236");
var _index3 = require("86b7162193851f53");
var _index4 = require("6071c86d3eb95bcf");
var _index5 = require("adb831f4e34cf8d0");
var _index6 = require("26eed989fb024afe");
var _index7 = require("8e4cd03974d82cc0");
var _Setter = require("264f22812daf122f");
// Rexports of internal for libraries to use.
// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874
/**
 * The {@link parse} function options.
 */ // This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
// This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const notWhitespaceRegExp = /\S/;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear](https://date-fns.org/docs/setISOWeekYear)
 *    and [setWeekYear](https://date-fns.org/docs/setWeekYear)).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateStr - The string to parse
 * @param formatStr - The string of tokens
 * @param referenceDate - defines values missing from the parsed dateString
 * @param options - An object with options.
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @returns The parsed date
 *
 * @throws `options.locale` must contain `match` property
 * @throws use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */ function parse(dateStr, formatStr, referenceDate, options) {
    const defaultOptions = (0, _index2.getDefaultOptions)();
    const locale = options?.locale ?? defaultOptions.locale ?? _index3.enUS;
    const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions.firstWeekContainsDate ?? defaultOptions.locale?.options?.firstWeekContainsDate ?? 1;
    const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions.weekStartsOn ?? defaultOptions.locale?.options?.weekStartsOn ?? 0;
    if (formatStr === "") {
        if (dateStr === "") return (0, _index4.toDate)(referenceDate);
        else return (0, _index.constructFrom)(referenceDate, NaN);
    }
    const subFnOptions = {
        firstWeekContainsDate,
        weekStartsOn,
        locale
    };
    // If timezone isn't specified, it will be set to the system timezone
    const setters = [
        new _Setter.DateToSystemTimezoneSetter()
    ];
    const tokens = formatStr.match(longFormattingTokensRegExp).map((substring)=>{
        const firstCharacter = substring[0];
        if (firstCharacter in _index5.longFormatters) {
            const longFormatter = _index5.longFormatters[firstCharacter];
            return longFormatter(substring, locale.formatLong);
        }
        return substring;
    }).join("").match(formattingTokensRegExp);
    const usedTokens = [];
    for (let token of tokens){
        if (!options?.useAdditionalWeekYearTokens && (0, _index6.isProtectedWeekYearToken)(token)) (0, _index6.warnOrThrowProtectedError)(token, formatStr, dateStr);
        if (!options?.useAdditionalDayOfYearTokens && (0, _index6.isProtectedDayOfYearToken)(token)) (0, _index6.warnOrThrowProtectedError)(token, formatStr, dateStr);
        const firstCharacter = token[0];
        const parser = _index7.parsers[firstCharacter];
        if (parser) {
            const { incompatibleTokens } = parser;
            if (Array.isArray(incompatibleTokens)) {
                const incompatibleToken = usedTokens.find((usedToken)=>incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter);
                if (incompatibleToken) throw new RangeError(`The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`);
            } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) throw new RangeError(`The format string mustn't contain \`${token}\` and any other token at the same time`);
            usedTokens.push({
                token: firstCharacter,
                fullToken: token
            });
            const parseResult = parser.run(dateStr, token, locale.match, subFnOptions);
            if (!parseResult) return (0, _index.constructFrom)(referenceDate, NaN);
            setters.push(parseResult.setter);
            dateStr = parseResult.rest;
        } else {
            if (firstCharacter.match(unescapedLatinCharacterRegExp)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
            // Replace two single quote characters with one single quote character
            if (token === "''") token = "'";
            else if (firstCharacter === "'") token = cleanEscapedString(token);
            // Cut token from string, or, if string doesn't match the token, return Invalid Date
            if (dateStr.indexOf(token) === 0) dateStr = dateStr.slice(token.length);
            else return (0, _index.constructFrom)(referenceDate, NaN);
        }
    }
    // Check if the remaining input contains something other than whitespace
    if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) return (0, _index.constructFrom)(referenceDate, NaN);
    const uniquePrioritySetters = setters.map((setter)=>setter.priority).sort((a, b)=>b - a).filter((priority, index, array)=>array.indexOf(priority) === index).map((priority)=>setters.filter((setter)=>setter.priority === priority).sort((a, b)=>b.subPriority - a.subPriority)).map((setterArray)=>setterArray[0]);
    let date = (0, _index4.toDate)(referenceDate);
    if (isNaN(date.getTime())) return (0, _index.constructFrom)(referenceDate, NaN);
    const flags = {};
    for (const setter of uniquePrioritySetters){
        if (!setter.validate(date, subFnOptions)) return (0, _index.constructFrom)(referenceDate, NaN);
        const result = setter.set(date, flags, subFnOptions);
        // Result is tuple (date, flags)
        if (Array.isArray(result)) {
            date = result[0];
            Object.assign(flags, result[1]);
        // Result is date
        } else date = result;
    }
    return (0, _index.constructFrom)(referenceDate, date);
}
function cleanEscapedString(input) {
    return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

},{"c53acb33da1787e9":"hNMdA","137ba7b89008c236":"fAxdh","86b7162193851f53":"haY68","6071c86d3eb95bcf":"actWA","adb831f4e34cf8d0":"jsbdH","26eed989fb024afe":"dFKqd","8e4cd03974d82cc0":"2oKol","264f22812daf122f":"kYmxL"}],"2oKol":[function(require,module,exports) {
"use strict";
exports.parsers = void 0;
var _EraParser = require("73877e75490bba35");
var _YearParser = require("534dbfd035c7afae");
var _LocalWeekYearParser = require("ab4450ec135364ae");
var _ISOWeekYearParser = require("85d23a44ac18532c");
var _ExtendedYearParser = require("179a88ef12f61a71");
var _QuarterParser = require("93232ed2f05ef2c3");
var _StandAloneQuarterParser = require("c7c6a63c21fda1ba");
var _MonthParser = require("9ccf03b202560527");
var _StandAloneMonthParser = require("250a7296cb9bd5d4");
var _LocalWeekParser = require("bcc281e24017fb49");
var _ISOWeekParser = require("b4a87b1ad452a0e8");
var _DateParser = require("ad6bc827b2f368e4");
var _DayOfYearParser = require("bb234ddd84c3b240");
var _DayParser = require("2d736796a40046e7");
var _LocalDayParser = require("f161fb5cee20fef5");
var _StandAloneLocalDayParser = require("3943fd5b7ea48b68");
var _ISODayParser = require("86ddbd54e3fa3dd2");
var _AMPMParser = require("b283318e653dbb40");
var _AMPMMidnightParser = require("d8c3b56df6ed7ec1");
var _DayPeriodParser = require("2c8f7cc10db4bdc2");
var _Hour1to12Parser = require("c7c3fbe3abdaa79c");
var _Hour0to23Parser = require("3a24c22368eeaf29");
var _Hour0To11Parser = require("7689b873a1aa23cf");
var _Hour1To24Parser = require("f2e24da70f1ce437");
var _MinuteParser = require("5b7be433eba9622a");
var _SecondParser = require("810daf17248738a9");
var _FractionOfSecondParser = require("7e5fdf1f35b534dd");
var _ISOTimezoneWithZParser = require("46cb8c323b79446f");
var _ISOTimezoneParser = require("1eeadf9bee6760d9");
var _TimestampSecondsParser = require("41f3d3eb54e297d3");
var _TimestampMillisecondsParser = require("85a0d4684faae6f7");
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */ // eslint-disable-next-line @typescript-eslint/no-explicit-any -- It's ok, we want any here
const parsers = exports.parsers = {
    G: new _EraParser.EraParser(),
    y: new _YearParser.YearParser(),
    Y: new _LocalWeekYearParser.LocalWeekYearParser(),
    R: new _ISOWeekYearParser.ISOWeekYearParser(),
    u: new _ExtendedYearParser.ExtendedYearParser(),
    Q: new _QuarterParser.QuarterParser(),
    q: new _StandAloneQuarterParser.StandAloneQuarterParser(),
    M: new _MonthParser.MonthParser(),
    L: new _StandAloneMonthParser.StandAloneMonthParser(),
    w: new _LocalWeekParser.LocalWeekParser(),
    I: new _ISOWeekParser.ISOWeekParser(),
    d: new _DateParser.DateParser(),
    D: new _DayOfYearParser.DayOfYearParser(),
    E: new _DayParser.DayParser(),
    e: new _LocalDayParser.LocalDayParser(),
    c: new _StandAloneLocalDayParser.StandAloneLocalDayParser(),
    i: new _ISODayParser.ISODayParser(),
    a: new _AMPMParser.AMPMParser(),
    b: new _AMPMMidnightParser.AMPMMidnightParser(),
    B: new _DayPeriodParser.DayPeriodParser(),
    h: new _Hour1to12Parser.Hour1to12Parser(),
    H: new _Hour0to23Parser.Hour0to23Parser(),
    K: new _Hour0To11Parser.Hour0To11Parser(),
    k: new _Hour1To24Parser.Hour1To24Parser(),
    m: new _MinuteParser.MinuteParser(),
    s: new _SecondParser.SecondParser(),
    S: new _FractionOfSecondParser.FractionOfSecondParser(),
    X: new _ISOTimezoneWithZParser.ISOTimezoneWithZParser(),
    x: new _ISOTimezoneParser.ISOTimezoneParser(),
    t: new _TimestampSecondsParser.TimestampSecondsParser(),
    T: new _TimestampMillisecondsParser.TimestampMillisecondsParser()
};

},{"73877e75490bba35":"iYhYF","534dbfd035c7afae":"kf1Wf","ab4450ec135364ae":"jDcds","85d23a44ac18532c":"ap5xA","179a88ef12f61a71":"lW99W","93232ed2f05ef2c3":"dsY9k","c7c6a63c21fda1ba":"aSfyW","9ccf03b202560527":"EYpZp","250a7296cb9bd5d4":"jbrkt","bcc281e24017fb49":"8rNDN","b4a87b1ad452a0e8":"dfdwt","ad6bc827b2f368e4":"fYv6C","bb234ddd84c3b240":"9cmRX","2d736796a40046e7":"ksDae","f161fb5cee20fef5":"jgAEp","3943fd5b7ea48b68":"4FMAA","86ddbd54e3fa3dd2":"eSKw6","b283318e653dbb40":"eqkPE","d8c3b56df6ed7ec1":"g3D3d","2c8f7cc10db4bdc2":"hkyVS","c7c3fbe3abdaa79c":"iRbV7","3a24c22368eeaf29":"fq0MM","7689b873a1aa23cf":"ejbIY","f2e24da70f1ce437":"eEJho","5b7be433eba9622a":"8XZpF","810daf17248738a9":"khJSC","7e5fdf1f35b534dd":"jT3Md","46cb8c323b79446f":"kUxSQ","1eeadf9bee6760d9":"ee2MS","41f3d3eb54e297d3":"8CwPK","85a0d4684faae6f7":"czEu6"}],"iYhYF":[function(require,module,exports) {
"use strict";
exports.EraParser = void 0;
var _Parser = require("3b6644e454c96bd5");
class EraParser extends _Parser.Parser {
    priority = 140;
    parse(dateString, token, match) {
        switch(token){
            // AD, BC
            case "G":
            case "GG":
            case "GGG":
                return match.era(dateString, {
                    width: "abbreviated"
                }) || match.era(dateString, {
                    width: "narrow"
                });
            // A, B
            case "GGGGG":
                return match.era(dateString, {
                    width: "narrow"
                });
            // Anno Domini, Before Christ
            case "GGGG":
            default:
                return match.era(dateString, {
                    width: "wide"
                }) || match.era(dateString, {
                    width: "abbreviated"
                }) || match.era(dateString, {
                    width: "narrow"
                });
        }
    }
    set(date, flags, value) {
        flags.era = value;
        date.setFullYear(value, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "R",
        "u",
        "t",
        "T"
    ];
}
exports.EraParser = EraParser;

},{"3b6644e454c96bd5":"6E7ou"}],"6E7ou":[function(require,module,exports) {
"use strict";
exports.Parser = void 0;
var _Setter = require("f9ccbe426415522b");
class Parser {
    run(dateString, token, match, options) {
        const result = this.parse(dateString, token, match, options);
        if (!result) return null;
        return {
            setter: new _Setter.ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
            rest: result.rest
        };
    }
    validate(_utcDate, _value, _options) {
        return true;
    }
}
exports.Parser = Parser;

},{"f9ccbe426415522b":"kYmxL"}],"kYmxL":[function(require,module,exports) {
"use strict";
exports.ValueSetter = exports.Setter = exports.DateToSystemTimezoneSetter = void 0;
var _index = require("22daacd9886737df");
var _index2 = require("80c3b8dc52dd858");
const TIMEZONE_UNIT_PRIORITY = 10;
class Setter {
    subPriority = 0;
    validate(_utcDate, _options) {
        return true;
    }
}
exports.Setter = Setter;
class ValueSetter extends Setter {
    constructor(value, validateValue, setValue, priority, subPriority){
        super();
        this.value = value;
        this.validateValue = validateValue;
        this.setValue = setValue;
        this.priority = priority;
        if (subPriority) this.subPriority = subPriority;
    }
    validate(date, options) {
        return this.validateValue(date, this.value, options);
    }
    set(date, flags, options) {
        return this.setValue(date, flags, this.value, options);
    }
}
exports.ValueSetter = ValueSetter;
class DateToSystemTimezoneSetter extends Setter {
    priority = TIMEZONE_UNIT_PRIORITY;
    subPriority = -1;
    set(date, flags) {
        if (flags.timestampIsSet) return date;
        return (0, _index2.constructFrom)(date, (0, _index.transpose)(date, Date));
    }
}
exports.DateToSystemTimezoneSetter = DateToSystemTimezoneSetter;

},{"22daacd9886737df":"4DdgS","80c3b8dc52dd858":"hNMdA"}],"4DdgS":[function(require,module,exports) {
"use strict";
exports.transpose = transpose;
var _index = require("e4cedfb3eb078b8e");
/**
 * @name transpose
 * @category Generic Helpers
 * @summary Transpose the date to the given constructor.
 *
 * @description
 * The function transposes the date to the given constructor. It helps you
 * to transpose the date in the system time zone to say `UTCDate` or any other
 * date extension.
 *
 * @typeParam DateInputType - The input `Date` type derived from the passed argument.
 * @typeParam DateOutputType - The output `Date` type derived from the passed constructor.
 *
 * @param fromDate - The date to use values from
 * @param constructor - The date constructor to use
 *
 * @returns Date transposed to the given constructor
 *
 * @example
 * // Create July 10, 2022 00:00 in locale time zone
 * const date = new Date(2022, 6, 10)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0800 (Singapore Standard Time)'
 *
 * @example
 * // Transpose the date to July 10, 2022 00:00 in UTC
 * transpose(date, UTCDate)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0000 (Coordinated Universal Time)'
 */ function transpose(fromDate, constructor) {
    const date = constructor instanceof Date ? (0, _index.constructFrom)(constructor, 0) : new constructor(0);
    date.setFullYear(fromDate.getFullYear(), fromDate.getMonth(), fromDate.getDate());
    date.setHours(fromDate.getHours(), fromDate.getMinutes(), fromDate.getSeconds(), fromDate.getMilliseconds());
    return date;
}

},{"e4cedfb3eb078b8e":"hNMdA"}],"kf1Wf":[function(require,module,exports) {
"use strict";
exports.YearParser = void 0;
var _Parser = require("410cdd8b24ffe202");
var _utils = require("feb431ad5324f1c2");
// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
class YearParser extends _Parser.Parser {
    priority = 130;
    incompatibleTokens = [
        "Y",
        "R",
        "u",
        "w",
        "I",
        "i",
        "e",
        "c",
        "t",
        "T"
    ];
    parse(dateString, token, match) {
        const valueCallback = (year)=>({
                year,
                isTwoDigitYear: token === "yy"
            });
        switch(token){
            case "y":
                return (0, _utils.mapValue)((0, _utils.parseNDigits)(4, dateString), valueCallback);
            case "yo":
                return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
                    unit: "year"
                }), valueCallback);
            default:
                return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
        }
    }
    validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
    }
    set(date, flags, value) {
        const currentYear = date.getFullYear();
        if (value.isTwoDigitYear) {
            const normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(value.year, currentYear);
            date.setFullYear(normalizedTwoDigitYear, 0, 1);
            date.setHours(0, 0, 0, 0);
            return date;
        }
        const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setFullYear(year, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
exports.YearParser = YearParser;

},{"410cdd8b24ffe202":"6E7ou","feb431ad5324f1c2":"6DK60"}],"6DK60":[function(require,module,exports) {
"use strict";
exports.dayPeriodEnumToHours = dayPeriodEnumToHours;
exports.isLeapYearIndex = isLeapYearIndex;
exports.mapValue = mapValue;
exports.normalizeTwoDigitYear = normalizeTwoDigitYear;
exports.parseAnyDigitsSigned = parseAnyDigitsSigned;
exports.parseNDigits = parseNDigits;
exports.parseNDigitsSigned = parseNDigitsSigned;
exports.parseNumericPattern = parseNumericPattern;
exports.parseTimezonePattern = parseTimezonePattern;
var _index = require("730ab950da1e266b");
var _constants = require("be7ba8dce2178d09");
function mapValue(parseFnResult, mapFn) {
    if (!parseFnResult) return parseFnResult;
    return {
        value: mapFn(parseFnResult.value),
        rest: parseFnResult.rest
    };
}
function parseNumericPattern(pattern, dateString) {
    const matchResult = dateString.match(pattern);
    if (!matchResult) return null;
    return {
        value: parseInt(matchResult[0], 10),
        rest: dateString.slice(matchResult[0].length)
    };
}
function parseTimezonePattern(pattern, dateString) {
    const matchResult = dateString.match(pattern);
    if (!matchResult) return null;
    // Input is 'Z'
    if (matchResult[0] === "Z") return {
        value: 0,
        rest: dateString.slice(1)
    };
    const sign = matchResult[1] === "+" ? 1 : -1;
    const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
        value: sign * (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute + seconds * _index.millisecondsInSecond),
        rest: dateString.slice(matchResult[0].length)
    };
}
function parseAnyDigitsSigned(dateString) {
    return parseNumericPattern(_constants.numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
    switch(n){
        case 1:
            return parseNumericPattern(_constants.numericPatterns.singleDigit, dateString);
        case 2:
            return parseNumericPattern(_constants.numericPatterns.twoDigits, dateString);
        case 3:
            return parseNumericPattern(_constants.numericPatterns.threeDigits, dateString);
        case 4:
            return parseNumericPattern(_constants.numericPatterns.fourDigits, dateString);
        default:
            return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
    }
}
function parseNDigitsSigned(n, dateString) {
    switch(n){
        case 1:
            return parseNumericPattern(_constants.numericPatterns.singleDigitSigned, dateString);
        case 2:
            return parseNumericPattern(_constants.numericPatterns.twoDigitsSigned, dateString);
        case 3:
            return parseNumericPattern(_constants.numericPatterns.threeDigitsSigned, dateString);
        case 4:
            return parseNumericPattern(_constants.numericPatterns.fourDigitsSigned, dateString);
        default:
            return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
    }
}
function dayPeriodEnumToHours(dayPeriod) {
    switch(dayPeriod){
        case "morning":
            return 4;
        case "evening":
            return 17;
        case "pm":
        case "noon":
        case "afternoon":
            return 12;
        case "am":
        case "midnight":
        case "night":
        default:
            return 0;
    }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    const isCommonEra = currentYear > 0;
    // Absolute number of the current year:
    // 1 -> 1 AC
    // 0 -> 1 BC
    // -1 -> 2 BC
    const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    let result;
    if (absCurrentYear <= 50) result = twoDigitYear || 100;
    else {
        const rangeEnd = absCurrentYear + 50;
        const rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
        const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
        result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }
    return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

},{"730ab950da1e266b":"1vXXw","be7ba8dce2178d09":"e1eTk"}],"e1eTk":[function(require,module,exports) {
"use strict";
exports.timezonePatterns = exports.numericPatterns = void 0;
const numericPatterns = exports.numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    date: /^(3[0-1]|[0-2]?\d)/,
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    week: /^(5[0-3]|[0-4]?\d)/,
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    hour11h: /^(1[0-1]|0?\d)/,
    hour12h: /^(1[0-2]|0?\d)/,
    minute: /^[0-5]?\d/,
    second: /^[0-5]?\d/,
    singleDigit: /^\d/,
    twoDigits: /^\d{1,2}/,
    threeDigits: /^\d{1,3}/,
    fourDigits: /^\d{1,4}/,
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    twoDigitsSigned: /^-?\d{1,2}/,
    threeDigitsSigned: /^-?\d{1,3}/,
    fourDigitsSigned: /^-?\d{1,4}/
};
const timezonePatterns = exports.timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

},{}],"jDcds":[function(require,module,exports) {
"use strict";
exports.LocalWeekYearParser = void 0;
var _index = require("c7a1c4cdd11de749");
var _index2 = require("36ab983d3ac96e94");
var _Parser = require("2580105d5efe4503");
var _utils = require("e7bc0ea0bf35d979");
// Local week-numbering year
class LocalWeekYearParser extends _Parser.Parser {
    priority = 130;
    parse(dateString, token, match) {
        const valueCallback = (year)=>({
                year,
                isTwoDigitYear: token === "YY"
            });
        switch(token){
            case "Y":
                return (0, _utils.mapValue)((0, _utils.parseNDigits)(4, dateString), valueCallback);
            case "Yo":
                return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
                    unit: "year"
                }), valueCallback);
            default:
                return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
        }
    }
    validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
    }
    set(date, flags, value, options) {
        const currentYear = (0, _index.getWeekYear)(date, options);
        if (value.isTwoDigitYear) {
            const normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(value.year, currentYear);
            date.setFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
            date.setHours(0, 0, 0, 0);
            return (0, _index2.startOfWeek)(date, options);
        }
        const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setFullYear(year, 0, options.firstWeekContainsDate);
        date.setHours(0, 0, 0, 0);
        return (0, _index2.startOfWeek)(date, options);
    }
    incompatibleTokens = [
        "y",
        "R",
        "u",
        "Q",
        "q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "i",
        "t",
        "T"
    ];
}
exports.LocalWeekYearParser = LocalWeekYearParser;

},{"c7a1c4cdd11de749":"7odmH","36ab983d3ac96e94":"dDDvv","2580105d5efe4503":"6E7ou","e7bc0ea0bf35d979":"6DK60"}],"ap5xA":[function(require,module,exports) {
"use strict";
exports.ISOWeekYearParser = void 0;
var _index = require("e78417787f8e8167");
var _index2 = require("ac68ccd301053769");
var _Parser = require("996e304581b01cde");
var _utils = require("338b9c7449577074");
// ISO week-numbering year
class ISOWeekYearParser extends _Parser.Parser {
    priority = 130;
    parse(dateString, token) {
        if (token === "R") return (0, _utils.parseNDigitsSigned)(4, dateString);
        return (0, _utils.parseNDigitsSigned)(token.length, dateString);
    }
    set(date, _flags, value) {
        const firstWeekOfYear = (0, _index2.constructFrom)(date, 0);
        firstWeekOfYear.setFullYear(value, 0, 4);
        firstWeekOfYear.setHours(0, 0, 0, 0);
        return (0, _index.startOfISOWeek)(firstWeekOfYear);
    }
    incompatibleTokens = [
        "G",
        "y",
        "Y",
        "u",
        "Q",
        "q",
        "M",
        "L",
        "w",
        "d",
        "D",
        "e",
        "c",
        "t",
        "T"
    ];
}
exports.ISOWeekYearParser = ISOWeekYearParser;

},{"e78417787f8e8167":"iF0wL","ac68ccd301053769":"hNMdA","996e304581b01cde":"6E7ou","338b9c7449577074":"6DK60"}],"lW99W":[function(require,module,exports) {
"use strict";
exports.ExtendedYearParser = void 0;
var _Parser = require("14062af0868fbb7b");
var _utils = require("1b6df6d2682df22c");
class ExtendedYearParser extends _Parser.Parser {
    priority = 130;
    parse(dateString, token) {
        if (token === "u") return (0, _utils.parseNDigitsSigned)(4, dateString);
        return (0, _utils.parseNDigitsSigned)(token.length, dateString);
    }
    set(date, _flags, value) {
        date.setFullYear(value, 0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "G",
        "y",
        "Y",
        "R",
        "w",
        "I",
        "i",
        "e",
        "c",
        "t",
        "T"
    ];
}
exports.ExtendedYearParser = ExtendedYearParser;

},{"14062af0868fbb7b":"6E7ou","1b6df6d2682df22c":"6DK60"}],"dsY9k":[function(require,module,exports) {
"use strict";
exports.QuarterParser = void 0;
var _Parser = require("2c403512ee0b4449");
var _utils = require("16f449bb6db64ee7");
class QuarterParser extends _Parser.Parser {
    priority = 120;
    parse(dateString, token, match) {
        switch(token){
            // 1, 2, 3, 4
            case "Q":
            case "QQ":
                return (0, _utils.parseNDigits)(token.length, dateString);
            // 1st, 2nd, 3rd, 4th
            case "Qo":
                return match.ordinalNumber(dateString, {
                    unit: "quarter"
                });
            // Q1, Q2, Q3, Q4
            case "QQQ":
                return match.quarter(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.quarter(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // 1, 2, 3, 4 (narrow quarter; could be not numerical)
            case "QQQQQ":
                return match.quarter(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // 1st quarter, 2nd quarter, ...
            case "QQQQ":
            default:
                return match.quarter(dateString, {
                    width: "wide",
                    context: "formatting"
                }) || match.quarter(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.quarter(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 4;
    }
    set(date, _flags, value) {
        date.setMonth((value - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "Y",
        "R",
        "q",
        "M",
        "L",
        "w",
        "I",
        "d",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
    ];
}
exports.QuarterParser = QuarterParser;

},{"2c403512ee0b4449":"6E7ou","16f449bb6db64ee7":"6DK60"}],"aSfyW":[function(require,module,exports) {
"use strict";
exports.StandAloneQuarterParser = void 0;
var _Parser = require("90bdba2189236368");
var _utils = require("ac5cbd54eec0970d");
class StandAloneQuarterParser extends _Parser.Parser {
    priority = 120;
    parse(dateString, token, match) {
        switch(token){
            // 1, 2, 3, 4
            case "q":
            case "qq":
                return (0, _utils.parseNDigits)(token.length, dateString);
            // 1st, 2nd, 3rd, 4th
            case "qo":
                return match.ordinalNumber(dateString, {
                    unit: "quarter"
                });
            // Q1, Q2, Q3, Q4
            case "qqq":
                return match.quarter(dateString, {
                    width: "abbreviated",
                    context: "standalone"
                }) || match.quarter(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
            // 1, 2, 3, 4 (narrow quarter; could be not numerical)
            case "qqqqq":
                return match.quarter(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
            // 1st quarter, 2nd quarter, ...
            case "qqqq":
            default:
                return match.quarter(dateString, {
                    width: "wide",
                    context: "standalone"
                }) || match.quarter(dateString, {
                    width: "abbreviated",
                    context: "standalone"
                }) || match.quarter(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 4;
    }
    set(date, _flags, value) {
        date.setMonth((value - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "Y",
        "R",
        "Q",
        "M",
        "L",
        "w",
        "I",
        "d",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
    ];
}
exports.StandAloneQuarterParser = StandAloneQuarterParser;

},{"90bdba2189236368":"6E7ou","ac5cbd54eec0970d":"6DK60"}],"EYpZp":[function(require,module,exports) {
"use strict";
exports.MonthParser = void 0;
var _constants = require("3ca19f0e27bab599");
var _Parser = require("3b0e5e45825bc96f");
var _utils = require("73c2131545335241");
class MonthParser extends _Parser.Parser {
    incompatibleTokens = [
        "Y",
        "R",
        "q",
        "Q",
        "L",
        "w",
        "I",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
    ];
    priority = 110;
    parse(dateString, token, match) {
        const valueCallback = (value)=>value - 1;
        switch(token){
            // 1, 2, ..., 12
            case "M":
                return (0, _utils.mapValue)((0, _utils.parseNumericPattern)(_constants.numericPatterns.month, dateString), valueCallback);
            // 01, 02, ..., 12
            case "MM":
                return (0, _utils.mapValue)((0, _utils.parseNDigits)(2, dateString), valueCallback);
            // 1st, 2nd, ..., 12th
            case "Mo":
                return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
                    unit: "month"
                }), valueCallback);
            // Jan, Feb, ..., Dec
            case "MMM":
                return match.month(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.month(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // J, F, ..., D
            case "MMMMM":
                return match.month(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // January, February, ..., December
            case "MMMM":
            default:
                return match.month(dateString, {
                    width: "wide",
                    context: "formatting"
                }) || match.month(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.month(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 11;
    }
    set(date, _flags, value) {
        date.setMonth(value, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
}
exports.MonthParser = MonthParser;

},{"3ca19f0e27bab599":"e1eTk","3b0e5e45825bc96f":"6E7ou","73c2131545335241":"6DK60"}],"jbrkt":[function(require,module,exports) {
"use strict";
exports.StandAloneMonthParser = void 0;
var _constants = require("98e1a06b2ff3c4de");
var _Parser = require("e11ccdcf59f2f7dd");
var _utils = require("e8b8449d7a3b60c1");
class StandAloneMonthParser extends _Parser.Parser {
    priority = 110;
    parse(dateString, token, match) {
        const valueCallback = (value)=>value - 1;
        switch(token){
            // 1, 2, ..., 12
            case "L":
                return (0, _utils.mapValue)((0, _utils.parseNumericPattern)(_constants.numericPatterns.month, dateString), valueCallback);
            // 01, 02, ..., 12
            case "LL":
                return (0, _utils.mapValue)((0, _utils.parseNDigits)(2, dateString), valueCallback);
            // 1st, 2nd, ..., 12th
            case "Lo":
                return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
                    unit: "month"
                }), valueCallback);
            // Jan, Feb, ..., Dec
            case "LLL":
                return match.month(dateString, {
                    width: "abbreviated",
                    context: "standalone"
                }) || match.month(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
            // J, F, ..., D
            case "LLLLL":
                return match.month(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
            // January, February, ..., December
            case "LLLL":
            default:
                return match.month(dateString, {
                    width: "wide",
                    context: "standalone"
                }) || match.month(dateString, {
                    width: "abbreviated",
                    context: "standalone"
                }) || match.month(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 11;
    }
    set(date, _flags, value) {
        date.setMonth(value, 1);
        date.setHours(0, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "Y",
        "R",
        "q",
        "Q",
        "M",
        "w",
        "I",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
    ];
}
exports.StandAloneMonthParser = StandAloneMonthParser;

},{"98e1a06b2ff3c4de":"e1eTk","e11ccdcf59f2f7dd":"6E7ou","e8b8449d7a3b60c1":"6DK60"}],"8rNDN":[function(require,module,exports) {
"use strict";
exports.LocalWeekParser = void 0;
var _index = require("13c2e2bf3016fdd5");
var _index2 = require("bbf7e0dcf711535f");
var _constants = require("2601195a0e99a978");
var _Parser = require("d6e7369fa8c2f278");
var _utils = require("1193e0f5bcd19001");
// Local week of year
class LocalWeekParser extends _Parser.Parser {
    priority = 100;
    parse(dateString, token, match) {
        switch(token){
            case "w":
                return (0, _utils.parseNumericPattern)(_constants.numericPatterns.week, dateString);
            case "wo":
                return match.ordinalNumber(dateString, {
                    unit: "week"
                });
            default:
                return (0, _utils.parseNDigits)(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 53;
    }
    set(date, _flags, value, options) {
        return (0, _index2.startOfWeek)((0, _index.setWeek)(date, value, options), options);
    }
    incompatibleTokens = [
        "y",
        "R",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "i",
        "t",
        "T"
    ];
}
exports.LocalWeekParser = LocalWeekParser;

},{"13c2e2bf3016fdd5":"3XINN","bbf7e0dcf711535f":"dDDvv","2601195a0e99a978":"e1eTk","d6e7369fa8c2f278":"6E7ou","1193e0f5bcd19001":"6DK60"}],"3XINN":[function(require,module,exports) {
"use strict";
exports.setWeek = setWeek;
var _index = require("d61926e41e1e9dfc");
var _index2 = require("d8306f2d82e3f3b8");
/**
 * The {@link setWeek} function options.
 */ /**
 * @name setWeek
 * @category Week Helpers
 * @summary Set the local week to the given date.
 *
 * @description
 * Set the local week to the given date, saving the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param week - The week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week set
 *
 * @example
 * // Set the 1st week to 2 January 2005 with default options:
 * const result = setWeek(new Date(2005, 0, 2), 1)
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // Set the 1st week to 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January:
 * const result = setWeek(new Date(2005, 0, 2), 1, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sun Jan 4 2004 00:00:00
 */ function setWeek(date, week, options) {
    const _date = (0, _index2.toDate)(date);
    const diff = (0, _index.getWeek)(_date, options) - week;
    _date.setDate(_date.getDate() - diff * 7);
    return _date;
}

},{"d61926e41e1e9dfc":"1zHej","d8306f2d82e3f3b8":"actWA"}],"dfdwt":[function(require,module,exports) {
"use strict";
exports.ISOWeekParser = void 0;
var _index = require("d0e9d8806b690ddf");
var _index2 = require("5eec22592445f1f4");
var _constants = require("1dcdea171de1c1d9");
var _Parser = require("3569999127d8de4");
var _utils = require("3c620a00554fc0c1");
// ISO week of year
class ISOWeekParser extends _Parser.Parser {
    priority = 100;
    parse(dateString, token, match) {
        switch(token){
            case "I":
                return (0, _utils.parseNumericPattern)(_constants.numericPatterns.week, dateString);
            case "Io":
                return match.ordinalNumber(dateString, {
                    unit: "week"
                });
            default:
                return (0, _utils.parseNDigits)(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 53;
    }
    set(date, _flags, value) {
        return (0, _index2.startOfISOWeek)((0, _index.setISOWeek)(date, value));
    }
    incompatibleTokens = [
        "y",
        "Y",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "w",
        "d",
        "D",
        "e",
        "c",
        "t",
        "T"
    ];
}
exports.ISOWeekParser = ISOWeekParser;

},{"d0e9d8806b690ddf":"6YGAL","5eec22592445f1f4":"iF0wL","1dcdea171de1c1d9":"e1eTk","3569999127d8de4":"6E7ou","3c620a00554fc0c1":"6DK60"}],"6YGAL":[function(require,module,exports) {
"use strict";
exports.setISOWeek = setISOWeek;
var _index = require("8291d064c3f19d2b");
var _index2 = require("2a6c0f5e0da284fe");
/**
 * @name setISOWeek
 * @category ISO Week Helpers
 * @summary Set the ISO week to the given date.
 *
 * @description
 * Set the ISO week to the given date, saving the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param week - The ISO week of the new date
 *
 * @returns The new date with the ISO week set
 *
 * @example
 * // Set the 53rd ISO week to 7 August 2004:
 * const result = setISOWeek(new Date(2004, 7, 7), 53)
 * //=> Sat Jan 01 2005 00:00:00
 */ function setISOWeek(date, week) {
    const _date = (0, _index2.toDate)(date);
    const diff = (0, _index.getISOWeek)(_date) - week;
    _date.setDate(_date.getDate() - diff * 7);
    return _date;
}

},{"8291d064c3f19d2b":"fNkwc","2a6c0f5e0da284fe":"actWA"}],"fYv6C":[function(require,module,exports) {
"use strict";
exports.DateParser = void 0;
var _constants = require("e37bf0ec17405e58");
var _Parser = require("e06fd271e217a3f4");
var _utils = require("19b066b35011bfca");
const DAYS_IN_MONTH = [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
const DAYS_IN_MONTH_LEAP_YEAR = [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
// Day of the month
class DateParser extends _Parser.Parser {
    priority = 90;
    subPriority = 1;
    parse(dateString, token, match) {
        switch(token){
            case "d":
                return (0, _utils.parseNumericPattern)(_constants.numericPatterns.date, dateString);
            case "do":
                return match.ordinalNumber(dateString, {
                    unit: "date"
                });
            default:
                return (0, _utils.parseNDigits)(token.length, dateString);
        }
    }
    validate(date, value) {
        const year = date.getFullYear();
        const isLeapYear = (0, _utils.isLeapYearIndex)(year);
        const month = date.getMonth();
        if (isLeapYear) return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
        else return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
    set(date, _flags, value) {
        date.setDate(value);
        date.setHours(0, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "Y",
        "R",
        "q",
        "Q",
        "w",
        "I",
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
    ];
}
exports.DateParser = DateParser;

},{"e37bf0ec17405e58":"e1eTk","e06fd271e217a3f4":"6E7ou","19b066b35011bfca":"6DK60"}],"9cmRX":[function(require,module,exports) {
"use strict";
exports.DayOfYearParser = void 0;
var _constants = require("83fbe2027339aec5");
var _Parser = require("332eeceadb0ccc98");
var _utils = require("73a8ca34cfbb7597");
class DayOfYearParser extends _Parser.Parser {
    priority = 90;
    subpriority = 1;
    parse(dateString, token, match) {
        switch(token){
            case "D":
            case "DD":
                return (0, _utils.parseNumericPattern)(_constants.numericPatterns.dayOfYear, dateString);
            case "Do":
                return match.ordinalNumber(dateString, {
                    unit: "date"
                });
            default:
                return (0, _utils.parseNDigits)(token.length, dateString);
        }
    }
    validate(date, value) {
        const year = date.getFullYear();
        const isLeapYear = (0, _utils.isLeapYearIndex)(year);
        if (isLeapYear) return value >= 1 && value <= 366;
        else return value >= 1 && value <= 365;
    }
    set(date, _flags, value) {
        date.setMonth(0, value);
        date.setHours(0, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "Y",
        "R",
        "q",
        "Q",
        "M",
        "L",
        "w",
        "I",
        "d",
        "E",
        "i",
        "e",
        "c",
        "t",
        "T"
    ];
}
exports.DayOfYearParser = DayOfYearParser;

},{"83fbe2027339aec5":"e1eTk","332eeceadb0ccc98":"6E7ou","73a8ca34cfbb7597":"6DK60"}],"ksDae":[function(require,module,exports) {
"use strict";
exports.DayParser = void 0;
var _index = require("b83dfcd67991d62c");
var _Parser = require("57319c0f2f714850");
// Day of week
class DayParser extends _Parser.Parser {
    priority = 90;
    parse(dateString, token, match) {
        switch(token){
            // Tue
            case "E":
            case "EE":
            case "EEE":
                return match.day(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "short",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // T
            case "EEEEE":
                return match.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tu
            case "EEEEEE":
                return match.day(dateString, {
                    width: "short",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tuesday
            case "EEEE":
            default:
                return match.day(dateString, {
                    width: "wide",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "short",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 6;
    }
    set(date, _flags, value, options) {
        date = (0, _index.setDay)(date, value, options);
        date.setHours(0, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "D",
        "i",
        "e",
        "c",
        "t",
        "T"
    ];
}
exports.DayParser = DayParser;

},{"b83dfcd67991d62c":"7QCQN","57319c0f2f714850":"6E7ou"}],"7QCQN":[function(require,module,exports) {
"use strict";
exports.setDay = setDay;
var _index = require("ea54a94a012b3b70");
var _index2 = require("e25634d79be71669");
var _index3 = require("10936b78e6318933");
/**
 * The {@link setDay} function options.
 */ /**
 * @name setDay
 * @category Weekday Helpers
 * @summary Set the day of the week to the given date.
 *
 * @description
 * Set the day of the week to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param day - The day of the week of the new date
 * @param options - An object with options.
 *
 * @returns The new date with the day of the week set
 *
 * @example
 * // Set week day to Sunday, with the default weekStartsOn of Sunday:
 * const result = setDay(new Date(2014, 8, 1), 0)
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Set week day to Sunday, with a weekStartsOn of Monday:
 * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */ function setDay(date, day, options) {
    const defaultOptions = (0, _index3.getDefaultOptions)();
    const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions.weekStartsOn ?? defaultOptions.locale?.options?.weekStartsOn ?? 0;
    const _date = (0, _index2.toDate)(date);
    const currentDay = _date.getDay();
    const remainder = day % 7;
    const dayIndex = (remainder + 7) % 7;
    const delta = 7 - weekStartsOn;
    const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
    return (0, _index.addDays)(_date, diff);
}

},{"ea54a94a012b3b70":"fL4dR","e25634d79be71669":"actWA","10936b78e6318933":"98fau"}],"jgAEp":[function(require,module,exports) {
"use strict";
exports.LocalDayParser = void 0;
var _index = require("bb1b3f00c539097f");
var _Parser = require("6571efdf5566e23");
var _utils = require("59a554a051b6be38");
// Local day of week
class LocalDayParser extends _Parser.Parser {
    priority = 90;
    parse(dateString, token, match, options) {
        const valueCallback = (value)=>{
            const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
            return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch(token){
            // 3
            case "e":
            case "ee":
                return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
            // 3rd
            case "eo":
                return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
                    unit: "day"
                }), valueCallback);
            // Tue
            case "eee":
                return match.day(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "short",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // T
            case "eeeee":
                return match.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tu
            case "eeeeee":
                return match.day(dateString, {
                    width: "short",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            // Tuesday
            case "eeee":
            default:
                return match.day(dateString, {
                    width: "wide",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "short",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 6;
    }
    set(date, _flags, value, options) {
        date = (0, _index.setDay)(date, value, options);
        date.setHours(0, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "y",
        "R",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "E",
        "i",
        "c",
        "t",
        "T"
    ];
}
exports.LocalDayParser = LocalDayParser;

},{"bb1b3f00c539097f":"7QCQN","6571efdf5566e23":"6E7ou","59a554a051b6be38":"6DK60"}],"4FMAA":[function(require,module,exports) {
"use strict";
exports.StandAloneLocalDayParser = void 0;
var _index = require("d9dbe8f35d194adf");
var _Parser = require("270cd8e0745b64ff");
var _utils = require("2894fe8ea24065ec");
// Stand-alone local day of week
class StandAloneLocalDayParser extends _Parser.Parser {
    priority = 90;
    parse(dateString, token, match, options) {
        const valueCallback = (value)=>{
            const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
            return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch(token){
            // 3
            case "c":
            case "cc":
                return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
            // 3rd
            case "co":
                return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
                    unit: "day"
                }), valueCallback);
            // Tue
            case "ccc":
                return match.day(dateString, {
                    width: "abbreviated",
                    context: "standalone"
                }) || match.day(dateString, {
                    width: "short",
                    context: "standalone"
                }) || match.day(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
            // T
            case "ccccc":
                return match.day(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
            // Tu
            case "cccccc":
                return match.day(dateString, {
                    width: "short",
                    context: "standalone"
                }) || match.day(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
            // Tuesday
            case "cccc":
            default:
                return match.day(dateString, {
                    width: "wide",
                    context: "standalone"
                }) || match.day(dateString, {
                    width: "abbreviated",
                    context: "standalone"
                }) || match.day(dateString, {
                    width: "short",
                    context: "standalone"
                }) || match.day(dateString, {
                    width: "narrow",
                    context: "standalone"
                });
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 6;
    }
    set(date, _flags, value, options) {
        date = (0, _index.setDay)(date, value, options);
        date.setHours(0, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "y",
        "R",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "I",
        "d",
        "D",
        "E",
        "i",
        "e",
        "t",
        "T"
    ];
}
exports.StandAloneLocalDayParser = StandAloneLocalDayParser;

},{"d9dbe8f35d194adf":"7QCQN","270cd8e0745b64ff":"6E7ou","2894fe8ea24065ec":"6DK60"}],"eSKw6":[function(require,module,exports) {
"use strict";
exports.ISODayParser = void 0;
var _index = require("8d5cfff7f7eb5ee5");
var _Parser = require("f0244744717726df");
var _utils = require("bf9b3cd7754e213e");
// ISO day of week
class ISODayParser extends _Parser.Parser {
    priority = 90;
    parse(dateString, token, match) {
        const valueCallback = (value)=>{
            if (value === 0) return 7;
            return value;
        };
        switch(token){
            // 2
            case "i":
            case "ii":
                return (0, _utils.parseNDigits)(token.length, dateString);
            // 2nd
            case "io":
                return match.ordinalNumber(dateString, {
                    unit: "day"
                });
            // Tue
            case "iii":
                return (0, _utils.mapValue)(match.day(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "short",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                }), valueCallback);
            // T
            case "iiiii":
                return (0, _utils.mapValue)(match.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                }), valueCallback);
            // Tu
            case "iiiiii":
                return (0, _utils.mapValue)(match.day(dateString, {
                    width: "short",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                }), valueCallback);
            // Tuesday
            case "iiii":
            default:
                return (0, _utils.mapValue)(match.day(dateString, {
                    width: "wide",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "short",
                    context: "formatting"
                }) || match.day(dateString, {
                    width: "narrow",
                    context: "formatting"
                }), valueCallback);
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 7;
    }
    set(date, _flags, value) {
        date = (0, _index.setISODay)(date, value);
        date.setHours(0, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "y",
        "Y",
        "u",
        "q",
        "Q",
        "M",
        "L",
        "w",
        "d",
        "D",
        "E",
        "e",
        "c",
        "t",
        "T"
    ];
}
exports.ISODayParser = ISODayParser;

},{"8d5cfff7f7eb5ee5":"hs8xy","f0244744717726df":"6E7ou","bf9b3cd7754e213e":"6DK60"}],"hs8xy":[function(require,module,exports) {
"use strict";
exports.setISODay = setISODay;
var _index = require("44745967f27ca3e1");
var _index2 = require("533ead4b5083b736");
var _index3 = require("3ceb9bffa1043609");
/**
 * @name setISODay
 * @category Weekday Helpers
 * @summary Set the day of the ISO week to the given date.
 *
 * @description
 * Set the day of the ISO week to the given date.
 * ISO week starts with Monday.
 * 7 is the index of Sunday, 1 is the index of Monday etc.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param day - The day of the ISO week of the new date
 *
 * @returns The new date with the day of the ISO week set
 *
 * @example
 * // Set Sunday to 1 September 2014:
 * const result = setISODay(new Date(2014, 8, 1), 7)
 * //=> Sun Sep 07 2014 00:00:00
 */ function setISODay(date, day) {
    const _date = (0, _index3.toDate)(date);
    const currentDay = (0, _index2.getISODay)(_date);
    const diff = day - currentDay;
    return (0, _index.addDays)(_date, diff);
}

},{"44745967f27ca3e1":"fL4dR","533ead4b5083b736":"9d1Pg","3ceb9bffa1043609":"actWA"}],"eqkPE":[function(require,module,exports) {
"use strict";
exports.AMPMParser = void 0;
var _Parser = require("8a2e19df354a4acd");
var _utils = require("24e42863940456ae");
class AMPMParser extends _Parser.Parser {
    priority = 80;
    parse(dateString, token, match) {
        switch(token){
            case "a":
            case "aa":
            case "aaa":
                return match.dayPeriod(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            case "aaaaa":
                return match.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            case "aaaa":
            default:
                return match.dayPeriod(dateString, {
                    width: "wide",
                    context: "formatting"
                }) || match.dayPeriod(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
        }
    }
    set(date, _flags, value) {
        date.setHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "b",
        "B",
        "H",
        "k",
        "t",
        "T"
    ];
}
exports.AMPMParser = AMPMParser;

},{"8a2e19df354a4acd":"6E7ou","24e42863940456ae":"6DK60"}],"g3D3d":[function(require,module,exports) {
"use strict";
exports.AMPMMidnightParser = void 0;
var _Parser = require("4760f05ad38083c4");
var _utils = require("e542420b98b8b2fa");
class AMPMMidnightParser extends _Parser.Parser {
    priority = 80;
    parse(dateString, token, match) {
        switch(token){
            case "b":
            case "bb":
            case "bbb":
                return match.dayPeriod(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            case "bbbbb":
                return match.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            case "bbbb":
            default:
                return match.dayPeriod(dateString, {
                    width: "wide",
                    context: "formatting"
                }) || match.dayPeriod(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
        }
    }
    set(date, _flags, value) {
        date.setHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "a",
        "B",
        "H",
        "k",
        "t",
        "T"
    ];
}
exports.AMPMMidnightParser = AMPMMidnightParser;

},{"4760f05ad38083c4":"6E7ou","e542420b98b8b2fa":"6DK60"}],"hkyVS":[function(require,module,exports) {
"use strict";
exports.DayPeriodParser = void 0;
var _Parser = require("d445f4eb1b43afa9");
var _utils = require("5bc662f5d6a57c6");
// in the morning, in the afternoon, in the evening, at night
class DayPeriodParser extends _Parser.Parser {
    priority = 80;
    parse(dateString, token, match) {
        switch(token){
            case "B":
            case "BB":
            case "BBB":
                return match.dayPeriod(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            case "BBBBB":
                return match.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
            case "BBBB":
            default:
                return match.dayPeriod(dateString, {
                    width: "wide",
                    context: "formatting"
                }) || match.dayPeriod(dateString, {
                    width: "abbreviated",
                    context: "formatting"
                }) || match.dayPeriod(dateString, {
                    width: "narrow",
                    context: "formatting"
                });
        }
    }
    set(date, _flags, value) {
        date.setHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "a",
        "b",
        "t",
        "T"
    ];
}
exports.DayPeriodParser = DayPeriodParser;

},{"d445f4eb1b43afa9":"6E7ou","5bc662f5d6a57c6":"6DK60"}],"iRbV7":[function(require,module,exports) {
"use strict";
exports.Hour1to12Parser = void 0;
var _constants = require("d7205af5d699aaaa");
var _Parser = require("72fa2cbc4fa1bbbf");
var _utils = require("554c03fdba31e004");
class Hour1to12Parser extends _Parser.Parser {
    priority = 70;
    parse(dateString, token, match) {
        switch(token){
            case "h":
                return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour12h, dateString);
            case "ho":
                return match.ordinalNumber(dateString, {
                    unit: "hour"
                });
            default:
                return (0, _utils.parseNDigits)(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 12;
    }
    set(date, _flags, value) {
        const isPM = date.getHours() >= 12;
        if (isPM && value < 12) date.setHours(value + 12, 0, 0, 0);
        else if (!isPM && value === 12) date.setHours(0, 0, 0, 0);
        else date.setHours(value, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "H",
        "K",
        "k",
        "t",
        "T"
    ];
}
exports.Hour1to12Parser = Hour1to12Parser;

},{"d7205af5d699aaaa":"e1eTk","72fa2cbc4fa1bbbf":"6E7ou","554c03fdba31e004":"6DK60"}],"fq0MM":[function(require,module,exports) {
"use strict";
exports.Hour0to23Parser = void 0;
var _constants = require("517fe295d5149361");
var _Parser = require("e9b40c7441c4ce4a");
var _utils = require("a8f3667076399d62");
class Hour0to23Parser extends _Parser.Parser {
    priority = 70;
    parse(dateString, token, match) {
        switch(token){
            case "H":
                return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour23h, dateString);
            case "Ho":
                return match.ordinalNumber(dateString, {
                    unit: "hour"
                });
            default:
                return (0, _utils.parseNDigits)(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 23;
    }
    set(date, _flags, value) {
        date.setHours(value, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "a",
        "b",
        "h",
        "K",
        "k",
        "t",
        "T"
    ];
}
exports.Hour0to23Parser = Hour0to23Parser;

},{"517fe295d5149361":"e1eTk","e9b40c7441c4ce4a":"6E7ou","a8f3667076399d62":"6DK60"}],"ejbIY":[function(require,module,exports) {
"use strict";
exports.Hour0To11Parser = void 0;
var _constants = require("dc236b3b65dd7165");
var _Parser = require("110fa5ad724dd337");
var _utils = require("b31387bf6c98a135");
class Hour0To11Parser extends _Parser.Parser {
    priority = 70;
    parse(dateString, token, match) {
        switch(token){
            case "K":
                return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour11h, dateString);
            case "Ko":
                return match.ordinalNumber(dateString, {
                    unit: "hour"
                });
            default:
                return (0, _utils.parseNDigits)(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 11;
    }
    set(date, _flags, value) {
        const isPM = date.getHours() >= 12;
        if (isPM && value < 12) date.setHours(value + 12, 0, 0, 0);
        else date.setHours(value, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "h",
        "H",
        "k",
        "t",
        "T"
    ];
}
exports.Hour0To11Parser = Hour0To11Parser;

},{"dc236b3b65dd7165":"e1eTk","110fa5ad724dd337":"6E7ou","b31387bf6c98a135":"6DK60"}],"eEJho":[function(require,module,exports) {
"use strict";
exports.Hour1To24Parser = void 0;
var _constants = require("8a98c953b97bd9d2");
var _Parser = require("1a7c1d02f575f2ef");
var _utils = require("c21199ad414d918f");
class Hour1To24Parser extends _Parser.Parser {
    priority = 70;
    parse(dateString, token, match) {
        switch(token){
            case "k":
                return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour24h, dateString);
            case "ko":
                return match.ordinalNumber(dateString, {
                    unit: "hour"
                });
            default:
                return (0, _utils.parseNDigits)(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 1 && value <= 24;
    }
    set(date, _flags, value) {
        const hours = value <= 24 ? value % 24 : value;
        date.setHours(hours, 0, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "a",
        "b",
        "h",
        "H",
        "K",
        "t",
        "T"
    ];
}
exports.Hour1To24Parser = Hour1To24Parser;

},{"8a98c953b97bd9d2":"e1eTk","1a7c1d02f575f2ef":"6E7ou","c21199ad414d918f":"6DK60"}],"8XZpF":[function(require,module,exports) {
"use strict";
exports.MinuteParser = void 0;
var _constants = require("ebf9011e7838a79d");
var _Parser = require("4c8575a7116c3b84");
var _utils = require("e234fafa49de7d98");
class MinuteParser extends _Parser.Parser {
    priority = 60;
    parse(dateString, token, match) {
        switch(token){
            case "m":
                return (0, _utils.parseNumericPattern)(_constants.numericPatterns.minute, dateString);
            case "mo":
                return match.ordinalNumber(dateString, {
                    unit: "minute"
                });
            default:
                return (0, _utils.parseNDigits)(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 59;
    }
    set(date, _flags, value) {
        date.setMinutes(value, 0, 0);
        return date;
    }
    incompatibleTokens = [
        "t",
        "T"
    ];
}
exports.MinuteParser = MinuteParser;

},{"ebf9011e7838a79d":"e1eTk","4c8575a7116c3b84":"6E7ou","e234fafa49de7d98":"6DK60"}],"khJSC":[function(require,module,exports) {
"use strict";
exports.SecondParser = void 0;
var _constants = require("7521dd0b4c1ed894");
var _Parser = require("6437b3e2aa607a12");
var _utils = require("c6865c0f9a49a776");
class SecondParser extends _Parser.Parser {
    priority = 50;
    parse(dateString, token, match) {
        switch(token){
            case "s":
                return (0, _utils.parseNumericPattern)(_constants.numericPatterns.second, dateString);
            case "so":
                return match.ordinalNumber(dateString, {
                    unit: "second"
                });
            default:
                return (0, _utils.parseNDigits)(token.length, dateString);
        }
    }
    validate(_date, value) {
        return value >= 0 && value <= 59;
    }
    set(date, _flags, value) {
        date.setSeconds(value, 0);
        return date;
    }
    incompatibleTokens = [
        "t",
        "T"
    ];
}
exports.SecondParser = SecondParser;

},{"7521dd0b4c1ed894":"e1eTk","6437b3e2aa607a12":"6E7ou","c6865c0f9a49a776":"6DK60"}],"jT3Md":[function(require,module,exports) {
"use strict";
exports.FractionOfSecondParser = void 0;
var _Parser = require("67c65f5bafa413a");
var _utils = require("150a83840d362903");
class FractionOfSecondParser extends _Parser.Parser {
    priority = 30;
    parse(dateString, token) {
        const valueCallback = (value)=>Math.floor(value * Math.pow(10, -token.length + 3));
        return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
    }
    set(date, _flags, value) {
        date.setMilliseconds(value);
        return date;
    }
    incompatibleTokens = [
        "t",
        "T"
    ];
}
exports.FractionOfSecondParser = FractionOfSecondParser;

},{"67c65f5bafa413a":"6E7ou","150a83840d362903":"6DK60"}],"kUxSQ":[function(require,module,exports) {
"use strict";
exports.ISOTimezoneWithZParser = void 0;
var _index = require("368f4220a25e7374");
var _index2 = require("558ce65157f0e599");
var _constants = require("6a63e07f10f267b2");
var _Parser = require("ee66541a7458714a");
var _utils = require("e5626238686f2ba");
// Timezone (ISO-8601. +00:00 is `'Z'`)
class ISOTimezoneWithZParser extends _Parser.Parser {
    priority = 10;
    parse(dateString, token) {
        switch(token){
            case "X":
                return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalMinutes, dateString);
            case "XX":
                return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basic, dateString);
            case "XXXX":
                return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalSeconds, dateString);
            case "XXXXX":
                return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extendedOptionalSeconds, dateString);
            case "XXX":
            default:
                return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extended, dateString);
        }
    }
    set(date, flags, value) {
        if (flags.timestampIsSet) return date;
        return (0, _index.constructFrom)(date, date.getTime() - (0, _index2.getTimezoneOffsetInMilliseconds)(date) - value);
    }
    incompatibleTokens = [
        "t",
        "T",
        "x"
    ];
}
exports.ISOTimezoneWithZParser = ISOTimezoneWithZParser;

},{"368f4220a25e7374":"hNMdA","558ce65157f0e599":"ke6Rl","6a63e07f10f267b2":"e1eTk","ee66541a7458714a":"6E7ou","e5626238686f2ba":"6DK60"}],"ee2MS":[function(require,module,exports) {
"use strict";
exports.ISOTimezoneParser = void 0;
var _index = require("20489a2406ed1f6");
var _index2 = require("7b0f4c2b6899a6a5");
var _constants = require("1da5ad1881c8c8be");
var _Parser = require("f83d1ed0441d94a4");
var _utils = require("3d4e56ba10e06f4a");
// Timezone (ISO-8601)
class ISOTimezoneParser extends _Parser.Parser {
    priority = 10;
    parse(dateString, token) {
        switch(token){
            case "x":
                return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalMinutes, dateString);
            case "xx":
                return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basic, dateString);
            case "xxxx":
                return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalSeconds, dateString);
            case "xxxxx":
                return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extendedOptionalSeconds, dateString);
            case "xxx":
            default:
                return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extended, dateString);
        }
    }
    set(date, flags, value) {
        if (flags.timestampIsSet) return date;
        return (0, _index.constructFrom)(date, date.getTime() - (0, _index2.getTimezoneOffsetInMilliseconds)(date) - value);
    }
    incompatibleTokens = [
        "t",
        "T",
        "X"
    ];
}
exports.ISOTimezoneParser = ISOTimezoneParser;

},{"20489a2406ed1f6":"hNMdA","7b0f4c2b6899a6a5":"ke6Rl","1da5ad1881c8c8be":"e1eTk","f83d1ed0441d94a4":"6E7ou","3d4e56ba10e06f4a":"6DK60"}],"8CwPK":[function(require,module,exports) {
"use strict";
exports.TimestampSecondsParser = void 0;
var _index = require("d45a9a59d4c4a1fc");
var _Parser = require("e6a228a9048e0b92");
var _utils = require("1a8a5d87134d1ddc");
class TimestampSecondsParser extends _Parser.Parser {
    priority = 40;
    parse(dateString) {
        return (0, _utils.parseAnyDigitsSigned)(dateString);
    }
    set(date, _flags, value) {
        return [
            (0, _index.constructFrom)(date, value * 1000),
            {
                timestampIsSet: true
            }
        ];
    }
    incompatibleTokens = "*";
}
exports.TimestampSecondsParser = TimestampSecondsParser;

},{"d45a9a59d4c4a1fc":"hNMdA","e6a228a9048e0b92":"6E7ou","1a8a5d87134d1ddc":"6DK60"}],"czEu6":[function(require,module,exports) {
"use strict";
exports.TimestampMillisecondsParser = void 0;
var _index = require("de438b7eb6bce284");
var _Parser = require("ea4d3aab51a2471d");
var _utils = require("f77d6322d2335550");
class TimestampMillisecondsParser extends _Parser.Parser {
    priority = 20;
    parse(dateString) {
        return (0, _utils.parseAnyDigitsSigned)(dateString);
    }
    set(date, _flags, value) {
        return [
            (0, _index.constructFrom)(date, value),
            {
                timestampIsSet: true
            }
        ];
    }
    incompatibleTokens = "*";
}
exports.TimestampMillisecondsParser = TimestampMillisecondsParser;

},{"de438b7eb6bce284":"hNMdA","ea4d3aab51a2471d":"6E7ou","f77d6322d2335550":"6DK60"}],"8FUr6":[function(require,module,exports) {
"use strict";
exports.isMonday = isMonday;
var _index = require("4d45be3b46965d43");
/**
 * @name isMonday
 * @category Weekday Helpers
 * @summary Is the given date Monday?
 *
 * @description
 * Is the given date Monday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Monday
 *
 * @example
 * // Is 22 September 2014 Monday?
 * const result = isMonday(new Date(2014, 8, 22))
 * //=> true
 */ function isMonday(date) {
    return (0, _index.toDate)(date).getDay() === 1;
}

},{"4d45be3b46965d43":"actWA"}],"8QzC7":[function(require,module,exports) {
"use strict";
exports.isPast = isPast;
var _index = require("612cfa3e3a2e40bb");
/**
 * @name isPast
 * @category Common Helpers
 * @summary Is the given date in the past?
 * @pure false
 *
 * @description
 * Is the given date in the past?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in the past
 *
 * @example
 * // If today is 6 October 2014, is 2 July 2014 in the past?
 * const result = isPast(new Date(2014, 6, 2))
 * //=> true
 */ function isPast(date) {
    return +(0, _index.toDate)(date) < Date.now();
}

},{"612cfa3e3a2e40bb":"actWA"}],"jSzvL":[function(require,module,exports) {
"use strict";
exports.isSameHour = isSameHour;
var _index = require("92c6a40dfa7c3154");
/**
 * @name isSameHour
 * @category Hour Helpers
 * @summary Are the given dates in the same hour (and same day)?
 *
 * @description
 * Are the given dates in the same hour (and same day)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same hour (and same day)
 *
 * @example
 * // Are 4 September 2014 06:00:00 and 4 September 06:30:00 in the same hour?
 * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 6, 30))
 * //=> true
 *
 * @example
 * // Are 4 September 2014 06:00:00 and 5 September 06:00:00 in the same hour?
 * const result = isSameHour(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 5, 6, 0))
 * //=> false
 */ function isSameHour(dateLeft, dateRight) {
    const dateLeftStartOfHour = (0, _index.startOfHour)(dateLeft);
    const dateRightStartOfHour = (0, _index.startOfHour)(dateRight);
    return +dateLeftStartOfHour === +dateRightStartOfHour;
}

},{"92c6a40dfa7c3154":"30rTC"}],"30rTC":[function(require,module,exports) {
"use strict";
exports.startOfHour = startOfHour;
var _index = require("9638b175da3d3e66");
/**
 * @name startOfHour
 * @category Hour Helpers
 * @summary Return the start of an hour for the given date.
 *
 * @description
 * Return the start of an hour for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of an hour
 *
 * @example
 * // The start of an hour for 2 September 2014 11:55:00:
 * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:00:00
 */ function startOfHour(date) {
    const _date = (0, _index.toDate)(date);
    _date.setMinutes(0, 0, 0);
    return _date;
}

},{"9638b175da3d3e66":"actWA"}],"jri8s":[function(require,module,exports) {
"use strict";
exports.isSameISOWeek = isSameISOWeek;
var _index = require("7954406766bf5469");
/**
 * @name isSameISOWeek
 * @category ISO Week Helpers
 * @summary Are the given dates in the same ISO week (and year)?
 *
 * @description
 * Are the given dates in the same ISO week (and year)?
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same ISO week (and year)
 *
 * @example
 * // Are 1 September 2014 and 7 September 2014 in the same ISO week?
 * const result = isSameISOWeek(new Date(2014, 8, 1), new Date(2014, 8, 7))
 * //=> true
 *
 * @example
 * // Are 1 September 2014 and 1 September 2015 in the same ISO week?
 * const result = isSameISOWeek(new Date(2014, 8, 1), new Date(2015, 8, 1))
 * //=> false
 */ function isSameISOWeek(dateLeft, dateRight) {
    return (0, _index.isSameWeek)(dateLeft, dateRight, {
        weekStartsOn: 1
    });
}

},{"7954406766bf5469":"16SmB"}],"16SmB":[function(require,module,exports) {
"use strict";
exports.isSameWeek = isSameWeek;
var _index = require("1599abc409fd1353");
/**
 * The {@link isSameWeek} function options.
 */ /**
 * @name isSameWeek
 * @category Week Helpers
 * @summary Are the given dates in the same week (and month and year)?
 *
 * @description
 * Are the given dates in the same week (and month and year)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 * @param options - An object with options
 *
 * @returns The dates are in the same week (and month and year)
 *
 * @example
 * // Are 31 August 2014 and 4 September 2014 in the same week?
 * const result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4))
 * //=> true
 *
 * @example
 * // If week starts with Monday,
 * // are 31 August 2014 and 4 September 2014 in the same week?
 * const result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4), {
 *   weekStartsOn: 1
 * })
 * //=> false
 *
 * @example
 * // Are 1 January 2014 and 1 January 2015 in the same week?
 * const result = isSameWeek(new Date(2014, 0, 1), new Date(2015, 0, 1))
 * //=> false
 */ function isSameWeek(dateLeft, dateRight, options) {
    const dateLeftStartOfWeek = (0, _index.startOfWeek)(dateLeft, options);
    const dateRightStartOfWeek = (0, _index.startOfWeek)(dateRight, options);
    return +dateLeftStartOfWeek === +dateRightStartOfWeek;
}

},{"1599abc409fd1353":"dDDvv"}],"bat4E":[function(require,module,exports) {
"use strict";
exports.isSameISOWeekYear = isSameISOWeekYear;
var _index = require("5a42f52d97607f01");
/**
 * @name isSameISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Are the given dates in the same ISO week-numbering year?
 *
 * @description
 * Are the given dates in the same ISO week-numbering year?
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same ISO week-numbering year
 *
 * @example
 * // Are 29 December 2003 and 2 January 2005 in the same ISO week-numbering year?
 * const result = isSameISOWeekYear(new Date(2003, 11, 29), new Date(2005, 0, 2))
 * //=> true
 */ function isSameISOWeekYear(dateLeft, dateRight) {
    const dateLeftStartOfYear = (0, _index.startOfISOWeekYear)(dateLeft);
    const dateRightStartOfYear = (0, _index.startOfISOWeekYear)(dateRight);
    return +dateLeftStartOfYear === +dateRightStartOfYear;
}

},{"5a42f52d97607f01":"eTm1l"}],"7whBx":[function(require,module,exports) {
"use strict";
exports.isSameMinute = isSameMinute;
var _index = require("3bc0f134b347fe7b");
/**
 * @name isSameMinute
 * @category Minute Helpers
 * @summary Are the given dates in the same minute (and hour and day)?
 *
 * @description
 * Are the given dates in the same minute (and hour and day)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same minute (and hour and day)
 *
 * @example
 * // Are 4 September 2014 06:30:00 and 4 September 2014 06:30:15 in the same minute?
 * const result = isSameMinute(
 *   new Date(2014, 8, 4, 6, 30),
 *   new Date(2014, 8, 4, 6, 30, 15)
 * )
 * //=> true
 *
 * @example
 * // Are 4 September 2014 06:30:00 and 5 September 2014 06:30:00 in the same minute?
 * const result = isSameMinute(
 *   new Date(2014, 8, 4, 6, 30),
 *   new Date(2014, 8, 5, 6, 30)
 * )
 * //=> false
 */ function isSameMinute(dateLeft, dateRight) {
    const dateLeftStartOfMinute = (0, _index.startOfMinute)(dateLeft);
    const dateRightStartOfMinute = (0, _index.startOfMinute)(dateRight);
    return +dateLeftStartOfMinute === +dateRightStartOfMinute;
}

},{"3bc0f134b347fe7b":"5zVrK"}],"1d9cq":[function(require,module,exports) {
"use strict";
exports.isSameMonth = isSameMonth;
var _index = require("23bd545f1d63f8a8");
/**
 * @name isSameMonth
 * @category Month Helpers
 * @summary Are the given dates in the same month (and year)?
 *
 * @description
 * Are the given dates in the same month (and year)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same month (and year)
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same month?
 * const result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 *
 * @example
 * // Are 2 September 2014 and 25 September 2015 in the same month?
 * const result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))
 * //=> false
 */ function isSameMonth(dateLeft, dateRight) {
    const _dateLeft = (0, _index.toDate)(dateLeft);
    const _dateRight = (0, _index.toDate)(dateRight);
    return _dateLeft.getFullYear() === _dateRight.getFullYear() && _dateLeft.getMonth() === _dateRight.getMonth();
}

},{"23bd545f1d63f8a8":"actWA"}],"fJJ3M":[function(require,module,exports) {
"use strict";
exports.isSameQuarter = isSameQuarter;
var _index = require("9629b8292d869723");
/**
 * @name isSameQuarter
 * @category Quarter Helpers
 * @summary Are the given dates in the same quarter (and year)?
 *
 * @description
 * Are the given dates in the same quarter (and year)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check

 * @returns The dates are in the same quarter (and year)
 *
 * @example
 * // Are 1 January 2014 and 8 March 2014 in the same quarter?
 * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2014, 2, 8))
 * //=> true
 *
 * @example
 * // Are 1 January 2014 and 1 January 2015 in the same quarter?
 * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2015, 0, 1))
 * //=> false
 */ function isSameQuarter(dateLeft, dateRight) {
    const dateLeftStartOfQuarter = (0, _index.startOfQuarter)(dateLeft);
    const dateRightStartOfQuarter = (0, _index.startOfQuarter)(dateRight);
    return +dateLeftStartOfQuarter === +dateRightStartOfQuarter;
}

},{"9629b8292d869723":"ipmWI"}],"j88au":[function(require,module,exports) {
"use strict";
exports.isSameSecond = isSameSecond;
var _index = require("53999e672988f9a4");
/**
 * @name isSameSecond
 * @category Second Helpers
 * @summary Are the given dates in the same second (and hour and day)?
 *
 * @description
 * Are the given dates in the same second (and hour and day)?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same second (and hour and day)
 *
 * @example
 * // Are 4 September 2014 06:30:15.000 and 4 September 2014 06:30.15.500 in the same second?
 * const result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 30, 15),
 *   new Date(2014, 8, 4, 6, 30, 15, 500)
 * )
 * //=> true
 *
 * @example
 * // Are 4 September 2014 06:00:15.000 and 4 September 2014 06:01.15.000 in the same second?
 * const result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 0, 15),
 *   new Date(2014, 8, 4, 6, 1, 15)
 * )
 * //=> false
 *
 * @example
 * // Are 4 September 2014 06:00:15.000 and 5 September 2014 06:00.15.000 in the same second?
 * const result = isSameSecond(
 *   new Date(2014, 8, 4, 6, 0, 15),
 *   new Date(2014, 8, 5, 6, 0, 15)
 * )
 * //=> false
 */ function isSameSecond(dateLeft, dateRight) {
    const dateLeftStartOfSecond = (0, _index.startOfSecond)(dateLeft);
    const dateRightStartOfSecond = (0, _index.startOfSecond)(dateRight);
    return +dateLeftStartOfSecond === +dateRightStartOfSecond;
}

},{"53999e672988f9a4":"7GNYs"}],"7GNYs":[function(require,module,exports) {
"use strict";
exports.startOfSecond = startOfSecond;
var _index = require("ac80d9695d08cfc2");
/**
 * @name startOfSecond
 * @category Second Helpers
 * @summary Return the start of a second for the given date.
 *
 * @description
 * Return the start of a second for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a second
 *
 * @example
 * // The start of a second for 1 December 2014 22:15:45.400:
 * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:45.000
 */ function startOfSecond(date) {
    const _date = (0, _index.toDate)(date);
    _date.setMilliseconds(0);
    return _date;
}

},{"ac80d9695d08cfc2":"actWA"}],"jkjxd":[function(require,module,exports) {
"use strict";
exports.isSameYear = isSameYear;
var _index = require("cf2635c669070340");
/**
 * @name isSameYear
 * @category Year Helpers
 * @summary Are the given dates in the same year?
 *
 * @description
 * Are the given dates in the same year?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param dateLeft - The first date to check
 * @param dateRight - The second date to check
 *
 * @returns The dates are in the same year
 *
 * @example
 * // Are 2 September 2014 and 25 September 2014 in the same year?
 * const result = isSameYear(new Date(2014, 8, 2), new Date(2014, 8, 25))
 * //=> true
 */ function isSameYear(dateLeft, dateRight) {
    const _dateLeft = (0, _index.toDate)(dateLeft);
    const _dateRight = (0, _index.toDate)(dateRight);
    return _dateLeft.getFullYear() === _dateRight.getFullYear();
}

},{"cf2635c669070340":"actWA"}],"bUS6W":[function(require,module,exports) {
"use strict";
exports.isThisHour = isThisHour;
var _index = require("7de0ff58b1d3a33e");
/**
 * @name isThisHour
 * @category Hour Helpers
 * @summary Is the given date in the same hour as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same hour as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this hour
 *
 * @example
 * // If now is 25 September 2014 18:30:15.500,
 * // is 25 September 2014 18:00:00 in this hour?
 * const result = isThisHour(new Date(2014, 8, 25, 18))
 * //=> true
 */ function isThisHour(date) {
    return (0, _index.isSameHour)(Date.now(), date);
}

},{"7de0ff58b1d3a33e":"jSzvL"}],"4X4G2":[function(require,module,exports) {
"use strict";
exports.isThisISOWeek = isThisISOWeek;
var _index = require("24dea389c4f3208");
/**
 * @name isThisISOWeek
 * @category ISO Week Helpers
 * @summary Is the given date in the same ISO week as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same ISO week as the current date?
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this ISO week
 *
 * @example
 * // If today is 25 September 2014, is 22 September 2014 in this ISO week?
 * const result = isThisISOWeek(new Date(2014, 8, 22))
 * //=> true
 */ function isThisISOWeek(date) {
    return (0, _index.isSameISOWeek)(date, Date.now());
}

},{"24dea389c4f3208":"jri8s"}],"3IALF":[function(require,module,exports) {
"use strict";
exports.isThisMinute = isThisMinute;
var _index = require("f2ca1a4c9ac3e09b");
/**
 * @name isThisMinute
 * @category Minute Helpers
 * @summary Is the given date in the same minute as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same minute as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this minute
 *
 * @example
 * // If now is 25 September 2014 18:30:15.500,
 * // is 25 September 2014 18:30:00 in this minute?
 * const result = isThisMinute(new Date(2014, 8, 25, 18, 30))
 * //=> true
 */ function isThisMinute(date) {
    return (0, _index.isSameMinute)(Date.now(), date);
}

},{"f2ca1a4c9ac3e09b":"7whBx"}],"efMjU":[function(require,module,exports) {
"use strict";
exports.isThisMonth = isThisMonth;
var _index = require("dd3ba3f0986a5bca");
/**
 * @name isThisMonth
 * @category Month Helpers
 * @summary Is the given date in the same month as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same month as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this month
 *
 * @example
 * // If today is 25 September 2014, is 15 September 2014 in this month?
 * const result = isThisMonth(new Date(2014, 8, 15))
 * //=> true
 */ function isThisMonth(date) {
    return (0, _index.isSameMonth)(Date.now(), date);
}

},{"dd3ba3f0986a5bca":"1d9cq"}],"7x5Jl":[function(require,module,exports) {
"use strict";
exports.isThisQuarter = isThisQuarter;
var _index = require("c5271e258f905e50");
/**
 * @name isThisQuarter
 * @category Quarter Helpers
 * @summary Is the given date in the same quarter as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same quarter as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this quarter
 *
 * @example
 * // If today is 25 September 2014, is 2 July 2014 in this quarter?
 * const result = isThisQuarter(new Date(2014, 6, 2))
 * //=> true
 */ function isThisQuarter(date) {
    return (0, _index.isSameQuarter)(Date.now(), date);
}

},{"c5271e258f905e50":"fJJ3M"}],"d4Gae":[function(require,module,exports) {
"use strict";
exports.isThisSecond = isThisSecond;
var _index = require("7a6df91b9bb7fd35");
/**
 * @name isThisSecond
 * @category Second Helpers
 * @summary Is the given date in the same second as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same second as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this second
 *
 * @example
 * // If now is 25 September 2014 18:30:15.500,
 * // is 25 September 2014 18:30:15.000 in this second?
 * const result = isThisSecond(new Date(2014, 8, 25, 18, 30, 15))
 * //=> true
 */ function isThisSecond(date) {
    return (0, _index.isSameSecond)(Date.now(), date);
}

},{"7a6df91b9bb7fd35":"j88au"}],"clx4b":[function(require,module,exports) {
"use strict";
exports.isThisWeek = isThisWeek;
var _index = require("69c5a3fbdbf00c23");
/**
 * The {@link isThisWeek} function options.
 */ /**
 * @name isThisWeek
 * @category Week Helpers
 * @summary Is the given date in the same week as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same week as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 * @param options - The object with options
 *
 * @returns The date is in this week
 *
 * @example
 * // If today is 25 September 2014, is 21 September 2014 in this week?
 * const result = isThisWeek(new Date(2014, 8, 21))
 * //=> true
 *
 * @example
 * // If today is 25 September 2014 and week starts with Monday
 * // is 21 September 2014 in this week?
 * const result = isThisWeek(new Date(2014, 8, 21), { weekStartsOn: 1 })
 * //=> false
 */ function isThisWeek(date, options) {
    return (0, _index.isSameWeek)(date, Date.now(), options);
}

},{"69c5a3fbdbf00c23":"16SmB"}],"bMtqV":[function(require,module,exports) {
"use strict";
exports.isThisYear = isThisYear;
var _index = require("9f4e70430c882f21");
/**
 * @name isThisYear
 * @category Year Helpers
 * @summary Is the given date in the same year as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same year as the current date?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is in this year
 *
 * @example
 * // If today is 25 September 2014, is 2 July 2014 in this year?
 * const result = isThisYear(new Date(2014, 6, 2))
 * //=> true
 */ function isThisYear(date) {
    return (0, _index.isSameYear)(date, Date.now());
}

},{"9f4e70430c882f21":"jkjxd"}],"kwI0m":[function(require,module,exports) {
"use strict";
exports.isThursday = isThursday;
var _index = require("4459e1a3e1b1de53");
/**
 * @name isThursday
 * @category Weekday Helpers
 * @summary Is the given date Thursday?
 *
 * @description
 * Is the given date Thursday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Thursday
 *
 * @example
 * // Is 25 September 2014 Thursday?
 * const result = isThursday(new Date(2014, 8, 25))
 * //=> true
 */ function isThursday(date) {
    return (0, _index.toDate)(date).getDay() === 4;
}

},{"4459e1a3e1b1de53":"actWA"}],"7J3Q2":[function(require,module,exports) {
"use strict";
exports.isToday = isToday;
var _index = require("3eb372a0c18844be");
/**
 * @name isToday
 * @category Day Helpers
 * @summary Is the given date today?
 * @pure false
 *
 * @description
 * Is the given date today?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is today
 *
 * @example
 * // If today is 6 October 2014, is 6 October 14:00:00 today?
 * const result = isToday(new Date(2014, 9, 6, 14, 0))
 * //=> true
 */ function isToday(date) {
    return (0, _index.isSameDay)(date, Date.now());
}

},{"3eb372a0c18844be":"7FjQf"}],"2brVA":[function(require,module,exports) {
"use strict";
exports.isTomorrow = isTomorrow;
var _index = require("f1846e6b3d2dd7a9");
var _index2 = require("4ca5bd7eee26e325");
/**
 * @name isTomorrow
 * @category Day Helpers
 * @summary Is the given date tomorrow?
 * @pure false
 *
 * @description
 * Is the given date tomorrow?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is tomorrow
 *
 * @example
 * // If today is 6 October 2014, is 7 October 14:00:00 tomorrow?
 * const result = isTomorrow(new Date(2014, 9, 7, 14, 0))
 * //=> true
 */ function isTomorrow(date) {
    return (0, _index2.isSameDay)(date, (0, _index.addDays)(Date.now(), 1));
}

},{"f1846e6b3d2dd7a9":"fL4dR","4ca5bd7eee26e325":"7FjQf"}],"azgGe":[function(require,module,exports) {
"use strict";
exports.isTuesday = isTuesday;
var _index = require("c3ce837a6fb5ce78");
/**
 * @name isTuesday
 * @category Weekday Helpers
 * @summary Is the given date Tuesday?
 *
 * @description
 * Is the given date Tuesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Tuesday
 *
 * @example
 * // Is 23 September 2014 Tuesday?
 * const result = isTuesday(new Date(2014, 8, 23))
 * //=> true
 */ function isTuesday(date) {
    return (0, _index.toDate)(date).getDay() === 2;
}

},{"c3ce837a6fb5ce78":"actWA"}],"fo6X0":[function(require,module,exports) {
"use strict";
exports.isWednesday = isWednesday;
var _index = require("91710f6e1e58b24");
/**
 * @name isWednesday
 * @category Weekday Helpers
 * @summary Is the given date Wednesday?
 *
 * @description
 * Is the given date Wednesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is Wednesday
 *
 * @example
 * // Is 24 September 2014 Wednesday?
 * const result = isWednesday(new Date(2014, 8, 24))
 * //=> true
 */ function isWednesday(date) {
    return (0, _index.toDate)(date).getDay() === 3;
}

},{"91710f6e1e58b24":"actWA"}],"lsZyH":[function(require,module,exports) {
"use strict";
exports.isWithinInterval = isWithinInterval;
var _index = require("3b15ed0c3afb2c68");
/**
 * @name isWithinInterval
 * @category Interval Helpers
 * @summary Is the given date within the interval?
 *
 * @description
 * Is the given date within the interval? (Including start and end.)
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 * @param interval - The interval to check
 *
 * @returns The date is within the interval
 *
 * @example
 * // For the date within the interval:
 * isWithinInterval(new Date(2014, 0, 3), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> true
 *
 * @example
 * // For the date outside of the interval:
 * isWithinInterval(new Date(2014, 0, 10), {
 *   start: new Date(2014, 0, 1),
 *   end: new Date(2014, 0, 7)
 * })
 * //=> false
 *
 * @example
 * // For date equal to interval start:
 * isWithinInterval(date, { start, end: date })
 * // => true
 *
 * @example
 * // For date equal to interval end:
 * isWithinInterval(date, { start: date, end })
 * // => true
 */ function isWithinInterval(date, interval) {
    const time = +(0, _index.toDate)(date);
    const [startTime, endTime] = [
        +(0, _index.toDate)(interval.start),
        +(0, _index.toDate)(interval.end)
    ].sort((a, b)=>a - b);
    return time >= startTime && time <= endTime;
}

},{"3b15ed0c3afb2c68":"actWA"}],"8fQcQ":[function(require,module,exports) {
"use strict";
exports.isYesterday = isYesterday;
var _index = require("b3978a4bf227dee2");
var _index2 = require("cff81870f5b68f09");
/**
 * @name isYesterday
 * @category Day Helpers
 * @summary Is the given date yesterday?
 * @pure false
 *
 * @description
 * Is the given date yesterday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 *
 * @returns The date is yesterday
 *
 * @example
 * // If today is 6 October 2014, is 5 October 14:00:00 yesterday?
 * const result = isYesterday(new Date(2014, 9, 5, 14, 0))
 * //=> true
 */ function isYesterday(date) {
    return (0, _index.isSameDay)(date, (0, _index2.subDays)(Date.now(), 1));
}

},{"b3978a4bf227dee2":"7FjQf","cff81870f5b68f09":"3dD7a"}],"3dD7a":[function(require,module,exports) {
"use strict";
exports.subDays = subDays;
var _index = require("e0eae9dbd8818809");
/**
 * @name subDays
 * @category Day Helpers
 * @summary Subtract the specified number of days from the given date.
 *
 * @description
 * Subtract the specified number of days from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of days to be subtracted.
 *
 * @returns The new date with the days subtracted
 *
 * @example
 * // Subtract 10 days from 1 September 2014:
 * const result = subDays(new Date(2014, 8, 1), 10)
 * //=> Fri Aug 22 2014 00:00:00
 */ function subDays(date, amount) {
    return (0, _index.addDays)(date, -amount);
}

},{"e0eae9dbd8818809":"fL4dR"}],"4SSWt":[function(require,module,exports) {
"use strict";
exports.lastDayOfDecade = lastDayOfDecade;
var _index = require("19690e8c5b1cff89");
/**
 * @name lastDayOfDecade
 * @category Decade Helpers
 * @summary Return the last day of a decade for the given date.
 *
 * @description
 * Return the last day of a decade for the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of a decade
 *
 * @example
 * // The last day of a decade for 21 December 2012 21:12:00:
 * const result = lastDayOfDecade(new Date(2012, 11, 21, 21, 12, 00))
 * //=> Wed Dec 31 2019 00:00:00
 */ function lastDayOfDecade(date) {
    const _date = (0, _index.toDate)(date);
    const year = _date.getFullYear();
    const decade = 9 + Math.floor(year / 10) * 10;
    _date.setFullYear(decade + 1, 0, 0);
    _date.setHours(0, 0, 0, 0);
    return _date;
}

},{"19690e8c5b1cff89":"actWA"}],"8aCUT":[function(require,module,exports) {
"use strict";
exports.lastDayOfISOWeek = lastDayOfISOWeek;
var _index = require("310c2c93bee18a1d");
/**
 * @name lastDayOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the last day of an ISO week for the given date.
 *
 * @description
 * Return the last day of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of an ISO week
 *
 * @example
 * // The last day of an ISO week for 2 September 2014 11:55:00:
 * const result = lastDayOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Sep 07 2014 00:00:00
 */ function lastDayOfISOWeek(date) {
    return (0, _index.lastDayOfWeek)(date, {
        weekStartsOn: 1
    });
}

},{"310c2c93bee18a1d":"hFSne"}],"hFSne":[function(require,module,exports) {
"use strict";
exports.lastDayOfWeek = lastDayOfWeek;
var _index = require("f4ff98d39b69e8fb");
var _index2 = require("44532e3c32a807e3");
/**
 * The {@link lastDayOfWeek} function options.
 */ /**
 * @name lastDayOfWeek
 * @category Week Helpers
 * @summary Return the last day of a week for the given date.
 *
 * @description
 * Return the last day of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The last day of a week
 *
 * @example
 * // The last day of a week for 2 September 2014 11:55:00:
 * const result = lastDayOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sat Sep 06 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the last day of the week for 2 September 2014 11:55:00:
 * const result = lastDayOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */ function lastDayOfWeek(date, options) {
    const defaultOptions = (0, _index2.getDefaultOptions)();
    const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions.weekStartsOn ?? defaultOptions.locale?.options?.weekStartsOn ?? 0;
    const _date = (0, _index.toDate)(date);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
    _date.setHours(0, 0, 0, 0);
    _date.setDate(_date.getDate() + diff);
    return _date;
}

},{"f4ff98d39b69e8fb":"actWA","44532e3c32a807e3":"98fau"}],"jW013":[function(require,module,exports) {
"use strict";
exports.lastDayOfISOWeekYear = lastDayOfISOWeekYear;
var _index = require("6f2d40dbf0beeab9");
var _index2 = require("50638a52881c58b3");
var _index3 = require("c4a7659712beecae");
/**
 * @name lastDayOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the last day of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the last day of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The end of an ISO week-numbering year
 *
 * @example
 * // The last day of an ISO week-numbering year for 2 July 2005:
 * const result = lastDayOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Sun Jan 01 2006 00:00:00
 */ function lastDayOfISOWeekYear(date) {
    const year = (0, _index.getISOWeekYear)(date);
    const fourthOfJanuary = (0, _index3.constructFrom)(date, 0);
    fourthOfJanuary.setFullYear(year + 1, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    const _date = (0, _index2.startOfISOWeek)(fourthOfJanuary);
    _date.setDate(_date.getDate() - 1);
    return _date;
}

},{"6f2d40dbf0beeab9":"jWChc","50638a52881c58b3":"iF0wL","c4a7659712beecae":"hNMdA"}],"ccmoZ":[function(require,module,exports) {
"use strict";
exports.lastDayOfQuarter = lastDayOfQuarter;
var _index = require("ab0d585d78bebc2b");
/**
 * @name lastDayOfQuarter
 * @category Quarter Helpers
 * @summary Return the last day of a year quarter for the given date.
 *
 * @description
 * Return the last day of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of a quarter
 *
 * @example
 * // The last day of a quarter for 2 September 2014 11:55:00:
 * const result = lastDayOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 00:00:00
 */ function lastDayOfQuarter(date) {
    const _date = (0, _index.toDate)(date);
    const currentMonth = _date.getMonth();
    const month = currentMonth - currentMonth % 3 + 3;
    _date.setMonth(month, 0);
    _date.setHours(0, 0, 0, 0);
    return _date;
}

},{"ab0d585d78bebc2b":"actWA"}],"9VAZa":[function(require,module,exports) {
"use strict";
exports.lastDayOfYear = lastDayOfYear;
var _index = require("fc978c197d626874");
/**
 * @name lastDayOfYear
 * @category Year Helpers
 * @summary Return the last day of a year for the given date.
 *
 * @description
 * Return the last day of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The last day of a year
 *
 * @example
 * // The last day of a year for 2 September 2014 11:55:00:
 * const result = lastDayOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Dec 31 2014 00:00:00
 */ function lastDayOfYear(date) {
    const _date = (0, _index.toDate)(date);
    const year = _date.getFullYear();
    _date.setFullYear(year + 1, 0, 0);
    _date.setHours(0, 0, 0, 0);
    return _date;
}

},{"fc978c197d626874":"actWA"}],"kU9pl":[function(require,module,exports) {
"use strict";
exports.lightFormat = lightFormat;
Object.defineProperty(exports, "lightFormatters", {
    enumerable: true,
    get: function() {
        return _index3.lightFormatters;
    }
});
var _index = require("e6e1e54ff83d376f");
var _index2 = require("6dbbe26649931a76");
var _index3 = require("8c1cb87f7b9fb7dc");
// Rexports of internal for libraries to use.
// See: https://github.com/date-fns/date-fns/issues/3638#issuecomment-1877082874
// This RegExp consists of three parts separated by `|`:
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps
const formattingTokensRegExp = /(\w)\1*|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @private
 */ /**
 * @name lightFormat
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. Unlike `format`,
 * `lightFormat` doesn't use locales and outputs date using the most popular tokens.
 *
 * > ⚠️ Please note that the `lightFormat` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   |
 * |---------------------------------|---------|-----------------------------------|
 * | AM, PM                          | a..aaa  | AM, PM                            |
 * |                                 | aaaa    | a.m., p.m.                        |
 * |                                 | aaaaa   | a, p                              |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 |
 * |                                 | yy      | 44, 01, 00, 17                    |
 * |                                 | yyy     | 044, 001, 000, 017                |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |
 * |                                 | MM      | 01, 02, ..., 12                   |
 * | Day of month                    | d       | 1, 2, ..., 31                     |
 * |                                 | dd      | 01, 02, ..., 31                   |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |
 * |                                 | hh      | 01, 02, ..., 11, 12               |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |
 * |                                 | HH      | 00, 01, 02, ..., 23               |
 * | Minute                          | m       | 0, 1, ..., 59                     |
 * |                                 | mm      | 00, 01, ..., 59                   |
 * | Second                          | s       | 0, 1, ..., 59                     |
 * |                                 | ss      | 00, 01, ..., 59                   |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |
 * |                                 | SS      | 00, 01, ..., 99                   |
 * |                                 | SSS     | 000, 001, ..., 999                |
 * |                                 | SSSS    | ...                               |
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 * @param format - The string of tokens
 *
 * @returns The formatted date string
 *
 * @throws `Invalid time value` if the date is invalid
 * @throws format string contains an unescaped latin alphabet character
 *
 * @example
 * const result = lightFormat(new Date(2014, 1, 11), 'yyyy-MM-dd')
 * //=> '2014-02-11'
 */ function lightFormat(date, formatStr) {
    const _date = (0, _index2.toDate)(date);
    if (!(0, _index.isValid)(_date)) throw new RangeError("Invalid time value");
    const tokens = formatStr.match(formattingTokensRegExp);
    // The only case when formattingTokensRegExp doesn't match the string is when it's empty
    if (!tokens) return "";
    const result = tokens.map((substring)=>{
        // Replace two single quote characters with one single quote character
        if (substring === "''") return "'";
        const firstCharacter = substring[0];
        if (firstCharacter === "'") return cleanEscapedString(substring);
        const formatter = _index3.lightFormatters[firstCharacter];
        if (formatter) return formatter(_date, substring);
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        return substring;
    }).join("");
    return result;
}
function cleanEscapedString(input) {
    const matches = input.match(escapedStringRegExp);
    if (!matches) return input;
    return matches[1].replace(doubleQuoteRegExp, "'");
}

},{"e6e1e54ff83d376f":"gbOJY","6dbbe26649931a76":"actWA","8c1cb87f7b9fb7dc":"bOcKP"}],"lzjRb":[function(require,module,exports) {
"use strict";
exports.milliseconds = milliseconds;
var _index = require("45cb8142d6d463ca");
/**
 * @name milliseconds
 * @category Millisecond Helpers
 * @summary
 * Returns the number of milliseconds in the specified, years, months, weeks, days, hours, minutes and seconds.
 *
 * @description
 * Returns the number of milliseconds in the specified, years, months, weeks, days, hours, minutes and seconds.
 *
 * One years equals 365.2425 days according to the formula:
 *
 * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
 * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
 *
 * One month is a year divided by 12.
 *
 * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be added.
 *
 * @returns The milliseconds
 *
 * @example
 * // 1 year in milliseconds
 * milliseconds({ years: 1 })
 * //=> 31556952000
 *
 * // 3 months in milliseconds
 * milliseconds({ months: 3 })
 * //=> 7889238000
 */ function milliseconds({ years, months, weeks, days, hours, minutes, seconds }) {
    let totalDays = 0;
    if (years) totalDays += years * _index.daysInYear;
    if (months) totalDays += months * (_index.daysInYear / 12);
    if (weeks) totalDays += weeks * 7;
    if (days) totalDays += days;
    let totalSeconds = totalDays * 86400;
    if (hours) totalSeconds += hours * 3600;
    if (minutes) totalSeconds += minutes * 60;
    if (seconds) totalSeconds += seconds;
    return Math.round(totalSeconds * 1000);
}

},{"45cb8142d6d463ca":"1vXXw"}],"jMfmL":[function(require,module,exports) {
"use strict";
exports.millisecondsToHours = millisecondsToHours;
var _index = require("d1e90fa8b924dd35");
/**
 * @name millisecondsToHours
 * @category Conversion Helpers
 * @summary Convert milliseconds to hours.
 *
 * @description
 * Convert a number of milliseconds to a full number of hours.
 *
 * @param milliseconds - The number of milliseconds to be converted
 *
 * @returns The number of milliseconds converted in hours
 *
 * @example
 * // Convert 7200000 milliseconds to hours:
 * const result = millisecondsToHours(7200000)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = millisecondsToHours(7199999)
 * //=> 1
 */ function millisecondsToHours(milliseconds) {
    const hours = milliseconds / _index.millisecondsInHour;
    return Math.floor(hours);
}

},{"d1e90fa8b924dd35":"1vXXw"}],"enzjB":[function(require,module,exports) {
"use strict";
exports.millisecondsToMinutes = millisecondsToMinutes;
var _index = require("5389415c189a3dc6");
/**
 * @name millisecondsToMinutes
 * @category Conversion Helpers
 * @summary Convert milliseconds to minutes.
 *
 * @description
 * Convert a number of milliseconds to a full number of minutes.
 *
 * @param milliseconds - The number of milliseconds to be converted
 *
 * @returns The number of milliseconds converted in minutes
 *
 * @example
 * // Convert 60000 milliseconds to minutes:
 * const result = millisecondsToMinutes(60000)
 * //=> 1
 *
 * @example
 * // It uses floor rounding:
 * const result = millisecondsToMinutes(119999)
 * //=> 1
 */ function millisecondsToMinutes(milliseconds) {
    const minutes = milliseconds / _index.millisecondsInMinute;
    return Math.floor(minutes);
}

},{"5389415c189a3dc6":"1vXXw"}],"jqSZU":[function(require,module,exports) {
"use strict";
exports.millisecondsToSeconds = millisecondsToSeconds;
var _index = require("861d3d04ff9a07fa");
/**
 * @name millisecondsToSeconds
 * @category Conversion Helpers
 * @summary Convert milliseconds to seconds.
 *
 * @description
 * Convert a number of milliseconds to a full number of seconds.
 *
 * @param milliseconds - The number of milliseconds to be converted
 *
 * @returns The number of milliseconds converted in seconds
 *
 * @example
 * // Convert 1000 miliseconds to seconds:
 * const result = millisecondsToSeconds(1000)
 * //=> 1
 *
 * @example
 * // It uses floor rounding:
 * const result = millisecondsToSeconds(1999)
 * //=> 1
 */ function millisecondsToSeconds(milliseconds) {
    const seconds = milliseconds / _index.millisecondsInSecond;
    return Math.floor(seconds);
}

},{"861d3d04ff9a07fa":"1vXXw"}],"g79VA":[function(require,module,exports) {
"use strict";
exports.minutesToHours = minutesToHours;
var _index = require("b2279c5d7baaa4de");
/**
 * @name minutesToHours
 * @category Conversion Helpers
 * @summary Convert minutes to hours.
 *
 * @description
 * Convert a number of minutes to a full number of hours.
 *
 * @param minutes - The number of minutes to be converted
 *
 * @returns The number of minutes converted in hours
 *
 * @example
 * // Convert 140 minutes to hours:
 * const result = minutesToHours(120)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = minutesToHours(179)
 * //=> 2
 */ function minutesToHours(minutes) {
    const hours = minutes / _index.minutesInHour;
    return Math.floor(hours);
}

},{"b2279c5d7baaa4de":"1vXXw"}],"inDwO":[function(require,module,exports) {
"use strict";
exports.minutesToMilliseconds = minutesToMilliseconds;
var _index = require("63cd685f54f399ba");
/**
 * @name minutesToMilliseconds
 * @category Conversion Helpers
 * @summary Convert minutes to milliseconds.
 *
 * @description
 * Convert a number of minutes to a full number of milliseconds.
 *
 * @param minutes - The number of minutes to be converted
 *
 * @returns The number of minutes converted in milliseconds
 *
 * @example
 * // Convert 2 minutes to milliseconds
 * const result = minutesToMilliseconds(2)
 * //=> 120000
 */ function minutesToMilliseconds(minutes) {
    return Math.floor(minutes * _index.millisecondsInMinute);
}

},{"63cd685f54f399ba":"1vXXw"}],"4Wxgd":[function(require,module,exports) {
"use strict";
exports.minutesToSeconds = minutesToSeconds;
var _index = require("46501645cea7f36c");
/**
 * @name minutesToSeconds
 * @category Conversion Helpers
 * @summary Convert minutes to seconds.
 *
 * @description
 * Convert a number of minutes to a full number of seconds.
 *
 * @param minutes - The number of minutes to be converted
 *
 * @returns The number of minutes converted in seconds
 *
 * @example
 * // Convert 2 minutes to seconds
 * const result = minutesToSeconds(2)
 * //=> 120
 */ function minutesToSeconds(minutes) {
    return Math.floor(minutes * _index.secondsInMinute);
}

},{"46501645cea7f36c":"1vXXw"}],"gHdRE":[function(require,module,exports) {
"use strict";
exports.monthsToQuarters = monthsToQuarters;
var _index = require("66be799395f33ad6");
/**
 * @name monthsToQuarters
 * @category Conversion Helpers
 * @summary Convert number of months to quarters.
 *
 * @description
 * Convert a number of months to a full number of quarters.
 *
 * @param months - The number of months to be converted.
 *
 * @returns The number of months converted in quarters
 *
 * @example
 * // Convert 6 months to quarters:
 * const result = monthsToQuarters(6)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = monthsToQuarters(7)
 * //=> 2
 */ function monthsToQuarters(months) {
    const quarters = months / _index.monthsInQuarter;
    return Math.floor(quarters);
}

},{"66be799395f33ad6":"1vXXw"}],"5rxTb":[function(require,module,exports) {
"use strict";
exports.monthsToYears = monthsToYears;
var _index = require("4aa74b8bb4072671");
/**
 * @name monthsToYears
 * @category Conversion Helpers
 * @summary Convert number of months to years.
 *
 * @description
 * Convert a number of months to a full number of years.
 *
 * @param months - The number of months to be converted
 *
 * @returns The number of months converted in years
 *
 * @example
 * // Convert 36 months to years:
 * const result = monthsToYears(36)
 * //=> 3
 *
 * // It uses floor rounding:
 * const result = monthsToYears(40)
 * //=> 3
 */ function monthsToYears(months) {
    const years = months / _index.monthsInYear;
    return Math.floor(years);
}

},{"4aa74b8bb4072671":"1vXXw"}],"8JvSy":[function(require,module,exports) {
"use strict";
exports.nextDay = nextDay;
var _index = require("ca24a3f0389dc83e");
var _index2 = require("69b65fb7d3c29c5e");
/**
 * @name nextDay
 * @category Weekday Helpers
 * @summary When is the next day of the week?
 *
 * @description
 * When is the next day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 * @param day - day of the week
 *
 * @returns The date is the next day of week
 *
 * @example
 * // When is the next Monday after Mar, 20, 2020?
 * const result = nextDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 23 2020 00:00:00
 *
 * @example
 * // When is the next Tuesday after Mar, 21, 2020?
 * const result = nextDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 24 2020 00:00:00
 */ function nextDay(date, day) {
    let delta = day - (0, _index2.getDay)(date);
    if (delta <= 0) delta += 7;
    return (0, _index.addDays)(date, delta);
}

},{"ca24a3f0389dc83e":"fL4dR","69b65fb7d3c29c5e":"esFEi"}],"7LrAi":[function(require,module,exports) {
"use strict";
exports.nextFriday = nextFriday;
var _index = require("f9faac43a000efc1");
/**
 * @name nextFriday
 * @category Weekday Helpers
 * @summary When is the next Friday?
 *
 * @description
 * When is the next Friday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Friday
 *
 * @example
 * // When is the next Friday after Mar, 22, 2020?
 * const result = nextFriday(new Date(2020, 2, 22))
 * //=> Fri Mar 27 2020 00:00:00
 */ function nextFriday(date) {
    return (0, _index.nextDay)(date, 5);
}

},{"f9faac43a000efc1":"8JvSy"}],"1YO5g":[function(require,module,exports) {
"use strict";
exports.nextMonday = nextMonday;
var _index = require("ce06f84d344dedae");
/**
 * @name nextMonday
 * @category Weekday Helpers
 * @summary When is the next Monday?
 *
 * @description
 * When is the next Monday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Monday
 *
 * @example
 * // When is the next Monday after Mar, 22, 2020?
 * const result = nextMonday(new Date(2020, 2, 22))
 * //=> Mon Mar 23 2020 00:00:00
 */ function nextMonday(date) {
    return (0, _index.nextDay)(date, 1);
}

},{"ce06f84d344dedae":"8JvSy"}],"gnebd":[function(require,module,exports) {
"use strict";
exports.nextSaturday = nextSaturday;
var _index = require("8c6693c27a70e211");
/**
 * @name nextSaturday
 * @category Weekday Helpers
 * @summary When is the next Saturday?
 *
 * @description
 * When is the next Saturday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Saturday
 *
 * @example
 * // When is the next Saturday after Mar, 22, 2020?
 * const result = nextSaturday(new Date(2020, 2, 22))
 * //=> Sat Mar 28 2020 00:00:00
 */ function nextSaturday(date) {
    return (0, _index.nextDay)(date, 6);
}

},{"8c6693c27a70e211":"8JvSy"}],"29SYN":[function(require,module,exports) {
"use strict";
exports.nextSunday = nextSunday;
var _index = require("a0d35069d4e97420");
/**
 * @name nextSunday
 * @category Weekday Helpers
 * @summary When is the next Sunday?
 *
 * @description
 * When is the next Sunday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Sunday
 *
 * @example
 * // When is the next Sunday after Mar, 22, 2020?
 * const result = nextSunday(new Date(2020, 2, 22))
 * //=> Sun Mar 29 2020 00:00:00
 */ function nextSunday(date) {
    return (0, _index.nextDay)(date, 0);
}

},{"a0d35069d4e97420":"8JvSy"}],"atse6":[function(require,module,exports) {
"use strict";
exports.nextThursday = nextThursday;
var _index = require("8312401f2830d3fd");
/**
 * @name nextThursday
 * @category Weekday Helpers
 * @summary When is the next Thursday?
 *
 * @description
 * When is the next Thursday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Thursday
 *
 * @example
 * // When is the next Thursday after Mar, 22, 2020?
 * const result = nextThursday(new Date(2020, 2, 22))
 * //=> Thur Mar 26 2020 00:00:00
 */ function nextThursday(date) {
    return (0, _index.nextDay)(date, 4);
}

},{"8312401f2830d3fd":"8JvSy"}],"02uJh":[function(require,module,exports) {
"use strict";
exports.nextTuesday = nextTuesday;
var _index = require("a2f85d404caa8de7");
/**
 * @name nextTuesday
 * @category Weekday Helpers
 * @summary When is the next Tuesday?
 *
 * @description
 * When is the next Tuesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Tuesday
 *
 * @example
 * // When is the next Tuesday after Mar, 22, 2020?
 * const result = nextTuesday(new Date(2020, 2, 22))
 * //=> Tue Mar 24 2020 00:00:00
 */ function nextTuesday(date) {
    return (0, _index.nextDay)(date, 2);
}

},{"a2f85d404caa8de7":"8JvSy"}],"j2uXA":[function(require,module,exports) {
"use strict";
exports.nextWednesday = nextWednesday;
var _index = require("3e112ee16fcb6127");
/**
 * @name nextWednesday
 * @category Weekday Helpers
 * @summary When is the next Wednesday?
 *
 * @description
 * When is the next Wednesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The next Wednesday
 *
 * @example
 * // When is the next Wednesday after Mar, 22, 2020?
 * const result = nextWednesday(new Date(2020, 2, 22))
 * //=> Wed Mar 25 2020 00:00:00
 */ function nextWednesday(date) {
    return (0, _index.nextDay)(date, 3);
}

},{"3e112ee16fcb6127":"8JvSy"}],"jsVo7":[function(require,module,exports) {
"use strict";
exports.parseISO = parseISO;
var _index = require("1a2fdaf01fdda35e");
/**
 * The {@link parseISO} function options.
 */ /**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param argument - The value to convert
 * @param options - An object with options
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * const result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * const result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */ function parseISO(argument, options) {
    const additionalDigits = options?.additionalDigits ?? 2;
    const dateStrings = splitDateString(argument);
    let date;
    if (dateStrings.date) {
        const parseYearResult = parseYear(dateStrings.date, additionalDigits);
        date = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }
    if (!date || isNaN(date.getTime())) return new Date(NaN);
    const timestamp = date.getTime();
    let time = 0;
    let offset;
    if (dateStrings.time) {
        time = parseTime(dateStrings.time);
        if (isNaN(time)) return new Date(NaN);
    }
    if (dateStrings.timezone) {
        offset = parseTimezone(dateStrings.timezone);
        if (isNaN(offset)) return new Date(NaN);
    } else {
        const dirtyDate = new Date(timestamp + time);
        // JS parsed string assuming it's in UTC timezone
        // but we need it to be parsed in our timezone
        // so we use utc values to build date in our timezone.
        // Year values from 0 to 99 map to the years 1900 to 1999
        // so set year explicitly with setFullYear.
        const result = new Date(0);
        result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
        result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
        return result;
    }
    return new Date(timestamp + time + offset);
}
const patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
};
const dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
const timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
    const dateStrings = {};
    const array = dateString.split(patterns.dateTimeDelimiter);
    let timeString;
    // The regex match should only return at maximum two array elements.
    // [date], [time], or [date, time].
    if (array.length > 2) return dateStrings;
    if (/:/.test(array[0])) timeString = array[0];
    else {
        dateStrings.date = array[0];
        timeString = array[1];
        if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
            dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
            timeString = dateString.substr(dateStrings.date.length, dateString.length);
        }
    }
    if (timeString) {
        const token = patterns.timezone.exec(timeString);
        if (token) {
            dateStrings.time = timeString.replace(token[1], "");
            dateStrings.timezone = token[1];
        } else dateStrings.time = timeString;
    }
    return dateStrings;
}
function parseYear(dateString, additionalDigits) {
    const regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
    const captures = dateString.match(regex);
    // Invalid ISO-formatted year
    if (!captures) return {
        year: NaN,
        restDateString: ""
    };
    const year = captures[1] ? parseInt(captures[1]) : null;
    const century = captures[2] ? parseInt(captures[2]) : null;
    // either year or century is null, not both
    return {
        year: century === null ? year : century * 100,
        restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
}
function parseDate(dateString, year) {
    // Invalid ISO-formatted year
    if (year === null) return new Date(NaN);
    const captures = dateString.match(dateRegex);
    // Invalid ISO-formatted string
    if (!captures) return new Date(NaN);
    const isWeekDate = !!captures[4];
    const dayOfYear = parseDateUnit(captures[1]);
    const month = parseDateUnit(captures[2]) - 1;
    const day = parseDateUnit(captures[3]);
    const week = parseDateUnit(captures[4]);
    const dayOfWeek = parseDateUnit(captures[5]) - 1;
    if (isWeekDate) {
        if (!validateWeekDate(year, week, dayOfWeek)) return new Date(NaN);
        return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
        const date = new Date(0);
        if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) return new Date(NaN);
        date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
        return date;
    }
}
function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
    const captures = timeString.match(timeRegex);
    if (!captures) return NaN; // Invalid ISO-formatted time
    const hours = parseTimeUnit(captures[1]);
    const minutes = parseTimeUnit(captures[2]);
    const seconds = parseTimeUnit(captures[3]);
    if (!validateTime(hours, minutes, seconds)) return NaN;
    return hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute + seconds * 1000;
}
function parseTimeUnit(value) {
    return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
    if (timezoneString === "Z") return 0;
    const captures = timezoneString.match(timezoneRegex);
    if (!captures) return 0;
    const sign = captures[1] === "+" ? -1 : 1;
    const hours = parseInt(captures[2]);
    const minutes = captures[3] && parseInt(captures[3]) || 0;
    if (!validateTimezone(hours, minutes)) return NaN;
    return sign * (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
    const date = new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    const fourthOfJanuaryDay = date.getUTCDay() || 7;
    const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
}
// Validation functions
// February is null to handle the leap year (using ||)
const daysInMonths = [
    31,
    null,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
    return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
    if (hours === 24) return minutes === 0 && seconds === 0;
    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
}

},{"1a2fdaf01fdda35e":"1vXXw"}],"45sna":[function(require,module,exports) {
"use strict";
exports.parseJSON = parseJSON; /**
 * @name parseJSON
 * @category Common Helpers
 * @summary Parse a JSON date string
 *
 * @description
 * Converts a complete ISO date string in UTC time, the typical format for transmitting
 * a date in JSON, to a JavaScript `Date` instance.
 *
 * This is a minimal implementation for converting dates retrieved from a JSON API to
 * a `Date` instance which can be used with other functions in the `date-fns` library.
 * The following formats are supported:
 *
 * - `2000-03-15T05:20:10.123Z`: The output of `.toISOString()` and `JSON.stringify(new Date())`
 * - `2000-03-15T05:20:10Z`: Without milliseconds
 * - `2000-03-15T05:20:10+00:00`: With a zero offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+05:45`: With a positive or negative offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+0000`: With a zero offset without a colon
 * - `2000-03-15T05:20:10`: Without a trailing 'Z' symbol
 * - `2000-03-15T05:20:10.1234567`: Up to 7 digits in milliseconds field. Only first 3 are taken into account since JS does not allow fractional milliseconds
 * - `2000-03-15 05:20:10`: With a space instead of a 'T' separator for APIs returning a SQL date without reformatting
 *
 * For convenience and ease of use these other input types are also supported
 * via [toDate](https://date-fns.org/docs/toDate):
 *
 * - A `Date` instance will be cloned
 * - A `number` will be treated as a timestamp
 *
 * Any other input type or invalid date strings will return an `Invalid Date`.
 *
 * @param dateStr - A fully formed ISO8601 date string to convert
 *
 * @returns The parsed date in the local time zone
 */ 
function parseJSON(dateStr) {
    const parts = dateStr.match(/(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/);
    if (parts) // Group 8 matches the sign
    return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4] - (+parts[9] || 0) * (parts[8] == "-" ? -1 : 1), +parts[5] - (+parts[10] || 0) * (parts[8] == "-" ? -1 : 1), +parts[6], +((parts[7] || "0") + "00").substring(0, 3)));
    return new Date(NaN);
}

},{}],"aTT5c":[function(require,module,exports) {
"use strict";
exports.previousDay = previousDay;
var _index = require("6bcf4fe96e3a047");
var _index2 = require("b4986229d0d7b311");
/**
 * @name previousDay
 * @category Weekday Helpers
 * @summary When is the previous day of the week?
 *
 * @description
 * When is the previous day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to check
 * @param day - The day of the week
 *
 * @returns The date is the previous day of week
 *
 * @example
 * // When is the previous Monday before Mar, 20, 2020?
 * const result = previousDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 16 2020 00:00:00
 *
 * @example
 * // When is the previous Tuesday before Mar, 21, 2020?
 * const result = previousDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 17 2020 00:00:00
 */ function previousDay(date, day) {
    let delta = (0, _index.getDay)(date) - day;
    if (delta <= 0) delta += 7;
    return (0, _index2.subDays)(date, delta);
}

},{"6bcf4fe96e3a047":"esFEi","b4986229d0d7b311":"3dD7a"}],"gIu7S":[function(require,module,exports) {
"use strict";
exports.previousFriday = previousFriday;
var _index = require("5712eb87dec2ab5c");
/**
 * @name previousFriday
 * @category Weekday Helpers
 * @summary When is the previous Friday?
 *
 * @description
 * When is the previous Friday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Friday
 *
 * @example
 * // When is the previous Friday before Jun, 19, 2021?
 * const result = previousFriday(new Date(2021, 5, 19))
 * //=> Fri June 18 2021 00:00:00
 */ function previousFriday(date) {
    return (0, _index.previousDay)(date, 5);
}

},{"5712eb87dec2ab5c":"aTT5c"}],"kcslc":[function(require,module,exports) {
"use strict";
exports.previousMonday = previousMonday;
var _index = require("254280db49759fbc");
/**
 * @name previousMonday
 * @category Weekday Helpers
 * @summary When is the previous Monday?
 *
 * @description
 * When is the previous Monday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Monday
 *
 * @example
 * // When is the previous Monday before Jun, 18, 2021?
 * const result = previousMonday(new Date(2021, 5, 18))
 * //=> Mon June 14 2021 00:00:00
 */ function previousMonday(date) {
    return (0, _index.previousDay)(date, 1);
}

},{"254280db49759fbc":"aTT5c"}],"hsMzT":[function(require,module,exports) {
"use strict";
exports.previousSaturday = previousSaturday;
var _index = require("5e091e090aa006e5");
/**
 * @name previousSaturday
 * @category Weekday Helpers
 * @summary When is the previous Saturday?
 *
 * @description
 * When is the previous Saturday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Saturday
 *
 * @example
 * // When is the previous Saturday before Jun, 20, 2021?
 * const result = previousSaturday(new Date(2021, 5, 20))
 * //=> Sat June 19 2021 00:00:00
 */ function previousSaturday(date) {
    return (0, _index.previousDay)(date, 6);
}

},{"5e091e090aa006e5":"aTT5c"}],"cNh8t":[function(require,module,exports) {
"use strict";
exports.previousSunday = previousSunday;
var _index = require("753c79621f212dff");
/**
 * @name previousSunday
 * @category Weekday Helpers
 * @summary When is the previous Sunday?
 *
 * @description
 * When is the previous Sunday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Sunday
 *
 * @example
 * // When is the previous Sunday before Jun, 21, 2021?
 * const result = previousSunday(new Date(2021, 5, 21))
 * //=> Sun June 20 2021 00:00:00
 */ function previousSunday(date) {
    return (0, _index.previousDay)(date, 0);
}

},{"753c79621f212dff":"aTT5c"}],"9mDjN":[function(require,module,exports) {
"use strict";
exports.previousThursday = previousThursday;
var _index = require("42407c55b7bd4cf3");
/**
 * @name previousThursday
 * @category Weekday Helpers
 * @summary When is the previous Thursday?
 *
 * @description
 * When is the previous Thursday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Thursday
 *
 * @example
 * // When is the previous Thursday before Jun, 18, 2021?
 * const result = previousThursday(new Date(2021, 5, 18))
 * //=> Thu June 17 2021 00:00:00
 */ function previousThursday(date) {
    return (0, _index.previousDay)(date, 4);
}

},{"42407c55b7bd4cf3":"aTT5c"}],"h1oS7":[function(require,module,exports) {
"use strict";
exports.previousTuesday = previousTuesday;
var _index = require("888458f94f4d3ea4");
/**
 * @name previousTuesday
 * @category Weekday Helpers
 * @summary When is the previous Tuesday?
 *
 * @description
 * When is the previous Tuesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Tuesday
 *
 * @example
 * // When is the previous Tuesday before Jun, 18, 2021?
 * const result = previousTuesday(new Date(2021, 5, 18))
 * //=> Tue June 15 2021 00:00:00
 */ function previousTuesday(date) {
    return (0, _index.previousDay)(date, 2);
}

},{"888458f94f4d3ea4":"aTT5c"}],"f0xQR":[function(require,module,exports) {
"use strict";
exports.previousWednesday = previousWednesday;
var _index = require("266acb1a1ae85529");
/**
 * @name previousWednesday
 * @category Weekday Helpers
 * @summary When is the previous Wednesday?
 *
 * @description
 * When is the previous Wednesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to start counting from
 *
 * @returns The previous Wednesday
 *
 * @example
 * // When is the previous Wednesday before Jun, 18, 2021?
 * const result = previousWednesday(new Date(2021, 5, 18))
 * //=> Wed June 16 2021 00:00:00
 */ function previousWednesday(date) {
    return (0, _index.previousDay)(date, 3);
}

},{"266acb1a1ae85529":"aTT5c"}],"h2o9r":[function(require,module,exports) {
"use strict";
exports.quartersToMonths = quartersToMonths;
var _index = require("581e6077138d352b");
/**
 * @name quartersToMonths
 * @category Conversion Helpers
 * @summary Convert number of quarters to months.
 *
 * @description
 * Convert a number of quarters to a full number of months.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in months
 *
 * @example
 * // Convert 2 quarters to months
 * const result = quartersToMonths(2)
 * //=> 6
 */ function quartersToMonths(quarters) {
    return Math.floor(quarters * _index.monthsInQuarter);
}

},{"581e6077138d352b":"1vXXw"}],"62942":[function(require,module,exports) {
"use strict";
exports.quartersToYears = quartersToYears;
var _index = require("99a6c61d70a5ffad");
/**
 * @name quartersToYears
 * @category Conversion Helpers
 * @summary Convert number of quarters to years.
 *
 * @description
 * Convert a number of quarters to a full number of years.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in years
 *
 * @example
 * // Convert 8 quarters to years
 * const result = quartersToYears(8)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = quartersToYears(11)
 * //=> 2
 */ function quartersToYears(quarters) {
    const years = quarters / _index.quartersInYear;
    return Math.floor(years);
}

},{"99a6c61d70a5ffad":"1vXXw"}],"1YDXi":[function(require,module,exports) {
"use strict";
exports.roundToNearestMinutes = roundToNearestMinutes;
var _index = require("156e571ea44e5631");
var _index2 = require("5f4467c863d899fa");
var _index3 = require("7ecafedd8c00c003");
/**
 * The {@link roundToNearestMinutes} function options.
 */ /**
 * @name roundToNearestMinutes
 * @category Minute Helpers
 * @summary Rounds the given date to the nearest minute
 *
 * @description
 * Rounds the given date to the nearest minute (or number of minutes).
 * Rounds up when the given date is exactly between the nearest round minutes.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to round
 * @param options - An object with options.
 *
 * @returns The new date rounded to the closest minute
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34))
 * //=> Thu Jul 10 2014 12:13:00
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest quarter hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { nearestTo: 15 })
 * //=> Thu Jul 10 2014 12:15:00
 *
 * @example
 * // Floor (rounds down) 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'floor' })
 * //=> Thu Jul 10 2014 12:12:00
 *
 * @example
 * // Ceil (rounds up) 10 July 2014 12:12:34 to nearest half hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'ceil', nearestTo: 30 })
 * //=> Thu Jul 10 2014 12:30:00
 */ function roundToNearestMinutes(date, options) {
    const nearestTo = options?.nearestTo ?? 1;
    if (nearestTo < 1 || nearestTo > 30) return (0, _index2.constructFrom)(date, NaN);
    const _date = (0, _index3.toDate)(date);
    const fractionalSeconds = _date.getSeconds() / 60;
    const fractionalMilliseconds = _date.getMilliseconds() / 1000 / 60;
    const minutes = _date.getMinutes() + fractionalSeconds + fractionalMilliseconds;
    // Unlike the `differenceIn*` functions, the default rounding behavior is `round` and not 'trunc'
    const method = options?.roundingMethod ?? "round";
    const roundingMethod = (0, _index.getRoundingMethod)(method);
    const roundedMinutes = roundingMethod(minutes / nearestTo) * nearestTo;
    const result = (0, _index2.constructFrom)(date, _date);
    result.setMinutes(roundedMinutes, 0, 0);
    return result;
}

},{"156e571ea44e5631":"1ipL6","5f4467c863d899fa":"hNMdA","7ecafedd8c00c003":"actWA"}],"yIjPa":[function(require,module,exports) {
"use strict";
exports.secondsToHours = secondsToHours;
var _index = require("3fef9b731b720044");
/**
 * @name secondsToHours
 * @category Conversion Helpers
 * @summary Convert seconds to hours.
 *
 * @description
 * Convert a number of seconds to a full number of hours.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in hours
 *
 * @example
 * // Convert 7200 seconds into hours
 * const result = secondsToHours(7200)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToHours(7199)
 * //=> 1
 */ function secondsToHours(seconds) {
    const hours = seconds / _index.secondsInHour;
    return Math.floor(hours);
}

},{"3fef9b731b720044":"1vXXw"}],"60YWC":[function(require,module,exports) {
"use strict";
exports.secondsToMilliseconds = secondsToMilliseconds;
var _index = require("a1974d1c766dbebe");
/**
 * @name secondsToMilliseconds
 * @category Conversion Helpers
 * @summary Convert seconds to milliseconds.
 *
 * @description
 * Convert a number of seconds to a full number of milliseconds.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in milliseconds
 *
 * @example
 * // Convert 2 seconds into milliseconds
 * const result = secondsToMilliseconds(2)
 * //=> 2000
 */ function secondsToMilliseconds(seconds) {
    return seconds * _index.millisecondsInSecond;
}

},{"a1974d1c766dbebe":"1vXXw"}],"7wRiH":[function(require,module,exports) {
"use strict";
exports.secondsToMinutes = secondsToMinutes;
var _index = require("88b262a06d5f2130");
/**
 * @name secondsToMinutes
 * @category Conversion Helpers
 * @summary Convert seconds to minutes.
 *
 * @description
 * Convert a number of seconds to a full number of minutes.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in minutes
 *
 * @example
 * // Convert 120 seconds into minutes
 * const result = secondsToMinutes(120)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToMinutes(119)
 * //=> 1
 */ function secondsToMinutes(seconds) {
    const minutes = seconds / _index.secondsInMinute;
    return Math.floor(minutes);
}

},{"88b262a06d5f2130":"1vXXw"}],"4BYNm":[function(require,module,exports) {
"use strict";
exports.set = set;
var _index = require("8ebda6aa298e3dce");
var _index2 = require("3a1600af3eb7d0e3");
var _index3 = require("1d29904d7d38b6d3");
/**
 * @name set
 * @category Common Helpers
 * @summary Set date values to a given date.
 *
 * @description
 * Set date values to a given date.
 *
 * Sets time values to date from object `values`.
 * A value is not set if it is undefined or null or doesn't exist in `values`.
 *
 * Note about bundle size: `set` does not internally use `setX` functions from date-fns but instead opts
 * to use native `Date#setX` methods. If you use this function, you may not want to include the
 * other `setX` functions that date-fns provides if you are concerned about the bundle size.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param values - The date values to be set
 *
 * @returns The new date with options set
 *
 * @example
 * // Transform 1 September 2014 into 20 October 2015 in a single line:
 * const result = set(new Date(2014, 8, 20), { year: 2015, month: 9, date: 20 })
 * //=> Tue Oct 20 2015 00:00:00
 *
 * @example
 * // Set 12 PM to 1 September 2014 01:23:45 to 1 September 2014 12:00:00:
 * const result = set(new Date(2014, 8, 1, 1, 23, 45), { hours: 12 })
 * //=> Mon Sep 01 2014 12:23:45
 */ function set(date, values) {
    let _date = (0, _index3.toDate)(date);
    // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
    if (isNaN(+_date)) return (0, _index.constructFrom)(date, NaN);
    if (values.year != null) _date.setFullYear(values.year);
    if (values.month != null) _date = (0, _index2.setMonth)(_date, values.month);
    if (values.date != null) _date.setDate(values.date);
    if (values.hours != null) _date.setHours(values.hours);
    if (values.minutes != null) _date.setMinutes(values.minutes);
    if (values.seconds != null) _date.setSeconds(values.seconds);
    if (values.milliseconds != null) _date.setMilliseconds(values.milliseconds);
    return _date;
}

},{"8ebda6aa298e3dce":"hNMdA","3a1600af3eb7d0e3":"5S4Rm","1d29904d7d38b6d3":"actWA"}],"5S4Rm":[function(require,module,exports) {
"use strict";
exports.setMonth = setMonth;
var _index = require("389800ba113a4b05");
var _index2 = require("c6d3e16f0e9f2d5d");
var _index3 = require("3008df466d06f93a");
/**
 * @name setMonth
 * @category Month Helpers
 * @summary Set the month to the given date.
 *
 * @description
 * Set the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param month - The month of the new date
 *
 * @returns The new date with the month set
 *
 * @example
 * // Set February to 1 September 2014:
 * const result = setMonth(new Date(2014, 8, 1), 1)
 * //=> Sat Feb 01 2014 00:00:00
 */ function setMonth(date, month) {
    const _date = (0, _index3.toDate)(date);
    const year = _date.getFullYear();
    const day = _date.getDate();
    const dateWithDesiredMonth = (0, _index.constructFrom)(date, 0);
    dateWithDesiredMonth.setFullYear(year, month, 15);
    dateWithDesiredMonth.setHours(0, 0, 0, 0);
    const daysInMonth = (0, _index2.getDaysInMonth)(dateWithDesiredMonth);
    // Set the last day of the new month
    // if the original date was the last day of the longer month
    _date.setMonth(month, Math.min(day, daysInMonth));
    return _date;
}

},{"389800ba113a4b05":"hNMdA","c6d3e16f0e9f2d5d":"iS77p","3008df466d06f93a":"actWA"}],"detLY":[function(require,module,exports) {
"use strict";
exports.setDate = setDate;
var _index = require("7057dcd16ee8e373");
/**
 * @name setDate
 * @category Day Helpers
 * @summary Set the day of the month to the given date.
 *
 * @description
 * Set the day of the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param dayOfMonth - The day of the month of the new date
 *
 * @returns The new date with the day of the month set
 *
 * @example
 * // Set the 30th day of the month to 1 September 2014:
 * const result = setDate(new Date(2014, 8, 1), 30)
 * //=> Tue Sep 30 2014 00:00:00
 */ function setDate(date, dayOfMonth) {
    const _date = (0, _index.toDate)(date);
    _date.setDate(dayOfMonth);
    return _date;
}

},{"7057dcd16ee8e373":"actWA"}],"8KclM":[function(require,module,exports) {
"use strict";
exports.setDayOfYear = setDayOfYear;
var _index = require("c0941b4402ad59f2");
/**
 * @name setDayOfYear
 * @category Day Helpers
 * @summary Set the day of the year to the given date.
 *
 * @description
 * Set the day of the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param dayOfYear - The day of the year of the new date
 *
 * @returns The new date with the day of the year set
 *
 * @example
 * // Set the 2nd day of the year to 2 July 2014:
 * const result = setDayOfYear(new Date(2014, 6, 2), 2)
 * //=> Thu Jan 02 2014 00:00:00
 */ function setDayOfYear(date, dayOfYear) {
    const _date = (0, _index.toDate)(date);
    _date.setMonth(0);
    _date.setDate(dayOfYear);
    return _date;
}

},{"c0941b4402ad59f2":"actWA"}],"2QTST":[function(require,module,exports) {
"use strict";
exports.setDefaultOptions = setDefaultOptions;
var _index = require("62255328988484e4");
/**
 * @name setDefaultOptions
 * @category Common Helpers
 * @summary Set default options including locale.
 * @pure false
 *
 * @description
 * Sets the defaults for
 * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
 * arguments for all functions.
 *
 * @param options - An object with options
 *
 * @example
 * // Set global locale:
 * import { es } from 'date-fns/locale'
 * setDefaultOptions({ locale: es })
 * const result = format(new Date(2014, 8, 2), 'PPPP')
 * //=> 'martes, 2 de septiembre de 2014'
 *
 * @example
 * // Start of the week for 2 September 2014:
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Start of the week for 2 September 2014,
 * // when we set that week starts on Monday by default:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Mon Sep 01 2014 00:00:00
 *
 * @example
 * // Manually set options take priority over default options:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2), { weekStartsOn: 0 })
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Remove the option by setting it to `undefined`:
 * setDefaultOptions({ weekStartsOn: 1 })
 * setDefaultOptions({ weekStartsOn: undefined })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 */ function setDefaultOptions(options) {
    const result = {};
    const defaultOptions = (0, _index.getDefaultOptions)();
    for(const property in defaultOptions)if (Object.prototype.hasOwnProperty.call(defaultOptions, property)) // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
    result[property] = defaultOptions[property];
    for(const property in options)if (Object.prototype.hasOwnProperty.call(options, property)) {
        if (options[property] === undefined) // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        delete result[property];
        else // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
        result[property] = options[property];
    }
    (0, _index.setDefaultOptions)(result);
}

},{"62255328988484e4":"98fau"}],"a7APw":[function(require,module,exports) {
"use strict";
exports.setHours = setHours;
var _index = require("1d11a257f15355a4");
/**
 * @name setHours
 * @category Hour Helpers
 * @summary Set the hours to the given date.
 *
 * @description
 * Set the hours to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param hours - The hours of the new date
 *
 * @returns The new date with the hours set
 *
 * @example
 * // Set 4 hours to 1 September 2014 11:30:00:
 * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)
 * //=> Mon Sep 01 2014 04:30:00
 */ function setHours(date, hours) {
    const _date = (0, _index.toDate)(date);
    _date.setHours(hours);
    return _date;
}

},{"1d11a257f15355a4":"actWA"}],"1EFb6":[function(require,module,exports) {
"use strict";
exports.setMilliseconds = setMilliseconds;
var _index = require("b10f979f8cdab20a");
/**
 * @name setMilliseconds
 * @category Millisecond Helpers
 * @summary Set the milliseconds to the given date.
 *
 * @description
 * Set the milliseconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param milliseconds - The milliseconds of the new date
 *
 * @returns The new date with the milliseconds set
 *
 * @example
 * // Set 300 milliseconds to 1 September 2014 11:30:40.500:
 * const result = setMilliseconds(new Date(2014, 8, 1, 11, 30, 40, 500), 300)
 * //=> Mon Sep 01 2014 11:30:40.300
 */ function setMilliseconds(date, milliseconds) {
    const _date = (0, _index.toDate)(date);
    _date.setMilliseconds(milliseconds);
    return _date;
}

},{"b10f979f8cdab20a":"actWA"}],"7JQAX":[function(require,module,exports) {
"use strict";
exports.setMinutes = setMinutes;
var _index = require("1f70a54677cb46ac");
/**
 * @name setMinutes
 * @category Minute Helpers
 * @summary Set the minutes to the given date.
 *
 * @description
 * Set the minutes to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param minutes - The minutes of the new date
 *
 * @returns The new date with the minutes set
 *
 * @example
 * // Set 45 minutes to 1 September 2014 11:30:40:
 * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:45:40
 */ function setMinutes(date, minutes) {
    const _date = (0, _index.toDate)(date);
    _date.setMinutes(minutes);
    return _date;
}

},{"1f70a54677cb46ac":"actWA"}],"1U8F7":[function(require,module,exports) {
"use strict";
exports.setQuarter = setQuarter;
var _index = require("f4776e1074765e6a");
var _index2 = require("f757c8c551ce95c6");
/**
 * @name setQuarter
 * @category Quarter Helpers
 * @summary Set the year quarter to the given date.
 *
 * @description
 * Set the year quarter to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param quarter - The quarter of the new date
 *
 * @returns The new date with the quarter set
 *
 * @example
 * // Set the 2nd quarter to 2 July 2014:
 * const result = setQuarter(new Date(2014, 6, 2), 2)
 * //=> Wed Apr 02 2014 00:00:00
 */ function setQuarter(date, quarter) {
    const _date = (0, _index2.toDate)(date);
    const oldQuarter = Math.floor(_date.getMonth() / 3) + 1;
    const diff = quarter - oldQuarter;
    return (0, _index.setMonth)(_date, _date.getMonth() + diff * 3);
}

},{"f4776e1074765e6a":"5S4Rm","f757c8c551ce95c6":"actWA"}],"E9tFo":[function(require,module,exports) {
"use strict";
exports.setSeconds = setSeconds;
var _index = require("d2223da5fd81400f");
/**
 * @name setSeconds
 * @category Second Helpers
 * @summary Set the seconds to the given date.
 *
 * @description
 * Set the seconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param seconds - The seconds of the new date
 *
 * @returns The new date with the seconds set
 *
 * @example
 * // Set 45 seconds to 1 September 2014 11:30:40:
 * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:30:45
 */ function setSeconds(date, seconds) {
    const _date = (0, _index.toDate)(date);
    _date.setSeconds(seconds);
    return _date;
}

},{"d2223da5fd81400f":"actWA"}],"kcJtI":[function(require,module,exports) {
"use strict";
exports.setWeekYear = setWeekYear;
var _index = require("892a4f6cbe4a4851");
var _index2 = require("a4760182880db22");
var _index3 = require("68ff92802fcb77db");
var _index4 = require("7450ee1debfdb61");
var _index5 = require("78c425fb7620dd8");
/**
 * The {@link setWeekYear} function options.
 */ /**
 * @name setWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Set the local week-numbering year to the given date.
 *
 * @description
 * Set the local week-numbering year to the given date,
 * saving the week number and the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param weekYear - The local week-numbering year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week-numbering year set
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010 with default options:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004)
 * //=> Sat Jan 03 2004 00:00:00
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010,
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sat Jan 01 2005 00:00:00
 */ function setWeekYear(date, weekYear, options) {
    const defaultOptions = (0, _index5.getDefaultOptions)();
    const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions.firstWeekContainsDate ?? defaultOptions.locale?.options?.firstWeekContainsDate ?? 1;
    let _date = (0, _index4.toDate)(date);
    const diff = (0, _index2.differenceInCalendarDays)(_date, (0, _index3.startOfWeekYear)(_date, options));
    const firstWeek = (0, _index.constructFrom)(date, 0);
    firstWeek.setFullYear(weekYear, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    _date = (0, _index3.startOfWeekYear)(firstWeek, options);
    _date.setDate(_date.getDate() + diff);
    return _date;
}

},{"892a4f6cbe4a4851":"hNMdA","a4760182880db22":"dvya7","68ff92802fcb77db":"diTjA","7450ee1debfdb61":"actWA","78c425fb7620dd8":"98fau"}],"4hEJG":[function(require,module,exports) {
"use strict";
exports.setYear = setYear;
var _index = require("7614d9b80a22fd43");
var _index2 = require("6c1bb22d849e1125");
/**
 * @name setYear
 * @category Year Helpers
 * @summary Set the year to the given date.
 *
 * @description
 * Set the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param year - The year of the new date
 *
 * @returns The new date with the year set
 *
 * @example
 * // Set year 2013 to 1 September 2014:
 * const result = setYear(new Date(2014, 8, 1), 2013)
 * //=> Sun Sep 01 2013 00:00:00
 */ function setYear(date, year) {
    const _date = (0, _index2.toDate)(date);
    // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
    if (isNaN(+_date)) return (0, _index.constructFrom)(date, NaN);
    _date.setFullYear(year);
    return _date;
}

},{"7614d9b80a22fd43":"hNMdA","6c1bb22d849e1125":"actWA"}],"lmg97":[function(require,module,exports) {
"use strict";
exports.startOfDecade = startOfDecade;
var _index = require("510fc86ca3ee446c");
/**
 * @name startOfDecade
 * @category Decade Helpers
 * @summary Return the start of a decade for the given date.
 *
 * @description
 * Return the start of a decade for the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The original date
 *
 * @returns The start of a decade
 *
 * @example
 * // The start of a decade for 21 October 2015 00:00:00:
 * const result = startOfDecade(new Date(2015, 9, 21, 00, 00, 00))
 * //=> Jan 01 2010 00:00:00
 */ function startOfDecade(date) {
    const _date = (0, _index.toDate)(date);
    const year = _date.getFullYear();
    const decade = Math.floor(year / 10) * 10;
    _date.setFullYear(decade, 0, 1);
    _date.setHours(0, 0, 0, 0);
    return _date;
}

},{"510fc86ca3ee446c":"actWA"}],"cMsqy":[function(require,module,exports) {
"use strict";
exports.startOfToday = startOfToday;
var _index = require("4ec5e387631c3390");
/**
 * @name startOfToday
 * @category Day Helpers
 * @summary Return the start of today.
 * @pure false
 *
 * @description
 * Return the start of today.
 *
 * @returns The start of today
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfToday()
 * //=> Mon Oct 6 2014 00:00:00
 */ function startOfToday() {
    return (0, _index.startOfDay)(Date.now());
}

},{"4ec5e387631c3390":"iJAa5"}],"04Svu":[function(require,module,exports) {
"use strict";
exports.startOfTomorrow = startOfTomorrow; /**
 * @name startOfTomorrow
 * @category Day Helpers
 * @summary Return the start of tomorrow.
 * @pure false
 *
 * @description
 * Return the start of tomorrow.
 *
 * @returns The start of tomorrow
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfTomorrow()
 * //=> Tue Oct 7 2014 00:00:00
 */ 
function startOfTomorrow() {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth();
    const day = now.getDate();
    const date = new Date(0);
    date.setFullYear(year, month, day + 1);
    date.setHours(0, 0, 0, 0);
    return date;
}

},{}],"dAxue":[function(require,module,exports) {
"use strict";
exports.startOfYesterday = startOfYesterday; /**
 * @name startOfYesterday
 * @category Day Helpers
 * @summary Return the start of yesterday.
 * @pure false
 *
 * @description
 * Return the start of yesterday.
 *
 * @returns The start of yesterday
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfYesterday()
 * //=> Sun Oct 5 2014 00:00:00
 */ 
function startOfYesterday() {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth();
    const day = now.getDate();
    const date = new Date(0);
    date.setFullYear(year, month, day - 1);
    date.setHours(0, 0, 0, 0);
    return date;
}

},{}],"bFznd":[function(require,module,exports) {
"use strict";
exports.sub = sub;
var _index = require("91c2f90d56fdcf39");
var _index2 = require("e9fb52a14c73dacb");
var _index3 = require("ebf995b47bb3f8a4");
/**
 * @name sub
 * @category Common Helpers
 * @summary Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @description
 * Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be subtracted
 *
 * | Key     | Description                        |
 * |---------|------------------------------------|
 * | years   | Amount of years to be subtracted   |
 * | months  | Amount of months to be subtracted  |
 * | weeks   | Amount of weeks to be subtracted   |
 * | days    | Amount of days to be subtracted    |
 * | hours   | Amount of hours to be subtracted   |
 * | minutes | Amount of minutes to be subtracted |
 * | seconds | Amount of seconds to be subtracted |
 *
 * All values default to 0
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract the following duration from 15 June 2017 15:29:20
 * const result = sub(new Date(2017, 5, 15, 15, 29, 20), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30
 * })
 * //=> Mon Sep 1 2014 10:19:50
 */ function sub(date, duration) {
    const { years = 0, months = 0, weeks = 0, days = 0, hours = 0, minutes = 0, seconds = 0 } = duration;
    // Subtract years and months
    const dateWithoutMonths = (0, _index2.subMonths)(date, months + years * 12);
    // Subtract weeks and days
    const dateWithoutDays = (0, _index.subDays)(dateWithoutMonths, days + weeks * 7);
    // Subtract hours, minutes and seconds
    const minutestoSub = minutes + hours * 60;
    const secondstoSub = seconds + minutestoSub * 60;
    const mstoSub = secondstoSub * 1000;
    const finalDate = (0, _index3.constructFrom)(date, dateWithoutDays.getTime() - mstoSub);
    return finalDate;
}

},{"91c2f90d56fdcf39":"3dD7a","e9fb52a14c73dacb":"bQpwZ","ebf995b47bb3f8a4":"hNMdA"}],"bQpwZ":[function(require,module,exports) {
"use strict";
exports.subMonths = subMonths;
var _index = require("fbb42da1293ae3b8");
/**
 * @name subMonths
 * @category Month Helpers
 * @summary Subtract the specified number of months from the given date.
 *
 * @description
 * Subtract the specified number of months from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of months to be subtracted.
 *
 * @returns The new date with the months subtracted
 *
 * @example
 * // Subtract 5 months from 1 February 2015:
 * const result = subMonths(new Date(2015, 1, 1), 5)
 * //=> Mon Sep 01 2014 00:00:00
 */ function subMonths(date, amount) {
    return (0, _index.addMonths)(date, -amount);
}

},{"fbb42da1293ae3b8":"alxIr"}],"7oOvu":[function(require,module,exports) {
"use strict";
exports.subBusinessDays = subBusinessDays;
var _index = require("8df6a7f983f79fd5");
/**
 * @name subBusinessDays
 * @category Day Helpers
 * @summary Substract the specified number of business days (mon - fri) to the given date.
 *
 * @description
 * Substract the specified number of business days (mon - fri) to the given date, ignoring weekends.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of business days to be subtracted.
 *
 * @returns The new date with the business days subtracted
 *
 * @example
 * // Substract 10 business days from 1 September 2014:
 * const result = subBusinessDays(new Date(2014, 8, 1), 10)
 * //=> Mon Aug 18 2014 00:00:00 (skipped weekend days)
 */ function subBusinessDays(date, amount) {
    return (0, _index.addBusinessDays)(date, -amount);
}

},{"8df6a7f983f79fd5":"475kI"}],"jVGj5":[function(require,module,exports) {
"use strict";
exports.subHours = subHours;
var _index = require("ebad1bf9dc571fa6");
/**
 * @name subHours
 * @category Hour Helpers
 * @summary Subtract the specified number of hours from the given date.
 *
 * @description
 * Subtract the specified number of hours from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of hours to be subtracted.
 *
 * @returns The new date with the hours subtracted
 *
 * @example
 * // Subtract 2 hours from 11 July 2014 01:00:00:
 * const result = subHours(new Date(2014, 6, 11, 1, 0), 2)
 * //=> Thu Jul 10 2014 23:00:00
 */ function subHours(date, amount) {
    return (0, _index.addHours)(date, -amount);
}

},{"ebad1bf9dc571fa6":"hzidA"}],"22JNI":[function(require,module,exports) {
"use strict";
exports.subMilliseconds = subMilliseconds;
var _index = require("7c01aad93387710b");
/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of milliseconds to be subtracted.
 *
 * @returns The new date with the milliseconds subtracted
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */ function subMilliseconds(date, amount) {
    return (0, _index.addMilliseconds)(date, -amount);
}

},{"7c01aad93387710b":"03zTk"}],"jPKrE":[function(require,module,exports) {
"use strict";
exports.subMinutes = subMinutes;
var _index = require("fd037b7c11707977");
/**
 * @name subMinutes
 * @category Minute Helpers
 * @summary Subtract the specified number of minutes from the given date.
 *
 * @description
 * Subtract the specified number of minutes from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of minutes to be subtracted.
 *
 * @returns The new date with the minutes subtracted
 *
 * @example
 * // Subtract 30 minutes from 10 July 2014 12:00:00:
 * const result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 11:30:00
 */ function subMinutes(date, amount) {
    return (0, _index.addMinutes)(date, -amount);
}

},{"fd037b7c11707977":"7jsut"}],"7ieGr":[function(require,module,exports) {
"use strict";
exports.subQuarters = subQuarters;
var _index = require("86570987ed766639");
/**
 * @name subQuarters
 * @category Quarter Helpers
 * @summary Subtract the specified number of year quarters from the given date.
 *
 * @description
 * Subtract the specified number of year quarters from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of quarters to be subtracted.
 *
 * @returns The new date with the quarters subtracted
 *
 * @example
 * // Subtract 3 quarters from 1 September 2014:
 * const result = subQuarters(new Date(2014, 8, 1), 3)
 * //=> Sun Dec 01 2013 00:00:00
 */ function subQuarters(date, amount) {
    return (0, _index.addQuarters)(date, -amount);
}

},{"86570987ed766639":"jW81o"}],"cvB1W":[function(require,module,exports) {
"use strict";
exports.subSeconds = subSeconds;
var _index = require("2550c81d2c438461");
/**
 * @name subSeconds
 * @category Second Helpers
 * @summary Subtract the specified number of seconds from the given date.
 *
 * @description
 * Subtract the specified number of seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of seconds to be subtracted.
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract 30 seconds from 10 July 2014 12:45:00:
 * const result = subSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:44:30
 */ function subSeconds(date, amount) {
    return (0, _index.addSeconds)(date, -amount);
}

},{"2550c81d2c438461":"1jCRu"}],"20wf8":[function(require,module,exports) {
"use strict";
exports.subWeeks = subWeeks;
var _index = require("cd59f83469fafb63");
/**
 * @name subWeeks
 * @category Week Helpers
 * @summary Subtract the specified number of weeks from the given date.
 *
 * @description
 * Subtract the specified number of weeks from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of weeks to be subtracted.
 *
 * @returns The new date with the weeks subtracted
 *
 * @example
 * // Subtract 4 weeks from 1 September 2014:
 * const result = subWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Aug 04 2014 00:00:00
 */ function subWeeks(date, amount) {
    return (0, _index.addWeeks)(date, -amount);
}

},{"cd59f83469fafb63":"6sRN6"}],"jmZa1":[function(require,module,exports) {
"use strict";
exports.subYears = subYears;
var _index = require("324b48dd502ccac0");
/**
 * @name subYears
 * @category Year Helpers
 * @summary Subtract the specified number of years from the given date.
 *
 * @description
 * Subtract the specified number of years from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 *
 * @param date - The date to be changed
 * @param amount - The amount of years to be subtracted.
 *
 * @returns The new date with the years subtracted
 *
 * @example
 * // Subtract 5 years from 1 September 2014:
 * const result = subYears(new Date(2014, 8, 1), 5)
 * //=> Tue Sep 01 2009 00:00:00
 */ function subYears(date, amount) {
    return (0, _index.addYears)(date, -amount);
}

},{"324b48dd502ccac0":"3IQD4"}],"6D2CR":[function(require,module,exports) {
"use strict";
exports.weeksToDays = weeksToDays;
var _index = require("359629129941baca");
/**
 * @name weeksToDays
 * @category Conversion Helpers
 * @summary Convert weeks to days.
 *
 * @description
 * Convert a number of weeks to a full number of days.
 *
 * @param weeks - The number of weeks to be converted
 *
 * @returns The number of weeks converted in days
 *
 * @example
 * // Convert 2 weeks into days
 * const result = weeksToDays(2)
 * //=> 14
 */ function weeksToDays(weeks) {
    return Math.floor(weeks * _index.daysInWeek);
}

},{"359629129941baca":"1vXXw"}],"gWLQa":[function(require,module,exports) {
"use strict";
exports.yearsToDays = yearsToDays;
var _index = require("432a3015152e66ed");
/**
 * @name yearsToDays
 * @category Conversion Helpers
 * @summary Convert years to days.
 *
 * @description
 * Convert a number of years to a full number of days.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in days
 *
 * @example
 * // Convert 2 years into days
 * const result = yearsToDays(2)
 * //=> 24
 */ function yearsToDays(years) {
    return Math.floor(years * _index.daysInYear);
}

},{"432a3015152e66ed":"1vXXw"}],"dD3ep":[function(require,module,exports) {
"use strict";
exports.yearsToMonths = yearsToMonths;
var _index = require("483a1f1b446e7a1c");
/**
 * @name yearsToMonths
 * @category Conversion Helpers
 * @summary Convert years to months.
 *
 * @description
 * Convert a number of years to a full number of months.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in months
 *
 * @example
 * // Convert 2 years into months
 * const result = yearsToMonths(2)
 * //=> 24
 */ function yearsToMonths(years) {
    return Math.floor(years * _index.monthsInYear);
}

},{"483a1f1b446e7a1c":"1vXXw"}],"di2PR":[function(require,module,exports) {
"use strict";
exports.yearsToQuarters = yearsToQuarters;
var _index = require("387b0aecfe84b867");
/**
 * @name yearsToQuarters
 * @category Conversion Helpers
 * @summary Convert years to quarters.
 *
 * @description
 * Convert a number of years to a full number of quarters.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in quarters
 *
 * @example
 * // Convert 2 years to quarters
 * const result = yearsToQuarters(2)
 * //=> 8
 */ function yearsToQuarters(years) {
    return Math.floor(years * _index.quartersInYear);
}

},{"387b0aecfe84b867":"1vXXw"}],"iKhKr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _twoJs = require("./two.js");
var _twoJsDefault = parcelHelpers.interopDefault(_twoJs);
var _pluginJs = require("./3-three/adjectives/plugin.js");
var _pluginJsDefault = parcelHelpers.interopDefault(_pluginJs);
var _pluginJs1 = require("./3-three/adverbs/plugin.js");
var _pluginJsDefault1 = parcelHelpers.interopDefault(_pluginJs1);
var _pluginJs2 = require("./3-three/chunker/plugin.js");
var _pluginJsDefault2 = parcelHelpers.interopDefault(_pluginJs2);
var _pluginJs3 = require("./3-three/misc/plugin.js");
var _pluginJsDefault3 = parcelHelpers.interopDefault(_pluginJs3);
var _pluginJs4 = require("./3-three/normalize/plugin.js");
var _pluginJsDefault4 = parcelHelpers.interopDefault(_pluginJs4);
var _pluginJs5 = require("./3-three/nouns/plugin.js");
var _pluginJsDefault5 = parcelHelpers.interopDefault(_pluginJs5);
var _pluginJs6 = require("./3-three/numbers/plugin.js");
var _pluginJsDefault6 = parcelHelpers.interopDefault(_pluginJs6);
var _pluginJs7 = require("./3-three/redact/plugin.js");
var _pluginJsDefault7 = parcelHelpers.interopDefault(_pluginJs7);
var _pluginJs8 = require("./3-three/sentences/plugin.js");
var _pluginJsDefault8 = parcelHelpers.interopDefault(_pluginJs8);
var _pluginJs9 = require("./3-three/topics/plugin.js");
var _pluginJsDefault9 = parcelHelpers.interopDefault(_pluginJs9);
var _pluginJs10 = require("./3-three/verbs/plugin.js");
var _pluginJsDefault10 = parcelHelpers.interopDefault(_pluginJs10);
var _pluginJs11 = require("./3-three/coreference/plugin.js");
var _pluginJsDefault11 = parcelHelpers.interopDefault(_pluginJs11);
(0, _twoJsDefault.default).plugin((0, _pluginJsDefault.default)) //
;
(0, _twoJsDefault.default).plugin((0, _pluginJsDefault1.default)) //
;
(0, _twoJsDefault.default).plugin((0, _pluginJsDefault2.default)) //
;
(0, _twoJsDefault.default).plugin((0, _pluginJsDefault11.default));
(0, _twoJsDefault.default).plugin((0, _pluginJsDefault3.default)) //
;
(0, _twoJsDefault.default).plugin((0, _pluginJsDefault4.default)) //
;
(0, _twoJsDefault.default).plugin((0, _pluginJsDefault5.default)) //
;
(0, _twoJsDefault.default).plugin((0, _pluginJsDefault6.default)) //
;
(0, _twoJsDefault.default).plugin((0, _pluginJsDefault7.default)) //
;
(0, _twoJsDefault.default).plugin((0, _pluginJsDefault8.default)) //
;
(0, _twoJsDefault.default).plugin((0, _pluginJsDefault9.default)) //
;
(0, _twoJsDefault.default).plugin((0, _pluginJsDefault10.default)) //
;
exports.default = (0, _twoJsDefault.default);

},{"./two.js":"9WEGm","./3-three/adjectives/plugin.js":"74uG7","./3-three/adverbs/plugin.js":"8dS3E","./3-three/chunker/plugin.js":"hnmzV","./3-three/misc/plugin.js":"4VSwx","./3-three/normalize/plugin.js":"ibCzb","./3-three/nouns/plugin.js":"cii9I","./3-three/numbers/plugin.js":"7MUiZ","./3-three/redact/plugin.js":"4memP","./3-three/sentences/plugin.js":"5hkub","./3-three/topics/plugin.js":"b19hu","./3-three/verbs/plugin.js":"4nIaT","./3-three/coreference/plugin.js":"jOABE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9WEGm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _oneJs = require("./one.js");
var _oneJsDefault = parcelHelpers.interopDefault(_oneJs);
var _pluginJs = require("./2-two/preTagger/plugin.js");
var _pluginJsDefault = parcelHelpers.interopDefault(_pluginJs);
var _pluginJs1 = require("./2-two/contraction-two/plugin.js");
var _pluginJsDefault1 = parcelHelpers.interopDefault(_pluginJs1);
var _pluginJs2 = require("./2-two/postTagger/plugin.js");
var _pluginJsDefault2 = parcelHelpers.interopDefault(_pluginJs2);
var _pluginJs3 = require("./2-two/lazy/plugin.js");
var _pluginJsDefault3 = parcelHelpers.interopDefault(_pluginJs3);
var _pluginJs4 = require("./2-two/swap/plugin.js");
var _pluginJsDefault4 = parcelHelpers.interopDefault(_pluginJs4);
(0, _oneJsDefault.default).plugin((0, _pluginJsDefault.default)) //~103kb
;
(0, _oneJsDefault.default).plugin((0, _pluginJsDefault1.default)) //
;
(0, _oneJsDefault.default).plugin((0, _pluginJsDefault2.default)) //~33kb
;
(0, _oneJsDefault.default).plugin((0, _pluginJsDefault3.default)) //
;
(0, _oneJsDefault.default).plugin((0, _pluginJsDefault4.default)) //
;
exports.default = (0, _oneJsDefault.default);

},{"./one.js":"j8939","./2-two/preTagger/plugin.js":"kITyy","./2-two/contraction-two/plugin.js":"dOxY6","./2-two/postTagger/plugin.js":"9nqPx","./2-two/lazy/plugin.js":"4qwqK","./2-two/swap/plugin.js":"4m1UV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j8939":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nlpJs = require("./nlp.js"); // 5kb
var _nlpJsDefault = parcelHelpers.interopDefault(_nlpJs);
var _pluginJs = require("./1-one/cache/plugin.js");
var _pluginJsDefault = parcelHelpers.interopDefault(_pluginJs);
var _pluginJs1 = require("./1-one/change/plugin.js");
var _pluginJsDefault1 = parcelHelpers.interopDefault(_pluginJs1);
var _pluginJs2 = require("./1-one/contraction-one/plugin.js");
var _pluginJsDefault2 = parcelHelpers.interopDefault(_pluginJs2);
var _pluginJs3 = require("./1-one/freeze/plugin.js");
var _pluginJsDefault3 = parcelHelpers.interopDefault(_pluginJs3);
var _pluginJs4 = require("./1-one/lexicon/plugin.js");
var _pluginJsDefault4 = parcelHelpers.interopDefault(_pluginJs4);
var _pluginJs5 = require("./1-one/lookup/plugin.js");
var _pluginJsDefault5 = parcelHelpers.interopDefault(_pluginJs5);
var _pluginJs6 = require("./1-one/match/plugin.js");
var _pluginJsDefault6 = parcelHelpers.interopDefault(_pluginJs6);
var _pluginJs7 = require("./1-one/output/plugin.js");
var _pluginJsDefault7 = parcelHelpers.interopDefault(_pluginJs7);
var _pluginJs8 = require("./1-one/pointers/plugin.js");
var _pluginJsDefault8 = parcelHelpers.interopDefault(_pluginJs8);
var _pluginJs9 = require("./1-one/sweep/plugin.js");
var _pluginJsDefault9 = parcelHelpers.interopDefault(_pluginJs9);
var _pluginJs10 = require("./1-one/tag/plugin.js");
var _pluginJsDefault10 = parcelHelpers.interopDefault(_pluginJs10);
var _pluginJs11 = require("./1-one/tokenize/plugin.js");
var _pluginJsDefault11 = parcelHelpers.interopDefault(_pluginJs11);
var _pluginJs12 = require("./1-one/typeahead/plugin.js");
var _pluginJsDefault12 = parcelHelpers.interopDefault(_pluginJs12);
// order here matters
(0, _nlpJsDefault.default).extend((0, _pluginJsDefault1.default)) //0kb
;
(0, _nlpJsDefault.default).extend((0, _pluginJsDefault7.default)) //0kb
;
(0, _nlpJsDefault.default).extend((0, _pluginJsDefault6.default)) //10kb
;
(0, _nlpJsDefault.default).extend((0, _pluginJsDefault8.default)) //2kb
;
(0, _nlpJsDefault.default).extend((0, _pluginJsDefault10.default)) //2kb
;
(0, _nlpJsDefault.default).plugin((0, _pluginJsDefault2.default)) //~6kb
;
(0, _nlpJsDefault.default).extend((0, _pluginJsDefault3.default)) //
;
(0, _nlpJsDefault.default).extend((0, _pluginJsDefault11.default)) //7kb
;
(0, _nlpJsDefault.default).plugin((0, _pluginJsDefault.default)) //~1kb
;
(0, _nlpJsDefault.default).extend((0, _pluginJsDefault5.default)) //7kb
;
(0, _nlpJsDefault.default).extend((0, _pluginJsDefault12.default)) //1kb
;
(0, _nlpJsDefault.default).extend((0, _pluginJsDefault4.default)) //1kb
;
(0, _nlpJsDefault.default).extend((0, _pluginJsDefault9.default)) //1kb
;
exports.default = (0, _nlpJsDefault.default // 40kb
);

},{"./nlp.js":"g5MgY","./1-one/cache/plugin.js":"b7gvB","./1-one/change/plugin.js":"84pjy","./1-one/contraction-one/plugin.js":"bbZda","./1-one/freeze/plugin.js":"9kMQI","./1-one/lexicon/plugin.js":"4HcRQ","./1-one/lookup/plugin.js":"fXsy1","./1-one/match/plugin.js":"4pcOC","./1-one/output/plugin.js":"eyYam","./1-one/pointers/plugin.js":"jdjW6","./1-one/sweep/plugin.js":"7Y5TO","./1-one/tag/plugin.js":"46q0n","./1-one/tokenize/plugin.js":"2ixvh","./1-one/typeahead/plugin.js":"9AItl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g5MgY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _viewJs = require("./API/View.js");
var _viewJsDefault = parcelHelpers.interopDefault(_viewJs);
var _worldJs = require("./API/world.js");
var _worldJsDefault = parcelHelpers.interopDefault(_worldJs);
var _versionJs = require("./_version.js");
var _versionJsDefault = parcelHelpers.interopDefault(_versionJs);
var _extendJs = require("./API/extend.js");
var _extendJsDefault = parcelHelpers.interopDefault(_extendJs);
var _libJs = require("./API/_lib.js");
var _inputsJs = require("./API/inputs.js");
var _inputsJsDefault = parcelHelpers.interopDefault(_inputsJs);
let world = Object.assign({}, (0, _worldJsDefault.default));
const nlp = function(input, lex) {
    if (lex) nlp.addWords(lex);
    let doc = (0, _inputsJsDefault.default)(input, (0, _viewJsDefault.default), world);
    if (input) doc.compute(world.hooks);
    return doc;
};
Object.defineProperty(nlp, "_world", {
    value: world,
    writable: true
});
/** don't run the POS-tagger */ nlp.tokenize = function(input, lex) {
    const { compute } = this._world;
    // add user-given words to lexicon
    if (lex) nlp.addWords(lex);
    // run the tokenizer
    let doc = (0, _inputsJsDefault.default)(input, (0, _viewJsDefault.default), world);
    // give contractions a shot, at least
    if (compute.contractions) doc.compute([
        "alias",
        "normal",
        "machine",
        "contractions"
    ]) //run it if we've got it
    ;
    return doc;
};
/** extend compromise functionality */ nlp.plugin = function(plugin) {
    (0, _extendJsDefault.default)(plugin, this._world, (0, _viewJsDefault.default), this);
    return this;
};
nlp.extend = nlp.plugin;
/** reach-into compromise internals */ nlp.world = function() {
    return this._world;
};
nlp.model = function() {
    return this._world.model;
};
nlp.methods = function() {
    return this._world.methods;
};
nlp.hooks = function() {
    return this._world.hooks;
};
/** log the decision-making to console */ nlp.verbose = (0, _libJs.verbose);
/** current library release version */ nlp.version = (0, _versionJsDefault.default);
exports.default = nlp;

},{"./API/View.js":"dQQxc","./API/world.js":"1tb8y","./_version.js":"hrnxK","./API/extend.js":"6QZJY","./API/_lib.js":"ekp3G","./API/inputs.js":"gv7NL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dQQxc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _worldJs = require("./world.js");
var _worldJsDefault = parcelHelpers.interopDefault(_worldJs);
var _indexJs = require("./methods/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
class View {
    constructor(document, pointer, groups = {}){
        // invisible props
        [
            [
                "document",
                document
            ],
            [
                "world",
                (0, _worldJsDefault.default)
            ],
            [
                "_groups",
                groups
            ],
            [
                "_cache",
                null
            ],
            [
                "viewType",
                "View"
            ]
        ].forEach((a)=>{
            Object.defineProperty(this, a[0], {
                value: a[1],
                writable: true
            });
        });
        this.ptrs = pointer;
    }
    /* getters:  */ get docs() {
        let docs = this.document;
        if (this.ptrs) docs = (0, _worldJsDefault.default).methods.one.getDoc(this.ptrs, this.document);
        return docs;
    }
    get pointer() {
        return this.ptrs;
    }
    get methods() {
        return this.world.methods;
    }
    get model() {
        return this.world.model;
    }
    get hooks() {
        return this.world.hooks;
    }
    get isView() {
        return true //this comes in handy sometimes
        ;
    }
    // is the view not-empty?
    get found() {
        return this.docs.length > 0;
    }
    // how many matches we have
    get length() {
        return this.docs.length;
    }
    // return a more-hackable pointer
    get fullPointer() {
        let { docs, ptrs, document } = this;
        // compute a proper pointer, from docs
        let pointers = ptrs || docs.map((_d, n)=>[
                n
            ]);
        // do we need to repair it, first?
        return pointers.map((a)=>{
            let [n, start, end, id, endId] = a;
            start = start || 0;
            end = end || (document[n] || []).length;
            //add frozen id, for good-measure
            if (document[n] && document[n][start]) {
                id = id || document[n][start].id;
                if (document[n][end - 1]) endId = endId || document[n][end - 1].id;
            }
            return [
                n,
                start,
                end,
                id,
                endId
            ];
        });
    }
    // create a new View, from this one
    update(pointer) {
        let m = new View(this.document, pointer);
        // send the cache down, too?
        if (this._cache && pointer && pointer.length > 0) {
            // only keep cache if it's a full-sentence
            let cache = [];
            pointer.forEach((ptr, i)=>{
                let [n, start, end] = ptr;
                if (ptr.length === 1) cache[i] = this._cache[n];
                else if (start === 0 && this.document[n].length === end) cache[i] = this._cache[n];
            });
            if (cache.length > 0) m._cache = cache;
        }
        m.world = this.world;
        return m;
    }
    // create a new View, from this one
    toView(pointer) {
        return new View(this.document, pointer || this.pointer);
    }
    fromText(input) {
        const { methods } = this;
        //assume ./01-tokenize is installed
        let document = methods.one.tokenize.fromString(input, this.world);
        let doc = new View(document);
        doc.world = this.world;
        doc.compute([
            "normal",
            "lexicon"
        ]);
        if (this.world.compute.preTagger) doc.compute("preTagger");
        return doc;
    }
    clone() {
        // clone the whole document
        let document = this.document.slice(0) //node 17: structuredClone(document);
        ;
        document = document.map((terms)=>{
            return terms.map((term)=>{
                term = Object.assign({}, term);
                term.tags = new Set(term.tags);
                return term;
            });
        });
        // clone only sub-document ?
        let m = this.update(this.pointer);
        m.document = document;
        m._cache = this._cache //clone this too?
        ;
        return m;
    }
}
Object.assign(View.prototype, (0, _indexJsDefault.default));
exports.default = View;

},{"./world.js":"1tb8y","./methods/index.js":"kIdDh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1tb8y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let methods = {
    one: {},
    two: {},
    three: {},
    four: {}
};
let model = {
    one: {},
    two: {},
    three: {}
};
let compute = {};
let hooks = [];
exports.default = {
    methods,
    model,
    compute,
    hooks
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kIdDh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _computeJs = require("./compute.js");
var _computeJsDefault = parcelHelpers.interopDefault(_computeJs);
var _loopsJs = require("./loops.js");
var _loopsJsDefault = parcelHelpers.interopDefault(_loopsJs);
var _utilsJs = require("./utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
const methods = Object.assign({}, (0, _utilsJsDefault.default), (0, _computeJsDefault.default), (0, _loopsJsDefault.default));
// aliases
methods.get = methods.eq;
exports.default = methods;

},{"./compute.js":"7bcXc","./loops.js":"hwzUP","./utils.js":"9fzTx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7bcXc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isArray = (input)=>Object.prototype.toString.call(input) === "[object Array]";
const fns = {
    /** add metadata to term objects */ compute: function(input) {
        const { world } = this;
        const compute = world.compute;
        // do one method
        if (typeof input === "string" && compute.hasOwnProperty(input)) compute[input](this);
        else if (isArray(input)) input.forEach((name)=>{
            if (world.compute.hasOwnProperty(name)) compute[name](this);
            else console.warn("no compute:", input) // eslint-disable-line
            ;
        });
        else if (typeof input === "function") input(this);
        else console.warn("no compute:", input) // eslint-disable-line
        ;
        return this;
    }
};
exports.default = fns;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hwzUP":[function(require,module,exports) {
// wrappers for loops in javascript arrays
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const forEach = function(cb) {
    let ptrs = this.fullPointer;
    ptrs.forEach((ptr, i)=>{
        let view = this.update([
            ptr
        ]);
        cb(view, i);
    });
    return this;
};
const map = function(cb, empty) {
    let ptrs = this.fullPointer;
    let res = ptrs.map((ptr, i)=>{
        let view = this.update([
            ptr
        ]);
        let out = cb(view, i);
        // if we returned nothing, return a view
        if (out === undefined) return this.none();
        return out;
    });
    if (res.length === 0) return empty || this.update([]);
    // return an array of values, or View objects?
    // user can return either from their callback
    if (res[0] !== undefined) {
        // array of strings
        if (typeof res[0] === "string") return res;
        // array of objects
        if (typeof res[0] === "object" && (res[0] === null || !res[0].isView)) return res;
    }
    // return a View object
    let all = [];
    res.forEach((ptr)=>{
        all = all.concat(ptr.fullPointer);
    });
    return this.toView(all);
};
const filter = function(cb) {
    let ptrs = this.fullPointer;
    ptrs = ptrs.filter((ptr, i)=>{
        let view = this.update([
            ptr
        ]);
        return cb(view, i);
    });
    let res = this.update(ptrs);
    return res;
};
const find = function(cb) {
    let ptrs = this.fullPointer;
    let found = ptrs.find((ptr, i)=>{
        let view = this.update([
            ptr
        ]);
        return cb(view, i);
    });
    return this.update([
        found
    ]);
};
const some = function(cb) {
    let ptrs = this.fullPointer;
    return ptrs.some((ptr, i)=>{
        let view = this.update([
            ptr
        ]);
        return cb(view, i);
    });
};
const random = function(n = 1) {
    let ptrs = this.fullPointer;
    let r = Math.floor(Math.random() * ptrs.length);
    //prevent it from going over the end
    if (r + n > this.length) {
        r = this.length - n;
        r = r < 0 ? 0 : r;
    }
    ptrs = ptrs.slice(r, r + n);
    return this.update(ptrs);
};
exports.default = {
    forEach,
    map,
    filter,
    find,
    some,
    random
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9fzTx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const utils = {
    /** */ termList: function() {
        return this.methods.one.termList(this.docs);
    },
    /** return individual terms*/ terms: function(n) {
        let m = this.match(".");
        // this is a bit faster than .match('.') 
        // let ptrs = []
        // this.docs.forEach((terms) => {
        //   terms.forEach((term) => {
        //     let [y, x] = term.index || []
        //     ptrs.push([y, x, x + 1])
        //   })
        // })
        // let m = this.update(ptrs)
        return typeof n === "number" ? m.eq(n) : m;
    },
    /** */ groups: function(group) {
        if (group || group === 0) return this.update(this._groups[group] || []);
        // return an object of Views
        let res = {};
        Object.keys(this._groups).forEach((k)=>{
            res[k] = this.update(this._groups[k]);
        });
        // this._groups = null
        return res;
    },
    /** */ eq: function(n) {
        let ptr = this.pointer;
        if (!ptr) ptr = this.docs.map((_doc, i)=>[
                i
            ]);
        if (ptr[n]) return this.update([
            ptr[n]
        ]);
        return this.none();
    },
    /** */ first: function() {
        return this.eq(0);
    },
    /** */ last: function() {
        let n = this.fullPointer.length - 1;
        return this.eq(n);
    },
    /** grab term[0] for every match */ firstTerms: function() {
        return this.match("^.");
    },
    /** grab the last term for every match  */ lastTerms: function() {
        return this.match(".$");
    },
    /** */ slice: function(min, max) {
        let pntrs = this.pointer || this.docs.map((_o, n)=>[
                n
            ]);
        pntrs = pntrs.slice(min, max);
        return this.update(pntrs);
    },
    /** return a view of the entire document */ all: function() {
        return this.update().toView();
    },
    /**  */ fullSentences: function() {
        let ptrs = this.fullPointer.map((a)=>[
                a[0]
            ]) //lazy!
        ;
        return this.update(ptrs).toView();
    },
    /** return a view of no parts of the document */ none: function() {
        return this.update([]);
    },
    /** are these two views looking at the same words? */ isDoc: function(b) {
        if (!b || !b.isView) return false;
        let aPtr = this.fullPointer;
        let bPtr = b.fullPointer;
        if (!aPtr.length === bPtr.length) return false;
        // ensure pointers are the same
        return aPtr.every((ptr, i)=>{
            if (!bPtr[i]) return false;
            // ensure [n, start, end] are all the same
            return ptr[0] === bPtr[i][0] && ptr[1] === bPtr[i][1] && ptr[2] === bPtr[i][2];
        });
    },
    /** how many seperate terms does the document have? */ wordCount: function() {
        return this.docs.reduce((count, terms)=>{
            count += terms.filter((t)=>t.text !== "").length;
            return count;
        }, 0);
    },
    // is the pointer the full sentence?
    isFull: function() {
        let ptrs = this.pointer;
        if (!ptrs) return true;
        // must start at beginning
        if (ptrs.length === 0 || ptrs[0][0] !== 0) return false;
        let wantTerms = 0;
        let haveTerms = 0;
        this.document.forEach((terms)=>wantTerms += terms.length);
        this.docs.forEach((terms)=>haveTerms += terms.length);
        return wantTerms === haveTerms;
    // for (let i = 0; i < ptrs.length; i += 1) {
    //   let [n, start, end] = ptrs[i]
    //   // it's not the start
    //   if (n !== i || start !== 0) {
    //     return false
    //   }
    //   // it's too short
    //   if (document[n].length > end) {
    //     return false
    //   }
    // }
    // return true
    },
    // return the nth elem of a doc
    getNth: function(n) {
        if (typeof n === "number") return this.eq(n);
        else if (typeof n === "string") return this.if(n);
        return this;
    }
};
utils.group = utils.groups;
utils.fullSentence = utils.fullSentences;
utils.sentence = utils.fullSentences;
utils.lastTerm = utils.lastTerms;
utils.firstTerm = utils.firstTerms;
exports.default = utils;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hrnxK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = "14.11.1";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6QZJY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isObject = function(item) {
    return item && typeof item === "object" && !Array.isArray(item);
};
// recursive merge of objects
function mergeDeep(model, plugin) {
    if (isObject(plugin)) {
        for(const key in plugin)if (isObject(plugin[key])) {
            if (!model[key]) Object.assign(model, {
                [key]: {}
            });
            mergeDeep(model[key], plugin[key]) //recursion
            ;
        // } else if (isArray(plugin[key])) {
        // console.log(key)
        // console.log(model)
        } else Object.assign(model, {
            [key]: plugin[key]
        });
    }
    return model;
}
// const merged = mergeDeep({ a: 1 }, { b: { c: { d: { e: 12345 } } } })
// console.dir(merged, { depth: 5 })
// vroom
function mergeQuick(model, plugin) {
    for(const key in plugin){
        model[key] = model[key] || {};
        Object.assign(model[key], plugin[key]);
    }
    return model;
}
const addIrregulars = function(model, conj) {
    let m = model.two.models || {};
    Object.keys(conj).forEach((k)=>{
        // verb forms
        if (conj[k].pastTense) {
            if (m.toPast) m.toPast.ex[k] = conj[k].pastTense;
            if (m.fromPast) m.fromPast.ex[conj[k].pastTense] = k;
        }
        if (conj[k].presentTense) {
            if (m.toPresent) m.toPresent.ex[k] = conj[k].presentTense;
            if (m.fromPresent) m.fromPresent.ex[conj[k].presentTense] = k;
        }
        if (conj[k].gerund) {
            if (m.toGerund) m.toGerund.ex[k] = conj[k].gerund;
            if (m.fromGerund) m.fromGerund.ex[conj[k].gerund] = k;
        }
        // adjective forms
        if (conj[k].comparative) {
            if (m.toComparative) m.toComparative.ex[k] = conj[k].comparative;
            if (m.fromComparative) m.fromComparative.ex[conj[k].comparative] = k;
        }
        if (conj[k].superlative) {
            if (m.toSuperlative) m.toSuperlative.ex[k] = conj[k].superlative;
            if (m.fromSuperlative) m.fromSuperlative.ex[conj[k].superlative] = k;
        }
    });
};
const extend = function(plugin, world, View, nlp) {
    const { methods, model, compute, hooks } = world;
    if (plugin.methods) mergeQuick(methods, plugin.methods);
    if (plugin.model) mergeDeep(model, plugin.model);
    if (plugin.irregulars) addIrregulars(model, plugin.irregulars);
    // shallow-merge compute
    if (plugin.compute) Object.assign(compute, plugin.compute);
    // append new hooks
    if (hooks) world.hooks = hooks.concat(plugin.hooks || []);
    // assign new class methods
    if (plugin.api) plugin.api(View);
    if (plugin.lib) Object.keys(plugin.lib).forEach((k)=>nlp[k] = plugin.lib[k]);
    if (plugin.tags) nlp.addTags(plugin.tags);
    if (plugin.words) nlp.addWords(plugin.words);
    if (plugin.mutate) plugin.mutate(world);
};
exports.default = extend;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ekp3G":[function(require,module,exports) {
/** log the decision-making to console */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "verbose", ()=>verbose);
var process = require("4726e0be974eb47d");
const verbose = function(set) {
    const env = typeof process === "undefined" || !process.env ? self.env || {} : process.env //use window, in browser
    ;
    env.DEBUG_TAGS = set === "tagger" || set === true ? true : "";
    env.DEBUG_MATCH = set === "match" || set === true ? true : "";
    env.DEBUG_CHUNKS = set === "chunker" || set === true ? true : "";
    return this;
};

},{"4726e0be974eb47d":"d5jf4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"gv7NL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isObject = (val)=>{
    return Object.prototype.toString.call(val) === "[object Object]";
};
const isArray = function(arr) {
    return Object.prototype.toString.call(arr) === "[object Array]";
};
// internal Term objects are slightly different
const fromJson = function(json) {
    return json.map((o)=>{
        return o.terms.map((term)=>{
            if (isArray(term.tags)) term.tags = new Set(term.tags);
            return term;
        });
    });
};
// interpret an array-of-arrays
const preTokenized = function(arr) {
    return arr.map((a)=>{
        return a.map((str)=>{
            return {
                text: str,
                normal: str,
                pre: "",
                post: " ",
                tags: new Set()
            };
        });
    });
};
const inputs = function(input, View, world) {
    const { methods } = world;
    let doc = new View([]);
    doc.world = world;
    // support a number
    if (typeof input === "number") input = String(input);
    // return empty doc
    if (!input) return doc;
    // parse a string
    if (typeof input === "string") {
        let document = methods.one.tokenize.fromString(input, world);
        return new View(document);
    }
    // handle compromise View
    if (isObject(input) && input.isView) return new View(input.document, input.ptrs);
    // handle json input
    if (isArray(input)) {
        // pre-tokenized array-of-arrays 
        if (isArray(input[0])) {
            let document = preTokenized(input);
            return new View(document);
        }
        // handle json output
        let document = fromJson(input);
        return new View(document);
    }
    return doc;
};
exports.default = inputs;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b7gvB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./methods/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _apiJs = require("./api.js");
var _apiJsDefault = parcelHelpers.interopDefault(_apiJs);
var _computeJs = require("./compute.js");
var _computeJsDefault = parcelHelpers.interopDefault(_computeJs);
exports.default = {
    api: (0, _apiJsDefault.default),
    compute: (0, _computeJsDefault.default),
    methods: (0, _indexJsDefault.default)
};

},{"./methods/index.js":"4ZBEy","./api.js":"juRu6","./compute.js":"7ByJa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4ZBEy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _cacheDocJs = require("./cacheDoc.js");
var _cacheDocJsDefault = parcelHelpers.interopDefault(_cacheDocJs);
exports.default = {
    one: {
        cacheDoc: (0, _cacheDocJsDefault.default)
    }
};

},{"./cacheDoc.js":"gSnCX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gSnCX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const createCache = function(document) {
    let cache = document.map((terms)=>{
        let stuff = new Set();
        terms.forEach((term)=>{
            // add words
            if (term.normal !== "") stuff.add(term.normal);
            // cache switch-status - '%Noun|Verb%'
            if (term.switch) stuff.add(`%${term.switch}%`);
            // cache implicit words, too
            if (term.implicit) stuff.add(term.implicit);
            if (term.machine) stuff.add(term.machine);
            if (term.root) stuff.add(term.root);
            // cache slashes words, etc
            if (term.alias) term.alias.forEach((str)=>stuff.add(str));
            let tags = Array.from(term.tags);
            for(let t = 0; t < tags.length; t += 1)stuff.add("#" + tags[t]);
        });
        return stuff;
    });
    return cache;
};
exports.default = createCache;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"juRu6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const methods = {
    /** */ cache: function() {
        this._cache = this.methods.one.cacheDoc(this.document);
        return this;
    },
    /** */ uncache: function() {
        this._cache = null;
        return this;
    }
};
const addAPI = function(View) {
    Object.assign(View.prototype, methods);
};
exports.default = addAPI;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7ByJa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    cache: function(view) {
        view._cache = view.methods.one.cacheDoc(view.document);
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"84pjy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./api/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./compute/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
exports.default = {
    api: (0, _indexJsDefault.default),
    compute: (0, _indexJsDefault1.default)
};

},{"./api/index.js":"kAi29","./compute/index.js":"ja4E9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kAi29":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _caseJs = require("./case.js");
var _caseJsDefault = parcelHelpers.interopDefault(_caseJs);
var _insertJs = require("./insert.js");
var _insertJsDefault = parcelHelpers.interopDefault(_insertJs);
var _replaceJs = require("./replace.js");
var _replaceJsDefault = parcelHelpers.interopDefault(_replaceJs);
var _removeJs = require("./remove.js");
var _removeJsDefault = parcelHelpers.interopDefault(_removeJs);
var _whitespaceJs = require("./whitespace.js");
var _whitespaceJsDefault = parcelHelpers.interopDefault(_whitespaceJs);
var _sortJs = require("./sort.js");
var _sortJsDefault = parcelHelpers.interopDefault(_sortJs);
var _concatJs = require("./concat.js");
var _concatJsDefault = parcelHelpers.interopDefault(_concatJs);
var _hardenJs = require("./harden.js");
var _hardenJsDefault = parcelHelpers.interopDefault(_hardenJs);
const methods = Object.assign({}, (0, _caseJsDefault.default), (0, _insertJsDefault.default), (0, _replaceJsDefault.default), (0, _removeJsDefault.default), (0, _whitespaceJsDefault.default), (0, _sortJsDefault.default), (0, _concatJsDefault.default), (0, _hardenJsDefault.default));
const addAPI = function(View) {
    Object.assign(View.prototype, methods);
};
exports.default = addAPI;

},{"./case.js":"ij53O","./insert.js":"7n4sS","./replace.js":"j8oXm","./remove.js":"aOJaS","./whitespace.js":"lnsJC","./sort.js":"49Hlm","./concat.js":"4YAVE","./harden.js":"2MaXX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ij53O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /** */ toLowerCase: function() {
        this.termList().forEach((t)=>{
            t.text = t.text.toLowerCase();
        });
        return this;
    },
    /** */ toUpperCase: function() {
        this.termList().forEach((t)=>{
            t.text = t.text.toUpperCase();
        });
        return this;
    },
    /** */ toTitleCase: function() {
        this.termList().forEach((t)=>{
            t.text = t.text.replace(/^ *[a-z\u00C0-\u00FF]/, (x)=>x.toUpperCase()) //support unicode?
            ;
        });
        return this;
    },
    /** */ toCamelCase: function() {
        this.docs.forEach((terms)=>{
            terms.forEach((t, i)=>{
                if (i !== 0) t.text = t.text.replace(/^ *[a-z\u00C0-\u00FF]/, (x)=>x.toUpperCase()) //support unicode?
                ;
                if (i !== terms.length - 1) t.post = "";
            });
        });
        return this;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7n4sS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _insertJs = require("./lib/insert.js");
var _uuidJs = require("../compute/uuid.js");
var _uuidJsDefault = parcelHelpers.interopDefault(_uuidJs);
// are we inserting inside a contraction?
// expand it first
const expand = function(m) {
    if (m.has("@hasContraction") && typeof m.contractions === "function") {
        let more = m.grow("@hasContraction");
        more.contractions().expand();
    }
};
const isArray = (arr)=>Object.prototype.toString.call(arr) === "[object Array]";
// set new ids for each terms
const addIds = function(terms) {
    terms = terms.map((term)=>{
        term.id = (0, _uuidJsDefault.default)(term);
        return term;
    });
    return terms;
};
const getTerms = function(input, world) {
    const { methods } = world;
    // create our terms from a string
    if (typeof input === "string") return methods.one.tokenize.fromString(input, world)[0] //assume one sentence
    ;
    //allow a view object
    if (typeof input === "object" && input.isView) return input.clone().docs[0] || [] //assume one sentence
    ;
    //allow an array of terms, too
    if (isArray(input)) return isArray(input[0]) ? input[0] : input;
    return [];
};
const insert = function(input, view, prepend) {
    const { document, world } = view;
    view.uncache();
    // insert words at end of each doc
    let ptrs = view.fullPointer;
    let selfPtrs = view.fullPointer;
    view.forEach((m, i)=>{
        let ptr = m.fullPointer[0];
        let [n] = ptr;
        // add-in the words
        let home = document[n];
        let terms = getTerms(input, world);
        // are we inserting nothing?
        if (terms.length === 0) return;
        terms = addIds(terms);
        if (prepend) {
            expand(view.update([
                ptr
            ]).firstTerm());
            (0, _insertJs.cleanPrepend)(home, ptr, terms, document);
        } else {
            expand(view.update([
                ptr
            ]).lastTerm());
            (0, _insertJs.cleanAppend)(home, ptr, terms, document);
        }
        // harden the pointer
        if (document[n] && document[n][ptr[1]]) ptr[3] = document[n][ptr[1]].id;
        // change self backwards by len
        selfPtrs[i] = ptr;
        // extend the pointer
        ptr[2] += terms.length;
        ptrs[i] = ptr;
    });
    let doc = view.toView(ptrs);
    // shift our self pointer, if necessary
    view.ptrs = selfPtrs;
    // try to tag them, too
    doc.compute([
        "id",
        "index",
        "lexicon"
    ]);
    if (doc.world.compute.preTagger) doc.compute("preTagger");
    return doc;
};
const fns = {
    insertAfter: function(input) {
        return insert(input, this, false);
    },
    insertBefore: function(input) {
        return insert(input, this, true);
    }
};
fns.append = fns.insertAfter;
fns.prepend = fns.insertBefore;
fns.insert = fns.insertAfter;
exports.default = fns;

},{"./lib/insert.js":"d5OIO","../compute/uuid.js":"fybQY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5OIO":[function(require,module,exports) {
// case logic
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cleanPrepend", ()=>cleanPrepend);
parcelHelpers.export(exports, "cleanAppend", ()=>cleanAppend);
parcelHelpers.export(exports, "spliceArr", ()=>spliceArr);
const isTitleCase = (str)=>/^\p{Lu}[\p{Ll}'’]/u.test(str) || /^\p{Lu}$/u.test(str);
const toTitleCase = (str)=>str.replace(/^\p{Ll}/u, (x)=>x.toUpperCase());
const toLowerCase = (str)=>str.replace(/^\p{Lu}/u, (x)=>x.toLowerCase());
// splice an array into an array
const spliceArr = (parent, index, child)=>{
    // tag them as dirty
    child.forEach((term)=>term.dirty = true);
    if (parent) {
        let args = [
            index,
            0
        ].concat(child);
        Array.prototype.splice.apply(parent, args);
    }
    return parent;
};
// add a space at end, if required
const endSpace = function(terms) {
    const hasSpace = / $/;
    const hasDash = /[-–—]/;
    let lastTerm = terms[terms.length - 1];
    if (lastTerm && !hasSpace.test(lastTerm.post) && !hasDash.test(lastTerm.post)) lastTerm.post += " ";
};
// sentence-ending punctuation should move in append
const movePunct = (source, end, needle)=>{
    const juicy = /[-.?!,;:)–—'"]/g;
    let wasLast = source[end - 1];
    if (!wasLast) return;
    let post = wasLast.post;
    if (juicy.test(post)) {
        let punct = post.match(juicy).join("") //not perfect
        ;
        let last = needle[needle.length - 1];
        last.post = punct + last.post;
        // remove it, from source
        wasLast.post = wasLast.post.replace(juicy, "");
    }
};
const moveTitleCase = function(home, start, needle) {
    let from = home[start];
    // should we bother?
    if (start !== 0 || !isTitleCase(from.text)) return;
    // titlecase new first term
    needle[0].text = toTitleCase(needle[0].text);
    // should we un-titlecase the old word?
    let old = home[start];
    if (old.tags.has("ProperNoun") || old.tags.has("Acronym")) return;
    if (isTitleCase(old.text) && old.text.length > 1) old.text = toLowerCase(old.text);
};
// put these words before the others
const cleanPrepend = function(home, ptr, needle, document) {
    let [n, start, end] = ptr;
    // introduce spaces appropriately
    if (start === 0) // at start - need space in insert
    endSpace(needle);
    else if (end === document[n].length) // at end - need space in home
    endSpace(needle);
    else {
        // in middle - need space in home and insert
        endSpace(needle);
        endSpace([
            home[ptr[1]]
        ]);
    }
    moveTitleCase(home, start, needle);
    // movePunct(home, end, needle)
    spliceArr(home, start, needle);
};
const cleanAppend = function(home, ptr, needle, document) {
    let [n, , end] = ptr;
    let total = (document[n] || []).length;
    if (end < total) {
        // are we in the middle?
        // add trailing space on self
        movePunct(home, end, needle);
        endSpace(needle);
    } else if (total === end) {
        // are we at the end?
        // add a space to predecessor
        endSpace(home);
        // very end, move period
        movePunct(home, end, needle);
        // is there another sentence after?
        if (document[n + 1]) needle[needle.length - 1].post += " ";
    }
    spliceArr(home, ptr[2], needle);
    // set new endId
    ptr[4] = needle[needle.length - 1].id;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fybQY":[function(require,module,exports) {
/*
unique & ordered term ids, based on time & term index

Base 36 (numbers+ascii)
  3 digit 4,600
  2 digit 1,200
  1 digit 36

  TTT|NNN|II|R

TTT -> 46 terms since load
NNN -> 46 thousand sentences (>1 inf-jest)
II  -> 1,200 words in a sentence (nuts)
R   -> 1-36 random number 

novels: 
  avg 80,000 words
    15 words per sentence
  5,000 sentences

Infinite Jest:
  36,247 sentences
  https://en.wikipedia.org/wiki/List_of_longest_novels

collisions are more-likely after
    46 seconds have passed,
  and 
    after 46-thousand sentences

*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let index = 0;
const pad3 = (str)=>{
    str = str.length < 3 ? "0" + str : str;
    return str.length < 3 ? "0" + str : str;
};
const toId = function(term) {
    let [n, i] = term.index || [
        0,
        0
    ];
    index += 1;
    //don't overflow index
    index = index > 46655 ? 0 : index;
    //don't overflow sentences
    n = n > 46655 ? 0 : n;
    // //don't overflow terms
    i = i > 1294 ? 0 : i;
    // 3 digits for time
    let id = pad3(index.toString(36));
    // 3 digit  for sentence index (46k)
    id += pad3(n.toString(36));
    // 1 digit for term index (36)
    let tx = i.toString(36);
    tx = tx.length < 2 ? "0" + tx : tx //pad2
    ;
    id += tx;
    // 1 digit random number
    let r = parseInt(Math.random() * 36, 10);
    id += r.toString(36);
    return term.normal + "|" + id.toUpperCase();
};
exports.default = toId // setInterval(() => console.log(toId(4, 12)), 100)
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j8oXm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const dollarStub = /\$[0-9a-z]+/g;
const fns = {};
const titleCase = function(str) {
    return str.replace(/\w\S*/g, (txt)=>txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase());
};
// doc.replace('foo', (m)=>{})
const replaceByFn = function(main, fn) {
    main.forEach((m)=>{
        let out = fn(m);
        m.replaceWith(out);
    });
    return main;
};
// support 'foo $0' replacements
const subDollarSign = function(input, main) {
    if (typeof input !== "string") return input;
    let groups = main.groups();
    input = input.replace(dollarStub, (a)=>{
        let num = a.replace(/\$/, "");
        if (groups.hasOwnProperty(num)) return groups[num].text();
        return a;
    });
    return input;
};
fns.replaceWith = function(input, keep = {}) {
    let ptrs = this.fullPointer;
    let main = this;
    this.uncache();
    if (typeof input === "function") return replaceByFn(main, input);
    let terms = main.docs[0];
    let isPossessive = keep.possessives && terms[terms.length - 1].tags.has("Possessive");
    // support 'foo $0' replacements
    input = subDollarSign(input, main);
    let original = this.update(ptrs);
    // soften-up pointer
    ptrs = ptrs.map((ptr)=>ptr.slice(0, 3));
    // original.freeze()
    let oldTags = (original.docs[0] || []).map((term)=>Array.from(term.tags));
    // slide this in
    if (typeof input === "string") input = this.fromText(input).compute("id");
    main.insertAfter(input);
    // are we replacing part of a contraction?
    if (original.has("@hasContraction") && main.contractions) {
        let more = main.grow("@hasContraction+");
        more.contractions().expand();
    }
    // delete the original terms
    main.delete(original) //science.
    ;
    // keep "John's"
    if (isPossessive) {
        let tmp = main.docs[0];
        let term = tmp[tmp.length - 1];
        if (!term.tags.has("Possessive")) {
            term.text += "'s";
            term.normal += "'s";
            term.tags.add("Possessive");
        }
    }
    // what should we return?
    let m = main.toView(ptrs).compute([
        "index",
        "lexicon"
    ]);
    if (m.world.compute.preTagger) m.compute("preTagger");
    // replace any old tags
    if (keep.tags) m.terms().forEach((term, i)=>{
        term.tagSafe(oldTags[i]);
    });
    // try to co-erce case, too
    if (keep.case && m.docs[0] && m.docs[0][0] && m.docs[0][0].index[1] === 0) m.docs[0][0].text = titleCase(m.docs[0][0].text);
    // try to keep some pre-post punctuation
    // if (m.terms().length === 1 && main.terms().length === 1) {
    //   console.log(original.docs)
    // }
    // console.log(input.docs[0])
    // let regs = input.docs[0].map(t => {
    //   return { id: t.id, optional: true }
    // })
    // m.after('(a|hoy)').debug()
    // m.growRight('(a|hoy)').debug()
    // console.log(m)
    return m;
};
fns.replace = function(match, input, keep) {
    if (match && !input) return this.replaceWith(match, keep);
    let m = this.match(match);
    if (!m.found) return this;
    this.soften();
    return m.replaceWith(input, keep);
};
exports.default = fns;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aOJaS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _removeJs = require("./lib/remove.js");
var _removeJsDefault = parcelHelpers.interopDefault(_removeJs);
const fixPointers = function(ptrs, gonePtrs) {
    ptrs = ptrs.map((ptr)=>{
        let [n] = ptr;
        if (!gonePtrs[n]) return ptr;
        gonePtrs[n].forEach((no)=>{
            let len = no[2] - no[1];
            // does it effect our pointer?
            if (ptr[1] <= no[1] && ptr[2] >= no[2]) ptr[2] -= len;
        });
        return ptr;
    });
    // decrement any pointers after a now-empty pointer
    ptrs.forEach((ptr, i)=>{
        // is the pointer now empty?
        if (ptr[1] === 0 && ptr[2] == 0) // go down subsequent pointers
        for(let n = i + 1; n < ptrs.length; n += 1){
            ptrs[n][0] -= 1;
            if (ptrs[n][0] < 0) ptrs[n][0] = 0;
        }
    });
    // remove any now-empty pointers
    ptrs = ptrs.filter((ptr)=>ptr[2] - ptr[1] > 0);
    // remove old hard-pointers
    ptrs = ptrs.map((ptr)=>{
        ptr[3] = null;
        ptr[4] = null;
        return ptr;
    });
    return ptrs;
};
const methods = {
    /** */ remove: function(reg) {
        const { indexN } = this.methods.one.pointer;
        this.uncache();
        // two modes:
        //  - a. remove self, from full parent
        let self = this.all();
        let not = this;
        //  - b. remove a match, from self
        if (reg) {
            self = this;
            not = this.match(reg);
        }
        let isFull = !self.ptrs;
        // is it part of a contraction?
        if (not.has("@hasContraction") && not.contractions) {
            let more = not.grow("@hasContraction");
            more.contractions().expand();
        }
        let ptrs = self.fullPointer;
        let nots = not.fullPointer.reverse();
        // remove them from the actual document)
        let document = (0, _removeJsDefault.default)(this.document, nots);
        // repair our pointers
        let gonePtrs = indexN(nots);
        ptrs = fixPointers(ptrs, gonePtrs);
        // clean up our original inputs
        self.ptrs = ptrs;
        self.document = document;
        self.compute("index");
        // if we started zoomed-out, try to end zoomed-out
        if (isFull) self.ptrs = undefined;
        if (!reg) {
            this.ptrs = [];
            return self.none();
        }
        let res = self.toView(ptrs) //return new document
        ;
        return res;
    }
};
// aliases
methods.delete = methods.remove;
exports.default = methods;

},{"./lib/remove.js":"DCg5y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"DCg5y":[function(require,module,exports) {
// transfer sentence-ending punctuation
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const repairPunct = function(terms, len) {
    let last = terms.length - 1;
    let from = terms[last];
    let to = terms[last - len];
    if (to && from) {
        to.post += from.post //this isn't perfect.
        ;
        to.post = to.post.replace(/ +([.?!,;:])/, "$1");
        // don't allow any silly punctuation outcomes like ',!'
        to.post = to.post.replace(/[,;:]+([.?!])/, "$1");
    }
};
// remove terms from document json
const pluckOut = function(document, nots) {
    nots.forEach((ptr)=>{
        let [n, start, end] = ptr;
        let len = end - start;
        if (!document[n]) return; // weird!
        if (end === document[n].length && end > 1) repairPunct(document[n], len);
        document[n].splice(start, len) // replaces len terms at index start
        ;
    });
    // remove any now-empty sentences
    // (foreach + splice = 'mutable filter')
    for(let i = document.length - 1; i >= 0; i -= 1)if (document[i].length === 0) {
        document.splice(i, 1);
        // remove any trailing whitespace before our removed sentence
        if (i === document.length && document[i - 1]) {
            let terms = document[i - 1];
            let lastTerm = terms[terms.length - 1];
            if (lastTerm) lastTerm.post = lastTerm.post.trimEnd();
        }
    // repair any downstream indexes
    // for (let k = i; k < document.length; k += 1) {
    //   document[k].forEach(term => term.index[0] -= 1)
    // }
    }
    return document;
};
exports.default = pluckOut;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lnsJC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const methods = {
    /** add this punctuation or whitespace before each match: */ pre: function(str, concat) {
        if (str === undefined && this.found) return this.docs[0][0].pre;
        this.docs.forEach((terms)=>{
            let term = terms[0];
            if (concat === true) term.pre += str;
            else term.pre = str;
        });
        return this;
    },
    /** add this punctuation or whitespace after each match: */ post: function(str, concat) {
        if (str === undefined) {
            let last = this.docs[this.docs.length - 1];
            return last[last.length - 1].post;
        }
        this.docs.forEach((terms)=>{
            let term = terms[terms.length - 1];
            if (concat === true) term.post += str;
            else term.post = str;
        });
        return this;
    },
    /** remove whitespace from start/end */ trim: function() {
        if (!this.found) return this;
        let docs = this.docs;
        let start = docs[0][0];
        start.pre = start.pre.trimStart();
        let last = docs[docs.length - 1];
        let end = last[last.length - 1];
        end.post = end.post.trimEnd();
        return this;
    },
    /** connect words with hyphen, and remove whitespace */ hyphenate: function() {
        this.docs.forEach((terms)=>{
            //remove whitespace
            terms.forEach((t, i)=>{
                if (i !== 0) t.pre = "";
                if (terms[i + 1]) t.post = "-";
            });
        });
        return this;
    },
    /** remove hyphens between words, and set whitespace */ dehyphenate: function() {
        const hasHyphen = /[-–—]/;
        this.docs.forEach((terms)=>{
            //remove whitespace
            terms.forEach((t)=>{
                if (hasHyphen.test(t.post)) t.post = " ";
            });
        });
        return this;
    },
    /** add quotations around these matches */ toQuotations: function(start, end) {
        start = start || `"`;
        end = end || `"`;
        this.docs.forEach((terms)=>{
            terms[0].pre = start + terms[0].pre;
            let last = terms[terms.length - 1];
            last.post = end + last.post;
        });
        return this;
    },
    /** add brackets around these matches */ toParentheses: function(start, end) {
        start = start || `(`;
        end = end || `)`;
        this.docs.forEach((terms)=>{
            terms[0].pre = start + terms[0].pre;
            let last = terms[terms.length - 1];
            last.post = end + last.post;
        });
        return this;
    }
};
// aliases
methods.deHyphenate = methods.dehyphenate;
methods.toQuotation = methods.toQuotations;
exports.default = methods;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"49Hlm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _sortJs = require("./lib/_sort.js");
var _sortJsDefault = parcelHelpers.interopDefault(_sortJs);
// aliases
const seqNames = new Set([
    "index",
    "sequence",
    "seq",
    "sequential",
    "chron",
    "chronological"
]);
const freqNames = new Set([
    "freq",
    "frequency",
    "topk",
    "repeats"
]);
const alphaNames = new Set([
    "alpha",
    "alphabetical"
]);
// support function as parameter
const customSort = function(view, fn) {
    let ptrs = view.fullPointer;
    ptrs = ptrs.sort((a, b)=>{
        a = view.update([
            a
        ]);
        b = view.update([
            b
        ]);
        return fn(a, b);
    });
    view.ptrs = ptrs //mutate original
    ;
    return view;
};
/** re-arrange the order of the matches (in place) */ const sort = function(input) {
    let { docs, pointer } = this;
    this.uncache();
    if (typeof input === "function") return customSort(this, input);
    input = input || "alpha";
    let ptrs = pointer || docs.map((_d, n)=>[
            n
        ]);
    let arr = docs.map((terms, n)=>{
        return {
            index: n,
            words: terms.length,
            normal: terms.map((t)=>t.machine || t.normal || "").join(" "),
            pointer: ptrs[n]
        };
    });
    // 'chronological' sorting
    if (seqNames.has(input)) input = "sequential";
    // alphabetical sorting
    if (alphaNames.has(input)) input = "alpha";
    // sort by frequency
    if (freqNames.has(input)) {
        arr = (0, _sortJsDefault.default).byFreq(arr);
        return this.update(arr.map((o)=>o.pointer));
    }
    // apply sort method on each phrase
    if (typeof (0, _sortJsDefault.default)[input] === "function") {
        arr = arr.sort((0, _sortJsDefault.default)[input]);
        return this.update(arr.map((o)=>o.pointer));
    }
    return this;
};
/** reverse the order of the matches, but not the words or index */ const reverse = function() {
    let ptrs = this.pointer || this.docs.map((_d, n)=>[
            n
        ]);
    ptrs = [].concat(ptrs);
    ptrs = ptrs.reverse();
    if (this._cache) this._cache = this._cache.reverse();
    return this.update(ptrs);
};
/** remove any duplicate matches */ const unique = function() {
    let already = new Set();
    let res = this.filter((m)=>{
        let txt = m.text("machine");
        if (already.has(txt)) return false;
        already.add(txt);
        return true;
    });
    // this.ptrs = res.ptrs //mutate original?
    return res //.compute('index')
    ;
};
exports.default = {
    unique,
    reverse,
    sort
};

},{"./lib/_sort.js":"42xRf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"42xRf":[function(require,module,exports) {
/** alphabetical order */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const alpha = (a, b)=>{
    if (a.normal < b.normal) return -1;
    if (a.normal > b.normal) return 1;
    return 0;
};
/** count the # of characters of each match */ const length = (a, b)=>{
    let left = a.normal.trim().length;
    let right = b.normal.trim().length;
    if (left < right) return 1;
    if (left > right) return -1;
    return 0;
};
/** count the # of terms in each match */ const wordCount = (a, b)=>{
    if (a.words < b.words) return 1;
    if (a.words > b.words) return -1;
    return 0;
};
/** count the # of terms in each match */ const sequential = (a, b)=>{
    if (a[0] < b[0]) return 1;
    if (a[0] > b[0]) return -1;
    return a[1] > b[1] ? 1 : -1;
};
/** sort by # of duplicates in the document*/ const byFreq = function(arr) {
    let counts = {};
    arr.forEach((o)=>{
        counts[o.normal] = counts[o.normal] || 0;
        counts[o.normal] += 1;
    });
    // sort by freq
    arr.sort((a, b)=>{
        let left = counts[a.normal];
        let right = counts[b.normal];
        if (left < right) return 1;
        if (left > right) return -1;
        return 0;
    });
    return arr;
};
exports.default = {
    alpha,
    length,
    wordCount,
    sequential,
    byFreq
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4YAVE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isArray = (arr)=>Object.prototype.toString.call(arr) === "[object Array]";
// append a new document, somehow
const combineDocs = function(homeDocs, inputDocs) {
    if (homeDocs.length > 0) {
        // add a space
        let end = homeDocs[homeDocs.length - 1];
        let last = end[end.length - 1];
        if (/ /.test(last.post) === false) last.post += " ";
    }
    homeDocs = homeDocs.concat(inputDocs);
    return homeDocs;
};
const combineViews = function(home, input) {
    // is it a view from the same document?
    if (home.document === input.document) {
        let ptrs = home.fullPointer.concat(input.fullPointer);
        return home.toView(ptrs).compute("index");
    }
    // update n of new pointer, to end of our pointer
    let ptrs = input.fullPointer;
    ptrs.forEach((a)=>{
        a[0] += home.document.length;
    });
    home.document = combineDocs(home.document, input.docs);
    return home.all();
};
exports.default = {
    // add string as new match/sentence
    concat: function(input) {
        // parse and splice-in new terms
        if (typeof input === "string") {
            let more = this.fromText(input);
            // easy concat
            if (!this.found || !this.ptrs) this.document = this.document.concat(more.document);
            else {
                // if we are in the middle, this is actually a splice operation
                let ptrs = this.fullPointer;
                let at = ptrs[ptrs.length - 1][0];
                this.document.splice(at, 0, ...more.document);
            }
            // put the docs
            return this.all().compute("index");
        }
        // plop some view objects together
        if (typeof input === "object" && input.isView) return combineViews(this, input);
        // assume it's an array of terms
        if (isArray(input)) {
            let docs = combineDocs(this.document, input);
            this.document = docs;
            return this.all();
        }
        return this;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2MaXX":[function(require,module,exports) {
// add indexes to pointers
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const harden = function() {
    this.ptrs = this.fullPointer;
    return this;
};
// remove indexes from pointers
const soften = function() {
    let ptr = this.ptrs;
    if (!ptr || ptr.length < 1) return this;
    ptr = ptr.map((a)=>a.slice(0, 3));
    this.ptrs = ptr;
    return this;
};
exports.default = {
    harden,
    soften
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ja4E9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _uuidJs = require("./uuid.js");
var _uuidJsDefault = parcelHelpers.interopDefault(_uuidJs);
const compute = {
    id: function(view) {
        let docs = view.docs;
        for(let n = 0; n < docs.length; n += 1)for(let i = 0; i < docs[n].length; i += 1){
            let term = docs[n][i];
            term.id = term.id || (0, _uuidJsDefault.default)(term);
        }
    }
};
exports.default = compute;

},{"./uuid.js":"fybQY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bbZda":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./model/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./compute/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
const plugin = {
    model: (0, _indexJsDefault.default),
    compute: (0, _indexJsDefault1.default),
    hooks: [
        "contractions"
    ]
};
exports.default = plugin;

},{"./model/index.js":"9giIw","./compute/index.js":"2B6dF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9giIw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _contractionsJs = require("./contractions.js");
var _contractionsJsDefault = parcelHelpers.interopDefault(_contractionsJs);
var _numberSuffixJs = require("./number-suffix.js");
var _numberSuffixJsDefault = parcelHelpers.interopDefault(_numberSuffixJs);
exports.default = {
    one: {
        contractions: (0, _contractionsJsDefault.default),
        numberSuffixes: (0, _numberSuffixJsDefault.default)
    }
};

},{"./contractions.js":"8BR7H","./number-suffix.js":"9rGjO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8BR7H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // simple mappings
    {
        word: "@",
        out: [
            "at"
        ]
    },
    {
        word: "arent",
        out: [
            "are",
            "not"
        ]
    },
    {
        word: "alot",
        out: [
            "a",
            "lot"
        ]
    },
    {
        word: "brb",
        out: [
            "be",
            "right",
            "back"
        ]
    },
    {
        word: "cannot",
        out: [
            "can",
            "not"
        ]
    },
    {
        word: "dun",
        out: [
            "do",
            "not"
        ]
    },
    {
        word: "can't",
        out: [
            "can",
            "not"
        ]
    },
    {
        word: "shan't",
        out: [
            "should",
            "not"
        ]
    },
    {
        word: "won't",
        out: [
            "will",
            "not"
        ]
    },
    {
        word: "that's",
        out: [
            "that",
            "is"
        ]
    },
    {
        word: "what's",
        out: [
            "what",
            "is"
        ]
    },
    {
        word: "let's",
        out: [
            "let",
            "us"
        ]
    },
    // { word: "there's", out: ['there', 'is'] },
    {
        word: "dunno",
        out: [
            "do",
            "not",
            "know"
        ]
    },
    {
        word: "gonna",
        out: [
            "going",
            "to"
        ]
    },
    {
        word: "gotta",
        out: [
            "have",
            "got",
            "to"
        ]
    },
    {
        word: "gimme",
        out: [
            "give",
            "me"
        ]
    },
    {
        word: "outta",
        out: [
            "out",
            "of"
        ]
    },
    {
        word: "tryna",
        out: [
            "trying",
            "to"
        ]
    },
    {
        word: "gtg",
        out: [
            "got",
            "to",
            "go"
        ]
    },
    {
        word: "im",
        out: [
            "i",
            "am"
        ]
    },
    {
        word: "imma",
        out: [
            "I",
            "will"
        ]
    },
    {
        word: "imo",
        out: [
            "in",
            "my",
            "opinion"
        ]
    },
    {
        word: "irl",
        out: [
            "in",
            "real",
            "life"
        ]
    },
    {
        word: "ive",
        out: [
            "i",
            "have"
        ]
    },
    {
        word: "rn",
        out: [
            "right",
            "now"
        ]
    },
    {
        word: "tbh",
        out: [
            "to",
            "be",
            "honest"
        ]
    },
    {
        word: "wanna",
        out: [
            "want",
            "to"
        ]
    },
    {
        word: `c'mere`,
        out: [
            "come",
            "here"
        ]
    },
    {
        word: `c'mon`,
        out: [
            "come",
            "on"
        ]
    },
    // shoulda, coulda
    {
        word: "shoulda",
        out: [
            "should",
            "have"
        ]
    },
    {
        word: "coulda",
        out: [
            "coulda",
            "have"
        ]
    },
    {
        word: "woulda",
        out: [
            "woulda",
            "have"
        ]
    },
    {
        word: "musta",
        out: [
            "must",
            "have"
        ]
    },
    {
        word: "tis",
        out: [
            "it",
            "is"
        ]
    },
    {
        word: "twas",
        out: [
            "it",
            "was"
        ]
    },
    {
        word: `y'know`,
        out: [
            "you",
            "know"
        ]
    },
    {
        word: "ne'er",
        out: [
            "never"
        ]
    },
    {
        word: "o'er",
        out: [
            "over"
        ]
    },
    // contraction-part mappings
    {
        after: "ll",
        out: [
            "will"
        ]
    },
    {
        after: "ve",
        out: [
            "have"
        ]
    },
    {
        after: "re",
        out: [
            "are"
        ]
    },
    {
        after: "m",
        out: [
            "am"
        ]
    },
    // french contractions
    {
        before: "c",
        out: [
            "ce"
        ]
    },
    {
        before: "m",
        out: [
            "me"
        ]
    },
    {
        before: "n",
        out: [
            "ne"
        ]
    },
    {
        before: "qu",
        out: [
            "que"
        ]
    },
    {
        before: "s",
        out: [
            "se"
        ]
    },
    {
        before: "t",
        out: [
            "tu"
        ]
    },
    // missing apostrophes
    {
        word: "shouldnt",
        out: [
            "should",
            "not"
        ]
    },
    {
        word: "couldnt",
        out: [
            "could",
            "not"
        ]
    },
    {
        word: "wouldnt",
        out: [
            "would",
            "not"
        ]
    },
    {
        word: "hasnt",
        out: [
            "has",
            "not"
        ]
    },
    {
        word: "wasnt",
        out: [
            "was",
            "not"
        ]
    },
    {
        word: "isnt",
        out: [
            "is",
            "not"
        ]
    },
    {
        word: "cant",
        out: [
            "can",
            "not"
        ]
    },
    {
        word: "dont",
        out: [
            "do",
            "not"
        ]
    },
    {
        word: "wont",
        out: [
            "will",
            "not"
        ]
    },
    // apostrophe d
    {
        word: "howd",
        out: [
            "how",
            "did"
        ]
    },
    {
        word: "whatd",
        out: [
            "what",
            "did"
        ]
    },
    {
        word: "whend",
        out: [
            "when",
            "did"
        ]
    },
    {
        word: "whered",
        out: [
            "where",
            "did"
        ]
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9rGjO":[function(require,module,exports) {
// number suffixes that are not units
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const t = true;
exports.default = {
    "st": t,
    "nd": t,
    "rd": t,
    "th": t,
    "am": t,
    "pm": t,
    "max": t,
    "\xb0": t,
    "s": t,
    "e": t,
    "er": t,
    "\xe8re": t,
    "\xe8me": t
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2B6dF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./contractions/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
exports.default = {
    contractions: (0, _indexJsDefault.default)
};

},{"./contractions/index.js":"l6Lmg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l6Lmg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _spliceJs = require("./_splice.js");
var _spliceJsDefault = parcelHelpers.interopDefault(_spliceJs);
var _apostropheDJs = require("./apostrophe-d.js");
var _apostropheDJsDefault = parcelHelpers.interopDefault(_apostropheDJs);
var _apostropheTJs = require("./apostrophe-t.js");
var _apostropheTJsDefault = parcelHelpers.interopDefault(_apostropheTJs);
var _frenchJs = require("./french.js");
var _frenchJsDefault = parcelHelpers.interopDefault(_frenchJs);
var _numberRangeJs = require("./number-range.js");
var _numberRangeJsDefault = parcelHelpers.interopDefault(_numberRangeJs);
var _numberUnitJs = require("./number-unit.js");
var _numberUnitJsDefault = parcelHelpers.interopDefault(_numberUnitJs);
const byApostrophe = /'/;
const numDash = /^[0-9][^-–—]*[-–—].*?[0-9]/;
// run tagger on our new implicit terms
const reTag = function(terms, view, start, len) {
    let tmp = view.update();
    tmp.document = [
        terms
    ];
    // offer to re-tag neighbours, too
    let end = start + len;
    if (start > 0) start -= 1;
    if (terms[end]) end += 1;
    tmp.ptrs = [
        [
            0,
            start,
            end
        ]
    ];
};
const byEnd = {
    // ain't
    t: (terms, i)=>(0, _apostropheTJsDefault.default)(terms, i),
    // how'd
    d: (terms, i)=>(0, _apostropheDJsDefault.default)(terms, i)
};
const byStart = {
    // j'aime
    j: (terms, i)=>(0, _frenchJsDefault.default).preJ(terms, i),
    // l'amour
    l: (terms, i)=>(0, _frenchJsDefault.default).preL(terms, i),
    // d'amerique
    d: (terms, i)=>(0, _frenchJsDefault.default).preD(terms, i)
};
// pull-apart known contractions from model
const knownOnes = function(list, term, before, after) {
    for(let i = 0; i < list.length; i += 1){
        let o = list[i];
        // look for word-word match (cannot-> [can, not])
        if (o.word === term.normal) return o.out;
        else if (after !== null && after === o.after) return [
            before
        ].concat(o.out);
        else if (before !== null && before === o.before && after && after.length > 2) return o.out.concat(after);
    }
    return null;
};
const toDocs = function(words, view) {
    let doc = view.fromText(words.join(" "));
    doc.compute([
        "id",
        "alias"
    ]);
    return doc.docs[0];
};
// there's is usually [there, is]
// but can be 'there has' for 'there has (..) been'
const thereHas = function(terms, i) {
    for(let k = i + 1; k < 5; k += 1){
        if (!terms[k]) break;
        if (terms[k].normal === "been") return [
            "there",
            "has"
        ];
    }
    return [
        "there",
        "is"
    ];
};
//really easy ones
const contractions = (view)=>{
    let { world, document } = view;
    const { model, methods } = world;
    let list = model.one.contractions || [];
    // let units = new Set(model.one.units || [])
    // each sentence
    document.forEach((terms, n)=>{
        // loop through terms backwards
        for(let i = terms.length - 1; i >= 0; i -= 1){
            let before = null;
            let after = null;
            if (byApostrophe.test(terms[i].normal) === true) {
                let res = terms[i].normal.split(byApostrophe);
                before = res[0];
                after = res[1];
            }
            // any known-ones, like 'dunno'?
            let words = knownOnes(list, terms[i], before, after);
            // ['foo', 's']
            if (!words && byEnd.hasOwnProperty(after)) words = byEnd[after](terms, i, world);
            // ['j', 'aime']
            if (!words && byStart.hasOwnProperty(before)) words = byStart[before](terms, i);
            // 'there is' vs 'there has'
            if (before === "there" && after === "s") words = thereHas(terms, i);
            // actually insert the new terms
            if (words) {
                words = toDocs(words, view);
                (0, _spliceJsDefault.default)(document, [
                    n,
                    i
                ], words);
                reTag(document[n], view, i, words.length);
                continue;
            }
            // '44-2' has special care
            if (numDash.test(terms[i].normal)) {
                words = (0, _numberRangeJsDefault.default)(terms, i);
                if (words) {
                    words = toDocs(words, view);
                    (0, _spliceJsDefault.default)(document, [
                        n,
                        i
                    ], words);
                    methods.one.setTag(words, "NumberRange", world) //add custom tag
                    ;
                    // is it a time-range, like '5-9pm'
                    if (words[2] && words[2].tags.has("Time")) methods.one.setTag([
                        words[0]
                    ], "Time", world, null, "time-range");
                    reTag(document[n], view, i, words.length);
                }
                continue;
            }
            // split-apart '4km'
            words = (0, _numberUnitJsDefault.default)(terms, i, world);
            if (words) {
                words = toDocs(words, view);
                (0, _spliceJsDefault.default)(document, [
                    n,
                    i
                ], words);
                methods.one.setTag([
                    words[1]
                ], "Unit", world, null, "contraction-unit");
            }
        }
    });
};
exports.default = contractions;

},{"./_splice.js":"31tmz","./apostrophe-d.js":"f5rwG","./apostrophe-t.js":"aYh7X","./french.js":"gs5Aa","./number-range.js":"fhyKH","./number-unit.js":"7gKLi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"31tmz":[function(require,module,exports) {
// put n new words where 1 word was
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const insertContraction = function(document, point, words) {
    let [n, w] = point;
    if (!words || words.length === 0) return;
    words = words.map((word, i)=>{
        word.implicit = word.text;
        word.machine = word.text;
        word.pre = "";
        word.post = "";
        word.text = "";
        word.normal = "";
        word.index = [
            n,
            w + i
        ];
        return word;
    });
    if (words[0]) {
        // move whitespace over
        words[0].pre = document[n][w].pre;
        words[words.length - 1].post = document[n][w].post;
        // add the text/normal to the first term
        words[0].text = document[n][w].text;
        words[0].normal = document[n][w].normal // move tags too?
        ;
    }
    // do the splice
    document[n].splice(w, 1, ...words);
};
exports.default = insertContraction;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f5rwG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const hasContraction = /'/;
//look for a past-tense verb
// const hasPastTense = (terms, i) => {
//   let after = terms.slice(i + 1, i + 3)
//   return after.some(t => t.tags.has('PastTense'))
// }
// he'd walked -> had
// how'd -> did
// he'd go -> would
const alwaysDid = new Set([
    "what",
    "how",
    "when",
    "where",
    "why"
]);
// after-words
const useWould = new Set([
    "be",
    "go",
    "start",
    "think",
    "need"
]);
const useHad = new Set([
    "been",
    "gone"
]);
// they'd gone
// they'd go
// he'd been
//    he had been
//    he would been
const _apostropheD = function(terms, i) {
    let before = terms[i].normal.split(hasContraction)[0];
    // what'd, how'd
    if (alwaysDid.has(before)) return [
        before,
        "did"
    ];
    if (terms[i + 1]) {
        // they'd gone
        if (useHad.has(terms[i + 1].normal)) return [
            before,
            "had"
        ];
        // they'd go
        if (useWould.has(terms[i + 1].normal)) return [
            before,
            "would"
        ];
    }
    return null;
//   if (hasPastTense(terms, i) === true) {
//     return [before, 'had']
//   }
//   // had/would/did
//   return [before, 'would']
};
exports.default = _apostropheD;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aYh7X":[function(require,module,exports) {
//ain't -> are/is not
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const apostropheT = function(terms, i) {
    if (terms[i].normal === "ain't" || terms[i].normal === "aint") return null //do this in ./two/
    ;
    let before = terms[i].normal.replace(/n't/, "");
    return [
        before,
        "not"
    ];
};
exports.default = apostropheT;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gs5Aa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const hasContraction = /'/;
const isFeminine = /(e|é|aison|sion|tion)$/;
const isMasculine = /(age|isme|acle|ege|oire)$/;
// l'amour
const preL = (terms, i)=>{
    // le/la
    let after = terms[i].normal.split(hasContraction)[1];
    // quick french gender disambig (rough)
    if (after && after.endsWith("e")) return [
        "la",
        after
    ];
    return [
        "le",
        after
    ];
};
// d'amerique
const preD = (terms, i)=>{
    let after = terms[i].normal.split(hasContraction)[1];
    // quick guess for noun-agreement (rough)
    if (after && isFeminine.test(after) && !isMasculine.test(after)) return [
        "du",
        after
    ];
    else if (after && after.endsWith("s")) return [
        "des",
        after
    ];
    return [
        "de",
        after
    ];
};
// j'aime
const preJ = (terms, i)=>{
    let after = terms[i].normal.split(hasContraction)[1];
    return [
        "je",
        after
    ];
};
exports.default = {
    preJ,
    preL,
    preD
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fhyKH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isRange = /^([0-9.]{1,4}[a-z]{0,2}) ?[-–—] ?([0-9]{1,4}[a-z]{0,2})$/i;
const timeRange = /^([0-9]{1,2}(:[0-9][0-9])?(am|pm)?) ?[-–—] ?([0-9]{1,2}(:[0-9][0-9])?(am|pm)?)$/i;
const phoneNum = /^[0-9]{3}-[0-9]{4}$/;
const numberRange = function(terms, i) {
    let term = terms[i];
    let parts = term.text.match(isRange);
    if (parts !== null) {
        // 123-1234 is a phone number, not a number-range
        if (term.tags.has("PhoneNumber") === true || phoneNum.test(term.text)) return null;
        return [
            parts[1],
            "to",
            parts[2]
        ];
    } else {
        parts = term.text.match(timeRange);
        if (parts !== null) return [
            parts[1],
            "to",
            parts[4]
        ];
    }
    return null;
};
exports.default = numberRange;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7gKLi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const numUnit = /^([+-]?[0-9][.,0-9]*)([a-z°²³µ/]+)$/ //(must be lowercase)
;
const numberUnit = function(terms, i, world) {
    const notUnit = world.model.one.numberSuffixes || {};
    let term = terms[i];
    let parts = term.text.match(numUnit);
    if (parts !== null) {
        // is it a recognized unit, like 'km'?
        let unit = parts[2].toLowerCase().trim();
        // don't split '3rd'
        if (notUnit.hasOwnProperty(unit)) return null;
        return [
            parts[1],
            unit
        ] //split it
        ;
    }
    return null;
};
exports.default = numberUnit;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9kMQI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    // lib: {
    //   freeze: function (obj) {
    //     this.world().model.two.freeze = obj
    //   },
    // },
    mutate: (world)=>{
        // add @isFrozen method
        world.methods.one.termMethods.isFrozen = (term)=>term.frozen === true;
    },
    api: function(View) {
        // set all terms to reject any desctructive tags
        View.prototype.freeze = function() {
            this.docs.forEach((ts)=>{
                ts.forEach((term)=>{
                    term.frozen = true;
                });
            });
            return this;
        };
        // reset all terms to allow  any desctructive tags
        View.prototype.unfreeze = function() {
            this.docs.forEach((ts)=>{
                ts.forEach((term)=>{
                    delete term.frozen;
                });
            });
            return this;
        };
        // return all frozen terms
        View.prototype.isFrozen = function() {
            return this.match("@isFrozen+");
        };
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4HcRQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./compute/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./methods/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _libJs = require("./lib.js");
var _libJsDefault = parcelHelpers.interopDefault(_libJs);
const model = {
    one: {
        lexicon: {},
        _multiCache: {},
        frozenLex: {}
    }
};
exports.default = {
    model,
    methods: (0, _indexJsDefault1.default),
    compute: (0, _indexJsDefault.default),
    lib: (0, _libJsDefault.default),
    hooks: [
        "lexicon"
    ]
};

},{"./compute/index.js":"hWFuE","./methods/index.js":"hQ6n5","./lib.js":"b1TmY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hWFuE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _multiWordJs = require("./multi-word.js");
var _multiWordJsDefault = parcelHelpers.interopDefault(_multiWordJs);
var _singleWordJs = require("./single-word.js");
var _singleWordJsDefault = parcelHelpers.interopDefault(_singleWordJs);
// tag any words in our lexicon - even if it hasn't been filled-up yet
// rest of pre-tagger is in ./two/preTagger
const lexicon = function(view) {
    const world = view.world;
    view.docs.forEach((terms)=>{
        for(let i = 0; i < terms.length; i += 1)if (terms[i].tags.size === 0) {
            let found = null;
            found = found || (0, _multiWordJsDefault.default)(terms, i, world);
            // lookup known words
            found = found || (0, _singleWordJsDefault.default)(terms, i, world);
        }
    });
};
exports.default = {
    lexicon
};

},{"./multi-word.js":"3RnDz","./single-word.js":"kW0l3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3RnDz":[function(require,module,exports) {
// scan-ahead to match multiple-word terms - 'jack rabbit'
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const multiWord = function(terms, start_i, world) {
    const { model, methods } = world;
    const setTag = methods.one.setTag;
    const multi = model.one._multiCache || {};
    const { lexicon, frozenLex } = model.one || {};
    let t = terms[start_i];
    let word = t.machine || t.normal;
    // found a word to scan-ahead on
    if (multi[word] !== undefined && terms[start_i + 1]) {
        let end = start_i + multi[word] - 1;
        for(let i = end; i > start_i; i -= 1){
            let words = terms.slice(start_i, i + 1);
            if (words.length <= 1) return false;
            let str = words.map((term)=>term.machine || term.normal).join(" ");
            // lookup frozen lexicon
            if (frozenLex.hasOwnProperty(str) === true) {
                setTag(words, frozenLex[str], world, false, "1-frozen-multi-lexicon");
                words.forEach((term)=>term.frozen = true);
                return true;
            }
            // lookup regular lexicon
            if (lexicon.hasOwnProperty(str) === true) {
                let tag = lexicon[str];
                setTag(words, tag, world, false, "1-multi-lexicon");
                // special case for phrasal-verbs - 2nd word is a #Particle
                if (tag && tag.length === 2 && (tag[0] === "PhrasalVerb" || tag[1] === "PhrasalVerb")) setTag([
                    words[1]
                ], "Particle", world, false, "1-phrasal-particle");
                return true;
            }
        }
        return false;
    }
    return null;
};
exports.default = multiWord;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kW0l3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const prefix = /^(under|over|mis|re|un|dis|semi|pre|post)-?/;
// anti|non|extra|inter|intra|over
const allowPrefix = new Set([
    "Verb",
    "Infinitive",
    "PastTense",
    "Gerund",
    "PresentTense",
    "Adjective",
    "Participle"
]);
// tag any words in our lexicon
const checkLexicon = function(terms, i, world) {
    const { model, methods } = world;
    // const fastTag = methods.one.fastTag
    const setTag = methods.one.setTag;
    const { lexicon, frozenLex } = model.one;
    // basic lexicon lookup
    let t = terms[i];
    let word = t.machine || t.normal;
    // freeze lex
    if (frozenLex[word] !== undefined && frozenLex.hasOwnProperty(word)) {
        setTag([
            t
        ], frozenLex[word], world, false, "1-freeze-lexicon");
        t.frozen = true;
        return true;
    }
    // normal lexicon lookup
    if (lexicon[word] !== undefined && lexicon.hasOwnProperty(word)) {
        setTag([
            t
        ], lexicon[word], world, false, "1-lexicon");
        return true;
    }
    // lookup aliases in the lexicon
    if (t.alias) {
        let found = t.alias.find((str)=>lexicon.hasOwnProperty(str));
        if (found) {
            setTag([
                t
            ], lexicon[found], world, false, "1-lexicon-alias");
            return true;
        }
    }
    // prefixing for verbs/adjectives
    if (prefix.test(word) === true) {
        let stem = word.replace(prefix, "");
        if (lexicon.hasOwnProperty(stem) && stem.length > 3) // only allow prefixes for verbs/adjectives
        {
            if (allowPrefix.has(lexicon[stem])) {
                // console.log('->', word, stem, lexicon[stem])
                setTag([
                    t
                ], lexicon[stem], world, false, "1-lexicon-prefix");
                return true;
            }
        }
    }
    return null;
};
exports.default = checkLexicon;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hQ6n5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _expandJs = require("./expand.js");
var _expandJsDefault = parcelHelpers.interopDefault(_expandJs);
exports.default = {
    one: {
        expandLexicon: (0, _expandJsDefault.default)
    }
};

},{"./expand.js":"krdVf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"krdVf":[function(require,module,exports) {
// derive clever things from our lexicon key-value pairs
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const expand = function(words) {
    // const { methods, model } = world
    let lex = {};
    // console.log('start:', Object.keys(lex).length)
    let _multi = {};
    // go through each word in this key-value obj:
    Object.keys(words).forEach((word)=>{
        let tag = words[word];
        // normalize lexicon a little bit
        word = word.toLowerCase().trim();
        word = word.replace(/'s\b/, "");
        // cache multi-word terms
        let split = word.split(/ /);
        if (split.length > 1) // prefer longer ones
        {
            if (_multi[split[0]] === undefined || split.length > _multi[split[0]]) _multi[split[0]] = split.length;
        }
        lex[word] = lex[word] || tag;
    });
    // cleanup
    delete lex[""];
    delete lex[null];
    delete lex[" "];
    return {
        lex,
        _multi
    };
};
exports.default = expand;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b1TmY":[function(require,module,exports) {
/** insert new words/phrases into the lexicon */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const addWords = function(words, isFrozen = false) {
    const world = this.world();
    const { methods, model } = world;
    if (!words) return;
    // normalize tag vals
    Object.keys(words).forEach((k)=>{
        if (typeof words[k] === "string" && words[k].startsWith("#")) words[k] = words[k].replace(/^#/, "");
    });
    // these words go into a seperate lexicon
    if (isFrozen === true) {
        let { lex, _multi } = methods.one.expandLexicon(words, world);
        Object.assign(model.one._multiCache, _multi);
        Object.assign(model.one.frozenLex, lex);
        return;
    }
    // add some words to our lexicon
    if (methods.two.expandLexicon) {
        // do fancy ./two version
        let { lex, _multi } = methods.two.expandLexicon(words, world);
        Object.assign(model.one.lexicon, lex);
        Object.assign(model.one._multiCache, _multi);
    }
    // do basic ./one version
    let { lex, _multi } = methods.one.expandLexicon(words, world);
    Object.assign(model.one.lexicon, lex);
    Object.assign(model.one._multiCache, _multi);
};
exports.default = {
    addWords
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fXsy1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./api/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _compressJs = require("./api/buildTrie/compress.js");
var _compressJsDefault = parcelHelpers.interopDefault(_compressJs);
var _indexJs1 = require("./api/buildTrie/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
/** pre-compile a list of matches to lookup */ const lib = {
    /** turn an array or object into a compressed trie*/ buildTrie: function(input) {
        const trie = (0, _indexJsDefault1.default)(input, this.world());
        return (0, _compressJsDefault.default)(trie);
    }
};
// add alias
lib.compile = lib.buildTrie;
exports.default = {
    api: (0, _indexJsDefault.default),
    lib
};

},{"./api/index.js":"lDpAu","./api/buildTrie/compress.js":"asqsr","./api/buildTrie/index.js":"Hv50b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lDpAu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>function(View) {
        /** find all matches in this document */ View.prototype.lookup = function(input, opts = {}) {
            if (!input) return this.none();
            if (typeof input === "string") input = [
                input
            ];
            let trie = isObject(input) ? input : (0, _indexJsDefault.default)(input, this.world);
            let res = (0, _scanJsDefault.default)(this, trie, opts);
            res = res.settle();
            return res;
        };
    });
var _indexJs = require("./buildTrie/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _scanJs = require("./scan.js");
var _scanJsDefault = parcelHelpers.interopDefault(_scanJs);
const isObject = (val)=>{
    return Object.prototype.toString.call(val) === "[object Object]";
};

},{"./buildTrie/index.js":"Hv50b","./scan.js":"lPH6h","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Hv50b":[function(require,module,exports) {
// edited by Spencer Kelly
// credit to https://github.com/BrunoRB/ahocorasick by Bruno Roberto Búrigo.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const tokenize = function(phrase, world) {
    const { methods, model } = world;
    let terms = methods.one.tokenize.splitTerms(phrase, model).map((t)=>methods.one.tokenize.splitWhitespace(t, model));
    return terms.map((term)=>term.text.toLowerCase());
};
// turn an array or object into a compressed aho-corasick structure
const buildTrie = function(phrases, world) {
    // const tokenize=methods.one.
    let goNext = [
        {}
    ];
    let endAs = [
        null
    ];
    let failTo = [
        0
    ];
    let xs = [];
    let n = 0;
    phrases.forEach(function(phrase) {
        let curr = 0;
        // let wordsB = phrase.split(/ /g).filter(w => w)
        let words = tokenize(phrase, world);
        for(let i = 0; i < words.length; i++){
            let word = words[i];
            if (goNext[curr] && goNext[curr].hasOwnProperty(word)) curr = goNext[curr][word];
            else {
                n++;
                goNext[curr][word] = n;
                goNext[n] = {};
                curr = n;
                endAs[n] = null;
            }
        }
        endAs[curr] = [
            words.length
        ];
    });
    // f(s) = 0 for all states of depth 1 (the ones from which the 0 state can transition to)
    for(let word in goNext[0]){
        n = goNext[0][word];
        failTo[n] = 0;
        xs.push(n);
    }
    while(xs.length){
        let r = xs.shift();
        // for each symbol a such that g(r, a) = s
        let keys = Object.keys(goNext[r]);
        for(let i = 0; i < keys.length; i += 1){
            let word = keys[i];
            let s = goNext[r][word];
            xs.push(s);
            // set state = f(r)
            n = failTo[r];
            while(n > 0 && !goNext[n].hasOwnProperty(word))n = failTo[n];
            if (goNext.hasOwnProperty(n)) {
                let fs = goNext[n][word];
                failTo[s] = fs;
                if (endAs[fs]) {
                    endAs[s] = endAs[s] || [];
                    endAs[s] = endAs[s].concat(endAs[fs]);
                }
            } else failTo[s] = 0;
        }
    }
    return {
        goNext,
        endAs,
        failTo
    };
};
exports.default = buildTrie // console.log(buildTrie(['smart and cool', 'smart and nice']))
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lPH6h":[function(require,module,exports) {
// follow our trie structure
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const scanWords = function(terms, trie, opts) {
    let n = 0;
    let results = [];
    for(let i = 0; i < terms.length; i++){
        let word = terms[i][opts.form] || terms[i].normal;
        // main match-logic loop:
        while(n > 0 && (trie.goNext[n] === undefined || !trie.goNext[n].hasOwnProperty(word)))n = trie.failTo[n] || 0 // (usually back to 0)
        ;
        // did we fail?
        if (!trie.goNext[n].hasOwnProperty(word)) continue;
        n = trie.goNext[n][word];
        if (trie.endAs[n]) {
            let arr = trie.endAs[n];
            for(let o = 0; o < arr.length; o++){
                let len = arr[o];
                let term = terms[i - len + 1];
                let [no, start] = term.index;
                results.push([
                    no,
                    start,
                    start + len,
                    term.id
                ]);
            }
        }
    }
    return results;
};
const cacheMiss = function(words, cache) {
    for(let i = 0; i < words.length; i += 1){
        if (cache.has(words[i]) === true) return false;
    }
    return true;
};
const scan = function(view, trie, opts) {
    let results = [];
    opts.form = opts.form || "normal";
    let docs = view.docs;
    if (!trie.goNext || !trie.goNext[0]) {
        console.error("Compromise invalid lookup trie") //eslint-disable-line
        ;
        return view.none();
    }
    let firstWords = Object.keys(trie.goNext[0]);
    // do each phrase
    for(let i = 0; i < docs.length; i++){
        // can we skip the phrase, all together?
        if (view._cache && view._cache[i] && cacheMiss(firstWords, view._cache[i]) === true) continue;
        let terms = docs[i];
        let found = scanWords(terms, trie, opts);
        if (found.length > 0) results = results.concat(found);
    }
    return view.update(results);
};
exports.default = scan;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"asqsr":[function(require,module,exports) {
// chop-off tail of redundant vals at end of array
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const truncate = (list, val)=>{
    for(let i = list.length - 1; i >= 0; i -= 1)if (list[i] !== val) {
        list = list.slice(0, i + 1);
        return list;
    }
    return list;
};
// prune trie a bit
const compress = function(trie) {
    trie.goNext = trie.goNext.map((o)=>{
        if (Object.keys(o).length === 0) return undefined;
        return o;
    });
    // chop-off tail of undefined vals in goNext array
    trie.goNext = truncate(trie.goNext, undefined);
    // chop-off tail of zeros in failTo array
    trie.failTo = truncate(trie.failTo, 0);
    // chop-off tail of nulls in endAs array
    trie.endAs = truncate(trie.endAs, null);
    return trie;
};
exports.default = compress;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4pcOC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./api/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./methods/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _libJs = require("./lib.js");
var _libJsDefault = parcelHelpers.interopDefault(_libJs);
exports.default = {
    api: (0, _indexJsDefault.default),
    methods: (0, _indexJsDefault1.default),
    lib: (0, _libJsDefault.default)
};

},{"./api/index.js":"4DTgR","./methods/index.js":"2tvPo","./lib.js":"aQn6C","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4DTgR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _matchJs = require("./match.js");
var _matchJsDefault = parcelHelpers.interopDefault(_matchJs);
var _lookaroundJs = require("./lookaround.js");
var _lookaroundJsDefault = parcelHelpers.interopDefault(_lookaroundJs);
var _splitJs = require("./split.js");
var _splitJsDefault = parcelHelpers.interopDefault(_splitJs);
const methods = Object.assign({}, (0, _matchJsDefault.default), (0, _lookaroundJsDefault.default), (0, _splitJsDefault.default));
// aliases
methods.lookBehind = methods.before;
methods.lookBefore = methods.before;
methods.lookAhead = methods.after;
methods.lookAfter = methods.after;
methods.notIf = methods.ifNo;
const matchAPI = function(View) {
    Object.assign(View.prototype, methods);
};
exports.default = matchAPI;

},{"./match.js":"e8aTu","./lookaround.js":"fVeSI","./split.js":"2MtYs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e8aTu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("./_lib.js");
const parseRegs = function(regs, opts, world) {
    const one = world.methods.one;
    if (typeof regs === "number") regs = String(regs);
    // support param as string
    if (typeof regs === "string") {
        regs = one.killUnicode(regs, world);
        regs = one.parseMatch(regs, opts, world);
    }
    return regs;
};
const match = function(regs, group, opts) {
    const one = this.methods.one;
    // support param as view object
    if ((0, _libJs.isView)(regs)) return this.intersection(regs);
    // support a compiled set of matches
    if ((0, _libJs.isNet)(regs)) return this.sweep(regs, {
        tagger: false
    }).view.settle();
    regs = parseRegs(regs, opts, this.world);
    let todo = {
        regs,
        group
    };
    let res = one.match(this.docs, todo, this._cache);
    let { ptrs, byGroup } = (0, _libJs.fixPointers)(res, this.fullPointer);
    let view = this.toView(ptrs);
    view._groups = byGroup;
    return view;
};
const matchOne = function(regs, group, opts) {
    const one = this.methods.one;
    // support at view as a param
    if ((0, _libJs.isView)(regs)) return this.intersection(regs).eq(0);
    // support a compiled set of matches
    if ((0, _libJs.isNet)(regs)) return this.sweep(regs, {
        tagger: false,
        matchOne: true
    }).view;
    regs = parseRegs(regs, opts, this.world);
    let todo = {
        regs,
        group,
        justOne: true
    };
    let res = one.match(this.docs, todo, this._cache);
    let { ptrs, byGroup } = (0, _libJs.fixPointers)(res, this.fullPointer);
    let view = this.toView(ptrs);
    view._groups = byGroup;
    return view;
};
const has = function(regs, group, opts) {
    const one = this.methods.one;
    // support view as input
    if ((0, _libJs.isView)(regs)) {
        let ptrs = regs.fullPointer // support a view object as input
        ;
        return ptrs.length > 0;
    }
    // support a compiled set of matches
    if ((0, _libJs.isNet)(regs)) return this.sweep(regs, {
        tagger: false
    }).view.found;
    regs = parseRegs(regs, opts, this.world);
    let todo = {
        regs,
        group,
        justOne: true
    };
    let ptrs = one.match(this.docs, todo, this._cache).ptrs;
    return ptrs.length > 0;
};
// 'if'
const ifFn = function(regs, group, opts) {
    const one = this.methods.one;
    // support view as input
    if ((0, _libJs.isView)(regs)) return this.filter((m)=>m.intersection(regs).found);
    // support a compiled set of matches
    if ((0, _libJs.isNet)(regs)) {
        let m = this.sweep(regs, {
            tagger: false
        }).view.settle();
        return this.if(m) //recurse with result
        ;
    }
    regs = parseRegs(regs, opts, this.world);
    let todo = {
        regs,
        group,
        justOne: true
    };
    let ptrs = this.fullPointer;
    let cache = this._cache || [];
    ptrs = ptrs.filter((ptr, i)=>{
        let m = this.update([
            ptr
        ]);
        let res = one.match(m.docs, todo, cache[i]).ptrs;
        return res.length > 0;
    });
    let view = this.update(ptrs);
    // try and reconstruct the cache
    if (this._cache) view._cache = ptrs.map((ptr)=>cache[ptr[0]]);
    return view;
};
const ifNo = function(regs, group, opts) {
    const { methods } = this;
    const one = methods.one;
    // support a view object as input
    if ((0, _libJs.isView)(regs)) return this.filter((m)=>!m.intersection(regs).found);
    // support a compiled set of matches
    if ((0, _libJs.isNet)(regs)) {
        let m = this.sweep(regs, {
            tagger: false
        }).view.settle();
        return this.ifNo(m);
    }
    // otherwise parse the match string
    regs = parseRegs(regs, opts, this.world);
    let cache = this._cache || [];
    let view = this.filter((m, i)=>{
        let todo = {
            regs,
            group,
            justOne: true
        };
        let ptrs = one.match(m.docs, todo, cache[i]).ptrs;
        return ptrs.length === 0;
    });
    // try to reconstruct the cache
    if (this._cache) view._cache = view.ptrs.map((ptr)=>cache[ptr[0]]);
    return view;
};
exports.default = {
    matchOne,
    match,
    has,
    if: ifFn,
    ifNo
};

},{"./_lib.js":"5r9li","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5r9li":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "relPointer", ()=>relPointer);
parcelHelpers.export(exports, "fixPointers", ()=>fixPointers);
parcelHelpers.export(exports, "isView", ()=>isView);
parcelHelpers.export(exports, "isNet", ()=>isNet);
const relPointer = function(ptrs, parent) {
    if (!parent) return ptrs;
    ptrs.forEach((ptr)=>{
        let n = ptr[0];
        if (parent[n]) {
            ptr[0] = parent[n][0] //n
            ;
            ptr[1] += parent[n][1] //start
            ;
            ptr[2] += parent[n][1] //end
            ;
        }
    });
    return ptrs;
};
const fixPointers = function(res, parent) {
    let { ptrs, byGroup } = res;
    ptrs = relPointer(ptrs, parent);
    Object.keys(byGroup).forEach((k)=>{
        byGroup[k] = relPointer(byGroup[k], parent);
    });
    return {
        ptrs,
        byGroup
    };
};
const isObject = (val)=>{
    return Object.prototype.toString.call(val) === "[object Object]";
};
const isView = (val)=>val && isObject(val) && val.isView === true;
const isNet = (val)=>val && isObject(val) && val.isNet === true;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fVeSI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const before = function(regs, group, opts) {
    const { indexN } = this.methods.one.pointer;
    let pre = [];
    let byN = indexN(this.fullPointer);
    Object.keys(byN).forEach((k)=>{
        // check only the earliest match in the sentence
        let first = byN[k].sort((a, b)=>a[1] > b[1] ? 1 : -1)[0];
        if (first[1] > 0) pre.push([
            first[0],
            0,
            first[1]
        ]);
    });
    let preWords = this.toView(pre);
    if (!regs) return preWords;
    return preWords.match(regs, group, opts);
};
const after = function(regs, group, opts) {
    const { indexN } = this.methods.one.pointer;
    let post = [];
    let byN = indexN(this.fullPointer);
    let document = this.document;
    Object.keys(byN).forEach((k)=>{
        // check only the latest match in the sentence
        let last = byN[k].sort((a, b)=>a[1] > b[1] ? -1 : 1)[0];
        let [n, , end] = last;
        if (end < document[n].length) post.push([
            n,
            end,
            document[n].length
        ]);
    });
    let postWords = this.toView(post);
    if (!regs) return postWords;
    return postWords.match(regs, group, opts);
};
const growLeft = function(regs, group, opts) {
    if (typeof regs === "string") regs = this.world.methods.one.parseMatch(regs, opts, this.world);
    regs[regs.length - 1].end = true // ensure matches are beside us ←
    ;
    let ptrs = this.fullPointer;
    this.forEach((m, n)=>{
        let more = m.before(regs, group);
        if (more.found) {
            let terms = more.terms();
            ptrs[n][1] -= terms.length;
            ptrs[n][3] = terms.docs[0][0].id;
        }
    });
    return this.update(ptrs);
};
const growRight = function(regs, group, opts) {
    if (typeof regs === "string") regs = this.world.methods.one.parseMatch(regs, opts, this.world);
    regs[0].start = true // ensure matches are beside us →
    ;
    let ptrs = this.fullPointer;
    this.forEach((m, n)=>{
        let more = m.after(regs, group);
        if (more.found) {
            let terms = more.terms();
            ptrs[n][2] += terms.length;
            ptrs[n][4] = null //remove end-id
            ;
        }
    });
    return this.update(ptrs);
};
const grow = function(regs, group, opts) {
    return this.growRight(regs, group, opts).growLeft(regs, group, opts);
};
exports.default = {
    before,
    after,
    growLeft,
    growRight,
    grow
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2MtYs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const combine = function(left, right) {
    return [
        left[0],
        left[1],
        right[2]
    ];
};
const isArray = function(arr) {
    return Object.prototype.toString.call(arr) === "[object Array]";
};
const getDoc = (reg, view, group)=>{
    if (typeof reg === "string" || isArray(reg)) return view.match(reg, group);
    if (!reg) return view.none();
    return reg;
};
const addIds = function(ptr, view) {
    let [n, start, end] = ptr;
    if (view.document[n] && view.document[n][start]) {
        ptr[3] = ptr[3] || view.document[n][start].id;
        if (view.document[n][end - 1]) ptr[4] = ptr[4] || view.document[n][end - 1].id;
    }
    return ptr;
};
const methods = {};
// [before], [match], [after]
methods.splitOn = function(m, group) {
    const { splitAll } = this.methods.one.pointer;
    let splits = getDoc(m, this, group).fullPointer;
    let all = splitAll(this.fullPointer, splits);
    let res = [];
    all.forEach((o)=>{
        res.push(o.passthrough);
        res.push(o.before);
        res.push(o.match);
        res.push(o.after);
    });
    res = res.filter((p)=>p);
    res = res.map((p)=>addIds(p, this));
    return this.update(res);
};
// [before], [match after]
methods.splitBefore = function(m, group) {
    const { splitAll } = this.methods.one.pointer;
    let splits = getDoc(m, this, group).fullPointer;
    let all = splitAll(this.fullPointer, splits);
    // repair matches to favor [match, after]
    // - instead of [before, match]
    for(let i = 0; i < all.length; i += 1){
        // move a before to a preceding after
        if (!all[i].after && all[i + 1] && all[i + 1].before) // ensure it's from the same original sentence
        {
            if (all[i].match && all[i].match[0] === all[i + 1].before[0]) {
                all[i].after = all[i + 1].before;
                delete all[i + 1].before;
            }
        }
    }
    let res = [];
    all.forEach((o)=>{
        res.push(o.passthrough);
        res.push(o.before);
        // a, [x, b]
        if (o.match && o.after) res.push(combine(o.match, o.after));
        else // a, [x], b
        res.push(o.match);
    });
    res = res.filter((p)=>p);
    res = res.map((p)=>addIds(p, this));
    return this.update(res);
};
// [before match], [after]
methods.splitAfter = function(m, group) {
    const { splitAll } = this.methods.one.pointer;
    let splits = getDoc(m, this, group).fullPointer;
    let all = splitAll(this.fullPointer, splits);
    let res = [];
    all.forEach((o)=>{
        res.push(o.passthrough);
        if (o.before && o.match) res.push(combine(o.before, o.match));
        else {
            res.push(o.before);
            res.push(o.match);
        }
        res.push(o.after);
    });
    res = res.filter((p)=>p);
    res = res.map((p)=>addIds(p, this));
    return this.update(res);
};
methods.split = methods.splitAfter;
exports.default = methods;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2tvPo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./parseMatch/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./match/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _termMethodsJs = require("./termMethods.js");
var _termMethodsJsDefault = parcelHelpers.interopDefault(_termMethodsJs);
const methods = {
    one: {
        termMethods: (0, _termMethodsJsDefault.default),
        parseMatch: (0, _indexJsDefault.default),
        match: (0, _indexJsDefault1.default)
    }
};
exports.default = methods;

},{"./parseMatch/index.js":"jFQ3E","./match/index.js":"ik9Lw","./termMethods.js":"7pXmB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jFQ3E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _01ParseBlocksJs = require("./01-parseBlocks.js");
var _01ParseBlocksJsDefault = parcelHelpers.interopDefault(_01ParseBlocksJs);
var _02ParseTokenJs = require("./02-parseToken.js");
var _02ParseTokenJsDefault = parcelHelpers.interopDefault(_02ParseTokenJs);
var _03SplitHyphensJs = require("./03-splitHyphens.js");
var _03SplitHyphensJsDefault = parcelHelpers.interopDefault(_03SplitHyphensJs);
var _04InflectRootJs = require("./04-inflect-root.js");
var _04InflectRootJsDefault = parcelHelpers.interopDefault(_04InflectRootJs);
var _05PostProcessJs = require("./05-postProcess.js");
var _05PostProcessJsDefault = parcelHelpers.interopDefault(_05PostProcessJs);
/** parse a match-syntax string into json */ const syntax = function(input, opts, world) {
    // fail-fast
    if (input === null || input === undefined || input === "") return [];
    opts = opts || {};
    if (typeof input === "number") input = String(input) //go for it?
    ;
    let tokens = (0, _01ParseBlocksJsDefault.default)(input);
    //turn them into objects
    tokens = tokens.map((str)=>(0, _02ParseTokenJsDefault.default)(str, opts));
    // '~re-do~'
    tokens = (0, _03SplitHyphensJsDefault.default)(tokens, world);
    // '{walk}'
    tokens = (0, _04InflectRootJsDefault.default)(tokens, world);
    //clean up anything weird
    tokens = (0, _05PostProcessJsDefault.default)(tokens, opts);
    // console.log(tokens)
    return tokens;
};
exports.default = syntax;

},{"./01-parseBlocks.js":"kaP68","./02-parseToken.js":"jggx9","./03-splitHyphens.js":"jr0NV","./04-inflect-root.js":"ghB87","./05-postProcess.js":"dBxKU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kaP68":[function(require,module,exports) {
// match  'foo /yes/' and not 'foo/no/bar'
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const bySlashes = /(?:^|\s)([![^]*(?:<[^<]*>)?\/.*?[^\\/]\/[?\]+*$~]*)(?:\s|$)/;
// match '(yes) but not foo(no)bar'
const byParentheses = /([!~[^]*(?:<[^<]*>)?\([^)]+[^\\)]\)[?\]+*$~]*)(?:\s|$)/;
// okay
const byWord = / /g;
const isBlock = (str)=>{
    return /^[![^]*(<[^<]*>)?\(/.test(str) && /\)[?\]+*$~]*$/.test(str);
};
const isReg = (str)=>{
    return /^[![^]*(<[^<]*>)?\//.test(str) && /\/[?\]+*$~]*$/.test(str);
};
const cleanUp = function(arr) {
    arr = arr.map((str)=>str.trim());
    arr = arr.filter((str)=>str);
    return arr;
};
const parseBlocks = function(txt) {
    // parse by /regex/ first
    let arr = txt.split(bySlashes);
    let res = [];
    // parse by (blocks), next
    arr.forEach((str)=>{
        if (isReg(str)) {
            res.push(str);
            return;
        }
        res = res.concat(str.split(byParentheses));
    });
    res = cleanUp(res);
    // split by spaces, now
    let final = [];
    res.forEach((str)=>{
        if (isBlock(str)) final.push(str);
        else if (isReg(str)) final.push(str);
        else final = final.concat(str.split(byWord));
    });
    final = cleanUp(final);
    return final;
};
exports.default = parseBlocks;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jggx9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const hasMinMax = /\{([0-9]+)?(, *[0-9]*)?\}/;
const andSign = /&&/;
// const hasDash = /\p{Letter}[-–—]\p{Letter}/u
const captureName = new RegExp(/^<\s*(\S+)\s*>/);
/* break-down a match expression into this:
{
  word:'',
  tag:'',
  regex:'',

  start:false,
  end:false,
  negative:false,
  anything:false,
  greedy:false,
  optional:false,

  named:'',
  choices:[],
}
*/ const titleCase = (str)=>str.charAt(0).toUpperCase() + str.substring(1);
const end = (str)=>str.charAt(str.length - 1);
const start = (str)=>str.charAt(0);
const stripStart = (str)=>str.substring(1);
const stripEnd = (str)=>str.substring(0, str.length - 1);
const stripBoth = function(str) {
    str = stripStart(str);
    str = stripEnd(str);
    return str;
};
//
const parseToken = function(w, opts) {
    let obj = {};
    //collect any flags (do it twice)
    for(let i = 0; i < 2; i += 1){
        //end-flag
        if (end(w) === "$") {
            obj.end = true;
            w = stripEnd(w);
        }
        //front-flag
        if (start(w) === "^") {
            obj.start = true;
            w = stripStart(w);
        }
        if (end(w) === "?") {
            obj.optional = true;
            w = stripEnd(w);
        }
        //capture group (this one can span multiple-terms)
        if (start(w) === "[" || end(w) === "]") {
            obj.group = null;
            if (start(w) === "[") obj.groupStart = true;
            if (end(w) === "]") obj.groupEnd = true;
            w = w.replace(/^\[/, "");
            w = w.replace(/\]$/, "");
            // Use capture group name
            if (start(w) === "<") {
                const res = captureName.exec(w);
                if (res.length >= 2) {
                    obj.group = res[1];
                    w = w.replace(res[0], "");
                }
            }
        }
        //back-flags
        if (end(w) === "+") {
            obj.greedy = true;
            w = stripEnd(w);
        }
        if (w !== "*" && end(w) === "*" && w !== "\\*") {
            obj.greedy = true;
            w = stripEnd(w);
        }
        if (start(w) === "!") {
            obj.negative = true;
            // obj.optional = true
            w = stripStart(w);
        }
        //soft-match
        if (start(w) === "~" && end(w) === "~" && w.length > 2) {
            w = stripBoth(w);
            obj.fuzzy = true;
            obj.min = opts.fuzzy || 0.85;
            if (/\(/.test(w) === false) {
                obj.word = w;
                return obj;
            }
        }
        //regex
        if (start(w) === "/" && end(w) === "/") {
            w = stripBoth(w);
            if (opts.caseSensitive) obj.use = "text";
            obj.regex = new RegExp(w) //potential vuln - security/detect-non-literal-regexp
            ;
            return obj;
        }
        // support foo{1,9}
        if (hasMinMax.test(w) === true) w = w.replace(hasMinMax, (_a, b, c)=>{
            if (c === undefined) {
                // '{3}'	Exactly three times
                obj.min = Number(b);
                obj.max = Number(b);
            } else {
                c = c.replace(/, */, "");
                if (b === undefined) {
                    // '{,9}' implied zero min
                    obj.min = 0;
                    obj.max = Number(c);
                } else {
                    // '{2,4}' Two to four times
                    obj.min = Number(b);
                    // '{3,}' Three or more times
                    obj.max = Number(c || 999);
                }
            }
            // use same method as '+'
            obj.greedy = true;
            // 0 as min means the same as '?'
            if (!obj.min) obj.optional = true;
            return "";
        });
        //wrapped-flags
        if (start(w) === "(" && end(w) === ")") {
            // support (one && two)
            if (andSign.test(w)) {
                obj.choices = w.split(andSign);
                obj.operator = "and";
            } else {
                obj.choices = w.split("|");
                obj.operator = "or";
            }
            //remove '(' and ')'
            obj.choices[0] = stripStart(obj.choices[0]);
            let last = obj.choices.length - 1;
            obj.choices[last] = stripEnd(obj.choices[last]);
            // clean up the results
            obj.choices = obj.choices.map((s)=>s.trim());
            obj.choices = obj.choices.filter((s)=>s);
            //recursion alert!
            obj.choices = obj.choices.map((str)=>{
                return str.split(/ /g).map((s)=>parseToken(s, opts));
            });
            w = "";
        }
        //root/sense overloaded
        if (start(w) === "{" && end(w) === "}") {
            w = stripBoth(w);
            // obj.sense = w
            obj.root = w;
            if (/\//.test(w)) {
                let split = obj.root.split(/\//);
                obj.root = split[0];
                obj.pos = split[1];
                if (obj.pos === "adj") obj.pos = "Adjective";
                // titlecase
                obj.pos = obj.pos.charAt(0).toUpperCase() + obj.pos.substr(1).toLowerCase();
                // add sense-number too
                if (split[2] !== undefined) obj.sense = split[2];
            }
            return obj;
        }
        //chunks
        if (start(w) === "<" && end(w) === ">") {
            w = stripBoth(w);
            obj.chunk = titleCase(w);
            obj.greedy = true;
            return obj;
        }
        if (start(w) === "%" && end(w) === "%") {
            w = stripBoth(w);
            obj.switch = w;
            return obj;
        }
    }
    //do the actual token content
    if (start(w) === "#") {
        obj.tag = stripStart(w);
        obj.tag = titleCase(obj.tag);
        return obj;
    }
    //dynamic function on a term object
    if (start(w) === "@") {
        obj.method = stripStart(w);
        return obj;
    }
    if (w === ".") {
        obj.anything = true;
        return obj;
    }
    //support alone-astrix
    if (w === "*") {
        obj.anything = true;
        obj.greedy = true;
        obj.optional = true;
        return obj;
    }
    if (w) {
        //somehow handle encoded-chars?
        w = w.replace("\\*", "*");
        w = w.replace("\\.", ".");
        if (opts.caseSensitive) obj.use = "text";
        else w = w.toLowerCase();
        obj.word = w;
    }
    return obj;
};
exports.default = parseToken;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jr0NV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const hasDash = /[a-z0-9][-–—][a-z]/i;
// match 're-do' -> ['re','do']
const splitHyphens = function(regs, world) {
    let prefixes = world.model.one.prefixes;
    for(let i = regs.length - 1; i >= 0; i -= 1){
        let reg = regs[i];
        if (reg.word && hasDash.test(reg.word)) {
            let words = reg.word.split(/[-–—]/g);
            // don't split 're-cycle', etc
            if (prefixes.hasOwnProperty(words[0])) continue;
            words = words.filter((w)=>w).reverse();
            regs.splice(i, 1);
            words.forEach((w)=>{
                let obj = Object.assign({}, reg);
                obj.word = w;
                regs.splice(i, 0, obj);
            });
        }
    }
    return regs;
};
exports.default = splitHyphens;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ghB87":[function(require,module,exports) {
// add all conjugations of this verb
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const addVerbs = function(token, world) {
    let { all } = world.methods.two.transform.verb || {};
    let str = token.root;
    if (!all) return [];
    return all(str, world.model);
};
// add all inflections of this noun
const addNoun = function(token, world) {
    let { all } = world.methods.two.transform.noun || {};
    if (!all) return [
        token.root
    ];
    return all(token.root, world.model);
};
// add all inflections of this adjective
const addAdjective = function(token, world) {
    let { all } = world.methods.two.transform.adjective || {};
    if (!all) return [
        token.root
    ];
    return all(token.root, world.model);
};
// turn '{walk}' into 'walking', 'walked', etc
const inflectRoot = function(regs, world) {
    // do we have compromise/two?
    regs = regs.map((token)=>{
        // a reg to convert '{foo}'
        if (token.root) {
            // check if compromise/two is loaded
            if (world.methods.two && world.methods.two.transform) {
                let choices = [];
                // have explicitly set from POS - '{sweet/adjective}'
                if (token.pos) {
                    if (token.pos === "Verb") choices = choices.concat(addVerbs(token, world));
                    else if (token.pos === "Noun") choices = choices.concat(addNoun(token, world));
                    else if (token.pos === "Adjective") choices = choices.concat(addAdjective(token, world));
                } else {
                    // do verb/noun/adj by default
                    choices = choices.concat(addVerbs(token, world));
                    choices = choices.concat(addNoun(token, world));
                    choices = choices.concat(addAdjective(token, world));
                }
                choices = choices.filter((str)=>str);
                if (choices.length > 0) {
                    token.operator = "or";
                    token.fastOr = new Set(choices);
                }
            } else {
                // if no compromise/two, drop down into 'machine' lookup
                token.machine = token.root;
                delete token.id;
                delete token.root;
            }
        }
        return token;
    });
    return regs;
};
exports.default = inflectRoot;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dBxKU":[function(require,module,exports) {
// name any [unnamed] capture-groups with a number
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const nameGroups = function(regs) {
    let index = 0;
    let inGroup = null;
    //'fill in' capture groups between start-end
    for(let i = 0; i < regs.length; i++){
        const token = regs[i];
        if (token.groupStart === true) {
            inGroup = token.group;
            if (inGroup === null) {
                inGroup = String(index);
                index += 1;
            }
        }
        if (inGroup !== null) token.group = inGroup;
        if (token.groupEnd === true) inGroup = null;
    }
    return regs;
};
// optimize an 'or' lookup, when the (a|b|c) list is simple or multi-word
const doFastOrMode = function(tokens) {
    return tokens.map((token)=>{
        if (token.choices !== undefined) {
            // make sure it's an OR
            if (token.operator !== "or") return token;
            if (token.fuzzy === true) return token;
            // are they all straight-up words? then optimize them.
            let shouldPack = token.choices.every((block)=>{
                if (block.length !== 1) return false;
                let reg = block[0];
                // ~fuzzy~ words need more care
                if (reg.fuzzy === true) return false;
                // ^ and $ get lost in fastOr
                if (reg.start || reg.end) return false;
                if (reg.word !== undefined && reg.negative !== true && reg.optional !== true && reg.method !== true) return true //reg is simple-enough
                ;
                return false;
            });
            if (shouldPack === true) {
                token.fastOr = new Set();
                token.choices.forEach((block)=>{
                    token.fastOr.add(block[0].word);
                });
                delete token.choices;
            }
        }
        return token;
    });
};
// support ~(a|b|c)~
const fuzzyOr = function(regs) {
    return regs.map((reg)=>{
        if (reg.fuzzy && reg.choices) // pass fuzzy-data to each OR choice
        reg.choices.forEach((r)=>{
            if (r.length === 1 && r[0].word) {
                r[0].fuzzy = true;
                r[0].min = reg.min;
            }
        });
        return reg;
    });
};
const postProcess = function(regs) {
    // ensure all capture groups names are filled between start and end
    regs = nameGroups(regs);
    // convert 'choices' format to 'fastOr' format
    regs = doFastOrMode(regs);
    // support ~(foo|bar)~
    regs = fuzzyOr(regs);
    return regs;
};
exports.default = postProcess;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ik9Lw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _01FailFastJs = require("./01-failFast.js");
var _01FailFastJsDefault = parcelHelpers.interopDefault(_01FailFastJs);
var _02FromHereJs = require("./02-from-here.js");
var _02FromHereJsDefault = parcelHelpers.interopDefault(_02FromHereJs);
var _03GetGroupJs = require("./03-getGroup.js");
var _03GetGroupJsDefault = parcelHelpers.interopDefault(_03GetGroupJs);
var _03NotIfJs = require("./03-notIf.js");
var _03NotIfJsDefault = parcelHelpers.interopDefault(_03NotIfJs);
// make proper pointers
const addSentence = function(res, n) {
    res.pointer[0] = n;
    Object.keys(res.groups).forEach((k)=>{
        res.groups[k][0] = n;
    });
    return res;
};
const handleStart = function(terms, regs, n) {
    let res = (0, _02FromHereJsDefault.default)(terms, regs, 0, terms.length);
    if (res) {
        res = addSentence(res, n);
        return res //getGroup([res], group)
        ;
    }
    return null;
};
// ok, here we go.
const runMatch = function(docs, todo, cache) {
    cache = cache || [];
    let { regs, group, justOne } = todo;
    let results = [];
    if (!regs || regs.length === 0) return {
        ptrs: [],
        byGroup: {}
    };
    const minLength = regs.filter((r)=>r.optional !== true && r.negative !== true).length;
    docs: for(let n = 0; n < docs.length; n += 1){
        let terms = docs[n];
        // let index = terms[0].index || []
        // can we skip this sentence?
        if (cache[n] && (0, _01FailFastJsDefault.default)(regs, cache[n])) continue;
        // ^start regs only run once, per phrase
        if (regs[0].start === true) {
            let foundStart = handleStart(terms, regs, n, group);
            if (foundStart) results.push(foundStart);
            continue;
        }
        //ok, try starting the match now from every term
        for(let i = 0; i < terms.length; i += 1){
            let slice = terms.slice(i);
            // ensure it's long-enough
            if (slice.length < minLength) break;
            let res = (0, _02FromHereJsDefault.default)(slice, regs, i, terms.length);
            // did we find a result?
            if (res) {
                // res = addSentence(res, index[0])
                res = addSentence(res, n);
                results.push(res);
                // should we stop here?
                if (justOne === true) break docs;
                // skip ahead, over these results
                let end = res.pointer[2];
                if (Math.abs(end - 1) > i) i = Math.abs(end - 1);
            }
        }
    }
    // ensure any end-results ($) match until the last term
    if (regs[regs.length - 1].end === true) results = results.filter((res)=>{
        let n = res.pointer[0];
        return docs[n].length === res.pointer[2];
    });
    if (todo.notIf) results = (0, _03NotIfJsDefault.default)(results, todo.notIf, docs);
    // grab the requested group
    results = (0, _03GetGroupJsDefault.default)(results, group);
    // add ids to pointers
    results.ptrs.forEach((ptr)=>{
        let [n, start, end] = ptr;
        ptr[3] = docs[n][start].id //start-id
        ;
        ptr[4] = docs[n][end - 1].id //end-id
        ;
    });
    return results;
};
exports.default = runMatch;

},{"./01-failFast.js":"8Qmxo","./02-from-here.js":"jLtR8","./03-getGroup.js":"f8AMl","./03-notIf.js":"9hoCQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Qmxo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const anyIntersection = function(setA, setB) {
    for (let elem of setB){
        if (setA.has(elem)) return true;
    }
    return false;
};
// check words/tags against our cache
const failFast = function(regs, cache) {
    for(let i = 0; i < regs.length; i += 1){
        let reg = regs[i];
        if (reg.optional === true || reg.negative === true || reg.fuzzy === true) continue;
        // is the word missing from the cache?
        if (reg.word !== undefined && cache.has(reg.word) === false) return true;
        // is the tag missing?
        if (reg.tag !== undefined && cache.has("#" + reg.tag) === false) return true;
        // perform a speedup for fast-or
        if (reg.fastOr && anyIntersection(reg.fastOr, cache) === false) return false;
    }
    return false;
};
exports.default = failFast;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jLtR8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _astrixJs = require("./steps/astrix.js");
var _astrixJsDefault = parcelHelpers.interopDefault(_astrixJs);
var _orBlockJs = require("./steps/or-block.js");
var _orBlockJsDefault = parcelHelpers.interopDefault(_orBlockJs);
var _andBlockJs = require("./steps/and-block.js");
var _andBlockJsDefault = parcelHelpers.interopDefault(_andBlockJs);
var _negativeJs = require("./steps/negative.js");
var _negativeJsDefault = parcelHelpers.interopDefault(_negativeJs);
var _simpleMatchJs = require("./steps/simple-match.js");
var _simpleMatchJsDefault = parcelHelpers.interopDefault(_simpleMatchJs);
var _greedyJs = require("./steps/logic/greedy.js");
var _doesMatchJs = require("./term/doesMatch.js");
var _doesMatchJsDefault = parcelHelpers.interopDefault(_doesMatchJs);
// i formally apologize for how complicated this is.
/** 
 * try a sequence of match tokens ('regs') 
 * on a sequence of terms, 
 * starting at this certain term.
 */ const tryHere = function(terms, regs, start_i, phrase_length) {
    // console.log(`\n\n:start: '${terms[0].text}':`)
    if (terms.length === 0 || regs.length === 0) return null;
    // all the variables that matter
    let state = {
        t: 0,
        terms: terms,
        r: 0,
        regs: regs,
        groups: {},
        start_i: start_i,
        phrase_length: phrase_length,
        inGroup: null
    };
    // we must satisfy every token in 'regs'
    // if we get to the end, we have a match.
    for(; state.r < regs.length; state.r += 1){
        let reg = regs[state.r];
        // Check if this reg has a named capture group
        state.hasGroup = Boolean(reg.group);
        // Reuse previous capture group if same
        if (state.hasGroup === true) state.inGroup = reg.group;
        else state.inGroup = null;
        //have we run-out of terms?
        if (!state.terms[state.t]) {
            //are all remaining regs optional or negative?
            const alive = regs.slice(state.r).some((remain)=>!remain.optional);
            if (alive === false) break; //done!
            return null // die
            ;
        }
        // support 'unspecific greedy' .* properly
        if (reg.anything === true && reg.greedy === true) {
            let alive = (0, _astrixJsDefault.default)(state);
            if (!alive) return null;
            continue;
        }
        // slow-OR - multi-word OR (a|b|foo bar)
        if (reg.choices !== undefined && reg.operator === "or") {
            let alive = (0, _orBlockJsDefault.default)(state);
            if (!alive) return null;
            continue;
        }
        // slow-AND - multi-word AND (#Noun && foo) blocks
        if (reg.choices !== undefined && reg.operator === "and") {
            let alive = (0, _andBlockJsDefault.default)(state);
            if (!alive) return null;
            continue;
        }
        // support '.' as any-single
        if (reg.anything === true) {
            // '!.' negative anything should insta-fail
            if (reg.negative && reg.anything) return null;
            let alive = (0, _simpleMatchJsDefault.default)(state);
            if (!alive) return null;
            continue;
        }
        // support 'foo*$' until the end
        if ((0, _greedyJs.isEndGreedy)(reg, state) === true) {
            let alive = (0, _simpleMatchJsDefault.default)(state);
            if (!alive) return null;
            continue;
        }
        // ok, it doesn't match - but maybe it wasn't *supposed* to?
        if (reg.negative) {
            // we want *anything* but this term
            let alive = (0, _negativeJsDefault.default)(state);
            if (!alive) return null;
            continue;
        }
        // ok, finally test the term-reg
        // console.log('   - ' + state.terms[state.t].text)
        let hasMatch = (0, _doesMatchJsDefault.default)(state.terms[state.t], reg, state.start_i + state.t, state.phrase_length);
        if (hasMatch === true) {
            let alive = (0, _simpleMatchJsDefault.default)(state);
            if (!alive) return null;
            continue;
        }
        // console.log('=-=-=-= here -=-=-=-')
        //ok who cares, keep going
        if (reg.optional === true) continue;
        // finally, we die
        return null;
    }
    //return our results, as pointers
    let pntr = [
        null,
        start_i,
        state.t + start_i
    ];
    if (pntr[1] === pntr[2]) return null //found 0 terms
    ;
    let groups = {};
    Object.keys(state.groups).forEach((k)=>{
        let o = state.groups[k];
        let start = start_i + o.start;
        groups[k] = [
            null,
            start,
            start + o.length
        ];
    });
    return {
        pointer: pntr,
        groups: groups
    };
};
exports.default = tryHere;

},{"./steps/astrix.js":"a04dZ","./steps/or-block.js":"39NsJ","./steps/and-block.js":"jy6Uo","./steps/negative.js":"6A2hK","./steps/simple-match.js":"duo1r","./steps/logic/greedy.js":"kj1b3","./term/doesMatch.js":"70Xh3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a04dZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _greedyJs = require("./logic/greedy.js");
var _libJs = require("../_lib.js");
//support 'unspecific greedy' .* properly
// its logic is 'greedy until', where it's looking for the next token
// '.+ foo' means we check for 'foo', indefinetly
const doAstrix = function(state) {
    let { regs } = state;
    let reg = regs[state.r];
    let skipto = (0, _greedyJs.greedyTo)(state, regs[state.r + 1]);
    //maybe we couldn't find it
    if (skipto === null || skipto === 0) return null;
    // ensure it's long enough
    if (reg.min !== undefined && skipto - state.t < reg.min) return null;
    // reduce it back, if it's too long
    if (reg.max !== undefined && skipto - state.t > reg.max) {
        state.t = state.t + reg.max;
        return true;
    }
    // set the group result
    if (state.hasGroup === true) {
        const g = (0, _libJs.getGroup)(state, state.t);
        g.length = skipto - state.t;
    }
    state.t = skipto;
    // log(`✓ |greedy|`)
    return true;
};
exports.default = doAstrix;

},{"./logic/greedy.js":"kj1b3","../_lib.js":"84LuU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kj1b3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isEndGreedy", ()=>isEndGreedy);
parcelHelpers.export(exports, "greedyTo", ()=>greedyTo);
parcelHelpers.export(exports, "getGreedy", ()=>getGreedy);
var _doesMatchJs = require("../../term/doesMatch.js");
var _doesMatchJsDefault = parcelHelpers.interopDefault(_doesMatchJs);
// for greedy checking, we no longer care about the reg.start
// value, and leaving it can cause failures for anchored greedy
// matches.  ditto for end-greedy matches: we need an earlier non-
// ending match to succceed until we get to the actual end.
const getGreedy = function(state, endReg) {
    let reg = Object.assign({}, state.regs[state.r], {
        start: false,
        end: false
    });
    let start = state.t;
    for(; state.t < state.terms.length; state.t += 1){
        //stop for next-reg match
        if (endReg && (0, _doesMatchJsDefault.default)(state.terms[state.t], endReg, state.start_i + state.t, state.phrase_length)) return state.t;
        let count = state.t - start + 1;
        // is it max-length now?
        if (reg.max !== undefined && count === reg.max) return state.t;
        //stop here
        if ((0, _doesMatchJsDefault.default)(state.terms[state.t], reg, state.start_i + state.t, state.phrase_length) === false) {
            // is it too short?
            if (reg.min !== undefined && count < reg.min) return null;
            return state.t;
        }
    }
    return state.t;
};
const greedyTo = function(state, nextReg) {
    let t = state.t;
    //if there's no next one, just go off the end!
    if (!nextReg) return state.terms.length;
    //otherwise, we're looking for the next one
    for(; t < state.terms.length; t += 1){
        if ((0, _doesMatchJsDefault.default)(state.terms[t], nextReg, state.start_i + t, state.phrase_length) === true) // console.log(`greedyTo ${state.terms[t].normal}`)
        return t;
    }
    //guess it doesn't exist, then.
    return null;
};
const isEndGreedy = function(reg, state) {
    if (reg.end === true && reg.greedy === true) {
        if (state.start_i + state.t < state.phrase_length - 1) {
            let tmpReg = Object.assign({}, reg, {
                end: false
            });
            if ((0, _doesMatchJsDefault.default)(state.terms[state.t], tmpReg, state.start_i + state.t, state.phrase_length) === true) // console.log(`endGreedy ${state.terms[state.t].normal}`)
            return true;
        }
    }
    return false;
};

},{"../../term/doesMatch.js":"70Xh3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"70Xh3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fuzzyJs = require("./_fuzzy.js");
var _fuzzyJsDefault = parcelHelpers.interopDefault(_fuzzyJs);
var _termMethodsJs = require("../../termMethods.js"); //this should load off of 'methods.one.termMethods'
var _termMethodsJsDefault = parcelHelpers.interopDefault(_termMethodsJs);
//declare it up here
let wrapMatch = function() {};
/** ignore optional/greedy logic, straight-up term match*/ const doesMatch = function(term, reg, index, length) {
    // support '.'
    if (reg.anything === true) return true;
    // support '^' (in parentheses)
    if (reg.start === true && index !== 0) return false;
    // support '$' (in parentheses)
    if (reg.end === true && index !== length - 1) return false;
    // match an id
    if (reg.id !== undefined && reg.id === term.id) return true;
    //support a text match
    if (reg.word !== undefined) {
        // check case-sensitivity, etc
        if (reg.use) return reg.word === term[reg.use];
        //match contractions, machine-form
        if (term.machine !== null && term.machine === reg.word) return true;
        // term aliases for slashes and things
        if (term.alias !== undefined && term.alias.hasOwnProperty(reg.word)) return true;
        // support ~ fuzzy match
        if (reg.fuzzy === true) {
            if (reg.word === term.root) return true;
            let score = (0, _fuzzyJsDefault.default)(reg.word, term.normal);
            if (score >= reg.min) return true;
        }
        // match slashes and things
        if (term.alias && term.alias.some((str)=>str === reg.word)) return true;
        //match either .normal or .text
        return reg.word === term.text || reg.word === term.normal;
    }
    //support #Tag
    if (reg.tag !== undefined) return term.tags.has(reg.tag) === true;
    //support @method
    if (reg.method !== undefined) {
        if (typeof (0, _termMethodsJsDefault.default)[reg.method] === "function" && (0, _termMethodsJsDefault.default)[reg.method](term) === true) return true;
        return false;
    }
    //support whitespace/punctuation
    if (reg.pre !== undefined) return term.pre && term.pre.includes(reg.pre);
    if (reg.post !== undefined) return term.post && term.post.includes(reg.post);
    //support /reg/
    if (reg.regex !== undefined) {
        let str = term.normal;
        if (reg.use) str = term[reg.use];
        return reg.regex.test(str);
    }
    //support <chunk>
    if (reg.chunk !== undefined) return term.chunk === reg.chunk;
    //support %Noun|Verb%
    if (reg.switch !== undefined) return term.switch === reg.switch;
    //support {machine}
    if (reg.machine !== undefined) return term.normal === reg.machine || term.machine === reg.machine || term.root === reg.machine;
    //support {word/sense}
    if (reg.sense !== undefined) return term.sense === reg.sense;
    // support optimized (one|two)
    if (reg.fastOr !== undefined) {
        // {work/verb} must be a verb
        if (reg.pos && !term.tags.has(reg.pos)) return null;
        let str = term.root || term.implicit || term.machine || term.normal;
        return reg.fastOr.has(str) || reg.fastOr.has(term.text);
    }
    //support slower (one|two)
    if (reg.choices !== undefined) {
        // try to support && operator
        if (reg.operator === "and") // must match them all
        return reg.choices.every((r)=>wrapMatch(term, r, index, length));
        // or must match one
        return reg.choices.some((r)=>wrapMatch(term, r, index, length));
    }
    return false;
};
// wrap result for !negative match logic
wrapMatch = function(t, reg, index, length) {
    let result = doesMatch(t, reg, index, length);
    if (reg.negative === true) return !result;
    return result;
};
exports.default = wrapMatch;

},{"./_fuzzy.js":"2Mk8h","../../termMethods.js":"7pXmB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Mk8h":[function(require,module,exports) {
// fuzzy-match (damerau-levenshtein)
// Based on  tad-lispy /node-damerau-levenshtein
// https://github.com/tad-lispy/node-damerau-levenshtein/blob/master/index.js
// count steps (insertions, deletions, substitutions, or transpositions)
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const editDistance = function(strA, strB) {
    let aLength = strA.length, bLength = strB.length;
    // fail-fast
    if (aLength === 0) return bLength;
    if (bLength === 0) return aLength;
    // If the limit is not defined it will be calculate from this and that args.
    let limit = (bLength > aLength ? bLength : aLength) + 1;
    if (Math.abs(aLength - bLength) > (limit || 100)) return limit || 100;
    // init the array
    let matrix = [];
    for(let i = 0; i < limit; i++){
        matrix[i] = [
            i
        ];
        matrix[i].length = limit;
    }
    for(let i = 0; i < limit; i++)matrix[0][i] = i;
    // Calculate matrix.
    let j, a_index, b_index, cost, min, t;
    for(let i = 1; i <= aLength; ++i){
        a_index = strA[i - 1];
        for(j = 1; j <= bLength; ++j){
            // Check the jagged distance total so far
            if (i === j && matrix[i][j] > 4) return aLength;
            b_index = strB[j - 1];
            cost = a_index === b_index ? 0 : 1 // Step 5
            ;
            // Calculate the minimum (much faster than Math.min(...)).
            min = matrix[i - 1][j] + 1 // Deletion.
            ;
            if ((t = matrix[i][j - 1] + 1) < min) min = t // Insertion.
            ;
            if ((t = matrix[i - 1][j - 1] + cost) < min) min = t // Substitution.
            ;
            // Update matrix.
            let shouldUpdate = i > 1 && j > 1 && a_index === strB[j - 2] && strA[i - 2] === b_index && (t = matrix[i - 2][j - 2] + cost) < min;
            if (shouldUpdate) matrix[i][j] = t;
            else matrix[i][j] = min;
        }
    }
    // return number of steps
    return matrix[aLength][bLength];
};
// score similarity by from 0-1 (steps/length)
const fuzzyMatch = function(strA, strB, minLength = 3) {
    if (strA === strB) return 1;
    //don't even bother on tiny strings
    if (strA.length < minLength || strB.length < minLength) return 0;
    const steps = editDistance(strA, strB);
    let length = Math.max(strA.length, strB.length);
    let relative = length === 0 ? 0 : steps / length;
    let similarity = 1 - relative;
    return similarity;
};
exports.default = fuzzyMatch;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7pXmB":[function(require,module,exports) {
// these methods are called with '@hasComma' in the match syntax
// various unicode quotation-mark formats
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const startQuote = /([\u0022\uFF02\u0027\u201C\u2018\u201F\u201B\u201E\u2E42\u201A\u00AB\u2039\u2035\u2036\u2037\u301D\u0060\u301F])/;
const endQuote = /([\u0022\uFF02\u0027\u201D\u2019\u00BB\u203A\u2032\u2033\u2034\u301E\u00B4])/;
const hasHyphen = /^[-–—]$/;
const hasDash = / [-–—]{1,3} /;
/** search the term's 'post' punctuation  */ const hasPost = (term, punct)=>term.post.indexOf(punct) !== -1;
/** search the term's 'pre' punctuation  */ const hasPre = (term, punct)=>term.pre.indexOf(punct) !== -1;
const methods = {
    /** does it have a quotation symbol?  */ hasQuote: (term)=>startQuote.test(term.pre) || endQuote.test(term.post),
    /** does it have a comma?  */ hasComma: (term)=>hasPost(term, ","),
    /** does it end in a period? */ hasPeriod: (term)=>hasPost(term, ".") === true && hasPost(term, "...") === false,
    /** does it end in an exclamation */ hasExclamation: (term)=>hasPost(term, "!"),
    /** does it end with a question mark? */ hasQuestionMark: (term)=>hasPost(term, "?") || hasPost(term, "\xbf"),
    /** is there a ... at the end? */ hasEllipses: (term)=>hasPost(term, "..") || hasPost(term, "\u2026") || hasPre(term, "..") || hasPre(term, "\u2026"),
    /** is there a semicolon after term word? */ hasSemicolon: (term)=>hasPost(term, ";"),
    /** is there a colon after term word? */ hasColon: (term)=>hasPost(term, ":"),
    /** is there a slash '/' in term word? */ hasSlash: (term)=>/\//.test(term.text),
    /** a hyphen connects two words like-term */ hasHyphen: (term)=>hasHyphen.test(term.post) || hasHyphen.test(term.pre),
    /** a dash separates words - like that */ hasDash: (term)=>hasDash.test(term.post) || hasDash.test(term.pre),
    /** is it multiple words combinded */ hasContraction: (term)=>Boolean(term.implicit),
    /** is it an acronym */ isAcronym: (term)=>term.tags.has("Acronym"),
    /** does it have any tags */ isKnown: (term)=>term.tags.size > 0,
    /** uppercase first letter, then a lowercase */ isTitleCase: (term)=>/^\p{Lu}[a-z'\u00C0-\u00FF]/u.test(term.text),
    /** uppercase all letters */ isUpperCase: (term)=>/^\p{Lu}+$/u.test(term.text)
};
// aliases
methods.hasQuotation = methods.hasQuote;
exports.default = methods;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"84LuU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getGroup", ()=>getGroup);
const getGroup = function(state, term_index) {
    if (state.groups[state.inGroup]) return state.groups[state.inGroup];
    state.groups[state.inGroup] = {
        start: term_index,
        length: 0
    };
    return state.groups[state.inGroup];
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"39NsJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _andOrJs = require("./logic/and-or.js");
var _libJs = require("../_lib.js");
const orBlock = function(state) {
    const { regs } = state;
    let reg = regs[state.r];
    let skipNum = (0, _andOrJs.doOrBlock)(state);
    // did we find a match?
    if (skipNum) {
        // handle 'not' logic
        if (reg.negative === true) return null // die
        ;
        // tuck in as named-group
        if (state.hasGroup === true) {
            const g = (0, _libJs.getGroup)(state, state.t);
            g.length += skipNum;
        }
        // ensure we're at the end
        if (reg.end === true) {
            let end = state.phrase_length;
            if (state.t + state.start_i + skipNum !== end) return null;
        }
        state.t += skipNum;
        // log(`✓ |found-or|`)
        return true;
    } else if (!reg.optional) return null //die
    ;
    return true;
};
exports.default = orBlock;

},{"./logic/and-or.js":"ipvBb","../_lib.js":"84LuU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ipvBb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "doOrBlock", ()=>doOrBlock);
parcelHelpers.export(exports, "doAndBlock", ()=>doAndBlock);
var _doesMatchJs = require("../../term/doesMatch.js");
var _doesMatchJsDefault = parcelHelpers.interopDefault(_doesMatchJs);
const isArray = function(arr) {
    return Object.prototype.toString.call(arr) === "[object Array]";
};
const doOrBlock = function(state, skipN = 0) {
    let block = state.regs[state.r];
    let wasFound = false;
    // do each multiword sequence
    for(let c = 0; c < block.choices.length; c += 1){
        // try to match this list of tokens
        let regs = block.choices[c];
        if (!isArray(regs)) return false;
        wasFound = regs.every((cr, w_index)=>{
            let extra = 0;
            let t = state.t + w_index + skipN + extra;
            if (state.terms[t] === undefined) return false;
            let foundBlock = (0, _doesMatchJsDefault.default)(state.terms[t], cr, t + state.start_i, state.phrase_length);
            // this can be greedy - '(foo+ bar)'
            if (foundBlock === true && cr.greedy === true) for(let i = 1; i < state.terms.length; i += 1){
                let term = state.terms[t + i];
                if (term) {
                    let keepGoing = (0, _doesMatchJsDefault.default)(term, cr, state.start_i + i, state.phrase_length);
                    if (keepGoing === true) extra += 1;
                    else break;
                }
            }
            skipN += extra;
            return foundBlock;
        });
        if (wasFound) {
            skipN += regs.length;
            break;
        }
    }
    // we found a match -  is it greedy though?
    if (wasFound && block.greedy === true) return doOrBlock(state, skipN) // try it again!
    ;
    return skipN;
};
const doAndBlock = function(state) {
    let longest = 0;
    // all blocks must match, and we return the greediest match
    let reg = state.regs[state.r];
    let allDidMatch = reg.choices.every((block)=>{
        //  for multi-word blocks, all must match
        let allWords = block.every((cr, w_index)=>{
            let tryTerm = state.t + w_index;
            if (state.terms[tryTerm] === undefined) return false;
            return (0, _doesMatchJsDefault.default)(state.terms[tryTerm], cr, tryTerm, state.phrase_length);
        });
        if (allWords === true && block.length > longest) longest = block.length;
        return allWords;
    });
    if (allDidMatch === true) // console.log(`doAndBlock ${state.terms[state.t].normal}`)
    return longest;
    return false;
};

},{"../../term/doesMatch.js":"70Xh3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jy6Uo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _andOrJs = require("./logic/and-or.js");
var _libJs = require("../_lib.js");
// '(foo && #Noun)' - require all matches on the term
const andBlock = function(state) {
    const { regs } = state;
    let reg = regs[state.r];
    let skipNum = (0, _andOrJs.doAndBlock)(state);
    if (skipNum) {
        // handle 'not' logic
        if (reg.negative === true) return null // die
        ;
        if (state.hasGroup === true) {
            const g = (0, _libJs.getGroup)(state, state.t);
            g.length += skipNum;
        }
        // ensure we're at the end
        if (reg.end === true) {
            let end = state.phrase_length - 1;
            if (state.t + state.start_i !== end) return null;
        }
        state.t += skipNum;
        // log(`✓ |found-and|`)
        return true;
    } else if (!reg.optional) return null //die
    ;
    return true;
};
exports.default = andBlock;

},{"./logic/and-or.js":"ipvBb","../_lib.js":"84LuU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6A2hK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _doesMatchJs = require("../term/doesMatch.js");
var _doesMatchJsDefault = parcelHelpers.interopDefault(_doesMatchJs);
var _negativeGreedyJs = require("./logic/negative-greedy.js");
var _negativeGreedyJsDefault = parcelHelpers.interopDefault(_negativeGreedyJs);
// '!foo' should match anything that isn't 'foo'
// if it matches, return false
const doNegative = function(state) {
    const { regs } = state;
    let reg = regs[state.r];
    // match *anything* but this term
    let tmpReg = Object.assign({}, reg);
    tmpReg.negative = false // try removing it
    ;
    // found it? if so, we die here
    let found = (0, _doesMatchJsDefault.default)(state.terms[state.t], tmpReg, state.start_i + state.t, state.phrase_length);
    if (found) return false //bye
    ;
    // should we skip the term too?
    if (reg.optional) {
        // "before after" - "before !foo? after"
        // does the next reg match the this term?
        let nextReg = regs[state.r + 1];
        if (nextReg) {
            let fNext = (0, _doesMatchJsDefault.default)(state.terms[state.t], nextReg, state.start_i + state.t, state.phrase_length);
            if (fNext) state.r += 1;
            else if (nextReg.optional && regs[state.r + 2]) {
                // ugh. ok,
                // support "!foo? extra? need"
                // but don't scan ahead more than that.
                let fNext2 = (0, _doesMatchJsDefault.default)(state.terms[state.t], regs[state.r + 2], state.start_i + state.t, state.phrase_length);
                if (fNext2) state.r += 2;
            }
        }
    }
    // negative greedy - !foo+  - super hard!
    if (reg.greedy) return (0, _negativeGreedyJsDefault.default)(state, tmpReg, regs[state.r + 1]);
    state.t += 1;
    return true;
};
exports.default = doNegative;

},{"../term/doesMatch.js":"70Xh3","./logic/negative-greedy.js":"AlPTC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"AlPTC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _doesMatchJs = require("../../term/doesMatch.js");
var _doesMatchJsDefault = parcelHelpers.interopDefault(_doesMatchJs);
const negGreedy = function(state, reg, nextReg) {
    let skip = 0;
    for(let t = state.t; t < state.terms.length; t += 1){
        let found = (0, _doesMatchJsDefault.default)(state.terms[t], reg, state.start_i + state.t, state.phrase_length);
        // we don't want a match, here
        if (found) break; //stop going
        // are we doing 'greedy-to'?
        // - "!foo+ after"  should stop at 'after'
        if (nextReg) {
            found = (0, _doesMatchJsDefault.default)(state.terms[t], nextReg, state.start_i + state.t, state.phrase_length);
            if (found) break;
        }
        skip += 1;
        // is it max-length now?
        if (reg.max !== undefined && skip === reg.max) break;
    }
    if (skip === 0) return false //dead
    ;
    // did we satisfy min for !foo{min,max}
    if (reg.min && reg.min > skip) return false //dead
    ;
    state.t += skip;
    // state.r += 1
    return true;
};
exports.default = negGreedy;

},{"../../term/doesMatch.js":"70Xh3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"duo1r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("../_lib.js");
var _optionalMatchJs = require("./optional-match.js");
var _optionalMatchJsDefault = parcelHelpers.interopDefault(_optionalMatchJs);
var _greedyMatchJs = require("./greedy-match.js");
var _greedyMatchJsDefault = parcelHelpers.interopDefault(_greedyMatchJs);
var _contractionSkipJs = require("./contraction-skip.js");
var _contractionSkipJsDefault = parcelHelpers.interopDefault(_contractionSkipJs);
// '[foo]' should also be logged as a group
const setGroup = function(state, startAt) {
    let reg = state.regs[state.r];
    // Get or create capture group
    const g = (0, _libJs.getGroup)(state, startAt);
    // Update group - add greedy or increment length
    if (state.t > 1 && reg.greedy) g.length += state.t - startAt;
    else g.length++;
};
// when a reg matches a term
const simpleMatch = function(state) {
    const { regs } = state;
    let reg = regs[state.r];
    let term = state.terms[state.t];
    let startAt = state.t;
    // if it's a negative optional match... :0
    if (reg.optional && regs[state.r + 1] && reg.negative) return true;
    // okay, it was a match, but if it's optional too,
    // we should check the next reg too, to skip it?
    if (reg.optional && regs[state.r + 1]) (0, _optionalMatchJsDefault.default)(state);
    // Contraction skip:
    // did we match the first part of a contraction?
    if (term.implicit && state.terms[state.t + 1]) (0, _contractionSkipJsDefault.default)(state);
    //advance to the next term!
    state.t += 1;
    //check any ending '$' flags
    //if this isn't the last term, refuse the match
    if (reg.end === true && state.t !== state.terms.length && reg.greedy !== true) return null //die
    ;
    // keep 'foo+' going...
    if (reg.greedy === true) {
        let alive = (0, _greedyMatchJsDefault.default)(state);
        if (!alive) return null;
    }
    // log '[foo]' as a group
    if (state.hasGroup === true) setGroup(state, startAt);
    return true;
};
exports.default = simpleMatch;

},{"../_lib.js":"84LuU","./optional-match.js":"h2Ojw","./greedy-match.js":"kVpcG","./contraction-skip.js":"02KrG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h2Ojw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _doesMatchJs = require("../term/doesMatch.js");
var _doesMatchJsDefault = parcelHelpers.interopDefault(_doesMatchJs);
// 'foo? foo' matches are tricky.
const foundOptional = function(state) {
    const { regs } = state;
    let reg = regs[state.r];
    let term = state.terms[state.t];
    // does the next reg match it too?
    let nextRegMatched = (0, _doesMatchJsDefault.default)(term, regs[state.r + 1], state.start_i + state.t, state.phrase_length);
    if (reg.negative || nextRegMatched) {
        // but does the next reg match the next term??
        // only skip if it doesn't
        let nextTerm = state.terms[state.t + 1];
        if (!nextTerm || !(0, _doesMatchJsDefault.default)(nextTerm, regs[state.r + 1], state.start_i + state.t, state.phrase_length)) state.r += 1;
    }
};
exports.default = foundOptional;

},{"../term/doesMatch.js":"70Xh3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kVpcG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _greedyJs = require("./logic/greedy.js");
// keep 'foo+' or 'foo*' going..
const greedyMatch = function(state) {
    const { regs, phrase_length } = state;
    let reg = regs[state.r];
    state.t = (0, _greedyJs.getGreedy)(state, regs[state.r + 1]);
    if (state.t === null) return null //greedy was too short
    ;
    // foo{2,4} - has a greed-minimum
    if (reg.min && reg.min > state.t) return null //greedy was too short
    ;
    // 'foo+$' - if also an end-anchor, ensure we really reached the end
    if (reg.end === true && state.start_i + state.t !== phrase_length) return null //greedy didn't reach the end
    ;
    return true;
};
exports.default = greedyMatch;

},{"./logic/greedy.js":"kj1b3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"02KrG":[function(require,module,exports) {
// for: ['we', 'have']
// a match for "we have" should work as normal
// but matching "we've" should skip over implict terms
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const contractionSkip = function(state) {
    let term = state.terms[state.t];
    let reg = state.regs[state.r];
    // did we match the first part of a contraction?
    if (term.implicit && state.terms[state.t + 1]) {
        let nextTerm = state.terms[state.t + 1];
        // ensure next word is implicit
        if (!nextTerm.implicit) return;
        // we matched "we've" - skip-over [we, have]
        if (reg.word === term.normal) state.t += 1;
        // also skip for @hasContraction
        if (reg.method === "hasContraction") state.t += 1;
    }
};
exports.default = contractionSkip;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f8AMl":[function(require,module,exports) {
// support returning a subset of a match
// like 'foo [bar] baz' -> bar
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const getGroup = function(res, group) {
    let ptrs = [];
    let byGroup = {};
    if (res.length === 0) return {
        ptrs,
        byGroup
    };
    if (typeof group === "number") group = String(group);
    if (group) res.forEach((r)=>{
        if (r.groups[group]) ptrs.push(r.groups[group]);
    });
    else res.forEach((r)=>{
        ptrs.push(r.pointer);
        Object.keys(r.groups).forEach((k)=>{
            byGroup[k] = byGroup[k] || [];
            byGroup[k].push(r.groups[k]);
        });
    });
    return {
        ptrs,
        byGroup
    };
};
exports.default = getGroup;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9hoCQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _02FromHereJs = require("./02-from-here.js");
var _02FromHereJsDefault = parcelHelpers.interopDefault(_02FromHereJs);
const notIf = function(results, not, docs) {
    results = results.filter((res)=>{
        let [n, start, end] = res.pointer;
        let terms = docs[n].slice(start, end);
        for(let i = 0; i < terms.length; i += 1){
            let slice = terms.slice(i);
            let found = (0, _02FromHereJsDefault.default)(slice, not, i, terms.length);
            if (found !== null) return false;
        }
        return true;
    });
    return results;
};
exports.default = notIf;

},{"./02-from-here.js":"jLtR8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aQn6C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /** pre-parse any match statements */ parseMatch: function(str, opts) {
        const world = this.world();
        let killUnicode = world.methods.one.killUnicode;
        if (killUnicode) str = killUnicode(str, world);
        return world.methods.one.parseMatch(str, opts, world);
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eyYam":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./api/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _hashJs = require("./api/lib/hash.js");
var _hashJsDefault = parcelHelpers.interopDefault(_hashJs);
exports.default = {
    api: (0, _indexJsDefault.default),
    methods: {
        one: {
            hash: (0, _hashJsDefault.default)
        }
    }
};

},{"./api/index.js":"5Mm9Z","./api/lib/hash.js":"7l8Ma","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Mm9Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _htmlJs = require("./html.js");
var _htmlJsDefault = parcelHelpers.interopDefault(_htmlJs);
var _jsonJs = require("./json.js");
var _jsonJsDefault = parcelHelpers.interopDefault(_jsonJs);
var _outJs = require("./out.js");
var _outJsDefault = parcelHelpers.interopDefault(_outJs);
var _textJs = require("./text.js");
var _textJsDefault = parcelHelpers.interopDefault(_textJs);
const methods = Object.assign({}, (0, _outJsDefault.default), (0, _textJsDefault.default), (0, _jsonJsDefault.default), (0, _htmlJsDefault.default));
const addAPI = function(View) {
    Object.assign(View.prototype, methods);
};
exports.default = addAPI;

},{"./html.js":"SmcO0","./json.js":"jsI9M","./out.js":"3zAZb","./text.js":"28owF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"SmcO0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isClass = /^\../;
const isId = /^#./;
const escapeXml = (str)=>{
    str = str.replace(/&/g, "&amp;");
    str = str.replace(/</g, "&lt;");
    str = str.replace(/>/g, "&gt;");
    str = str.replace(/"/g, "&quot;");
    str = str.replace(/'/g, "&apos;");
    return str;
};
// interpret .class, #id, tagName
const toTag = function(k) {
    let start = "";
    let end = "</span>";
    k = escapeXml(k);
    if (isClass.test(k)) start = `<span class="${k.replace(/^\./, "")}"`;
    else if (isId.test(k)) start = `<span id="${k.replace(/^#/, "")}"`;
    else {
        start = `<${k}`;
        end = `</${k}>`;
    }
    start += ">";
    return {
        start,
        end
    };
};
const getIndex = function(doc, obj) {
    let starts = {};
    let ends = {};
    Object.keys(obj).forEach((k)=>{
        let res = obj[k];
        let tag = toTag(k);
        if (typeof res === "string") res = doc.match(res);
        res.docs.forEach((terms)=>{
            // don't highlight implicit terms
            if (terms.every((t)=>t.implicit)) return;
            let a = terms[0].id;
            starts[a] = starts[a] || [];
            starts[a].push(tag.start);
            let b = terms[terms.length - 1].id;
            ends[b] = ends[b] || [];
            ends[b].push(tag.end);
        });
    });
    return {
        starts,
        ends
    };
};
const html = function(obj) {
    // index ids to highlight
    let { starts, ends } = getIndex(this, obj);
    // create the text output
    let out = "";
    this.docs.forEach((terms)=>{
        for(let i = 0; i < terms.length; i += 1){
            let t = terms[i];
            // do a span tag
            if (starts.hasOwnProperty(t.id)) out += starts[t.id].join("");
            out += t.pre || "";
            out += t.text || "";
            if (ends.hasOwnProperty(t.id)) out += ends[t.id].join("");
            out += t.post || "";
        }
    });
    return out;
};
exports.default = {
    html
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jsI9M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _textJs = require("./lib/_text.js");
var _fmtsJs = require("./_fmts.js");
var _fmtsJsDefault = parcelHelpers.interopDefault(_fmtsJs);
var _hashJs = require("./lib/hash.js");
var _hashJsDefault = parcelHelpers.interopDefault(_hashJs);
const defaults = {
    text: true,
    terms: true
};
let opts = {
    case: "none",
    unicode: "some",
    form: "machine",
    punctuation: "some"
};
const merge = function(a, b) {
    return Object.assign({}, a, b);
};
const fns = {
    text: (terms)=>(0, _textJs.textFromTerms)(terms, {
            keepPunct: true
        }, false),
    normal: (terms)=>(0, _textJs.textFromTerms)(terms, merge((0, _fmtsJsDefault.default).normal, {
            keepPunct: true
        }), false),
    implicit: (terms)=>(0, _textJs.textFromTerms)(terms, merge((0, _fmtsJsDefault.default).implicit, {
            keepPunct: true
        }), false),
    machine: (terms)=>(0, _textJs.textFromTerms)(terms, opts, false),
    root: (terms)=>(0, _textJs.textFromTerms)(terms, merge(opts, {
            form: "root"
        }), false),
    hash: (terms)=>(0, _hashJsDefault.default)((0, _textJs.textFromTerms)(terms, {
            keepPunct: true
        }, false)),
    offset: (terms)=>{
        let len = fns.text(terms).length;
        return {
            index: terms[0].offset.index,
            start: terms[0].offset.start,
            length: len
        };
    },
    terms: (terms)=>{
        return terms.map((t)=>{
            let term = Object.assign({}, t);
            term.tags = Array.from(t.tags);
            return term;
        });
    },
    confidence: (_terms, view, i)=>view.eq(i).confidence(),
    syllables: (_terms, view, i)=>view.eq(i).syllables(),
    sentence: (_terms, view, i)=>view.eq(i).fullSentence().text(),
    dirty: (terms)=>terms.some((t)=>t.dirty === true)
};
fns.sentences = fns.sentence;
fns.clean = fns.normal;
fns.reduced = fns.root;
const toJSON = function(view, option) {
    option = option || {};
    if (typeof option === "string") option = {};
    option = Object.assign({}, defaults, option);
    // run any necessary upfront steps
    if (option.offset) view.compute("offset");
    return view.docs.map((terms, i)=>{
        let res = {};
        Object.keys(option).forEach((k)=>{
            if (option[k] && fns[k]) res[k] = fns[k](terms, view, i);
        });
        return res;
    });
};
const methods = {
    /** return data */ json: function(n) {
        let res = toJSON(this, n);
        if (typeof n === "number") return res[n];
        return res;
    }
};
methods.data = methods.json;
exports.default = methods;

},{"./lib/_text.js":"5hJqn","./_fmts.js":"egowa","./lib/hash.js":"7l8Ma","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5hJqn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "textFromDoc", ()=>textFromDoc);
parcelHelpers.export(exports, "textFromTerms", ()=>textFromTerms);
const trimEnd = /[,:;)\]*.?~!\u0022\uFF02\u201D\u2019\u00BB\u203A\u2032\u2033\u2034\u301E\u00B4—-]+$/;
const trimStart = /^[(['"*~\uFF02\u201C\u2018\u201F\u201B\u201E\u2E42\u201A\u00AB\u2039\u2035\u2036\u2037\u301D\u0060\u301F]+/;
const punctToKill = /[,:;)('"\u201D\]]/;
const isHyphen = /^[-–—]$/;
const hasSpace = / /;
const textFromTerms = function(terms, opts, keepSpace = true) {
    let txt = "";
    terms.forEach((t)=>{
        let pre = t.pre || "";
        let post = t.post || "";
        if (opts.punctuation === "some") {
            pre = pre.replace(trimStart, "");
            // replace a hyphen with a space
            if (isHyphen.test(post)) post = " ";
            post = post.replace(punctToKill, "");
            // cleanup exclamations
            post = post.replace(/\?!+/, "?");
            post = post.replace(/!+/, "!");
            post = post.replace(/\?+/, "?");
            // kill elipses
            post = post.replace(/\.{2,}/, "");
            // kill abbreviation periods
            if (t.tags.has("Abbreviation")) post = post.replace(/\./, "");
        }
        if (opts.whitespace === "some") {
            pre = pre.replace(/\s/, "") //remove pre-whitespace
            ;
            post = post.replace(/\s+/, " ") //replace post-whitespace with a space
            ;
        }
        if (!opts.keepPunct) {
            pre = pre.replace(trimStart, "");
            if (post === "-") post = " ";
            else post = post.replace(trimEnd, "");
        }
        // grab the correct word format
        let word = t[opts.form || "text"] || t.normal || "";
        if (opts.form === "implicit") word = t.implicit || t.text;
        if (opts.form === "root" && t.implicit) word = t.root || t.implicit || t.normal;
        // add an implicit space, for contractions
        if ((opts.form === "machine" || opts.form === "implicit" || opts.form === "root") && t.implicit) {
            if (!post || !hasSpace.test(post)) post += " ";
        }
        txt += pre + word + post;
    });
    if (keepSpace === false) txt = txt.trim();
    if (opts.lowerCase === true) txt = txt.toLowerCase();
    return txt;
};
const textFromDoc = function(docs, opts) {
    let text = "";
    if (!docs || !docs[0] || !docs[0][0]) return text;
    for(let i = 0; i < docs.length; i += 1)// middle
    text += textFromTerms(docs[i], opts, true);
    if (!opts.keepSpace) text = text.trim();
    if (opts.keepEndPunct === false) {
        // don't remove ':)' etc
        if (!docs[0][0].tags.has("Emoticon")) text = text.replace(trimStart, "");
        // remove ending periods
        let last = docs[docs.length - 1];
        if (!last[last.length - 1].tags.has("Emoticon")) text = text.replace(trimEnd, "");
    }
    if (opts.cleanWhitespace === true) text = text.trim();
    return text;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"egowa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const fmts = {
    text: {
        form: "text"
    },
    normal: {
        whitespace: "some",
        punctuation: "some",
        case: "some",
        unicode: "some",
        form: "normal"
    },
    machine: {
        keepSpace: false,
        whitespace: "some",
        punctuation: "some",
        case: "none",
        unicode: "some",
        form: "machine"
    },
    root: {
        keepSpace: false,
        whitespace: "some",
        punctuation: "some",
        case: "some",
        unicode: "some",
        form: "root"
    },
    implicit: {
        form: "implicit"
    }
};
fmts.clean = fmts.normal;
fmts.reduced = fmts.root;
exports.default = fmts;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7l8Ma":[function(require,module,exports) {
/* eslint-disable no-bitwise */ /* eslint-disable no-mixed-operators */ /* eslint-disable no-multi-assign */ // https://github.com/jbt/tiny-hashes/
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>md5);
let k = [], i = 0;
for(; i < 64;)k[i] = 0 | Math.sin(++i % Math.PI) * 4294967296;
function md5(s) {
    let b, c, d, h = [
        b = 0x67452301,
        c = 0xEFCDAB89,
        ~b,
        ~c
    ], words = [], j = decodeURI(encodeURI(s)) + "\x80", a = j.length;
    s = --a / 4 + 2 | 15;
    words[--s] = a * 8;
    for(; ~a;)words[a >> 2] |= j.charCodeAt(a) << 8 * a--;
    for(i = j = 0; i < s; i += 16){
        a = h;
        for(; j < 64; a = [
            d = a[3],
            b + ((d = a[0] + [
                b & c | ~b & d,
                d & b | ~d & c,
                b ^ c ^ d,
                c ^ (b | ~d)
            ][a = j >> 4] + k[j] + ~~words[i | [
                j,
                5 * j + 1,
                3 * j + 5,
                7 * j
            ][a] & 15]) << (a = [
                7,
                12,
                17,
                22,
                5,
                9,
                14,
                20,
                4,
                11,
                16,
                23,
                6,
                10,
                15,
                21
            ][4 * a + j++ % 4]) | d >>> -a),
            b,
            c
        ]){
            b = a[1] | 0;
            c = a[2];
        }
        for(j = 4; j;)h[--j] += a[j];
    }
    for(s = ""; j < 32;)s += (h[j >> 3] >> (1 ^ j++) * 4 & 15).toString(16);
    return s;
} // console.log(md5('food-safety'))

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3zAZb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./debug/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _wrapJs = require("./wrap.js");
var _wrapJsDefault = parcelHelpers.interopDefault(_wrapJs);
var _hashJs = require("./lib/hash.js");
var _hashJsDefault = parcelHelpers.interopDefault(_hashJs);
const isObject = (val)=>{
    return Object.prototype.toString.call(val) === "[object Object]";
};
// sort by frequency
const topk = function(arr) {
    let obj = {};
    arr.forEach((a)=>{
        obj[a] = obj[a] || 0;
        obj[a] += 1;
    });
    let res = Object.keys(obj).map((k)=>{
        return {
            normal: k,
            count: obj[k]
        };
    });
    return res.sort((a, b)=>a.count > b.count ? -1 : 0);
};
/** some named output formats */ const out = function(method) {
    // support custom outputs
    if (isObject(method)) return (0, _wrapJsDefault.default)(this, method);
    // text out formats
    if (method === "text") return this.text();
    if (method === "normal") return this.text("normal");
    if (method === "root") return this.text("root");
    if (method === "machine" || method === "reduced") return this.text("machine");
    if (method === "hash" || method === "md5") return (0, _hashJsDefault.default)(this.text());
    // json data formats
    if (method === "json") return this.json();
    if (method === "offset" || method === "offsets") {
        this.compute("offset");
        return this.json({
            offset: true
        });
    }
    if (method === "array") {
        let arr = this.docs.map((terms)=>{
            return terms.reduce((str, t)=>{
                return str + t.pre + t.text + t.post;
            }, "").trim();
        });
        return arr.filter((str)=>str);
    }
    // return terms sorted by frequency
    if (method === "freq" || method === "frequency" || method === "topk") return topk(this.json({
        normal: true
    }).map((o)=>o.normal));
    // some handy ad-hoc outputs
    if (method === "terms") {
        let list = [];
        this.docs.forEach((terms)=>{
            let words = terms.map((t)=>t.text);
            words = words.filter((t)=>t);
            list = list.concat(words);
        });
        return list;
    }
    if (method === "tags") return this.docs.map((terms)=>{
        return terms.reduce((h, t)=>{
            h[t.implicit || t.normal] = Array.from(t.tags);
            return h;
        }, {});
    });
    if (method === "debug") return this.debug() //allow
    ;
    return this.text();
};
const methods = {
    /** */ debug: (0, _indexJsDefault.default),
    /** */ out,
    /** */ wrap: function(obj) {
        return (0, _wrapJsDefault.default)(this, obj);
    }
};
exports.default = methods;

},{"./debug/index.js":"136Wn","./wrap.js":"8mWD2","./lib/hash.js":"7l8Ma","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"136Wn":[function(require,module,exports) {
/* eslint-disable no-console */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _clientSideJs = require("./client-side.js");
var _clientSideJsDefault = parcelHelpers.interopDefault(_clientSideJs);
var _tagsJs = require("./tags.js");
var _tagsJsDefault = parcelHelpers.interopDefault(_tagsJs);
var _chunksJs = require("./chunks.js");
var _chunksJsDefault = parcelHelpers.interopDefault(_chunksJs);
var _highlightJs = require("./highlight.js");
var _highlightJsDefault = parcelHelpers.interopDefault(_highlightJs);
function isClientSide() {
    return typeof window !== "undefined" && window.document;
}
//output some helpful stuff to the console
const debug = function(opts = {}) {
    let view = this;
    if (typeof opts === "string") {
        let tmp = {};
        tmp[opts] = true //allow string input
        ;
        opts = tmp;
    }
    if (isClientSide()) {
        (0, _clientSideJsDefault.default)(view);
        return view;
    }
    if (opts.tags !== false) {
        (0, _tagsJsDefault.default)(view);
        console.log("\n");
    }
    // output chunk-view, too
    if (opts.chunks === true) {
        (0, _chunksJsDefault.default)(view);
        console.log("\n");
    }
    // highlight match in sentence
    if (opts.highlight === true) {
        (0, _highlightJsDefault.default)(view);
        console.log("\n");
    }
    return view;
};
exports.default = debug;

},{"./client-side.js":"gE45r","./tags.js":"asaaD","./chunks.js":"3ODCI","./highlight.js":"bI58Z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gE45r":[function(require,module,exports) {
/* eslint-disable no-console */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const logClientSide = function(view) {
    console.log("%c -=-=- ", "background-color:#6699cc;");
    view.forEach((m)=>{
        console.groupCollapsed(m.text());
        let terms = m.docs[0];
        let out = terms.map((t)=>{
            let text = t.text || "-";
            if (t.implicit) text = "[" + t.implicit + "]";
            let tags = "[" + Array.from(t.tags).join(", ") + "]";
            return {
                text,
                tags
            };
        });
        console.table(out, [
            "text",
            "tags"
        ]);
        console.groupEnd();
    });
};
exports.default = logClientSide;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"asaaD":[function(require,module,exports) {
/* eslint-disable no-console */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorJs = require("./_color.js");
var _colorJsDefault = parcelHelpers.interopDefault(_colorJs);
const tagString = function(tags, model) {
    if (model.one.tagSet) tags = tags.map((tag)=>{
        if (!model.one.tagSet.hasOwnProperty(tag)) return tag;
        const c = model.one.tagSet[tag].color || "blue";
        return (0, _colorJsDefault.default)[c](tag);
    });
    return tags.join(", ");
};
const showTags = function(view) {
    let { docs, model } = view;
    if (docs.length === 0) console.log((0, _colorJsDefault.default).blue("\n     \u2500\u2500\u2500\u2500\u2500\u2500"));
    docs.forEach((terms)=>{
        console.log((0, _colorJsDefault.default).blue("\n  \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"));
        terms.forEach((t)=>{
            let tags = [
                ...t.tags || []
            ];
            let text = t.text || "-";
            if (t.sense) text = `{${t.normal}/${t.sense}}`;
            if (t.implicit) text = "[" + t.implicit + "]";
            text = (0, _colorJsDefault.default).yellow(text);
            let word = "'" + text + "'";
            if (t.reference) {
                let str = view.update([
                    t.reference
                ]).text("normal");
                word += ` - ${(0, _colorJsDefault.default).dim((0, _colorJsDefault.default).i("[" + str + "]"))}`;
            }
            word = word.padEnd(18);
            let str = (0, _colorJsDefault.default).blue("  \u2502 ") + (0, _colorJsDefault.default).i(word) + "  - " + tagString(tags, model);
            console.log(str);
        });
    });
};
exports.default = showTags;

},{"./_color.js":"4kzLV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4kzLV":[function(require,module,exports) {
// https://stackoverflow.com/questions/9781218/how-to-change-node-jss-console-font-color
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const reset = "\x1b[0m";
//cheaper than requiring chalk
const cli = {
    green: (str)=>"\x1b[32m" + str + reset,
    red: (str)=>"\x1b[31m" + str + reset,
    blue: (str)=>"\x1b[34m" + str + reset,
    magenta: (str)=>"\x1b[35m" + str + reset,
    cyan: (str)=>"\x1b[36m" + str + reset,
    yellow: (str)=>"\x1b[33m" + str + reset,
    black: (str)=>"\x1b[30m" + str + reset,
    dim: (str)=>"\x1b[2m" + str + reset,
    i: (str)=>"\x1b[3m" + str + reset
};
exports.default = cli;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3ODCI":[function(require,module,exports) {
/* eslint-disable no-console */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorJs = require("./_color.js");
var _colorJsDefault = parcelHelpers.interopDefault(_colorJs);
const showChunks = function(view) {
    let { docs } = view;
    console.log("");
    docs.forEach((terms)=>{
        let out = [];
        terms.forEach((term)=>{
            if (term.chunk === "Noun") out.push((0, _colorJsDefault.default).blue(term.implicit || term.normal));
            else if (term.chunk === "Verb") out.push((0, _colorJsDefault.default).green(term.implicit || term.normal));
            else if (term.chunk === "Adjective") out.push((0, _colorJsDefault.default).yellow(term.implicit || term.normal));
            else if (term.chunk === "Pivot") out.push((0, _colorJsDefault.default).red(term.implicit || term.normal));
            else out.push(term.implicit || term.normal);
        });
        console.log(out.join(" "), "\n");
    });
};
exports.default = showChunks;

},{"./_color.js":"4kzLV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bI58Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorJs = require("./_color.js");
var _colorJsDefault = parcelHelpers.interopDefault(_colorJs);
const split = (txt, offset, index)=>{
    let buff = index * 9 //there are 9 new chars addded to each highlight
    ;
    let start = offset.start + buff;
    let end = start + offset.length;
    let pre = txt.substring(0, start);
    let mid = txt.substring(start, end);
    let post = txt.substring(end, txt.length);
    return [
        pre,
        mid,
        post
    ];
};
const spliceIn = function(txt, offset, index) {
    let parts = split(txt, offset, index);
    return `${parts[0]}${(0, _colorJsDefault.default).blue(parts[1])}${parts[2]}`;
};
const showHighlight = function(doc) {
    if (!doc.found) return;
    let bySentence = {};
    doc.fullPointer.forEach((ptr)=>{
        bySentence[ptr[0]] = bySentence[ptr[0]] || [];
        bySentence[ptr[0]].push(ptr);
    });
    Object.keys(bySentence).forEach((k)=>{
        let full = doc.update([
            [
                Number(k)
            ]
        ]);
        let txt = full.text();
        let matches = doc.update(bySentence[k]);
        let json = matches.json({
            offset: true
        });
        json.forEach((obj, i)=>{
            txt = spliceIn(txt, obj.offset, i);
        });
        console.log(txt) // eslint-disable-line
        ;
    });
};
exports.default = showHighlight;

},{"./_color.js":"4kzLV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8mWD2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const toText = function(term) {
    let pre = term.pre || "";
    let post = term.post || "";
    return pre + term.text + post;
};
const findStarts = function(doc, obj) {
    let starts = {};
    Object.keys(obj).forEach((reg)=>{
        let m = doc.match(reg);
        m.fullPointer.forEach((a)=>{
            starts[a[3]] = {
                fn: obj[reg],
                end: a[2]
            };
        });
    });
    return starts;
};
const wrap = function(doc, obj) {
    // index ids to highlight
    let starts = findStarts(doc, obj);
    let text = "";
    doc.docs.forEach((terms, n)=>{
        for(let i = 0; i < terms.length; i += 1){
            let t = terms[i];
            // do a span tag
            if (starts.hasOwnProperty(t.id)) {
                let { fn, end } = starts[t.id];
                let m = doc.update([
                    [
                        n,
                        i,
                        end
                    ]
                ]);
                text += terms[i].pre || "";
                text += fn(m);
                i = end - 1;
                text += terms[i].post || "";
            } else text += toText(t);
        }
    });
    return text;
};
exports.default = wrap;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"28owF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _textJs = require("./lib/_text.js");
var _fmtsJs = require("./_fmts.js");
var _fmtsJsDefault = parcelHelpers.interopDefault(_fmtsJs);
const isObject = (val)=>{
    return Object.prototype.toString.call(val) === "[object Object]";
};
exports.default = {
    /** */ text: function(fmt) {
        let opts = {};
        if (fmt && typeof fmt === "string" && (0, _fmtsJsDefault.default).hasOwnProperty(fmt)) opts = Object.assign({}, (0, _fmtsJsDefault.default)[fmt]);
        else if (fmt && isObject(fmt)) opts = Object.assign({}, fmt) //todo: fixme
        ;
        // is it a full document?
        if (opts.keepSpace === undefined && !this.isFull()) opts.keepSpace = false;
        if (opts.keepEndPunct === undefined && this.pointer) {
            let ptr = this.pointer[0];
            if (ptr && ptr[1]) opts.keepEndPunct = false;
            else opts.keepEndPunct = true;
        }
        // set defaults
        if (opts.keepPunct === undefined) opts.keepPunct = true;
        if (opts.keepSpace === undefined) opts.keepSpace = true;
        return (0, _textJs.textFromDoc)(this.docs, opts);
    }
};

},{"./lib/_text.js":"5hJqn","./_fmts.js":"egowa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jdjW6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./methods/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./api/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
exports.default = {
    methods: (0, _indexJsDefault.default),
    api: (0, _indexJsDefault1.default)
};

},{"./methods/index.js":"gwElk","./api/index.js":"fcZxY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gwElk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("../api/lib/_lib.js");
var _splitJs = require("../api/lib/split.js");
var _splitJsDefault = parcelHelpers.interopDefault(_splitJs);
var _getDocJs = require("./getDoc.js");
var _getDocJsDefault = parcelHelpers.interopDefault(_getDocJs);
// flat list of terms from nested document
const termList = function(docs) {
    let arr = [];
    for(let i = 0; i < docs.length; i += 1)for(let t = 0; t < docs[i].length; t += 1)arr.push(docs[i][t]);
    return arr;
};
exports.default = {
    one: {
        termList,
        getDoc: (0, _getDocJsDefault.default),
        pointer: {
            indexN: (0, _libJs.indexN),
            splitAll: (0, _splitJsDefault.default)
        }
    }
};

},{"../api/lib/_lib.js":"252au","../api/lib/split.js":"iFliB","./getDoc.js":"4OqX7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"252au":[function(require,module,exports) {
// do the pointers intersect?
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "doesOverlap", ()=>doesOverlap);
parcelHelpers.export(exports, "getExtent", ()=>getExtent);
parcelHelpers.export(exports, "indexN", ()=>indexN);
parcelHelpers.export(exports, "uniquePtrs", ()=>uniquePtrs);
const doesOverlap = function(a, b) {
    if (a[0] !== b[0]) return false;
    let [, startA, endA] = a;
    let [, startB, endB] = b;
    // [a,a,a,-,-,-,]
    // [-,-,b,b,b,-,]
    if (startA <= startB && endA > startB) return true;
    // [-,-,-,a,a,-,]
    // [-,-,b,b,b,-,]
    if (startB <= startA && endB > startA) return true;
    return false;
};
const getExtent = function(ptrs) {
    let min = ptrs[0][1];
    let max = ptrs[0][2];
    ptrs.forEach((ptr)=>{
        if (ptr[1] < min) min = ptr[1];
        if (ptr[2] > max) max = ptr[2];
    });
    return [
        ptrs[0][0],
        min,
        max
    ];
};
const indexN = function(ptrs) {
    let byN = {};
    ptrs.forEach((ref)=>{
        byN[ref[0]] = byN[ref[0]] || [];
        byN[ref[0]].push(ref);
    });
    return byN;
};
const uniquePtrs = function(arr) {
    let obj = {};
    for(let i = 0; i < arr.length; i += 1)obj[arr[i].join(",")] = arr[i];
    return Object.values(obj);
} // a before b
 // console.log(doesOverlap([0, 0, 4], [0, 2, 5]))
 // // b before a
 // console.log(doesOverlap([0, 3, 4], [0, 1, 5]))
 // // disjoint
 // console.log(doesOverlap([0, 0, 3], [0, 4, 5]))
 // neighbours
 // console.log(doesOverlap([0, 1, 3], [0, 3, 5]))
 // console.log(doesOverlap([0, 3, 5], [0, 1, 3]))
 // console.log(
 //   getExtent([
 //     [0, 3, 4],
 //     [0, 4, 5],
 //     [0, 1, 2],
 //   ])
 // )
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iFliB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("./_lib.js");
// split a pointer, by match pointer
const pivotBy = function(full, m) {
    let [n, start] = full;
    let mStart = m[1];
    let mEnd = m[2];
    let res = {};
    // is there space before the match?
    if (start < mStart) {
        let end = mStart < full[2] ? mStart : full[2] // find closest end-point
        ;
        res.before = [
            n,
            start,
            end
        ] //before segment
        ;
    }
    res.match = m;
    // is there space after the match?
    if (full[2] > mEnd) res.after = [
        n,
        mEnd,
        full[2]
    ] //after segment
    ;
    return res;
};
const doesMatch = function(full, m) {
    return full[1] <= m[1] && m[2] <= full[2];
};
const splitAll = function(full, m) {
    let byN = (0, _libJs.indexN)(m);
    let res = [];
    full.forEach((ptr)=>{
        let [n] = ptr;
        let matches = byN[n] || [];
        matches = matches.filter((p)=>doesMatch(ptr, p));
        if (matches.length === 0) {
            res.push({
                passthrough: ptr
            });
            return;
        }
        // ensure matches are in-order
        matches = matches.sort((a, b)=>a[1] - b[1]);
        // start splitting our left-to-right
        let carry = ptr;
        matches.forEach((p, i)=>{
            let found = pivotBy(carry, p);
            // last one
            if (!matches[i + 1]) res.push(found);
            else {
                res.push({
                    before: found.before,
                    match: found.match
                });
                if (found.after) carry = found.after;
            }
        });
    });
    return res;
};
exports.default = splitAll;

},{"./_lib.js":"252au","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4OqX7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const max = 20;
// sweep-around looking for our start term uuid
const blindSweep = function(id, doc, n) {
    for(let i = 0; i < max; i += 1){
        // look up a sentence
        if (doc[n - i]) {
            let index = doc[n - i].findIndex((term)=>term.id === id);
            if (index !== -1) return [
                n - i,
                index
            ];
        }
        // look down a sentence
        if (doc[n + i]) {
            let index = doc[n + i].findIndex((term)=>term.id === id);
            if (index !== -1) return [
                n + i,
                index
            ];
        }
    }
    return null;
};
const repairEnding = function(ptr, document) {
    let [n, start, , , endId] = ptr;
    let terms = document[n];
    // look for end-id
    let newEnd = terms.findIndex((t)=>t.id === endId);
    if (newEnd === -1) {
        // if end-term wasn't found, so go all the way to the end
        ptr[2] = document[n].length;
        ptr[4] = terms.length ? terms[terms.length - 1].id : null;
    } else ptr[2] = newEnd // repair ending pointer
    ;
    return document[n].slice(start, ptr[2] + 1);
};
/** return a subset of the document, from a pointer */ const getDoc = function(ptrs, document) {
    let doc = [];
    ptrs.forEach((ptr, i)=>{
        if (!ptr) return;
        let [n, start, end, id, endId] = ptr //parsePointer(ptr)
        ;
        let terms = document[n] || [];
        if (start === undefined) start = 0;
        if (end === undefined) end = terms.length;
        if (id && (!terms[start] || terms[start].id !== id)) {
            // console.log('  repairing pointer...')
            let wild = blindSweep(id, document, n);
            if (wild !== null) {
                let len = end - start;
                terms = document[wild[0]].slice(wild[1], wild[1] + len);
                // actually change the pointer
                let startId = terms[0] ? terms[0].id : null;
                ptrs[i] = [
                    wild[0],
                    wild[1],
                    wild[1] + len,
                    startId
                ];
            }
        } else terms = terms.slice(start, end);
        if (terms.length === 0) return;
        if (start === end) return;
        // test end-id, if it exists
        if (endId && terms[terms.length - 1].id !== endId) terms = repairEnding(ptr, document);
        // otherwise, looks good!
        doc.push(terms);
    });
    doc = doc.filter((a)=>a.length > 0);
    return doc;
};
exports.default = getDoc;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fcZxY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _unionJs = require("./lib/union.js");
var _unionJsDefault = parcelHelpers.interopDefault(_unionJs);
var _differenceJs = require("./lib/difference.js");
var _differenceJsDefault = parcelHelpers.interopDefault(_differenceJs);
var _intersectionJs = require("./lib/intersection.js");
var _intersectionJsDefault = parcelHelpers.interopDefault(_intersectionJs);
const isArray = function(arr) {
    return Object.prototype.toString.call(arr) === "[object Array]";
};
const getDoc = (m, view)=>{
    if (typeof m === "string" || isArray(m)) return view.match(m);
    if (!m) return view.none();
    // support pre-parsed reg object
    return m;
};
// 'harden' our json pointers, again
const addIds = function(ptrs, docs) {
    return ptrs.map((ptr)=>{
        let [n, start] = ptr;
        if (docs[n] && docs[n][start]) ptr[3] = docs[n][start].id;
        return ptr;
    });
};
const methods = {};
// all parts, minus duplicates
methods.union = function(m) {
    m = getDoc(m, this);
    let ptrs = (0, _unionJsDefault.default)(this.fullPointer, m.fullPointer);
    ptrs = addIds(ptrs, this.document);
    return this.toView(ptrs);
};
methods.and = methods.union;
// only parts they both have
methods.intersection = function(m) {
    m = getDoc(m, this);
    let ptrs = (0, _intersectionJsDefault.default)(this.fullPointer, m.fullPointer);
    ptrs = addIds(ptrs, this.document);
    return this.toView(ptrs);
};
// only parts of a that b does not have
methods.not = function(m) {
    m = getDoc(m, this);
    let ptrs = (0, _differenceJsDefault.default)(this.fullPointer, m.fullPointer);
    ptrs = addIds(ptrs, this.document);
    return this.toView(ptrs);
};
methods.difference = methods.not;
// get opposite of a
methods.complement = function() {
    let doc = this.all();
    let ptrs = (0, _differenceJsDefault.default)(doc.fullPointer, this.fullPointer);
    ptrs = addIds(ptrs, this.document);
    return this.toView(ptrs);
};
// remove overlaps
methods.settle = function() {
    let ptrs = this.fullPointer;
    ptrs.forEach((ptr)=>{
        ptrs = (0, _unionJsDefault.default)(ptrs, [
            ptr
        ]);
    });
    ptrs = addIds(ptrs, this.document);
    return this.update(ptrs);
};
const addAPI = function(View) {
    // add set/intersection/union
    Object.assign(View.prototype, methods);
};
exports.default = addAPI;

},{"./lib/union.js":"2E5ue","./lib/difference.js":"d5Yk9","./lib/intersection.js":"ciEeP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2E5ue":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("./_lib.js");
// a union is a + b, minus duplicates
const getUnion = function(a, b) {
    let both = a.concat(b);
    let byN = (0, _libJs.indexN)(both);
    let res = [];
    both.forEach((ptr)=>{
        let [n] = ptr;
        if (byN[n].length === 1) {
            // we're alone on this sentence, so we're good
            res.push(ptr);
            return;
        }
        // there may be overlaps
        let hmm = byN[n].filter((m)=>(0, _libJs.doesOverlap)(ptr, m));
        hmm.push(ptr);
        let range = (0, _libJs.getExtent)(hmm);
        res.push(range);
    });
    res = (0, _libJs.uniquePtrs)(res);
    return res;
};
exports.default = getUnion // two disjoint
 // console.log(getUnion([[1, 3, 4]], [[0, 1, 2]]))
 // two disjoint
 // console.log(getUnion([[0, 3, 4]], [[0, 1, 2]]))
 // overlap-plus
 // console.log(getUnion([[0, 1, 4]], [[0, 2, 6]]))
 // overlap
 // console.log(getUnion([[0, 1, 4]], [[0, 2, 3]]))
 // neighbours
 // console.log(getUnion([[0, 1, 3]], [[0, 3, 5]]))
;

},{"./_lib.js":"252au","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5Yk9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _splitJs = require("./split.js");
var _splitJsDefault = parcelHelpers.interopDefault(_splitJs);
const subtract = function(refs, not) {
    let res = [];
    let found = (0, _splitJsDefault.default)(refs, not);
    found.forEach((o)=>{
        if (o.passthrough) res.push(o.passthrough);
        if (o.before) res.push(o.before);
        if (o.after) res.push(o.after);
    });
    return res;
};
exports.default = subtract // console.log(subtract([[0, 0, 2]], [[0, 0, 1]]))
 // console.log(subtract([[0, 0, 2]], [[0, 1, 2]]))
;

},{"./split.js":"iFliB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ciEeP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("./_lib.js");
// [a,a,a,a,-,-,]
// [-,-,b,b,b,-,]
// [-,-,x,x,-,-,]
const intersection = function(a, b) {
    // find the latest-start
    let start = a[1] < b[1] ? b[1] : a[1];
    // find the earliest-end
    let end = a[2] > b[2] ? b[2] : a[2];
    // does it form a valid pointer?
    if (start < end) return [
        a[0],
        start,
        end
    ];
    return null;
};
const getIntersection = function(a, b) {
    let byN = (0, _libJs.indexN)(b);
    let res = [];
    a.forEach((ptr)=>{
        let hmm = byN[ptr[0]] || [];
        hmm = hmm.filter((p)=>(0, _libJs.doesOverlap)(ptr, p));
        // no sentence-pairs, so no intersection
        if (hmm.length === 0) return;
        hmm.forEach((h)=>{
            let overlap = intersection(ptr, h);
            if (overlap) res.push(overlap);
        });
    });
    return res;
};
exports.default = getIntersection // console.log(getIntersection([[0, 1, 3]], [[0, 2, 4]]))
;

},{"./_lib.js":"252au","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Y5TO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("./lib.js");
var _libJsDefault = parcelHelpers.interopDefault(_libJs);
var _apiJs = require("./api.js");
var _apiJsDefault = parcelHelpers.interopDefault(_apiJs);
var _indexJs = require("./methods/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
exports.default = {
    lib: (0, _libJsDefault.default),
    api: (0, _apiJsDefault.default),
    methods: {
        one: (0, _indexJsDefault.default)
    }
};

},{"./lib.js":"6ueQ1","./api.js":"8nHvK","./methods/index.js":"bKbrB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6ueQ1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    // compile a list of matches into a match-net
    buildNet: function(matches) {
        const methods = this.methods();
        let net = methods.one.buildNet(matches, this.world());
        net.isNet = true;
        return net;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8nHvK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const api = function(View) {
    /** speedy match a sequence of matches */ View.prototype.sweep = function(net, opts = {}) {
        const { world, docs } = this;
        const { methods } = world;
        let found = methods.one.bulkMatch(docs, net, this.methods, opts);
        // apply any changes
        if (opts.tagger !== false) methods.one.bulkTagger(found, docs, this.world);
        // fix the pointers
        // collect all found results into a View
        found = found.map((o)=>{
            let ptr = o.pointer;
            let term = docs[ptr[0]][ptr[1]];
            let len = ptr[2] - ptr[1];
            if (term.index) o.pointer = [
                term.index[0],
                term.index[1],
                ptr[1] + len
            ];
            return o;
        });
        let ptrs = found.map((o)=>o.pointer);
        // cleanup results a bit
        found = found.map((obj)=>{
            obj.view = this.update([
                obj.pointer
            ]);
            delete obj.regs;
            delete obj.needs;
            delete obj.pointer;
            delete obj._expanded;
            return obj;
        });
        return {
            view: this.update(ptrs),
            found
        };
    };
};
exports.default = api;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bKbrB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./buildNet/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./sweep/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("./tagger/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
exports.default = {
    buildNet: (0, _indexJsDefault.default),
    bulkMatch: (0, _indexJsDefault1.default),
    bulkTagger: (0, _indexJsDefault2.default)
};

},{"./buildNet/index.js":"33ZMQ","./sweep/index.js":"k8qHu","./tagger/index.js":"aPhL1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"33ZMQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _01ParseJs = require("./01-parse.js");
var _01ParseJsDefault = parcelHelpers.interopDefault(_01ParseJs);
// do some indexing on the list of matches
const buildNet = function(matches, world) {
    // turn match-syntax into json
    matches = (0, _01ParseJsDefault.default)(matches, world);
    // collect by wants and needs
    let hooks = {};
    matches.forEach((obj)=>{
        // add needs
        obj.needs.forEach((str)=>{
            hooks[str] = Array.isArray(hooks[str]) ? hooks[str] : [];
            hooks[str].push(obj);
        });
        // add wants
        obj.wants.forEach((str)=>{
            hooks[str] = Array.isArray(hooks[str]) ? hooks[str] : [];
            hooks[str].push(obj);
        });
    });
    // remove duplicates
    Object.keys(hooks).forEach((k)=>{
        let already = {};
        hooks[k] = hooks[k].filter((obj)=>{
            if (typeof already[obj.match] === "boolean") return false;
            already[obj.match] = true;
            return true;
        });
    });
    // keep all un-cacheable matches (those with no needs) 
    let always = matches.filter((o)=>o.needs.length === 0 && o.wants.length === 0);
    return {
        hooks,
        always
    };
};
exports.default = buildNet;

},{"./01-parse.js":"5NNPG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5NNPG":[function(require,module,exports) {
// extract the clear needs for an individual match token
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const getTokenNeeds = function(reg) {
    // negatives can't be cached
    if (reg.optional === true || reg.negative === true) return null;
    if (reg.tag) return "#" + reg.tag;
    if (reg.word) return reg.word;
    if (reg.switch) return `%${reg.switch}%`;
    return null;
};
const getNeeds = function(regs) {
    let needs = [];
    regs.forEach((reg)=>{
        needs.push(getTokenNeeds(reg));
        // support AND (foo && tag)
        if (reg.operator === "and" && reg.choices) reg.choices.forEach((oneSide)=>{
            oneSide.forEach((r)=>{
                needs.push(getTokenNeeds(r));
            });
        });
    });
    return needs.filter((str)=>str);
};
const getWants = function(regs) {
    let wants = [];
    let count = 0;
    regs.forEach((reg)=>{
        if (reg.operator === "or" && !reg.optional && !reg.negative) {
            // add fast-or terms
            if (reg.fastOr) Array.from(reg.fastOr).forEach((w)=>{
                wants.push(w);
            });
            // add slow-or
            if (reg.choices) reg.choices.forEach((rs)=>{
                rs.forEach((r)=>{
                    let n = getTokenNeeds(r);
                    if (n) wants.push(n);
                });
            });
            count += 1;
        }
    });
    return {
        wants,
        count
    };
};
const parse = function(matches, world) {
    const parseMatch = world.methods.one.parseMatch;
    matches.forEach((obj)=>{
        obj.regs = parseMatch(obj.match, {}, world);
        // wrap these ifNo properties into an array
        if (typeof obj.ifNo === "string") obj.ifNo = [
            obj.ifNo
        ];
        if (obj.notIf) obj.notIf = parseMatch(obj.notIf, {}, world);
        // cache any requirements up-front 
        obj.needs = getNeeds(obj.regs);
        let { wants, count } = getWants(obj.regs);
        obj.wants = wants;
        obj.minWant = count;
        // get rid of tiny sentences
        obj.minWords = obj.regs.filter((o)=>!o.optional).length;
    });
    return matches;
};
exports.default = parse;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k8qHu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _01GetHooksJs = require("./01-getHooks.js");
var _01GetHooksJsDefault = parcelHelpers.interopDefault(_01GetHooksJs);
var _02TrimDownJs = require("./02-trim-down.js");
var _02TrimDownJsDefault = parcelHelpers.interopDefault(_02TrimDownJs);
// import getWants from './03-get-wants.js'
var _04RunMatchJs = require("./04-runMatch.js");
var _04RunMatchJsDefault = parcelHelpers.interopDefault(_04RunMatchJs);
const tooSmall = function(maybeList, document) {
    return maybeList.map((arr, i)=>{
        let termCount = document[i].length;
        arr = arr.filter((o)=>{
            return termCount >= o.minWords;
        });
        return arr;
    });
};
const sweep = function(document, net, methods, opts = {}) {
    // find suitable matches to attempt, on each sentence
    let docCache = methods.one.cacheDoc(document);
    // collect possible matches for this document
    let maybeList = (0, _01GetHooksJsDefault.default)(docCache, net.hooks);
    // ensure all defined needs are met for each match
    maybeList = (0, _02TrimDownJsDefault.default)(maybeList, docCache, document);
    // add unchacheable matches to each sentence's todo-list
    if (net.always.length > 0) maybeList = maybeList.map((arr)=>arr.concat(net.always));
    // if we don't have enough words
    maybeList = tooSmall(maybeList, document);
    // now actually run the matches
    let results = (0, _04RunMatchJsDefault.default)(maybeList, document, docCache, methods, opts);
    // console.dir(results, { depth: 5 })
    return results;
};
exports.default = sweep;

},{"./01-getHooks.js":"R8jLm","./02-trim-down.js":"dmbuB","./04-runMatch.js":"1c8Rt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"R8jLm":[function(require,module,exports) {
// for each cached-sentence, find a list of possible matches
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const getHooks = function(docCaches, hooks) {
    return docCaches.map((set, i)=>{
        let maybe = [];
        Object.keys(hooks).forEach((k)=>{
            if (docCaches[i].has(k)) maybe = maybe.concat(hooks[k]);
        });
        // remove duplicates
        let already = {};
        maybe = maybe.filter((m)=>{
            if (typeof already[m.match] === "boolean") return false;
            already[m.match] = true;
            return true;
        });
        return maybe;
    });
};
exports.default = getHooks;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dmbuB":[function(require,module,exports) {
// filter-down list of maybe-matches
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const localTrim = function(maybeList, docCache) {
    return maybeList.map((list, n)=>{
        let haves = docCache[n];
        // ensure all stated-needs of the match are met
        list = list.filter((obj)=>{
            return obj.needs.every((need)=>haves.has(need));
        });
        // ensure nothing matches in our 'ifNo' property
        list = list.filter((obj)=>{
            if (obj.ifNo !== undefined && obj.ifNo.some((no)=>haves.has(no)) === true) return false;
            return true;
        });
        // ensure atleast one(?) of the wants is found
        list = list.filter((obj)=>{
            if (obj.wants.length === 0) return true;
            // ensure there's one cache-hit
            let found = obj.wants.filter((str)=>haves.has(str)).length;
            return found >= obj.minWant;
        });
        return list;
    });
};
exports.default = localTrim;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1c8Rt":[function(require,module,exports) {
// finally,
// actually run these match-statements on the terms
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const runMatch = function(maybeList, document, docCache, methods, opts) {
    let results = [];
    for(let n = 0; n < maybeList.length; n += 1)for(let i = 0; i < maybeList[n].length; i += 1){
        let m = maybeList[n][i];
        // ok, actually do the work.
        let res = methods.one.match([
            document[n]
        ], m);
        // found something.
        if (res.ptrs.length > 0) {
            res.ptrs.forEach((ptr)=>{
                ptr[0] = n // fix the sentence pointer
                ;
                // check ifNo
                // if (m.ifNo !== undefined) {
                //   let terms = document[n].slice(ptr[1], ptr[2])
                //   for (let k = 0; k < m.ifNo.length; k += 1) {
                //     const no = m.ifNo[k]
                //     // quick-check cache
                //     if (docCache[n].has(no)) {
                //       if (no.startsWith('#')) {
                //         let tag = no.replace(/^#/, '')
                //         if (terms.find(t => t.tags.has(tag))) {
                //           console.log('+' + tag)
                //           return
                //         }
                //       } else if (terms.find(t => t.normal === no || t.tags.has(no))) {
                //         console.log('+' + no)
                //         return
                //       }
                //     }
                //   }
                // }
                let todo = Object.assign({}, m, {
                    pointer: ptr
                });
                if (m.unTag !== undefined) todo.unTag = m.unTag;
                results.push(todo);
            });
            //ok cool, can we stop early?
            if (opts.matchOne === true) return [
                results[0]
            ];
        }
    }
    return results;
};
exports.default = runMatch;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aPhL1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _canBeJs = require("./canBe.js");
var _canBeJsDefault = parcelHelpers.interopDefault(_canBeJs);
var process = require("6e04dfb4329cf33e");
const tagger = function(list, document, world) {
    const { model, methods } = world;
    const { getDoc, setTag, unTag } = methods.one;
    const looksPlural = methods.two.looksPlural;
    if (list.length === 0) return list;
    // some logging for debugging
    const env = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
    if (env.DEBUG_TAGS) console.log(`

  \x1b[32m\u{2192} ${list.length} post-tagger:\x1b[0m`) //eslint-disable-line
    ;
    return list.map((todo)=>{
        if (!todo.tag && !todo.chunk && !todo.unTag) return;
        let reason = todo.reason || todo.match;
        let terms = getDoc([
            todo.pointer
        ], document)[0];
        // handle 'safe' tag
        if (todo.safe === true) {
            // check for conflicting tags
            if ((0, _canBeJsDefault.default)(terms, todo.tag, model) === false) return;
            // dont tag half of a hyphenated word
            if (terms[terms.length - 1].post === "-") return;
        }
        if (todo.tag !== undefined) {
            setTag(terms, todo.tag, world, todo.safe, `[post] '${reason}'`);
            // quick and dirty plural tagger
            if (todo.tag === "Noun" && looksPlural) {
                let term = terms[terms.length - 1];
                if (looksPlural(term.text)) setTag([
                    term
                ], "Plural", world, todo.safe, "quick-plural");
                else setTag([
                    term
                ], "Singular", world, todo.safe, "quick-singular");
            }
        }
        if (todo.unTag !== undefined) unTag(terms, todo.unTag, world, todo.safe, reason);
        // allow setting chunks, too
        if (todo.chunk) terms.forEach((t)=>t.chunk = todo.chunk);
    });
};
exports.default = tagger;

},{"6e04dfb4329cf33e":"d5jf4","./canBe.js":"azM7y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"azM7y":[function(require,module,exports) {
// is this tag consistent with the tags they already have?
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const canBe = function(terms, tag, model) {
    let tagSet = model.one.tagSet;
    if (!tagSet.hasOwnProperty(tag)) return true;
    let not = tagSet[tag].not || [];
    for(let i = 0; i < terms.length; i += 1){
        let term = terms[i];
        for(let k = 0; k < not.length; k += 1){
            if (term.tags.has(not[k]) === true) return false //found a tag conflict - bail!
            ;
        }
    }
    return true;
};
exports.default = canBe;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"46q0n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./methods/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./api/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _libJs = require("./lib.js");
var _libJsDefault = parcelHelpers.interopDefault(_libJs);
var _tagRankJs = require("./compute/tagRank.js");
var _tagRankJsDefault = parcelHelpers.interopDefault(_tagRankJs);
exports.default = {
    model: {
        one: {
            tagSet: {}
        }
    },
    compute: {
        tagRank: (0, _tagRankJsDefault.default)
    },
    methods: (0, _indexJsDefault.default),
    api: (0, _indexJsDefault1.default),
    lib: (0, _libJsDefault.default)
};

},{"./methods/index.js":"j78rQ","./api/index.js":"lVyux","./lib.js":"c5Uwm","./compute/tagRank.js":"goLpg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j78rQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _setTagJs = require("./setTag.js");
var _setTagJsDefault = parcelHelpers.interopDefault(_setTagJs);
var _unTagJs = require("./unTag.js");
var _unTagJsDefault = parcelHelpers.interopDefault(_unTagJs);
var _canBeJs = require("./canBe.js");
var _canBeJsDefault = parcelHelpers.interopDefault(_canBeJs);
var _indexJs = require("./addTags/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
exports.default = {
    one: {
        setTag: (0, _setTagJsDefault.default),
        unTag: (0, _unTagJsDefault.default),
        addTags: (0, _indexJsDefault.default),
        canBe: (0, _canBeJsDefault.default)
    }
};

},{"./setTag.js":"hwnd7","./unTag.js":"9b9Ib","./canBe.js":"jsMh5","./addTags/index.js":"gYEF4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hwnd7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var process = require("4d582a60917a9993");
const isMulti = / /;
const addChunk = function(term, tag) {
    if (tag === "Noun") term.chunk = tag;
    if (tag === "Verb") term.chunk = tag;
};
const tagTerm = function(term, tag, tagSet, isSafe) {
    // does it already have this tag?
    if (term.tags.has(tag) === true) return null;
    // allow this shorthand in multiple-tag strings
    if (tag === ".") return null;
    // don't overwrite any tags, if term is frozen
    if (term.frozen === true) isSafe = true;
    // for known tags, do logical dependencies first
    let known = tagSet[tag];
    if (known) {
        // first, we remove any conflicting tags
        if (known.not && known.not.length > 0) for(let o = 0; o < known.not.length; o += 1){
            // if we're in tagSafe, skip this term.
            if (isSafe === true && term.tags.has(known.not[o])) return null;
            term.tags.delete(known.not[o]);
        }
        // add parent tags
        if (known.parents && known.parents.length > 0) for(let o = 0; o < known.parents.length; o += 1){
            term.tags.add(known.parents[o]);
            addChunk(term, known.parents[o]);
        }
    }
    // finally, add our tag
    term.tags.add(tag);
    // now it's dirty?
    term.dirty = true;
    // add a chunk too, if it's easy
    addChunk(term, tag);
    return true;
};
// support '#Noun . #Adjective' syntax
const multiTag = function(terms, tagString, tagSet, isSafe) {
    let tags = tagString.split(isMulti);
    terms.forEach((term, i)=>{
        let tag = tags[i];
        if (tag) {
            tag = tag.replace(/^#/, "");
            tagTerm(term, tag, tagSet, isSafe);
        }
    });
};
const isArray = function(arr) {
    return Object.prototype.toString.call(arr) === "[object Array]";
};
// verbose-mode tagger debuging
const log = (terms, tag, reason = "")=>{
    const yellow = (str)=>"\x1b[33m\x1b[3m" + str + "\x1b[0m";
    const i = (str)=>"\x1b[3m" + str + "\x1b[0m";
    let word = terms.map((t)=>{
        return t.text || "[" + t.implicit + "]";
    }).join(" ");
    if (typeof tag !== "string" && tag.length > 2) tag = tag.slice(0, 2).join(", #") + " +" //truncate the list of tags
    ;
    tag = typeof tag !== "string" ? tag.join(", #") : tag;
    console.log(` ${yellow(word).padEnd(24)} \x1b[32m\u{2192}\x1b[0m #${tag.padEnd(22)}  ${i(reason)}`) // eslint-disable-line
    ;
};
// add a tag to all these terms
const setTag = function(terms, tag, world = {}, isSafe, reason) {
    const tagSet = world.model.one.tagSet || {};
    if (!tag) return;
    // some logging for debugging
    const env = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
    if (env && env.DEBUG_TAGS) log(terms, tag, reason);
    if (isArray(tag) === true) {
        tag.forEach((tg)=>setTag(terms, tg, world, isSafe));
        return;
    }
    if (typeof tag !== "string") {
        console.warn(`compromise: Invalid tag '${tag}'`) // eslint-disable-line
        ;
        return;
    }
    tag = tag.trim();
    // support '#Noun . #Adjective' syntax
    if (isMulti.test(tag)) {
        multiTag(terms, tag, tagSet, isSafe);
        return;
    }
    tag = tag.replace(/^#/, "");
    // let set = false
    for(let i = 0; i < terms.length; i += 1)tagTerm(terms[i], tag, tagSet, isSafe);
};
exports.default = setTag;

},{"4d582a60917a9993":"d5jf4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9b9Ib":[function(require,module,exports) {
// remove this tag, and its children, from these terms
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const unTag = function(terms, tag, tagSet) {
    tag = tag.trim().replace(/^#/, "");
    for(let i = 0; i < terms.length; i += 1){
        let term = terms[i];
        // don't untag anything if term is frozen
        if (term.frozen === true) continue;
        // support clearing all tags, with '*'
        if (tag === "*") {
            term.tags.clear();
            continue;
        }
        // for known tags, do logical dependencies first
        let known = tagSet[tag];
        // removing #Verb should also remove #PastTense
        if (known && known.children.length > 0) for(let o = 0; o < known.children.length; o += 1)term.tags.delete(known.children[o]);
        term.tags.delete(tag);
    }
};
exports.default = unTag;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jsMh5":[function(require,module,exports) {
// quick check if this tag will require any untagging
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const canBe = function(term, tag, tagSet) {
    if (!tagSet.hasOwnProperty(tag)) return true // everything can be an unknown tag
    ;
    let not = tagSet[tag].not || [];
    for(let i = 0; i < not.length; i += 1){
        if (term.tags.has(not[i])) return false;
    }
    return true;
};
exports.default = canBe;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gYEF4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _gradSchool = require("grad-school");
var _gradSchoolDefault = parcelHelpers.interopDefault(_gradSchool);
var _02FmtJs = require("./02-fmt.js");
var _02FmtJsDefault = parcelHelpers.interopDefault(_02FmtJs);
var _01ValidateJs = require("./01-validate.js");
var _01ValidateJsDefault = parcelHelpers.interopDefault(_01ValidateJs);
// 'fill-down' parent logic inference
const compute = function(allTags) {
    // setup graph-lib format
    const flatList = Object.keys(allTags).map((k)=>{
        let o = allTags[k];
        const props = {
            not: new Set(o.not),
            also: o.also,
            is: o.is,
            novel: o.novel
        };
        return {
            id: k,
            parent: o.is,
            props,
            children: []
        };
    });
    const graph = (0, _gradSchoolDefault.default)(flatList).cache().fillDown();
    return graph.out("array");
};
const fromUser = function(tags) {
    Object.keys(tags).forEach((k)=>{
        tags[k] = Object.assign({}, tags[k]);
        tags[k].novel = true;
    });
    return tags;
};
const addTags = function(tags, already) {
    // are these tags internal ones, or user-generated?
    if (Object.keys(already).length > 0) tags = fromUser(tags);
    tags = (0, _01ValidateJsDefault.default)(tags, already);
    let allTags = Object.assign({}, already, tags);
    // do some basic setting-up
    // 'fill-down' parent logic
    const nodes = compute(allTags);
    // convert it to our final format
    const res = (0, _02FmtJsDefault.default)(nodes);
    return res;
};
exports.default = addTags;

},{"grad-school":"cLcRN","./02-fmt.js":"5gj8o","./01-validate.js":"dtdCM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cLcRN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>_);
const e = function(e) {
    return e.children = e.children || [], e._cache = e._cache || {}, e.props = e.props || {}, e._cache.parents = e._cache.parents || [], e._cache.children = e._cache.children || [], e;
}, t = /^ *(#|\/\/)/, n = function(t) {
    let n = t.trim().split(/->/), r = [];
    n.forEach((t)=>{
        r = r.concat(function(t) {
            if (!(t = t.trim())) return null;
            if (/^\[/.test(t) && /\]$/.test(t)) {
                let n = (t = (t = t.replace(/^\[/, "")).replace(/\]$/, "")).split(/,/);
                return n = n.map((e)=>e.trim()).filter((e)=>e), n = n.map((t)=>e({
                        id: t
                    })), n;
            }
            return [
                e({
                    id: t
                })
            ];
        }(t));
    }), r = r.filter((e)=>e);
    let i = r[0];
    for(let e = 1; e < r.length; e += 1)i.children.push(r[e]), i = r[e];
    return r[0];
}, r = (e, t)=>{
    let n = [], r = [
        e
    ];
    for(; r.length > 0;){
        let e = r.pop();
        n.push(e), e.children && e.children.forEach((n)=>{
            t && t(e, n), r.push(n);
        });
    }
    return n;
}, i = (e)=>"[object Array]" === Object.prototype.toString.call(e), c = (e)=>(e = e || "").trim(), s = function(c = []) {
    var s;
    return "string" == typeof c ? function(r) {
        let i = r.split(/\r?\n/), c = [];
        i.forEach((e)=>{
            if (!e.trim() || t.test(e)) return;
            let r = ((e)=>{
                const t = /^( {2}|\t)/;
                let n = 0;
                for(; t.test(e);)e = e.replace(t, ""), n += 1;
                return n;
            })(e);
            c.push({
                indent: r,
                node: n(e)
            });
        });
        let s = function(e) {
            let t = {
                children: []
            };
            return e.forEach((n, r)=>{
                0 === n.indent ? t.children = t.children.concat(n.node) : e[r - 1] && (function(e, t) {
                    let n = e[t].indent;
                    for(; t >= 0; t -= 1)if (e[t].indent < n) return e[t];
                    return e[0];
                })(e, r).node.children.push(n.node);
            }), t;
        }(c);
        return s = e(s), s;
    }(c) : i(c) ? function(t) {
        let n = {};
        t.forEach((e)=>{
            n[e.id] = e;
        });
        let r = e({});
        return t.forEach((t)=>{
            if ((t = e(t)).parent) {
                if (n.hasOwnProperty(t.parent)) {
                    let e = n[t.parent];
                    delete t.parent, e.children.push(t);
                } else console.warn(`[Grad] - missing node '${t.parent}'`);
            } else r.children.push(t);
        }), r;
    }(c) : (r(s = c).forEach(e), s);
}, h = (e)=>"\x1b[31m" + e + "\x1b[0m", o = (e)=>"\x1b[2m" + e + "\x1b[0m", l = function(e, t) {
    let n = "-> ";
    t && (n = o("\u2192 "));
    let i = "";
    return r(e).forEach((e, r)=>{
        let c = e.id || "";
        if (t && (c = h(c)), 0 === r && !e.id) return;
        let s = e._cache.parents.length;
        i += "    ".repeat(s) + n + c + "\n";
    }), i;
}, a = function(e) {
    let t = r(e);
    t.forEach((e)=>{
        delete (e = Object.assign({}, e)).children;
    });
    let n = t[0];
    return n && !n.id && 0 === Object.keys(n.props).length && t.shift(), t;
}, p = {
    text: l,
    txt: l,
    array: a,
    flat: a
}, d = function(e, t) {
    return "nested" === t || "json" === t ? e : "debug" === t ? (console.log(l(e, !0)), null) : p.hasOwnProperty(t) ? p[t](e) : e;
}, u = (e)=>{
    r(e, (e, t)=>{
        e.id && (e._cache.parents = e._cache.parents || [], t._cache.parents = e._cache.parents.concat([
            e.id
        ]));
    });
}, f = (e, t)=>(Object.keys(t).forEach((n)=>{
        if (t[n] instanceof Set) {
            let r = e[n] || new Set;
            e[n] = new Set([
                ...r,
                ...t[n]
            ]);
        } else if (((e)=>e && "object" == typeof e && !Array.isArray(e))(t[n])) {
            let r = e[n] || {};
            e[n] = Object.assign({}, t[n], r);
        } else i(t[n]) ? e[n] = t[n].concat(e[n] || []) : void 0 === e[n] && (e[n] = t[n]);
    }), e), j = /\//;
class g {
    constructor(e = {}){
        Object.defineProperty(this, "json", {
            enumerable: !1,
            value: e,
            writable: !0
        });
    }
    get children() {
        return this.json.children;
    }
    get id() {
        return this.json.id;
    }
    get found() {
        return this.json.id || this.json.children.length > 0;
    }
    props(e = {}) {
        let t = this.json.props || {};
        return "string" == typeof e && (t[e] = !0), this.json.props = Object.assign(t, e), this;
    }
    get(t) {
        if (t = c(t), !j.test(t)) {
            let e = this.json.children.find((e)=>e.id === t);
            return new g(e);
        }
        let n = ((e, t)=>{
            let n = ((e)=>"string" != typeof e ? e : (e = e.replace(/^\//, "")).split(/\//))(t = t || "");
            for(let t = 0; t < n.length; t += 1){
                let r = e.children.find((e)=>e.id === n[t]);
                if (!r) return null;
                e = r;
            }
            return e;
        })(this.json, t) || e({});
        return new g(n);
    }
    add(t, n = {}) {
        if (i(t)) return t.forEach((e)=>this.add(c(e), n)), this;
        t = c(t);
        let r = e({
            id: t,
            props: n
        });
        return this.json.children.push(r), new g(r);
    }
    remove(e) {
        return e = c(e), this.json.children = this.json.children.filter((t)=>t.id !== e), this;
    }
    nodes() {
        return r(this.json).map((e)=>(delete (e = Object.assign({}, e)).children, e));
    }
    cache() {
        return ((e)=>{
            let t = r(e, (e, t)=>{
                e.id && (e._cache.parents = e._cache.parents || [], e._cache.children = e._cache.children || [], t._cache.parents = e._cache.parents.concat([
                    e.id
                ]));
            }), n = {};
            t.forEach((e)=>{
                e.id && (n[e.id] = e);
            }), t.forEach((e)=>{
                e._cache.parents.forEach((t)=>{
                    n.hasOwnProperty(t) && n[t]._cache.children.push(e.id);
                });
            }), e._cache.children = Object.keys(n);
        })(this.json), this;
    }
    list() {
        return r(this.json);
    }
    fillDown() {
        var e;
        return e = this.json, r(e, (e, t)=>{
            t.props = f(t.props, e.props);
        }), this;
    }
    depth() {
        u(this.json);
        let e = r(this.json), t = e.length > 1 ? 1 : 0;
        return e.forEach((e)=>{
            if (0 === e._cache.parents.length) return;
            let n = e._cache.parents.length + 1;
            n > t && (t = n);
        }), t;
    }
    out(e) {
        return u(this.json), d(this.json, e);
    }
    debug() {
        return u(this.json), d(this.json, "debug"), this;
    }
}
const _ = function(e) {
    let t = s(e);
    return new g(t);
};
_.prototype.plugin = function(e) {
    e(this);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5gj8o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _colorsJs = require("./_colors.js");
var _colorsJsDefault = parcelHelpers.interopDefault(_colorsJs);
const getColor = function(node) {
    if ((0, _colorsJsDefault.default).hasOwnProperty(node.id)) return (0, _colorsJsDefault.default)[node.id];
    if ((0, _colorsJsDefault.default).hasOwnProperty(node.is)) return (0, _colorsJsDefault.default)[node.is];
    let found = node._cache.parents.find((c)=>(0, _colorsJsDefault.default)[c]);
    return (0, _colorsJsDefault.default)[found];
};
// convert tags to our final format
const fmt = function(nodes) {
    const res = {};
    nodes.forEach((node)=>{
        let { not, also, is, novel } = node.props;
        let parents = node._cache.parents;
        if (also) parents = parents.concat(also);
        res[node.id] = {
            is,
            not,
            novel,
            also,
            parents,
            children: node._cache.children,
            color: getColor(node)
        };
    });
    // lastly, add all children of all nots
    Object.keys(res).forEach((k)=>{
        let nots = new Set(res[k].not);
        res[k].not.forEach((not)=>{
            if (res[not]) res[not].children.forEach((tag)=>nots.add(tag));
        });
        res[k].not = Array.from(nots);
    });
    return res;
};
exports.default = fmt;

},{"./_colors.js":"cqKKD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cqKKD":[function(require,module,exports) {
// i just made these up
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const colors = {
    Noun: "blue",
    Verb: "green",
    Negative: "green",
    Date: "red",
    Value: "red",
    Adjective: "magenta",
    Preposition: "cyan",
    Conjunction: "cyan",
    Determiner: "cyan",
    Hyphenated: "cyan",
    Adverb: "cyan"
};
exports.default = colors;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dtdCM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const toArr = function(input) {
    if (!input) return [];
    if (typeof input === "string") return [
        input
    ];
    return input;
};
const addImplied = function(tags, already) {
    Object.keys(tags).forEach((k)=>{
        // support deprecated fmts
        if (tags[k].isA) tags[k].is = tags[k].isA;
        if (tags[k].notA) tags[k].not = tags[k].notA;
        // add any implicit 'is' tags
        if (tags[k].is && typeof tags[k].is === "string") {
            if (!already.hasOwnProperty(tags[k].is) && !tags.hasOwnProperty(tags[k].is)) tags[tags[k].is] = {};
        }
        // add any implicit 'not' tags
        if (tags[k].not && typeof tags[k].not === "string" && !tags.hasOwnProperty(tags[k].not)) {
            if (!already.hasOwnProperty(tags[k].not) && !tags.hasOwnProperty(tags[k].not)) tags[tags[k].not] = {};
        }
    });
    return tags;
};
const validate = function(tags, already) {
    tags = addImplied(tags, already);
    // property validation
    Object.keys(tags).forEach((k)=>{
        tags[k].children = toArr(tags[k].children);
        tags[k].not = toArr(tags[k].not);
    });
    // not links are bi-directional
    // add any incoming not tags
    Object.keys(tags).forEach((k)=>{
        let nots = tags[k].not || [];
        nots.forEach((no)=>{
            if (tags[no] && tags[no].not) tags[no].not.push(k);
        });
    });
    return tags;
};
exports.default = validate;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lVyux":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tagJs = require("./tag.js");
var _tagJsDefault = parcelHelpers.interopDefault(_tagJs);
const tagAPI = function(View) {
    Object.assign(View.prototype, (0, _tagJsDefault.default));
};
exports.default = tagAPI;

},{"./tag.js":"28vwS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"28vwS":[function(require,module,exports) {
/* eslint no-console: 0 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isArray = function(arr) {
    return Object.prototype.toString.call(arr) === "[object Array]";
};
const fns = {
    /** add a given tag, to all these terms */ tag: function(input, reason = "", isSafe) {
        if (!this.found || !input) return this;
        let terms = this.termList();
        if (terms.length === 0) return this;
        const { methods, verbose, world } = this;
        // logger
        if (verbose === true) console.log(" +  ", input, reason || "");
        if (isArray(input)) input.forEach((tag)=>methods.one.setTag(terms, tag, world, isSafe, reason));
        else methods.one.setTag(terms, input, world, isSafe, reason);
        // uncache
        this.uncache();
        return this;
    },
    /** add a given tag, only if it is consistent */ tagSafe: function(input, reason = "") {
        return this.tag(input, reason, true);
    },
    /** remove a given tag from all these terms */ unTag: function(input, reason) {
        if (!this.found || !input) return this;
        let terms = this.termList();
        if (terms.length === 0) return this;
        const { methods, verbose, model } = this;
        // logger
        if (verbose === true) console.log(" -  ", input, reason || "");
        let tagSet = model.one.tagSet;
        if (isArray(input)) input.forEach((tag)=>methods.one.unTag(terms, tag, tagSet));
        else methods.one.unTag(terms, input, tagSet);
        // uncache
        this.uncache();
        return this;
    },
    /** return only the terms that can be this tag  */ canBe: function(tag) {
        tag = tag.replace(/^#/, "");
        let tagSet = this.model.one.tagSet;
        let canBe = this.methods.one.canBe;
        let nope = [];
        this.document.forEach((terms, n)=>{
            terms.forEach((term, i)=>{
                if (!canBe(term, tag, tagSet)) nope.push([
                    n,
                    i,
                    i + 1
                ]);
            });
        });
        let noDoc = this.update(nope);
        return this.difference(noDoc);
    }
};
exports.default = fns;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c5Uwm":[function(require,module,exports) {
// wire-up more pos-tags to our model
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const addTags = function(tags) {
    const { model, methods } = this.world();
    const tagSet = model.one.tagSet;
    const fn = methods.one.addTags;
    let res = fn(tags, tagSet);
    model.one.tagSet = res;
    return this;
};
exports.default = {
    addTags
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"goLpg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const boringTags = new Set([
    "Auxiliary",
    "Possessive"
]);
const sortByKids = function(tags, tagSet) {
    tags = tags.sort((a, b)=>{
        // (unknown tags are interesting)
        if (boringTags.has(a) || !tagSet.hasOwnProperty(b)) return 1;
        if (boringTags.has(b) || !tagSet.hasOwnProperty(a)) return -1;
        let kids = tagSet[a].children || [];
        let aKids = kids.length;
        kids = tagSet[b].children || [];
        let bKids = kids.length;
        return aKids - bKids;
    });
    return tags;
};
const tagRank = function(view) {
    const { document, world } = view;
    const tagSet = world.model.one.tagSet;
    document.forEach((terms)=>{
        terms.forEach((term)=>{
            let tags = Array.from(term.tags);
            term.tagRank = sortByKids(tags, tagSet);
        });
    });
};
exports.default = tagRank;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2ixvh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./methods/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./model/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("./compute/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
exports.default = {
    compute: (0, _indexJsDefault2.default),
    methods: (0, _indexJsDefault.default),
    model: (0, _indexJsDefault1.default),
    hooks: [
        "alias",
        "machine",
        "index",
        "id"
    ]
} // const plugin = function (world) {
 //   let { methods, model, parsers } = world
 //   Object.assign({}, methods, _methods)
 //   Object.assign(model, _model)
 //   methods.one.tokenize.fromString = tokenize
 //   parsers.push('normal')
 //   parsers.push('alias')
 //   parsers.push('machine')
 //   // extend View class
 //   // addMethods(View)
 // }
 // export default plugin
;

},{"./methods/index.js":"aEIKX","./model/index.js":"jOeHg","./compute/index.js":"1WhT6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aEIKX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./01-sentences/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./02-terms/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("./03-whitespace/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _unicodeJs = require("./unicode.js");
var _unicodeJsDefault = parcelHelpers.interopDefault(_unicodeJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);
var _isSentenceJs = require("./01-sentences/is-sentence.js");
var _isSentenceJsDefault = parcelHelpers.interopDefault(_isSentenceJs);
exports.default = {
    one: {
        killUnicode: (0, _unicodeJsDefault.default),
        tokenize: {
            splitSentences: (0, _indexJsDefault.default),
            isSentence: (0, _isSentenceJsDefault.default),
            splitTerms: (0, _indexJsDefault1.default),
            splitWhitespace: (0, _indexJsDefault2.default),
            fromString: (0, _parseJsDefault.default)
        }
    }
};

},{"./01-sentences/index.js":"bT9HM","./02-terms/index.js":"i2Yr5","./03-whitespace/index.js":"kn7mM","./unicode.js":"Ynsli","./parse.js":"kCfoW","./01-sentences/is-sentence.js":"c18ey","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bT9HM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _01SimpleSplitJs = require("./01-simple-split.js");
var _01SimpleSplitJsDefault = parcelHelpers.interopDefault(_01SimpleSplitJs);
var _02SimpleMergeJs = require("./02-simple-merge.js");
var _02SimpleMergeJsDefault = parcelHelpers.interopDefault(_02SimpleMergeJs);
var _03SmartMergeJs = require("./03-smart-merge.js");
var _03SmartMergeJsDefault = parcelHelpers.interopDefault(_03SmartMergeJs);
var _04QuoteMergeJs = require("./04-quote-merge.js");
var _04QuoteMergeJsDefault = parcelHelpers.interopDefault(_04QuoteMergeJs);
var _05ParensMergeJs = require("./05-parens-merge.js");
var _05ParensMergeJsDefault = parcelHelpers.interopDefault(_05ParensMergeJs);
//(Rule-based sentence boundary segmentation) - chop given text into its proper sentences.
// Ignore periods/questions/exclamations used in acronyms/abbreviations/numbers, etc.
//regs-
const hasSomething = /\S/;
const startWhitespace = /^\s+/;
const splitSentences = function(text, world) {
    text = text || "";
    text = String(text);
    // Ensure it 'smells like' a sentence
    if (!text || typeof text !== "string" || hasSomething.test(text) === false) return [];
    // cleanup unicode-spaces
    text = text.replace("\xa0", " ");
    // First do a greedy-split..
    let splits = (0, _01SimpleSplitJsDefault.default)(text);
    // Filter-out the crap ones
    let sentences = (0, _02SimpleMergeJsDefault.default)(splits);
    //detection of non-sentence chunks:
    sentences = (0, _03SmartMergeJsDefault.default)(sentences, world);
    // allow 'he said "no sir." and left.'
    sentences = (0, _04QuoteMergeJsDefault.default)(sentences);
    // allow 'i thought (no way!) and left.'
    sentences = (0, _05ParensMergeJsDefault.default)(sentences);
    //if we never got a sentence, return the given text
    if (sentences.length === 0) return [
        text
    ];
    //move whitespace to the ends of sentences, when possible
    //['hello',' world'] -> ['hello ','world']
    for(let i = 1; i < sentences.length; i += 1){
        let ws = sentences[i].match(startWhitespace);
        if (ws !== null) {
            sentences[i - 1] += ws[0];
            sentences[i] = sentences[i].replace(startWhitespace, "");
        }
    }
    return sentences;
};
exports.default = splitSentences;

},{"./01-simple-split.js":"aoklL","./02-simple-merge.js":"e5Drp","./03-smart-merge.js":"wJE4u","./04-quote-merge.js":"5Sw78","./05-parens-merge.js":"bspaN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aoklL":[function(require,module,exports) {
// split by periods, question marks, unicode ⁇, etc
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const initSplit = /([.!?\u203D\u2E18\u203C\u2047-\u2049\u3002]+\s)/g;
// merge these back into prev sentence
const splitsOnly = /^[.!?\u203D\u2E18\u203C\u2047-\u2049\u3002]+\s$/;
const newLine = /((?:\r?\n|\r)+)/ // Match different new-line formats
;
// Start with a regex:
const basicSplit = function(text) {
    let all = [];
    //first, split by newline
    let lines = text.split(newLine);
    for(let i = 0; i < lines.length; i++){
        //split by period, question-mark, and exclamation-mark
        let arr = lines[i].split(initSplit);
        for(let o = 0; o < arr.length; o++){
            // merge 'foo' + '.'
            if (arr[o + 1] && splitsOnly.test(arr[o + 1]) === true) {
                arr[o] += arr[o + 1];
                arr[o + 1] = "";
            }
            if (arr[o] !== "") all.push(arr[o]);
        }
    }
    return all;
};
exports.default = basicSplit;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e5Drp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const hasLetter = /[a-z0-9\u00C0-\u00FF\u00a9\u00ae\u2000-\u3300\ud000-\udfff]/i;
const hasSomething = /\S/;
const notEmpty = function(splits) {
    let chunks = [];
    for(let i = 0; i < splits.length; i++){
        let s = splits[i];
        if (s === undefined || s === "") continue;
        //this is meaningful whitespace
        if (hasSomething.test(s) === false || hasLetter.test(s) === false) {
            //add it to the last one
            if (chunks[chunks.length - 1]) {
                chunks[chunks.length - 1] += s;
                continue;
            } else if (splits[i + 1]) {
                //add it to the next one
                splits[i + 1] = s + splits[i + 1];
                continue;
            }
        }
        //else, only whitespace, no terms, no sentence
        chunks.push(s);
    }
    return chunks;
};
exports.default = notEmpty;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"wJE4u":[function(require,module,exports) {
//loop through these chunks, and join the non-sentence chunks back together..
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const smartMerge = function(chunks, world) {
    const isSentence = world.methods.one.tokenize.isSentence;
    const abbrevs = world.model.one.abbreviations || new Set();
    let sentences = [];
    for(let i = 0; i < chunks.length; i++){
        let c = chunks[i];
        //should this chunk be combined with the next one?
        if (chunks[i + 1] && isSentence(c, abbrevs) === false) chunks[i + 1] = c + (chunks[i + 1] || "");
        else if (c && c.length > 0) {
            //this chunk is a proper sentence..
            sentences.push(c);
            chunks[i] = "";
        }
    }
    return sentences;
};
exports.default = smartMerge;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Sw78":[function(require,module,exports) {
/* eslint-disable regexp/no-dupe-characters-character-class */ // merge embedded quotes into 1 sentence
// like - 'he said "no!" and left.' 
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const MAX_QUOTE = 280 // ¯\_(ツ)_/¯
;
// don't support single-quotes for multi-sentences
const pairs = {
    '"': '"',
    "\uFF02": "\uFF02",
    // '\u0027': '\u0027', // 'StraightSingleQuotes'
    "\u201C": "\u201D",
    // '\u2018': '\u2019', // 'CommaSingleQuotes'
    "\u201F": "\u201D",
    // '\u201B': '\u2019', // 'CurlySingleQuotesReversed'
    "\u201E": "\u201D",
    "\u2E42": "\u201D",
    "\u201A": "\u2019",
    "\xab": "\xbb",
    "\u2039": "\u203A",
    "\u2035": "\u2032",
    "\u2036": "\u2033",
    "\u2037": "\u2034",
    "\u301D": "\u301E",
    // '\u0060': '\u00B4', // 'PrimeSingleQuotes'
    "\u301F": "\u301E"
};
const openQuote = RegExp("[" + Object.keys(pairs).join("") + "]", "g");
const closeQuote = RegExp("[" + Object.values(pairs).join("") + "]", "g");
const closesQuote = function(str) {
    if (!str) return false;
    let m = str.match(closeQuote);
    if (m !== null && m.length === 1) return true;
    return false;
};
// allow micro-sentences when inside a quotation, like:
// the doc said "no sir. i will not beg" and walked away.
const quoteMerge = function(splits) {
    let arr = [];
    for(let i = 0; i < splits.length; i += 1){
        let split = splits[i];
        // do we have an open-quote and not a closed one?
        let m = split.match(openQuote);
        if (m !== null && m.length === 1) {
            // look at the next sentence for a closing quote,
            if (closesQuote(splits[i + 1]) && splits[i + 1].length < MAX_QUOTE) {
                splits[i] += splits[i + 1] // merge them
                ;
                arr.push(splits[i]);
                splits[i + 1] = "";
                i += 1;
                continue;
            }
            // look at n+2 for a closing quote,
            if (closesQuote(splits[i + 2])) {
                let toAdd = splits[i + 1] + splits[i + 2] // merge them all
                ;
                //make sure it's not too-long
                if (toAdd.length < MAX_QUOTE) {
                    splits[i] += toAdd;
                    arr.push(splits[i]);
                    splits[i + 1] = "";
                    splits[i + 2] = "";
                    i += 2;
                    continue;
                }
            }
        }
        arr.push(splits[i]);
    }
    return arr;
};
exports.default = quoteMerge;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bspaN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const MAX_LEN = 250 // ¯\_(ツ)_/¯
;
// support unicode variants?
// https://stackoverflow.com/questions/13535172/list-of-all-unicodes-open-close-brackets
const hasOpen = /\(/g;
const hasClosed = /\)/g;
const mergeParens = function(splits) {
    let arr = [];
    for(let i = 0; i < splits.length; i += 1){
        let split = splits[i];
        let m = split.match(hasOpen);
        if (m !== null && m.length === 1) // look at next sentence, for closing parenthesis
        {
            if (splits[i + 1] && splits[i + 1].length < MAX_LEN) {
                let m2 = splits[i + 1].match(hasClosed);
                if (m2 !== null && m.length === 1 && !hasOpen.test(splits[i + 1])) {
                    // merge in 2nd sentence
                    splits[i] += splits[i + 1];
                    arr.push(splits[i]);
                    splits[i + 1] = "";
                    i += 1;
                    continue;
                }
            }
        }
        arr.push(splits[i]);
    }
    return arr;
};
exports.default = mergeParens;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i2Yr5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _01HyphensJs = require("./01-hyphens.js");
var _03RangesJs = require("./03-ranges.js");
var _03RangesJsDefault = parcelHelpers.interopDefault(_03RangesJs);
var _02SlashesJs = require("./02-slashes.js");
var _02SlashesJsDefault = parcelHelpers.interopDefault(_02SlashesJs);
const wordlike = /\S/;
const isBoundary = /^[!?.]+$/;
const naiiveSplit = /(\S+)/;
let notWord = [
    ".",
    "?",
    "!",
    ":",
    ";",
    "-",
    "\u2013",
    "\u2014",
    "--",
    "...",
    "(",
    ")",
    "[",
    "]",
    '"',
    "'",
    "`",
    "\xab",
    "\xbb",
    "*",
    "\u2022"
];
notWord = notWord.reduce((h, c)=>{
    h[c] = true;
    return h;
}, {});
const isArray = function(arr) {
    return Object.prototype.toString.call(arr) === "[object Array]";
};
//turn a string into an array of strings (naiive for now, lumped later)
const splitWords = function(str, model) {
    let result = [];
    let arr = [];
    //start with a naiive split
    str = str || "";
    if (typeof str === "number") str = String(str);
    if (isArray(str)) return str;
    const words = str.split(naiiveSplit);
    for(let i = 0; i < words.length; i++){
        //split 'one-two'
        if ((0, _01HyphensJs.hasHyphen)(words[i], model) === true) {
            arr = arr.concat((0, _01HyphensJs.splitHyphens)(words[i]));
            continue;
        }
        arr.push(words[i]);
    }
    //greedy merge whitespace+arr to the right
    let carry = "";
    for(let i = 0; i < arr.length; i++){
        let word = arr[i];
        //if it's more than a whitespace
        if (wordlike.test(word) === true && notWord.hasOwnProperty(word) === false && isBoundary.test(word) === false) {
            //put whitespace on end of previous term, if possible
            if (result.length > 0) {
                result[result.length - 1] += carry;
                result.push(word);
            } else //otherwise, but whitespace before
            result.push(carry + word);
            carry = "";
        } else carry += word;
    }
    //handle last one
    if (carry) {
        if (result.length === 0) result[0] = "";
        result[result.length - 1] += carry //put it on the end
        ;
    }
    // combine 'one / two'
    result = (0, _02SlashesJsDefault.default)(result);
    result = (0, _03RangesJsDefault.default)(result);
    // remove empty results
    result = result.filter((s)=>s);
    return result;
};
exports.default = splitWords;

},{"./01-hyphens.js":"kptN1","./03-ranges.js":"dj1rd","./02-slashes.js":"4qQUw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kptN1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "splitHyphens", ()=>splitHyphens);
parcelHelpers.export(exports, "hasHyphen", ()=>hasHyphen);
const hasHyphen = function(str, model) {
    let parts = str.split(/[-–—]/);
    if (parts.length <= 1) return false;
    const { prefixes, suffixes } = model.one;
    // l-theanine, x-ray
    if (parts[0].length === 1 && /[a-z]/i.test(parts[0])) return false;
    //dont split 're-do'
    if (prefixes.hasOwnProperty(parts[0])) return false;
    //dont split 'flower-like'
    parts[1] = parts[1].trim().replace(/[.?!]$/, "");
    if (suffixes.hasOwnProperty(parts[1])) return false;
    //letter-number 'aug-20'
    let reg = /^([a-z\u00C0-\u00FF`"'/]+)[-–—]([a-z0-9\u00C0-\u00FF].*)/i;
    if (reg.test(str) === true) return true;
    //number-letter '20-aug'
    let reg2 = /^([0-9]{1,4})[-–—]([a-z\u00C0-\u00FF`"'/-]+$)/i;
    if (reg2.test(str) === true) return true;
    return false;
};
const splitHyphens = function(word) {
    let arr = [];
    //support multiple-hyphenated-terms
    const hyphens = word.split(/[-–—]/);
    let whichDash = "-";
    let found = word.match(/[-–—]/);
    if (found && found[0]) whichDash = found;
    for(let o = 0; o < hyphens.length; o++)if (o === hyphens.length - 1) arr.push(hyphens[o]);
    else arr.push(hyphens[o] + whichDash);
    return arr;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dj1rd":[function(require,module,exports) {
// combine '2 - 5' like '2-5' is
// 2-4: 2, 4
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const combineRanges = function(arr) {
    const startRange = /^[0-9]{1,4}(:[0-9][0-9])?([a-z]{1,2})? ?[-–—] ?$/;
    const endRange = /^[0-9]{1,4}([a-z]{1,2})? ?$/;
    for(let i = 0; i < arr.length - 1; i += 1)if (arr[i + 1] && startRange.test(arr[i]) && endRange.test(arr[i + 1])) {
        arr[i] = arr[i] + arr[i + 1];
        arr[i + 1] = null;
    }
    return arr;
};
exports.default = combineRanges;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4qQUw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isSlash = /\p{L} ?\/ ?\p{L}+$/u;
// 'he / she' should be one word
const combineSlashes = function(arr) {
    for(let i = 1; i < arr.length - 1; i++)if (isSlash.test(arr[i])) {
        arr[i - 1] += arr[i] + arr[i + 1];
        arr[i] = null;
        arr[i + 1] = null;
    }
    return arr;
};
exports.default = combineSlashes;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kn7mM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tokenizeJs = require("./tokenize.js");
var _tokenizeJsDefault = parcelHelpers.interopDefault(_tokenizeJs);
const parseTerm = (txt, model)=>{
    // cleanup any punctuation as whitespace
    let { str, pre, post } = (0, _tokenizeJsDefault.default)(txt, model);
    const parsed = {
        text: str,
        pre: pre,
        post: post,
        tags: new Set()
    };
    return parsed;
};
exports.default = parseTerm;

},{"./tokenize.js":"dGZMq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dGZMq":[function(require,module,exports) {
//all punctuation marks, from https://en.wikipedia.org/wiki/Punctuation
//we have slightly different rules for start/end - like #hashtags.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isLetter = /\p{Letter}/u;
const isNumber = /[\p{Number}\p{Currency_Symbol}]/u;
const hasAcronym = /^[a-z]\.([a-z]\.)+/i;
const chillin = /[sn]['’]$/;
const normalizePunctuation = function(str, model) {
    // quick lookup for allowed pre/post punctuation
    let { prePunctuation, postPunctuation, emoticons } = model.one;
    let original = str;
    let pre = "";
    let post = "";
    let chars = Array.from(str);
    // punctuation-only words, like '<3'
    if (emoticons.hasOwnProperty(str.trim())) return {
        str: str.trim(),
        pre,
        post: " "
    } //not great
    ;
    // pop any punctuation off of the start
    let len = chars.length;
    for(let i = 0; i < len; i += 1){
        let c = chars[0];
        // keep any declared chars
        if (prePunctuation[c] === true) continue; //keep it
        // keep '+' or '-' only before a number
        if ((c === "+" || c === "-") && isNumber.test(chars[1])) break; //done
        // '97 - year short-form
        if (c === "'" && c.length === 3 && isNumber.test(chars[1])) break; //done
        // start of word
        if (isLetter.test(c) || isNumber.test(c)) break; //done
        // punctuation
        pre += chars.shift() //keep going
        ;
    }
    // pop any punctuation off of the end
    len = chars.length;
    for(let i = 0; i < len; i += 1){
        let c = chars[chars.length - 1];
        // keep any declared chars
        if (postPunctuation[c] === true) continue; //keep it
        // start of word
        if (isLetter.test(c) || isNumber.test(c)) break; //done
        // F.B.I.
        if (c === "." && hasAcronym.test(original) === true) continue; //keep it
        //  keep s-apostrophe - "flanders'" or "chillin'"
        if (c === "'" && chillin.test(original) === true) continue; //keep it
        // punctuation
        post = chars.pop() + post //keep going
        ;
    }
    str = chars.join("");
    //we went too far..
    if (str === "") {
        // do a very mild parse, and hope for the best.
        original = original.replace(/ *$/, (after)=>{
            post = after || "";
            return "";
        });
        str = original;
        pre = "";
    }
    return {
        str,
        pre,
        post
    };
};
exports.default = normalizePunctuation;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Ynsli":[function(require,module,exports) {
// 'Björk' to 'Bjork'.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const killUnicode = function(str, world) {
    const unicode = world.model.one.unicode || {};
    str = str || "";
    let chars = str.split("");
    chars.forEach((s, i)=>{
        if (unicode[s]) chars[i] = unicode[s];
    });
    return chars.join("");
};
exports.default = killUnicode;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kCfoW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../compute/normal/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
// turn a string input into a 'document' json format
const parse = function(input, world) {
    const { methods, model } = world;
    const { splitSentences, splitTerms, splitWhitespace } = methods.one.tokenize;
    input = input || "";
    // split into sentences
    let sentences = splitSentences(input, world);
    // split into word objects
    input = sentences.map((txt)=>{
        let terms = splitTerms(txt, model);
        // split into [pre-text-post]
        terms = terms.map((t)=>splitWhitespace(t, model));
        // add normalized term format, always
        terms.forEach((t)=>{
            (0, _indexJsDefault.default)(t, world);
        });
        return terms;
    });
    return input;
};
exports.default = parse;

},{"../compute/normal/index.js":"84ckl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"84ckl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _01CleanupJs = require("./01-cleanup.js");
var _01CleanupJsDefault = parcelHelpers.interopDefault(_01CleanupJs);
// import doUnicode from './02-unicode.js'
var _02AcronymsJs = require("./02-acronyms.js");
var _02AcronymsJsDefault = parcelHelpers.interopDefault(_02AcronymsJs);
const normalize = function(term, world) {
    const killUnicode = world.methods.one.killUnicode;
    // console.log(world.methods.one)
    let str = term.text || "";
    str = (0, _01CleanupJsDefault.default)(str);
    //(very) rough ASCII transliteration -  bjŏrk -> bjork
    str = killUnicode(str, world);
    str = (0, _02AcronymsJsDefault.default)(str);
    term.normal = str;
};
exports.default = normalize;

},{"./01-cleanup.js":"6KRab","./02-acronyms.js":"aH0TL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6KRab":[function(require,module,exports) {
/** some basic operations on a string to reduce noise */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const clean = function(str) {
    str = str || "";
    str = str.toLowerCase();
    str = str.trim();
    let original = str;
    //punctuation
    str = str.replace(/[,;.!?]+$/, "");
    //coerce Unicode ellipses
    str = str.replace(/\u2026/g, "...");
    //en-dash
    str = str.replace(/\u2013/g, "-");
    //strip leading & trailing grammatical punctuation
    if (/^[:;]/.test(str) === false) {
        str = str.replace(/\.{3,}$/g, "");
        str = str.replace(/[",.!:;?)]+$/g, "");
        str = str.replace(/^['"(]+/g, "");
    }
    // remove zero-width characters
    str = str.replace(/[\u200B-\u200D\uFEFF]/g, "");
    //do this again..
    str = str.trim();
    //oh shucks,
    if (str === "") str = original;
    //no-commas in numbers
    str = str.replace(/([0-9]),([0-9])/g, "$1$2");
    return str;
};
exports.default = clean;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aH0TL":[function(require,module,exports) {
// do acronyms need to be ASCII?  ... kind of?
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const periodAcronym = /([A-Z]\.)+[A-Z]?,?$/;
const oneLetterAcronym = /^[A-Z]\.,?$/;
const noPeriodAcronym = /[A-Z]{2,}('s|,)?$/;
const lowerCaseAcronym = /([a-z]\.)+[a-z]\.?$/;
const isAcronym = function(str) {
    //like N.D.A
    if (periodAcronym.test(str) === true) return true;
    //like c.e.o
    if (lowerCaseAcronym.test(str) === true) return true;
    //like 'F.'
    if (oneLetterAcronym.test(str) === true) return true;
    //like NDA
    if (noPeriodAcronym.test(str) === true) return true;
    return false;
};
const doAcronym = function(str) {
    if (isAcronym(str)) str = str.replace(/\./g, "");
    return str;
};
exports.default = doAcronym;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c18ey":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isAcronym = /[ .][A-Z]\.? *$/i //asci - 'n.s.a.'
;
const hasEllipse = /(?:\u2026|\.{2,}) *$/ // '...'
;
const hasLetter = /\p{L}/u;
const hasPeriod = /\. *$/;
const leadInit = /^[A-Z]\. $/ // "W. Kensington"
;
/** does this look like a sentence? */ const isSentence = function(str, abbrevs) {
    // must have a letter
    if (hasLetter.test(str) === false) return false;
    // check for 'F.B.I.'
    if (isAcronym.test(str) === true) return false;
    // check for leading initial - "W. Kensington"
    if (str.length === 3 && leadInit.test(str)) return false;
    //check for '...'
    if (hasEllipse.test(str) === true) return false;
    let txt = str.replace(/[.!?\u203D\u2E18\u203C\u2047-\u2049] *$/, "");
    let words = txt.split(" ");
    let lastWord = words[words.length - 1].toLowerCase();
    // check for 'Mr.' (and not mr?)
    if (abbrevs.hasOwnProperty(lastWord) === true && hasPeriod.test(str) === true) return false;
    // //check for jeopardy!
    // if (blacklist.hasOwnProperty(lastWord)) {
    //   return false
    // }
    return true;
};
exports.default = isSentence;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jOeHg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _aliasesJs = require("./aliases.js");
var _aliasesJsDefault = parcelHelpers.interopDefault(_aliasesJs);
var _lexiconJs = require("./lexicon.js");
var _prefixesJs = require("./prefixes.js");
var _prefixesJsDefault = parcelHelpers.interopDefault(_prefixesJs);
var _suffixesJs = require("./suffixes.js");
var _suffixesJsDefault = parcelHelpers.interopDefault(_suffixesJs);
var _unicodeJs = require("./unicode.js");
var _unicodeJsDefault = parcelHelpers.interopDefault(_unicodeJs);
var _punctuationJs = require("./punctuation.js");
exports.default = {
    one: {
        aliases: (0, _aliasesJsDefault.default),
        abbreviations: (0, _lexiconJs.abbreviations),
        prefixes: (0, _prefixesJsDefault.default),
        suffixes: (0, _suffixesJsDefault.default),
        prePunctuation: (0, _punctuationJs.prePunctuation),
        postPunctuation: (0, _punctuationJs.postPunctuation),
        lexicon: (0, _lexiconJs.lexicon),
        unicode: (0, _unicodeJsDefault.default),
        emoticons: (0, _punctuationJs.emoticons)
    }
};

},{"./aliases.js":"5s4RR","./lexicon.js":"aUzar","./prefixes.js":"6KDU8","./suffixes.js":"hiDUF","./unicode.js":"g1b5B","./punctuation.js":"jSqvQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5s4RR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const aliases = {
    "&": "and",
    "@": "at",
    "%": "percent",
    "plz": "please",
    "bein": "being"
};
exports.default = aliases;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aUzar":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lexicon", ()=>lexicon);
parcelHelpers.export(exports, "abbreviations", ()=>abbreviations);
var _miscJs = require("./abbreviations/misc.js");
var _miscJsDefault = parcelHelpers.interopDefault(_miscJs);
var _honorificsJs = require("./abbreviations/honorifics.js");
var _honorificsJsDefault = parcelHelpers.interopDefault(_honorificsJs);
var _monthsJs = require("./abbreviations/months.js");
var _monthsJsDefault = parcelHelpers.interopDefault(_monthsJs);
var _nounsJs = require("./abbreviations/nouns.js");
var _nounsJsDefault = parcelHelpers.interopDefault(_nounsJs);
var _organizationsJs = require("./abbreviations/organizations.js");
var _organizationsJsDefault = parcelHelpers.interopDefault(_organizationsJs);
var _placesJs = require("./abbreviations/places.js");
var _placesJsDefault = parcelHelpers.interopDefault(_placesJs);
var _unitsJs = require("./abbreviations/units.js");
var _unitsJsDefault = parcelHelpers.interopDefault(_unitsJs);
// add our abbreviation list to our lexicon
let list = [
    [
        (0, _miscJsDefault.default)
    ],
    [
        (0, _unitsJsDefault.default),
        "Unit"
    ],
    [
        (0, _nounsJsDefault.default),
        "Noun"
    ],
    [
        (0, _honorificsJsDefault.default),
        "Honorific"
    ],
    [
        (0, _monthsJsDefault.default),
        "Month"
    ],
    [
        (0, _organizationsJsDefault.default),
        "Organization"
    ],
    [
        (0, _placesJsDefault.default),
        "Place"
    ]
];
// create key-val for sentence-tokenizer
let abbreviations = {};
// add them to a future lexicon
let lexicon = {};
list.forEach((a)=>{
    a[0].forEach((w)=>{
        // sentence abbrevs
        abbreviations[w] = true;
        // future-lexicon
        lexicon[w] = "Abbreviation";
        if (a[1] !== undefined) lexicon[w] = [
            lexicon[w],
            a[1]
        ];
    });
});

},{"./abbreviations/misc.js":"9T3ZF","./abbreviations/honorifics.js":"daB0m","./abbreviations/months.js":"c32th","./abbreviations/nouns.js":"aVNfO","./abbreviations/organizations.js":"6YfuE","./abbreviations/places.js":"51NMP","./abbreviations/units.js":"7Haxe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9T3ZF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    "approx",
    "apt",
    "bc",
    "cyn",
    "eg",
    "esp",
    "est",
    "etc",
    "ex",
    "exp",
    "prob",
    "pron",
    "gal",
    "min",
    "pseud",
    "fig",
    "jd",
    "lat",
    "lng",
    "vol",
    "fm",
    "def",
    "misc",
    "plz",
    "ea",
    "ps",
    "sec",
    "pt",
    "pref",
    "pl",
    "pp",
    "qt",
    "fr",
    "sq",
    "nee",
    "ss",
    "tel",
    "temp",
    "vet",
    "ver",
    "fem",
    "masc",
    "eng",
    "adj",
    "vb",
    "rb",
    "inf",
    "situ",
    "vivo",
    "vitro",
    "wr"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"daB0m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    "adj",
    "adm",
    "adv",
    "asst",
    "atty",
    "bldg",
    "brig",
    "capt",
    "cmdr",
    "comdr",
    "cpl",
    "det",
    "dr",
    "esq",
    "gen",
    "gov",
    "hon",
    "jr",
    "llb",
    "lt",
    "maj",
    "messrs",
    "mlle",
    "mme",
    "mr",
    "mrs",
    "ms",
    "mstr",
    "phd",
    "prof",
    "pvt",
    "rep",
    "reps",
    "res",
    "rev",
    "sen",
    "sens",
    "sfc",
    "sgt",
    "sir",
    "sr",
    "supt",
    "surg"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c32th":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    "jan",
    "feb",
    "mar",
    "apr",
    "jun",
    "jul",
    "aug",
    "sep",
    "sept",
    "oct",
    "nov",
    "dec"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aVNfO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    "ad",
    "al",
    "arc",
    "ba",
    "bl",
    "ca",
    "cca",
    "col",
    "corp",
    "ft",
    "fy",
    "ie",
    "lit",
    "ma",
    "md",
    "pd",
    "tce"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6YfuE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    "dept",
    "univ",
    "assn",
    "bros",
    "inc",
    "ltd",
    "co"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"51NMP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    "rd",
    "st",
    "dist",
    "mt",
    "ave",
    "blvd",
    "cl",
    // 'ct',
    "cres",
    "hwy",
    //states
    "ariz",
    "cal",
    "calif",
    "colo",
    "conn",
    "fla",
    "fl",
    "ga",
    "ida",
    "ia",
    "kan",
    "kans",
    "minn",
    "neb",
    "nebr",
    "okla",
    "penna",
    "penn",
    "pa",
    "dak",
    "tenn",
    "tex",
    "ut",
    "vt",
    "va",
    "wis",
    "wisc",
    "wy",
    "wyo",
    "usafa",
    "alta",
    "ont",
    "que",
    "sask"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Haxe":[function(require,module,exports) {
// units that are abbreviations too
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    "dl",
    "ml",
    "gal",
    // 'ft', //ambiguous
    "qt",
    "pt",
    "tbl",
    "tsp",
    "tbsp",
    "km",
    "dm",
    "cm",
    "mm",
    "mi",
    "td",
    "hr",
    "hrs",
    "kg",
    "hg",
    "dg",
    "cg",
    "mg",
    "\xb5g",
    "lb",
    "oz",
    "sq ft",
    "hz",
    "mps",
    "mph",
    "kmph",
    "kb",
    "mb",
    // 'gb', //ambig
    "tb",
    "lx",
    "lm",
    // 'pa', //ambig
    "fl oz",
    "yb"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6KDU8":[function(require,module,exports) {
// dashed prefixes that are not independent words
//  'mid-century', 'pre-history'
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    "anti",
    "bi",
    "co",
    "contra",
    "de",
    "extra",
    "infra",
    "inter",
    "intra",
    "macro",
    "micro",
    "mis",
    "mono",
    "multi",
    "peri",
    "pre",
    "pro",
    "proto",
    "pseudo",
    "re",
    "sub",
    "supra",
    "trans",
    "tri",
    "un",
    "out",
    "ex"
].reduce((h, str)=>{
    h[str] = true;
    return h;
}, {});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hiDUF":[function(require,module,exports) {
// dashed suffixes that are not independent words
//  'flower-like', 'president-elect'
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    "like": true,
    "ish": true,
    "less": true,
    "able": true,
    "elect": true,
    "type": true,
    "designate": true
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g1b5B":[function(require,module,exports) {
//a hugely-ignorant, and widely subjective transliteration of latin, cryllic, greek unicode characters to english ascii.
//approximate visual (not semantic or phonetic) relationship between unicode and ascii characters
//http://en.wikipedia.org/wiki/List_of_Unicode_characters
//https://docs.google.com/spreadsheet/ccc?key=0Ah46z755j7cVdFRDM1A2YVpwa1ZYWlpJM2pQZ003M0E
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let compact = {
    "!": "\xa1",
    "?": "\xbf\u0241",
    '"': '\u201C\u201D"\u275D\u275E',
    "'": "\u2018\u201B\u275B\u275C\u2019",
    "-": "\u2014\u2013",
    a: "\xaa\xc0\xc1\xc2\xc3\xc4\xc5\xe0\xe1\xe2\xe3\xe4\xe5\u0100\u0101\u0102\u0103\u0104\u0105\u01CD\u01CE\u01DE\u01DF\u01E0\u01E1\u01FA\u01FB\u0200\u0201\u0202\u0203\u0226\u0227\u023A\u0386\u0391\u0394\u039B\u03AC\u03B1\u03BB\u0410\u0430\u0466\u0467\u04D0\u04D1\u04D2\u04D3\u019B\xe6",
    b: "\xdf\xfe\u0180\u0181\u0182\u0183\u0184\u0185\u0243\u0392\u03B2\u03D0\u03E6\u0411\u0412\u042A\u042C\u0432\u044A\u044C\u0462\u0463\u048C\u048D",
    c: "\xa2\xa9\xc7\xe7\u0106\u0107\u0108\u0109\u010A\u010B\u010C\u010D\u0186\u0187\u0188\u023B\u023C\u037B\u037C\u03F2\u03F9\u03FD\u03FE\u0421\u0441\u0454\u0480\u0481\u04AA\u04AB",
    d: "\xd0\u010E\u010F\u0110\u0111\u0189\u018A\u0221\u018B\u018C",
    e: "\xc8\xc9\xca\xcb\xe8\xe9\xea\xeb\u0112\u0113\u0114\u0115\u0116\u0117\u0118\u0119\u011A\u011B\u0190\u0204\u0205\u0206\u0207\u0228\u0229\u0246\u0247\u0388\u0395\u039E\u03A3\u03AD\u03B5\u03BE\u03F5\u0400\u0401\u0415\u0435\u0450\u0451\u04BC\u04BD\u04BE\u04BF\u04D6\u04D7\u1EC5",
    f: "\u0191\u0192\u03DC\u03DD\u04FA\u04FB\u0492\u0493\u017F",
    g: "\u011C\u011D\u011E\u011F\u0120\u0121\u0122\u0123\u0193\u01E4\u01E5\u01E6\u01E7\u01F4\u01F5",
    h: "\u0124\u0125\u0126\u0127\u0195\u01F6\u021E\u021F\u0389\u0397\u0402\u040A\u040B\u041D\u043D\u0452\u045B\u04A2\u04A3\u04A4\u04A5\u04BA\u04BB\u04C9\u04CA",
    I: "\xcc\xcd\xce\xcf",
    i: "\xec\xed\xee\xef\u0128\u0129\u012A\u012B\u012C\u012D\u012E\u012F\u0130\u0131\u0196\u0197\u0208\u0209\u020A\u020B\u038A\u0390\u03AA\u03AF\u03B9\u03CA\u0406\u0407\u0456\u0457i\u0307",
    j: "\u0134\u0135\u01F0\u0237\u0248\u0249\u03F3\u0408\u0458",
    k: "\u0136\u0137\u0138\u0198\u0199\u01E8\u01E9\u039A\u03BA\u040C\u0416\u041A\u0436\u043A\u045C\u049A\u049B\u049C\u049D\u049E\u049F\u04A0\u04A1",
    l: "\u0139\u013A\u013B\u013C\u013D\u013E\u013F\u0140\u0141\u0142\u019A\u01AA\u01C0\u01CF\u01D0\u0234\u023D\u0399\u04C0\u04CF",
    m: "\u039C\u03FA\u03FB\u041C\u043C\u04CD\u04CE",
    n: "\xd1\xf1\u0143\u0144\u0145\u0146\u0147\u0148\u0149\u014A\u014B\u019D\u019E\u01F8\u01F9\u0220\u0235\u039D\u03A0\u03AE\u03B7\u03DE\u040D\u0418\u0419\u041B\u041F\u0438\u0439\u043B\u043F\u045D\u048A\u048B\u04C5\u04C6\u04E2\u04E3\u04E4\u04E5\u03C0",
    o: "\xd2\xd3\xd4\xd5\xd6\xd8\xf0\xf2\xf3\xf4\xf5\xf6\xf8\u014C\u014D\u014E\u014F\u0150\u0151\u019F\u01A0\u01A1\u01D1\u01D2\u01EA\u01EB\u01EC\u01ED\u01FE\u01FF\u020C\u020D\u020E\u020F\u022A\u022B\u022C\u022D\u022E\u022F\u0230\u0231\u038C\u0398\u039F\u03B8\u03BF\u03C3\u03CC\u03D5\u03D8\u03D9\u03EC\u03F4\u041E\u0424\u043E\u0472\u0473\u04E6\u04E7\u04E8\u04E9\u04EA\u04EB",
    p: "\u01A4\u03A1\u03C1\u03F7\u03F8\u03FC\u0420\u0440\u048E\u048F\xde",
    q: "\u024A\u024B",
    r: "\u0154\u0155\u0156\u0157\u0158\u0159\u01A6\u0210\u0211\u0212\u0213\u024C\u024D\u0403\u0413\u042F\u0433\u044F\u0453\u0490\u0491",
    s: "\u015A\u015B\u015C\u015D\u015E\u015F\u0160\u0161\u01A7\u01A8\u0218\u0219\u023F\u0405\u0455",
    t: "\u0162\u0163\u0164\u0165\u0166\u0167\u01AB\u01AC\u01AD\u01AE\u021A\u021B\u0236\u023E\u0393\u03A4\u03C4\u03EE\u0422\u0442",
    u: "\xd9\xda\xdb\xdc\xf9\xfa\xfb\xfc\u0168\u0169\u016A\u016B\u016C\u016D\u016E\u016F\u0170\u0171\u0172\u0173\u01AF\u01B0\u01B1\u01B2\u01D3\u01D4\u01D5\u01D6\u01D7\u01D8\u01D9\u01DA\u01DB\u01DC\u0214\u0215\u0216\u0217\u0244\u03B0\u03C5\u03CB\u03CD",
    v: "\u03BD\u0474\u0475\u0476\u0477",
    w: "\u0174\u0175\u019C\u03C9\u03CE\u03D6\u03E2\u03E3\u0428\u0429\u0448\u0449\u0461\u047F",
    x: "\xd7\u03A7\u03C7\u03D7\u03F0\u0425\u0445\u04B2\u04B3\u04FC\u04FD\u04FE\u04FF",
    y: "\xdd\xfd\xff\u0176\u0177\u0178\u01B3\u01B4\u0232\u0233\u024E\u024F\u038E\u03A5\u03AB\u03B3\u03C8\u03D2\u03D3\u03D4\u040E\u0423\u0443\u0447\u045E\u0470\u0471\u04AE\u04AF\u04B0\u04B1\u04EE\u04EF\u04F0\u04F1\u04F2\u04F3",
    z: "\u0179\u017A\u017B\u017C\u017D\u017E\u01B5\u01B6\u0224\u0225\u0240\u0396"
};
//decompress data into two hashes
let unicode = {};
Object.keys(compact).forEach(function(k) {
    compact[k].split("").forEach(function(s) {
        unicode[s] = k;
    });
});
exports.default = unicode;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jSqvQ":[function(require,module,exports) {
// https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5Cp%7Bpunctuation%7D
// punctuation to keep at start of word
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "prePunctuation", ()=>prePunctuation);
parcelHelpers.export(exports, "postPunctuation", ()=>postPunctuation);
parcelHelpers.export(exports, "emoticons", ()=>emoticons);
const prePunctuation = {
    "#": true,
    "@": true,
    "_": true,
    "\xb0": true,
    // '+': true,//+4
    // '\\-',//-4  (escape)
    // '.',//.4
    // zero-width chars
    "\u200B": true,
    "\u200C": true,
    "\u200D": true,
    "\uFEFF": true
};
// punctuation to keep at end of word
const postPunctuation = {
    "%": true,
    "_": true,
    "\xb0": true,
    // '\'',// sometimes
    // zero-width chars
    "\u200B": true,
    "\u200C": true,
    "\u200D": true,
    "\uFEFF": true
};
const emoticons = {
    "<3": true,
    "</3": true,
    "<\\3": true,
    ":^P": true,
    ":^p": true,
    ":^O": true,
    ":^3": true
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1WhT6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _aliasJs = require("./alias.js");
var _aliasJsDefault = parcelHelpers.interopDefault(_aliasJs);
var _indexJs = require("./normal/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _machineJs = require("./machine.js");
var _machineJsDefault = parcelHelpers.interopDefault(_machineJs);
var _freqJs = require("./freq.js");
var _freqJsDefault = parcelHelpers.interopDefault(_freqJs);
var _offsetJs = require("./offset.js");
var _offsetJsDefault = parcelHelpers.interopDefault(_offsetJs);
var _reindexJs = require("./reindex.js");
var _reindexJsDefault = parcelHelpers.interopDefault(_reindexJs);
var _wordCountJs = require("./wordCount.js");
var _wordCountJsDefault = parcelHelpers.interopDefault(_wordCountJs);
// cheat-method for a quick loop
const termLoop = function(view, fn) {
    let docs = view.docs;
    for(let i = 0; i < docs.length; i += 1)for(let t = 0; t < docs[i].length; t += 1)fn(docs[i][t], view.world);
};
const methods = {
    alias: (view)=>termLoop(view, (0, _aliasJsDefault.default)),
    machine: (view)=>termLoop(view, (0, _machineJsDefault.default)),
    normal: (view)=>termLoop(view, (0, _indexJsDefault.default)),
    freq: (0, _freqJsDefault.default),
    offset: (0, _offsetJsDefault.default),
    index: (0, _reindexJsDefault.default),
    wordCount: (0, _wordCountJsDefault.default)
};
exports.default = methods;

},{"./alias.js":"fA764","./normal/index.js":"84ckl","./machine.js":"S4WXU","./freq.js":"h89Ht","./offset.js":"94iNc","./reindex.js":"cmYn9","./wordCount.js":"fF2gB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fA764":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const hasSlash = /\//;
const hasDomain = /[a-z]\.[a-z]/i;
const isMath = /[0-9]/;
// const hasSlash = /[a-z\u00C0-\u00FF] ?\/ ?[a-z\u00C0-\u00FF]/
// const hasApostrophe = /['’]s$/
const addAliases = function(term, world) {
    let str = term.normal || term.text || term.machine;
    const aliases = world.model.one.aliases;
    // lookup known aliases like '&'
    if (aliases.hasOwnProperty(str)) {
        term.alias = term.alias || [];
        term.alias.push(aliases[str]);
    }
    // support slashes as aliases
    if (hasSlash.test(str) && !hasDomain.test(str) && !isMath.test(str)) {
        let arr = str.split(hasSlash);
        // don't split urls and things
        if (arr.length <= 2) arr.forEach((word)=>{
            word = word.trim();
            if (word !== "") {
                term.alias = term.alias || [];
                term.alias.push(word);
            }
        });
    }
    // aliases for apostrophe-s
    // if (hasApostrophe.test(str)) {
    //   let main = str.replace(hasApostrophe, '').trim()
    //   term.alias = term.alias || []
    //   term.alias.push(main)
    // }
    return term;
};
exports.default = addAliases;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"S4WXU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const hasDash = /^\p{Letter}+-\p{Letter}+$/u;
// 'machine' is a normalized form that looses human-readability
const doMachine = function(term) {
    let str = term.implicit || term.normal || term.text;
    // remove apostrophes
    str = str.replace(/['’]s$/, "");
    str = str.replace(/s['’]$/, "s");
    //lookin'->looking (make it easier for conjugation)
    str = str.replace(/([aeiou][ktrp])in'$/, "$1ing");
    //turn re-enactment to reenactment
    if (hasDash.test(str)) str = str.replace(/-/g, "");
    //#tags, @mentions
    str = str.replace(/^[#@]/, "");
    if (str !== term.normal) term.machine = str;
};
exports.default = doMachine;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h89Ht":[function(require,module,exports) {
// sort words by frequency
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const freq = function(view) {
    let docs = view.docs;
    let counts = {};
    for(let i = 0; i < docs.length; i += 1)for(let t = 0; t < docs[i].length; t += 1){
        let term = docs[i][t];
        let word = term.machine || term.normal;
        counts[word] = counts[word] || 0;
        counts[word] += 1;
    }
    // add counts on each term
    for(let i = 0; i < docs.length; i += 1)for(let t = 0; t < docs[i].length; t += 1){
        let term = docs[i][t];
        let word = term.machine || term.normal;
        term.freq = counts[word];
    }
};
exports.default = freq;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"94iNc":[function(require,module,exports) {
// get all character startings in doc
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const offset = function(view) {
    let elapsed = 0;
    let index = 0;
    let docs = view.document //start from the actual-top
    ;
    for(let i = 0; i < docs.length; i += 1)for(let t = 0; t < docs[i].length; t += 1){
        let term = docs[i][t];
        term.offset = {
            index: index,
            start: elapsed + term.pre.length,
            length: term.text.length
        };
        elapsed += term.pre.length + term.text.length + term.post.length;
        index += 1;
    }
};
exports.default = offset;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cmYn9":[function(require,module,exports) {
// cheat- add the document's pointer to the terms
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const index = function(view) {
    // console.log('reindex')
    let document = view.document;
    for(let n = 0; n < document.length; n += 1)for(let i = 0; i < document[n].length; i += 1)document[n][i].index = [
        n,
        i
    ];
// let ptrs = b.fullPointer
// console.log(ptrs)
// for (let i = 0; i < docs.length; i += 1) {
//   const [n, start] = ptrs[i]
//   for (let t = 0; t < docs[i].length; t += 1) {
//     let term = docs[i][t]
//     term.index = [n, start + t]
//   }
// }
};
exports.default = index;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fF2gB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const wordCount = function(view) {
    let n = 0;
    let docs = view.docs;
    for(let i = 0; i < docs.length; i += 1)for(let t = 0; t < docs[i].length; t += 1){
        if (docs[i][t].normal === "") continue; //skip implicit words
        n += 1;
        docs[i][t].wordCount = n;
    }
};
exports.default = wordCount;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9AItl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _computeJs = require("./compute.js");
var _computeJsDefault = parcelHelpers.interopDefault(_computeJs);
var _apiJs = require("./api.js");
var _apiJsDefault = parcelHelpers.interopDefault(_apiJs);
var _indexJs = require("./lib/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
const model = {
    one: {
        typeahead: {} //set a blank key-val
    }
};
exports.default = {
    model,
    api: (0, _apiJsDefault.default),
    lib: (0, _indexJsDefault.default),
    compute: (0, _computeJsDefault.default),
    hooks: [
        "typeahead"
    ]
};

},{"./compute.js":"bdJGz","./api.js":"utQgB","./lib/index.js":"jK7AM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bdJGz":[function(require,module,exports) {
// lookup last word in the type-ahead prefixes
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const typeahead = function(view) {
    const prefixes = view.model.one.typeahead;
    const docs = view.docs;
    if (docs.length === 0 || Object.keys(prefixes).length === 0) return;
    let lastPhrase = docs[docs.length - 1] || [];
    let lastTerm = lastPhrase[lastPhrase.length - 1];
    // if we've already put whitespace, end.
    if (lastTerm.post) return;
    // if we found something
    if (prefixes.hasOwnProperty(lastTerm.normal)) {
        let found = prefixes[lastTerm.normal];
        // add full-word as an implicit result
        lastTerm.implicit = found;
        lastTerm.machine = found;
        lastTerm.typeahead = true;
        // tag it, as our assumed term
        if (view.compute.preTagger) view.last().unTag("*").compute([
            "lexicon",
            "preTagger"
        ]);
    }
};
exports.default = {
    typeahead
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"utQgB":[function(require,module,exports) {
// assume any discovered prefixes
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const autoFill = function() {
    const docs = this.docs;
    if (docs.length === 0) return this;
    let lastPhrase = docs[docs.length - 1] || [];
    let term = lastPhrase[lastPhrase.length - 1];
    if (term.typeahead === true && term.machine) {
        term.text = term.machine;
        term.normal = term.machine;
    }
    return this;
};
const api = function(View) {
    View.prototype.autoFill = autoFill;
};
exports.default = api;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jK7AM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _allPrefixesJs = require("./allPrefixes.js");
var _allPrefixesJsDefault = parcelHelpers.interopDefault(_allPrefixesJs);
const isObject = (val)=>{
    return Object.prototype.toString.call(val) === "[object Object]";
};
const defaults = {
    safe: true,
    min: 3
};
const prepare = function(words = [], opts = {}) {
    let model = this.model();
    opts = Object.assign({}, defaults, opts);
    if (isObject(words)) {
        Object.assign(model.one.lexicon, words);
        words = Object.keys(words);
    }
    let prefixes = (0, _allPrefixesJsDefault.default)(words, opts, this.world());
    // manually combine these with any existing prefixes
    Object.keys(prefixes).forEach((str)=>{
        // explode any overlaps
        if (model.one.typeahead.hasOwnProperty(str)) {
            delete model.one.typeahead[str];
            return;
        }
        model.one.typeahead[str] = prefixes[str];
    });
    return this;
};
exports.default = {
    typeahead: prepare
};

},{"./allPrefixes.js":"cMmFP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cMmFP":[function(require,module,exports) {
// generate all the possible prefixes up-front
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const getPrefixes = function(arr, opts, world) {
    let index = {};
    let collisions = [];
    let existing = world.prefixes || {};
    arr.forEach((str)=>{
        str = str.toLowerCase().trim();
        let max = str.length;
        if (opts.max && max > opts.max) max = opts.max;
        for(let size = opts.min; size < max; size += 1){
            let prefix = str.substring(0, size);
            // ensure prefix is not a word
            if (opts.safe && world.model.one.lexicon.hasOwnProperty(prefix)) continue;
            // does it already exist?
            if (existing.hasOwnProperty(prefix) === true) {
                collisions.push(prefix);
                continue;
            }
            if (index.hasOwnProperty(prefix) === true) {
                collisions.push(prefix);
                continue;
            }
            index[prefix] = str;
        }
    });
    // merge with existing prefixes
    index = Object.assign({}, existing, index);
    // remove ambiguous-prefixes
    collisions.forEach((str)=>{
        delete index[str];
    });
    return index;
};
exports.default = getPrefixes;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kITyy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./model/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./methods/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("./compute/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("./tagSet/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
exports.default = {
    compute: (0, _indexJsDefault2.default),
    methods: (0, _indexJsDefault1.default),
    model: (0, _indexJsDefault.default),
    tags: (0, _indexJsDefault3.default),
    hooks: [
        "preTagger"
    ]
};

},{"./model/index.js":"4IvtX","./methods/index.js":"6Zd6V","./compute/index.js":"gpW0x","./tagSet/index.js":"dtblM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4IvtX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _pluralsJs = require("./irregulars/plurals.js");
var _pluralsJsDefault = parcelHelpers.interopDefault(_pluralsJs);
var _indexJs = require("./lexicon/index.js");
var _indexJs1 = require("./clues/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs1);
var _suffixesJs = require("./patterns/suffixes.js");
var _suffixesJsDefault = parcelHelpers.interopDefault(_suffixesJs);
var _prefixesJs = require("./patterns/prefixes.js");
var _prefixesJsDefault = parcelHelpers.interopDefault(_prefixesJs);
var _endsWithJs = require("./patterns/endsWith.js");
var _endsWithJsDefault = parcelHelpers.interopDefault(_endsWithJs);
var _neighboursJs = require("./patterns/neighbours.js");
var _neighboursJsDefault = parcelHelpers.interopDefault(_neighboursJs);
var _indexJs2 = require("./models/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs2);
var _regexNormalJs = require("./regex/regex-normal.js");
var _regexNormalJsDefault = parcelHelpers.interopDefault(_regexNormalJs);
var _regexTextJs = require("./regex/regex-text.js");
var _regexTextJsDefault = parcelHelpers.interopDefault(_regexTextJs);
var _regexNumbersJs = require("./regex/regex-numbers.js");
var _regexNumbersJsDefault = parcelHelpers.interopDefault(_regexNumbersJs);
var _orgWordsJs = require("./orgWords.js");
var _orgWordsJsDefault = parcelHelpers.interopDefault(_orgWordsJs);
var _placeWordsJs = require("./placeWords.js");
var _placeWordsJsDefault = parcelHelpers.interopDefault(_placeWordsJs);
var _indexJs3 = require("./_expand/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs3);
let model = {
    one: {
        _multiCache: {},
        lexicon: (0, _indexJs.lexicon),
        frozenLex: (0, _indexJs.frozenLex)
    },
    two: {
        irregularPlurals: (0, _pluralsJsDefault.default),
        models: (0, _indexJsDefault1.default),
        suffixPatterns: (0, _suffixesJsDefault.default),
        prefixPatterns: (0, _prefixesJsDefault.default),
        endsWith: (0, _endsWithJsDefault.default),
        neighbours: (0, _neighboursJsDefault.default),
        regexNormal: (0, _regexNormalJsDefault.default),
        regexText: (0, _regexTextJsDefault.default),
        regexNumbers: (0, _regexNumbersJsDefault.default),
        switches: (0, _indexJs.switches),
        clues: (0, _indexJsDefault.default),
        uncountable: {},
        orgWords: (0, _orgWordsJsDefault.default),
        placeWords: (0, _placeWordsJsDefault.default)
    }
};
model = (0, _indexJsDefault2.default)(model);
exports.default = model // console.log(model.one.lexicon.see)
;

},{"./irregulars/plurals.js":"cpmt2","./lexicon/index.js":"dEKVu","./clues/index.js":"lHQUO","./patterns/suffixes.js":"jfysp","./patterns/prefixes.js":"ajUtP","./patterns/endsWith.js":"7n5E9","./patterns/neighbours.js":"5EXtj","./models/index.js":"cwapb","./regex/regex-normal.js":"g2VUh","./regex/regex-text.js":"dA6kH","./regex/regex-numbers.js":"5N04K","./orgWords.js":"6TrGN","./placeWords.js":"bcpgj","./_expand/index.js":"4zXBH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cpmt2":[function(require,module,exports) {
//nouns with irregular plural/singular forms
//used in nouns.toPlural(), and also in the lexicon.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    // -a
    addendum: "addenda",
    corpus: "corpora",
    criterion: "criteria",
    curriculum: "curricula",
    genus: "genera",
    memorandum: "memoranda",
    opus: "opera",
    ovum: "ova",
    phenomenon: "phenomena",
    referendum: "referenda",
    // -ae
    alga: "algae",
    alumna: "alumnae",
    antenna: "antennae",
    formula: "formulae",
    larva: "larvae",
    nebula: "nebulae",
    vertebra: "vertebrae",
    // -is
    analysis: "analyses",
    axis: "axes",
    diagnosis: "diagnoses",
    parenthesis: "parentheses",
    prognosis: "prognoses",
    synopsis: "synopses",
    thesis: "theses",
    neurosis: "neuroses",
    // -x
    appendix: "appendices",
    index: "indices",
    matrix: "matrices",
    ox: "oxen",
    sex: "sexes",
    // -i
    alumnus: "alumni",
    bacillus: "bacilli",
    cactus: "cacti",
    fungus: "fungi",
    hippopotamus: "hippopotami",
    libretto: "libretti",
    modulus: "moduli",
    nucleus: "nuclei",
    octopus: "octopi",
    radius: "radii",
    stimulus: "stimuli",
    syllabus: "syllabi",
    // -ie
    cookie: "cookies",
    calorie: "calories",
    auntie: "aunties",
    movie: "movies",
    pie: "pies",
    rookie: "rookies",
    tie: "ties",
    zombie: "zombies",
    // -f
    leaf: "leaves",
    loaf: "loaves",
    thief: "thieves",
    // ee-
    foot: "feet",
    goose: "geese",
    tooth: "teeth",
    // -eaux
    beau: "beaux",
    chateau: "chateaux",
    tableau: "tableaux",
    // -ses
    bus: "buses",
    gas: "gases",
    circus: "circuses",
    crisis: "crises",
    virus: "viruses",
    database: "databases",
    excuse: "excuses",
    abuse: "abuses",
    avocado: "avocados",
    barracks: "barracks",
    child: "children",
    clothes: "clothes",
    echo: "echoes",
    embargo: "embargoes",
    epoch: "epochs",
    deer: "deer",
    halo: "halos",
    man: "men",
    woman: "women",
    mosquito: "mosquitoes",
    mouse: "mice",
    person: "people",
    quiz: "quizzes",
    rodeo: "rodeos",
    shoe: "shoes",
    sombrero: "sombreros",
    stomach: "stomachs",
    tornado: "tornados",
    tuxedo: "tuxedos",
    volcano: "volcanoes"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dEKVu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lexicon", ()=>lexicon);
parcelHelpers.export(exports, "switches", ()=>switches);
parcelHelpers.export(exports, "frozenLex", ()=>(0, _frozenLexJsDefault.default));
var _dataJs = require("./_data.js");
var _dataJsDefault = parcelHelpers.interopDefault(_dataJs);
var _efrt = require("efrt");
var _miscJs = require("./misc.js");
var _miscJsDefault = parcelHelpers.interopDefault(_miscJs);
var _frozenLexJs = require("./frozenLex.js");
var _frozenLexJsDefault = parcelHelpers.interopDefault(_frozenLexJs);
var _emoticonsJs = require("./emoticons.js");
var _emoticonsJsDefault = parcelHelpers.interopDefault(_emoticonsJs);
var _indexJs = require("../../methods/transform/nouns/toPlural/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _pluralsJs = require("../irregulars/plurals.js");
var _pluralsJsDefault = parcelHelpers.interopDefault(_pluralsJs);
// unpack our lexicon of words
// (found in ./lexicon/)
// more clever things are done on the data later
//  - once the plugin is applied
const hasSwitch = /\|/;
let lexicon = (0, _miscJsDefault.default);
let switches = {};
const tmpModel = {
    two: {
        irregularPlurals: (0, _pluralsJsDefault.default),
        uncountable: {}
    }
};
Object.keys((0, _dataJsDefault.default)).forEach((tag)=>{
    let wordsObj = (0, _efrt.unpack)((0, _dataJsDefault.default)[tag]);
    // POS tag, or something fancier?
    if (!hasSwitch.test(tag)) {
        // set them as simple word key-value lookup
        Object.keys(wordsObj).forEach((w)=>{
            lexicon[w] = tag;
        });
        return;
    }
    // add them as seperate key-val object
    Object.keys(wordsObj).forEach((w)=>{
        switches[w] = tag;
        // pluralize Noun|Verb switches
        if (tag === "Noun|Verb") {
            let plural = (0, _indexJsDefault.default)(w, tmpModel);
            switches[plural] = "Plural|Verb";
        }
    });
});
// add ':)'
(0, _emoticonsJsDefault.default).forEach((str)=>lexicon[str] = "Emoticon");
// misc cleanup
delete lexicon[""];
delete lexicon[null];
delete lexicon[" "];

},{"./_data.js":"83C6J","efrt":"fAVpb","./misc.js":"dnVVm","./frozenLex.js":"cQ8ge","./emoticons.js":"77h12","../../methods/transform/nouns/toPlural/index.js":"iAp4R","../irregulars/plurals.js":"cpmt2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"83C6J":[function(require,module,exports) {
// generated in ./lib/lexicon
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    "Comparative": "true\xa6bett1f0;arth0ew0in0;er",
    "Superlative": "true\xa6earlier",
    "PresentTense": "true\xa6bests,sounds",
    "Condition": "true\xa6lest,unless",
    "PastTense": "true\xa6began,came,d4had,kneel3l2m0sa4we1;ea0sg2;nt;eap0i0;ed;id",
    "Participle": "true\xa60:0A;a07b02c00dXeat0fSgQhPoJprov0rHs7t6u4w1;ak0ithdra03o2r1;i03uZ;k0v0;nd1pr05;ergoJoJ;ak0hHo3;e9h7lain,o6p5t4un3w1;o1um;rn;g,k;ol0reT;iRok0;ught,wn;ak0o1ruL;ne,wn;en,wn;ewriOi1uK;dd0s0;ut3ver1;do4se0t1;ak0h2;do2g1;roH;ne;ast0i7;iv0o1;ne,tt0;all0loCor1;bi3g2s1;ak0e0;iv0oA;dd0;ove,r1;a6eamt,iv0u1;nk;hos0lu1;ng;e4i3lo2ui1;lt;wn;tt0;at0en,gun;r2w1;ak0ok0;is0;en",
    "Gerund": "true\xa6accord0be0doin,go0result0stain0;ing",
    "Expression": "true\xa6a0Yb0Uc0Sd0Oe0Mfarew0Lg0FhZjeez,lWmVnToOpLsJtIuFvEw7y0;a5e3i1u0;ck,p;k04p0;ee,pee;a0p,s;!h;!a,h,y;a5h2o1t0;af,f;rd up,w;atsoever,e1o0;a,ops;e,w;hoo,t;ery w06oi0L;gh,h0;! 0h,m;huh,oh;here nPsk,ut tut;h0ic;eesh,hh,it,oo;ff,h1l0ow,sst;ease,s,z;ew,ooey;h1i,mg,o0uch,w,y;h,o,ps;! 0h;hTmy go0wT;d,sh;a7evertheless,o0;!pe;eh,mm;ah,eh,m1ol0;!s;ao,fao;aCeBi9o2u0;h,mph,rra0zzC;h,y;l1o0;r6y9;la,y0;! 0;c1moCsmok0;es;ow;!p hip hoor0;ay;ck,e,llo,y;ha1i,lleluj0;ah;!ha;ah,ee4o1r0;eat scott,r;l1od0sh; grief,bye;ly;! whiz;ell;e0h,t cetera,ureka,ww,xcuse me;k,p;'oh,a0rat,uh;m0ng;mit,n0;!it;mon,o0;ngratulations,wabunga;a2oo1r0tw,ye;avo,r;!ya;h,m; 1h0ka,las,men,rgh,ye;!a,em,h,oy;la",
    "Negative": "true\xa6n0;ever,o0;n,t",
    "QuestionWord": "true\xa6how3wh0;at,e1ich,o0y;!m,se;n,re; come,'s",
    "Reflexive": "true\xa6h4it5my5o1the0your2;ir1m1;ne3ur0;sel0;f,ves;er0im0;self",
    "Plural": "true\xa6dick0gre0ones,records;ens",
    "Unit|Noun": "true\xa6cEfDgChBinchAk9lb,m6newt5oz,p4qt,t1y0;ardEd;able1b0ea1sp;!l,sp;spo1;a,t,x;on9;!b,g,i1l,m,p0;h,s;!les;!b,elvin,g,m;!es;g,z;al,b;eet,oot,t;m,up0;!s",
    "Value": "true\xa6a few",
    "Imperative": "true\xa6bewa0come he0;re",
    "Plural|Verb": "true\xa6leaves",
    "Demonym": "true\xa60:15;1:12;a0Vb0Oc0Dd0Ce08f07g04h02iYjVkTlPmLnIomHpEqatari,rCs7t5u4v3welAz2;am0Gimbabwe0;enezuel0ietnam0I;gAkrai1;aiwTex0hai,rinida0Ju2;ni0Prkmen;a5cotti4e3ingapoOlovak,oma0Spaniard,udRw2y0W;ede,iss;negal0Cr09;sh;mo0uT;o5us0Jw2;and0;a2eru0Fhilippi0Nortugu07uerto r0S;kist3lesti1na2raguay0;ma1;ani;ami00i2orweP;caragu0geri2;an,en;a3ex0Lo2;ngo0Drocc0;cedo1la2;gasy,y07;a4eb9i2;b2thua1;e0Cy0;o,t01;azakh,eny0o2uwaiI;re0;a2orda1;ma0Ap2;anO;celandic,nd4r2sraeli,ta01vo05;a2iB;ni0qi;i0oneU;aiAin2ondur0unO;di;amEe2hanai0reek,uatemal0;or2rm0;gi0;ilipino,ren8;cuadoVgyp4mira3ngli2sto1thiopi0urope0;shm0;ti;ti0;aPominUut3;a9h6o4roat3ub0ze2;ch;!i0;lom2ngol5;bi0;a6i2;le0n2;ese;lifor1m2na3;bo2eroo1;di0;angladeshi,el6o4r3ul2;gaE;azi9it;li2s1;vi0;aru2gi0;si0;fAl7merBngol0r5si0us2;sie,tr2;a2i0;li0;genti2me1;ne;ba1ge2;ri0;ni0;gh0r2;ic0;an",
    "Organization": "true\xa60:4R;a3Ub3Cc2Pd2He2Df27g1Zh1Ti1Pj1Nk1Ll1Gm12n0Po0Mp0Cqu0Br02sTtHuCv9w3xiaomi,y1;amaha,m1Bou1w1B;gov,tu3D;a4e2iki1orld trade organizati34;leaRped0O;lls fargo,st1;fie2Iinghou2S;l1rner br3V;gree3Kl street journ2Jm1E;an halOeriz2Yisa,o1;dafo2Zl1;kswagMvo;b4kip,n2ps,s1;a tod3Bps;es3Ni1;lev3Gted natio3D;er,s; mobi33aco beRd bOe9gi frida3Mh3im horto3Bmz,o1witt3E;shi4Ay1;ota,s r 05;e 1in lizzy;b3carpen3Kdaily ma3Eguess w2holli0rolling st21s1w2;mashing pumpki36uprem0;ho;ea1lack eyed pe3Yyr0Q;ch bo3Etl0;l2n3Rs1xas instrumen1U;co,la m1F;efoni0Kus;a8cientology,e5ieme2Zmirnoff,np,o3pice gir6quare0Ata1ubaru;rbuc1to35;ks;ny,undgard1;en;a2x pisto1;ls;g1Xrs;few2Ninsbur32lesfor03msu2F;adiohead,b8e4o1yana3D;man empi1Yyal 1;b1dutch she4;ank;a3d 1max,vl21;bu1c2Bhot chili peppe2Zlobst2O;ll;ders dige1Ml madrid;c,s;ant3Bizn2R;a8bs,e5fiz2Jhilip4i3r1;emier 1udenti1E;leagTo2L;nk floyd,zza hut; morrBs;psi2tro1uge0E;br34chi0Tn34;!co;lant2Vn1yp17; 2ason28da2Q;ld navy,pec,range juli2xf1;am;us;aAb9e6fl,h5i4o1sa,vid3wa;k2tre dame,vart1;is;ia;ke,ntendo,ss0QvZ;l,s;c,st1Ptflix,w1; 1sweek;kids on the block,york0D;a,c;nd23s2t1;ional aca2Qo,we0V;a,c02d0T;aDcdonalCe9i6lb,o3tv,y1;spa1;ce;b1Unsanto,ody blu0t1;ley cr1or0U;ue;c2t1;as,subisO;helin,rosoft;dica2rcedes benz,talli1;ca;id,re;ds;cs milk,tt1Az25;a3e1g,ittle caesa1Q; ore0Anovo,x1;is,mark,us; 1bour party;pres0Ez boy;atv,fc,kk,lm,m1od1P;art;iffy lu0Soy divisi0Kpmorgan1sa;! cha0A;bm,hop,k3n1tv;g,te1;l,rpol;ea;a5ewlett pack1Wi3o1sbc,yundai;me dep1n1Q;ot;tac1zbollah;hi;lliburt09sbro;eneral 6hq,ithub,l5mb,o2reen d0Pu1;cci,ns n ros0;ldman sachs,o1;dye1g0I;ar;axo smith kli05encoX;electr0Om1;oto10;a5bi,c barcelo4da,edex,i2leetwood m04o1rito l0H;rd,xcZ;at,fa,nancial1resto00; tim0;na;cebook,nnie mae;b0Bsa,u3xxon1; m1m1;ob0K;!rosceptics;aiml0Ee6isney,o4u1;nkin donu2po10ran dur1;an;ts;j,w j1;on0;a,f lepp12ll,peche mode,r spieg02stiny's chi1;ld;aJbc,hFiDloudflaCnn,o3r1;aigsli5eedence clearwater reviv1ossra09;al;c7inba6l4m1o0Est09;ca2p1;aq;st;dplSg1;ate;se;a c1o chanQ;ola;re;a,sco1tigroup;! systems;ev2i1;ck fil a,na daily;r1y;on;d2pital o1rls jr;ne;bury,ill1;ac;aEbc,eBf9l5mw,ni,o1p,rexiteeU;ei3mbardiIston 1;glo1pizza;be;ng;o2ue c1;roV;ckbuster video,omingda1;le; g1g1;oodriL;cht2e ge0rkshire hathaw1;ay;el;cardi,idu,nana republ3s1xt5y5;f,kin robbi1;ns;ic;bYcTdidSerosmith,iRlKmEnheuser busDol,ppleAr6s4u3v2y1;er;is,on;di,todesk;hland o1sociated E;il;b3g2m1;co;os;ys; compu1be0;te1;rs;ch;c,d,erican3t1;!r1;ak; ex1;pre1;ss; 5catel2ta1;ir;! lu1;ce1;nt;jazeera,qae1;da;g,rbnb;as;/dc,a3er,tivision1;! blizz1;ard;demy of scienc0;es;ba",
    "Possessive": "true\xa6its,my,our0thy;!s",
    "Noun|Verb": "true\xa60:9W;1:AA;2:96;3:A3;4:9R;5:A2;6:9K;7:8N;8:7L;9:A8;A:93;B:8D;C:8X;a9Ob8Qc7Id6Re6Gf5Sg5Hh55i4Xj4Uk4Rl4Em40n3Vo3Sp2Squ2Rr21s0Jt02u00vVwGyFzD;ip,oD;ne,om;awn,e6Fie68;aOeMhJiHoErD;ap,e9Oink2;nd0rDuC;kDry,sh5Hth;!shop;ck,nDpe,re,sh;!d,g;e86iD;p,sD;k,p0t2;aDed,lco8W;r,th0;it,lk,rEsDt4ve,x;h,te;!ehou1ra9;aGen5FiFoD;iDmAte,w;ce,d;be,ew,sA;cuum,l4B;pDr7;da5gra6Elo6A;aReQhrPiOoMrGuEwiDy5Z;n,st;nDrn;e,n7O;aGeFiEoDu6;t,ub2;bu5ck4Jgg0m,p;at,k,nd;ck,de,in,nsDp,v7J;f0i8R;ll,ne,p,r4Yss,t94uD;ch,r;ck,de,e,le,me,p,re;e5Wow,u6;ar,e,ll,mp0st,xt;g,lDng2rg7Ps5x;k,ly;a0Sc0Ne0Kh0Fi0Dk0Cl0Am08n06o05pXquaBtKuFwD;ea88iD;ng,pe,t4;bGit,m,ppErD;fa3ge,pri1v2U;lDo6S;e6Py;!je8;aMeLiKoHrEuDy2;dy,ff,mb2;a85eEiDo5Pugg2;ke,ng;am,ss,t4;ckEop,p,rD;e,m;ing,pi2;ck,nk,t4;er,m,p;ck,ff,ge,in,ke,lEmp,nd,p2rDte,y;!e,t;k,l;aJeIiHlGoFrDur,y;ay,e56inDu3;g,k2;ns8Bt;a5Qit;ll,n,r87te;ed,ll;m,n,rk;b,uC;aDee1Tow;ke,p;a5Je4FiDo53;le,rk;eep,iDou4;ce,p,t;ateboa7Ii;de,gnDl2Vnk,p,ze;!al;aGeFiEoDuff2;ck,p,re,w;ft,p,v0;d,i3Ylt0;ck,de,pe,re,ve;aEed,nDrv1It;se,t2N;l,r4t;aGhedu2oBrD;aEeDibb2o3Z;en,w;pe,t4;le,n,r2M;cDfegua72il,mp2;k,rifi3;aZeHhy6LiGoEuD;b,in,le,n,s5X;a6ck,ll,oDpe,u5;f,t;de,ng,ot,p,s1W;aTcSdo,el,fQgPje8lOmMnLo17pJque6sFturn,vDwa6V;eDi27;al,r1;er74oFpe8tEuD;lt,me;!a55;l71rt;air,eaDly,o53;l,t;dezvo2Zt;aDedy;ke,rk;ea1i4G;a6Iist0r5N;act6Yer1Vo71uD;nd,se;a38o6F;ch,s6G;c1Dge,iEke,lly,nDp1Wt1W;ge,k,t;n,se;es6Biv0;a04e00hYiXlToNrEsy4uD;mp,n4rcha1sh;aKeIiHoDu4O;be,ceFdu3fi2grDje8mi1p,te6;amDe6W;!me;ed,ss;ce,de,nt;sDy;er6Cs;cti3i1;iHlFoEp,re,sDuCw0;e,i5Yt;l,p;iDl;ce,sh;nt,s5V;aEce,e32uD;g,mp,n7;ce,nDy;!t;ck,le,n17pe,tNvot;a1oD;ne,tograph;ak,eFnErDt;fu55mA;!c32;!l,r;ckJiInHrFsEtDu1y;ch,e9;s,te;k,tD;!y;!ic;nt,r,se;!a7;bje8ff0il,oErDutli3Qver4B;bAd0ie9;ze;a4ReFoDur1;d,tD;e,i3;ed,gle8tD;!work;aMeKiIoEuD;rd0;ck,d3Rld,nEp,uDve;nt,th;it5EkD;ey;lk,n4Brr5CsDx;s,ta2B;asuBn4UrDss;ge,it;il,nFp,rk3WsEtD;ch,t0;h,k,t0;da5n0oeuvB;aLeJiHoEuD;mp,st;aEbby,ck,g,oDve;k,t;d,n;cDft,mAnIst;en1k;aDc0Pe4vK;ch,d,k,p,se;bFcEnd,p,t4uD;gh,n4;e,k;el,o2U;eEiDno4E;ck,d,ll,ss;el,y;aEo1OuD;i3mp;m,zz;mpJnEr46ssD;ue;c1Rdex,fluGha2k,se2HteDvoi3;nt,rD;e6fa3viD;ew;en3;a8le2A;aJeHiGoEuD;g,nt;l3Ano2Dok,pDr1u1;!e;ghli1Fke,nt,re,t;aDd7lp;d,t;ck,mGndFrEsh,tDu9;ch,e;bo3Xm,ne4Eve6;!le;!m0;aMear,ift,lKossJrFuD;arDe4Alp,n;antee,d;aFiEoDumb2;uCwth;ll,nd,p;de,sp;ip;aBoDue;ss,w;g,in,me,ng,s,te,ze;aZeWiRlNoJrFuD;ck,el,nDss,zz;c38d;aEoDy;st,wn;cDgme,me,nchi1;tuB;cFg,il,ld,rD;ce,e29mDwa31;!at;us;aFe0Vip,oDy;at,ck,od,wD;!er;g,ke,me,re,sh,vo1E;eGgFlEnDre,sh,t,x;an3i0Q;e,m,t0;ht,uB;ld;aEeDn3;d,l;r,tuB;ce,il,ll,rm,vo2W;cho,d7ffe8nMsKxFyeD;!baD;ll;cGerci1hFpDtra8;eriDo0W;en3me9;au6ibA;el,han7u1;caDtima5;pe;count0d,vy;a01eSiMoJrEuDye;b,el,mp,pli2X;aGeFiEoD;ne,p;ft,ll,nk,p,ve;am,ss;ft,g,in;cEd7ubt,wnloD;ad;k,u0E;ge6p,sFt4vD;e,iDor3;de;char7gui1h,liEpD;at4lay,u5;ke;al,bKcJfeIlGmaCposAsEtaD;il;e07iD;gn,re;ay,ega5iD;ght;at,ct;li04rea1;a5ut;b,ma7n3rDte;e,t;a0Eent0Dh06irc2l03oKrFuD;be,e,rDt;b,e,l,ve;aGeFoEuDy;sh;p,ss,wd;dAep;ck,ft,sh;at,de,in,lTmMnFordina5py,re,st,uDv0;gh,nDp2rt;s01t;ceHdu8fli8glomeIsFtDveN;a8rD;a6ol;e9tru8;ct;ntDrn;ra5;bHfoGmFpD;leDouCromi1;me9;aCe9it,u5;rt;at,iD;ne;lap1oD;r,ur;aEiDoud,ub;ck,p;im,w;aEeDip;at,ck,er;iGllen7nErD;ge,m,t;ge,nD;el;n,r;er,re;ke,ll,mp,noe,pGrXsFtEuDve;se,ti0I;alog,ch;h,t;!tuB;re;a03eZiXlToPrHuEyD;pa11;bb2ck2dgEff0mp,rDst,zz;den,n;et;anJeHiFoadEuD;i1sh;ca6;be,d7;ge;aDed;ch,k;ch,d;aFg,mb,nEoDrd0tt2x,ycott;k,st,t;d,e;rd,st;aFeCiDoYur;nk,tz;nd;me;as,d,ke,nd,opsy,tD;!ch,e;aFef,lt,nDt;d,efA;it;r,t;ck,il,lan3nIrFsEtt2;le;e,h;!gDk;aDe;in;!d,g,k;bu1c05dZge,iYlVnTppQrLsIttGucEwaD;rd;tiD;on;aDempt;ck;k,sD;i6ocia5;st;chFmD;!oD;ur;!iD;ve;eEroa4;ch;al;chDg0sw0;or;aEt0;er;rm;d,m,r;dreHvD;an3oD;ca5;te;ce;ss;cDe,he,t;eFoD;rd,u9;nt;nt,ss;se",
    "Actor": "true\xa60:7B;1:7G;2:6A;3:7F;4:7O;5:7K;a6Nb62c4Ud4Be41f3Sg3Bh30i2Uj2Qkin2Pl2Km26n1Zo1Sp0Vqu0Tr0JsQtJuHvEw8yo6;gi,ut6;h,ub0;aAe9i8o7r6;estl0it0;m2rk0;fe,nn0t2Bza2H;atherm2ld0;ge earn0it0nder0rri1;eter7i6oyF;ll5Qp,s3Z;an,ina2U;n6s0;c6Uder03;aoisea23e9herapi5iktok0o8r6ut1yco6S;a6endseLo43;d0mp,nscri0Bvel0;ddl0u1G;a0Qchn7en6na4st0;ag0;i3Oo0D;aiXcUeRhPiMki0mu26oJpGquaFtBu7wee6;p0theart;lt2per7r6;f0ge6Iviv1;h6inten0Ist5Ivis1;ero,um2;a8ep7r6;ang0eam0;bro2Nc2Ofa2Nmo2Nsi20;ff0tesm2;tt0;ec7ir2Do6;kesp59u0M;ia5Jt3;l7me6An,rcere6ul;r,ss;di0oi5;n7s6;sy,t0;g0n0;am2ephe1Iow6;girl,m2r2Q;cretInior cit3Fr6;gea4v6;a4it1;hol4Xi7reen6ulpt1;wr2C;e01on;l1nt;aEe9o8u6;l0nn6;er up,ingE;g40le mod3Zof0;a4Zc8fug2Ppo32searQv6;ere4Uolution6;ary;e6luYru22;ptio3T;bbi,dic5Vpp0;arter6e2Z;back;aYeWhSiRlOoKr8sycho7u6;nk,p31;logi5;aGeDiBo6;d9fess1g7ph47s6;pe2Ktitu51;en6ramm0;it1y;igy,uc0;est4Nme mini0Unce6s3E;!ss;a7si6;de4;ch0;ctiti39nk0P;dca0Oet,li6pula50rnst42;c2Itic6;al scie6i2;nti5;a6umb0;nn0y6;er,ma4Lwright;lgrim,one0;a8iloso7otogra7ra6ysi1V;se;ph0;ntom,rmaci5;r6ssi1T;form0s4O;i3El,nel3Yr8st1tr6wn;i6on;arWot;ent4Wi42tn0;ccupa4ffBp8r7ut6;ca5l0B;ac4Iganiz0ig2Fph2;er3t6;i1Jomet6;ri5;ic0spring;aBe9ie4Xo7u6;n,rser3J;b6mad,vi4V;le2Vo4D;i6mesis,phew;ce,ghb1;nny,rr3t1X;aEeDiAo7u6yst1Y;m8si16;der3gul,m7n6th0;arDk;!my;ni7s6;f02s0Jt0;on,st0;chan1Qnt1rcha4;gi9k0n8rtyr,t6y1;e,riar6;ch;ag0iac;ci2stra3I;a7e2Aieutena4o6;rd,s0v0;bor0d7ndlo6ss,urea3Fwy0ym2;rd;!y;!s28;e8o7u6;ggl0;gg0urna2U;st0;c3Hdol,llu3Ummigra4n6; l9c1Qfa4habi42nov3s7ve6;nt1stig3;pe0Nt6;a1Fig3ru0M;aw;airFeBistoAo8u6ygie1K;man6sba2H;!ita8;bo,st6usekN;age,e3P;ri2;ir,r6;m7o6;!ine;it;dress0sty2C;aLeIhostGirl26ladi3oCrand7u6;e5ru;c9daug0Jfa8m7pa6s2Y;!re4;a,o6;th0;hi1B;al7d6lf0;!de3A;ie,k6te26;eep0;!wr6;it0;isha,n6;i6tl04;us;mbl0rden0;aDella,iAo7r6;eela2Nie1P;e,re6ster pare4;be1Hm2r6st0;unn0;an2ZgZlmm17nanci0r6tt0;e6st la2H; marsh2OfigXm2;rm0th0;conoEdDlectriCm8n7x6;amin0cellency,i2A;emy,trepreneur,vironmenta1J;c8p6;er1loye6;e,r;ee;ci2;it1;mi5;aKeBi8ork,ri7u6we02;de,tche2H;ft0v0;ct3eti7plom2Hre6va;ct1;ci2ti2;aDcor3fencCi0InAput9s7tectLvel6;op0;ce1Ge6ign0;rt0;ee,y;iz6;en;em2;c1Ml0;d8nc0redev7ug6;ht0;il;!dy;a06e04fo,hXitizenWlToBr9u6;r3stomer6;! representat6;ive;e3it6;ic;lJmGnAord9rpor1Nu7w6;boy,ork0;n6ri0;ciTte1Q;in3;fidantAgressSs9t6;e0Kr6;ibut1o6;ll0;tab13ul1O;!e;edi2m6pos0rade;a0EeQissi6;on0;leag8on7um6;ni5;el;ue;e6own;an0r6;ic,k;!s;a9e7i6um;ld;erle6f;ad0;ir7nce6plFract0;ll1;m2wI;lebri6o;ty;dBptAr6shi0;e7pe6;nt0;r,t6;ak0;ain;et;aMeLiJlogg0oErBu6;dd0Fild0rgl9siness6;m2p7w6;om2;ers05;ar;i7o6;!k0th0;cklay0de,gadi0;hemi2oge8y6;!frie6;nd;ym2;an;cyc6sR;li5;atbox0ings;by,nk0r6;b0on7te6;nd0;!e07;c04dWge4nQpLrHsFtAu7yatull6;ah;nt7t6;h1oG;!ie;h8t6;e6orney;nda4;ie5le6;te;sis00tron6;aut,om0;chbis8isto7tis6;an,t;crU;hop;ost9p6;ari6rentiS;ti6;on;le;a9cest1im3nou8y6;bo6;dy;nc0;ly5rc6;hi5;mi8v6;entur0is1;er;ni7r6;al;str3;at1;or;counBquaintanArob9t6;ivi5or,re6;ss;st;at;ce;ta4;nt",
    "Adj|Noun": "true\xa60:1F;1:1M;a1Db17c0Vd0Se0Nf0Eg0Bh09i07ju06l03mXnVoTpOrJsCt8u5v2watershed;a2ision10;gabo5nilla,ria2;b0Wnt;ndergr2pstairs;adua14ou2;nd;a4e2oken,ri0;en,r2;min0rori13;boo,n;age,e6ilv0Glack,o4quat,ta3u2well;bordina0Xper6;b0Mndard;ciali0Yl2vereign;e,ve1;cret,n2ri0;ior;a5e3ou2ubbiM;nd,tiZ;ar,bCl0Ynt0p2side1;resent0Xublican;ci0Qsh;a5eriodic0last11otenti0r2;emi3incip0o2;!fession0;er,um;rall5st,tie1;ff2pposi0Hv0;ens0Qi0D;agg02ov2uts;el;a6e4iniatKo2;bi02der08r2;al,t0;di2tr0P;an,um;le,riH;attPi3u2;sh;ber0ght,qD;stice,veniU;de0mpressioZn2;cumbe1dividu0no0Fsta1terim;alf,o2umdrum;bby,melG;en3old,ra2;ph0Dve;er0ious;a8e6i5l4u2;git05t2;ure;uid;ne;llow,m2;aGiM;ir,t,vo2;riOuriO;l4p02x2;c2ecutWpeX;ess;d2iK;er;ar3e2;mographWrivQ;k,l3;hiGlassUo3rude,unn2;ing;m6n2operM;creCstitue1te3vertab2;le;mpor2nt;ary;ic,m3p2;anion,lex;er3u2;ni8;ci0;e6lank,o5r2;i3u2;te;ef;ttom,urgeois;st;cademCd9l5n3r2;ab,ctB;im0tarctA;al;e4tern2;at2;ive;rt;oles2ult;ce1;nt;ic",
    "Adj|Past": "true\xa60:4Q;1:4C;2:4H;3:4E;a44b3Tc36d2Je29f20g1Wh1Si1Jj1Gkno1Fl1Am15n12o0Xp0Mqu0Kr08sLtEuAv9w4yellow0;a7ea6o4rinkl0;r4u3Y;n,ri0;k31th3;rp0sh0tZ;ari0e1O;n5p4s0;d1li1Rset;cov3derstood,i4;fi0t0;a8e3Rhr7i6ouTr4urn0wi4C;a4imm0ou2G;ck0in0pp0;ed,r0;eat2Qi37;m0nn0r4;get0ni2T;aOcKeIhGimFm0Hoak0pDt7u4;bsid3Ogge44s4;pe4ta2Y;ct0nd0;a8e7i2Eok0r5u4;ff0mp0nn0;ength2Hip4;ed,p0;am0reotyp0;in0t0;eci4ik0oH;al3Efi0;pRul1;a4ock0ut;d0r0;a4c1Jle2t31;l0s3Ut0;a6or5r4;at4e25;ch0;r0tt3;t4ut0;is2Mur1;aEe5o4;tt0;cAdJf2Bg9je2l8m0Knew0p7qu6s4;eTpe2t4;or0ri2;e3Dir0;e1lac0;at0e2Q;i0Rul1;eiv0o4ycl0;mme2Lrd0v3;in0lli0ti2A;a4ot0;li28;aCer30iBlAo9r5u4;mp0zzl0;e6i2Oo4;ce2Fd4lo1Anou30pos0te2v0;uc0;fe1CocCp0Iss0;i2Kli1L;ann0e2CuS;ck0erc0ss0;ck0i2Hr4st0;allLk0;bse7c6pp13rgan2Dver4;lo4whelm0;ok0;cupi0;rv0;aJe5o4;t0uri1A;ed0gle2;a6e5ix0o4ut0ys1N;di1Nt15u26;as0Clt0;n4rk0;ag0ufact0A;e6i5o4;ad0ck0st,v0;cens0m04st0;ft,v4;el0;tt0wn;a5o15u4;dg0s1B;gg0;llumSmpAn4sol1;br0cre1Ldebt0f8jZspir0t5v4;it0olv0;e4ox0Y;gr1n4re23;d0si15;e2l1o1Wuri1;li0o01r4;ov0;a6e1o4um03;ok0r4;ri0Z;mm3rm0;i6r5u4;a1Bid0;a0Ui0Rown;ft0;aAe9i8l6oc0Ir4;a4i0oz0Y;ctHg19m0;avo0Ju4;st3;ni08tt0x0;ar0;d0il0sc4;in1;dCl1mBn9quipp0s8x4;agger1c6p4te0T;a0Se4os0;ct0rie1D;it0;cap0tabliZ;cha0XgFha1As4;ur0;a0Zbarra0N;i0Buc1;aMeDi5r4;a01i0;gni08miniSre2s4;a9c6grun0Ft4;o4re0Hu17;rt0;iplWou4;nt0r4;ag0;bl0;cBdRf9l8p7ra6t5v4;elop0ot0;ail0ermQ;ng0;re07;ay0ight0;e4in0o0M;rr0;ay0enTor1;m5t0z4;ed,zl0;ag0p4;en0;aPeLhIlHo9r6u4;lt4r0stom03;iv1;a5owd0u4;sh0;ck0mp0;d0loAm7n4ok0v3;centr1f5s4troC;id3olid1;us0;b5pl4;ic1;in0;r0ur0;assi9os0utt3;ar5i4;ll0;g0m0;lebr1n6r4;ti4;fi0;tralJ;g0lcul1;aDewild3iCl9o7r5urn4;ed,t;ok4uis0;en;il0r0t4und;tl0;e5i4;nd0;ss0;as0;ffl0k0laMs0tt3;bPcNdKfIg0lFmaz0nDppBrm0ss9u5wa4;rd0;g5thor4;iz0;me4;nt0;o6u4;m0r0;li0re4;ci1;im1ticip1;at0;a5leg0t3;er0;rm0;fe2;ct0;ju5o7va4;nc0;st0;ce4knowledg0;pt0;and5so4;rb0;on0;ed",
    "Singular": "true\xa60:5H;1:5F;2:4U;3:4Q;4:50;5:55;6:5J;a4Yb4Hc3Kd32e2Uf2Lg2Gh25in21j20k1Zl1Sm1Jn1Fo19p0Pqu0Or0DsXtKuFvAw7x r54yo yo;a7ha3Mo3N;f3i4Nt0Ey7;! arou36;arAe8ideo ga2No7;cabu4Fl58;gMr7t;di4Vt1V;iety,ni4L;n9p2Xr8s 7;do40s5A;bani1in0;coordinat37der7;estima1to21we3Y; rex,aIeHhFiDoCr9u8v7;! show;m2Ln2rntJto1B;agedy,ib7o4A;e,u7;n0ta42;ni1p2rq3I;c,er,m7;etD;ing7ree23;!y;am,mp3C;ct2le6x return;aLcKeIhor4MiHkFoEpin off,tBu9y7;ll7ner4Ist4P;ab2U;b7i1n25per bowl,rro1U;st3Itot0;at8ipe2Do1Irate4Eudent7;! lo0G;i36u1;ft ser4Hmeo1F;elet5i7;ll,r3R;b35gn2Qte;ab2Gc7min38;t,urity gua2K;e6ho2V;bbatic0la3Fndwi0Opi5;av5eBhetor2i8o7;de6om,w;t8v7;erb29;e,u0;bBc9f7publ2r0Xspi1;er7orm3;e6r0;i7ord label;p2Et0;a1u42;estion mark,ot2C;aNeKhoJiGlEoCr8u7yram1C;ddi3DpCrpo1Gs3F;e9o7;bl3Vs7;pe3Fta1;dic1Omi1Cp1Nroga3Rss relea1C;p7rt0;py;a7ebisci1;q2Ate;cn2e8g7;!gy;!r;ne call,tocoI;anut,d8r7t0yo1;cen3Fsp3G;al,est0;nop4r8t7;e,hog5;adi0Yi2R;atme0bj3Bc9pia1rde0thers,utspok5ve7wn3;n,r7;ti0Mview;cu8e7;an;pi3;ar9it8ot7umb3;a2Bhi2N;e,ra1;cot2ra33;aDeAi8o7ur0;nopo4p15rni2Jsq1Oti32uld;c,li0Yn07s7tt5;chief,si30;d8nu,t7;al,i3;al,ic;gna1mm0nd12rsupi0te7yf4;ri0;aBegAi9u7;ddi1n7;ch;ght bulb,me,p06ving room; 8e0J;bor11y 7;up;eyno1itt5;el4ourn0;c9dices,itia2Kni22s8tel0Jvert7;eb1H;e25titu1;en2Hi2Q;aGeCighBo8u7;man right,s1Z;me7rmoDsp1Dtb0I;! r7;un; scho0WriW;a7i1K;d7v5; start,pho7;ne;ndful,sh brown,v5ze;a9elat0Glaci3r7ul4yp1P;an7enadi3id;a19d slam,ny;df4r7;l2ni1F;aEeti1EiDlu1oAr8un7;er0;ee market,i7onti3;ga1;l4ur7;so7;me;eNref4;br2mi4;conoDffi1Mgg,lecto0Pmbas1BnApidem2s1Wth2ven9x8yel7;id;ampXempl0Lte6;i16t;er1Iterp7;ri7;se;my;eJiCo9r7ump tru0R;agonf4i7;er,ve thru;c8g1Bi4or,ssi3wn7;side;to0CumenC;aCgniBnn3s8vide7;nd;conte6incen1Bp7tri0Y;osi7;tion;ta0E;le0U;ath9c8f7ni0terre6;ault 03err0;al,im0;!b7;ed;aUeRhKiJlHoBr7;edit ca9uc7;ib7;le;rd;efficBke,lAmmuniqJns8pi3rr0t0Uus7yo1;in;erv7uG;atoZ;ic,lO;ie6;er0Li7oth;e6n2;ty,vil wK;aBeqAick5oco9r7;istmas car7ysanthemum;ol;la1;ue;ndeli3racteri7;st2;i8llCr7;e0tifica1;liW;hi3nDpCrAt7ucus;erpi7hedr0;ll7;ar;!bohyd7ri3;ra1;it0;a7e,nib0;l,ry;aKeJiop2leHoFrBu7;nny,r7tterf4;g7i0;la7;ry;eak8i7;ck;fa7thro9;st;dy,ro7wl;ugh;mi7;sh;an,l4;nki8rri3;er;ng;cQdKlGnDppeti1rBs9tt2utop7;sy;ic;ce6pe7;ct;r7sen0;ay;ec8oma4ti8;ly;do1;i5l7;er7y;gy;en; hominBj8van7;tage;ec7;ti7;ve;em;cAe8qui7;tt0;ta1;te;i8ru0;al;de6;nt",
    "Person|Noun": "true\xa6a0Eb07c03dWeUfQgOhLjHkiGlFmCnBolive,p7r4s3trini06v1wa0;ng,rd,tts;an,enus,iol0;a,et;ky,onPumm09;ay,e1o0uby;bin,d,se;ed,x;a2e1o0;l,tt04;aLnJ;dYge,tR;at,orm;a0eloW;t0x,ya;!s;a9eo,iH;ng,tP;a2e1o0;lGy;an,w3;de,smi4y;a0erb,iOolBuntR;ll,z0;el;ail,e0iLuy;ne;a1ern,i0lo;elds,nn;ith,n0;ny;a0dEmir,ula,ve;rl;a4e3i1j,ol0;ly;ck,x0;ie;an,ja;i0wn;sy;am,h0liff,rystal;a0in,ristian;mbers,ri0;ty;a4e3i2o,r0ud;an0ook;dy;ll;nedict,rg;k0nks;er;l0rt;fredo,ma",
    "Actor|Verb": "true\xa6aCb8c5doctor,engineAfool,g3host,judge,m2nerd,p1recruit,scout,ushAvolunteAwi0;mp,tneA;arent,ilot;an,ime;eek,oof,r0uide;adu8oom;ha1o0;ach,nscript,ok;mpion,uffeur;o2u0;lly,tch0;er;ss;ddi1ffili0rchite1;ate;ct",
    "MaleName": "true\xa60:H6;1:FZ;2:DS;3:GQ;4:CZ;5:FV;6:GM;7:FP;8:GW;9:ET;A:C2;B:GD;aF8bE1cCQdBMeASfA1g8Yh88i7Uj6Sk6Bl5Mm48n3So3Ip33qu31r26s1Et0Ru0Ov0CwTxSyHzC;aCor0;cChC1karia,nAT;!hDkC;!aF6;!ar7CeF5;aJevgenBSoEuC;en,rFVsCu3FvEF;if,uf;nDs6OusC;ouf,s6N;aCg;s,tC;an,h0;hli,nCrosE1ss09;is,nC;!iBU;avi2ho5;aPeNiDoCyaEL;jcieBJlfgang,odrFutR;lFnC;f8TsC;lCt1;ow;bGey,frEhe4QlC;aE5iCy;am,e,s;ed8iC;d,ed;eAur;i,ndeD2rn2sC;!l9t1;lDyC;l1ne;lDtC;!er;aCHy;aKernDAiFladDoC;jteB0lodymyr;!iC;mFQsDB;cFha0ktBZnceDrgCOvC;a0ek;!nC;t,zo;!e4StBV;lCnC7sily;!entC;in9J;ghE2lCm70nax,ri,sm0;riCyss87;ch,k;aWeRhNiLoGrEuDyC;!l2roEDs1;n6r6E;avD0eCist0oy,um0;ntCRvBKy;bFdAWmCny;!asDmCoharu;aFFie,y;!z;iA6y;mCt4;!my,othy;adEeoDia0SomC;!as;!dor91;!de4;dFrC;enBKrC;anBJeCy;ll,nBI;!dy;dgh,ha,iCnn2req,tsu5V;cDAka;aYcotWeThPiMlobod0oKpenc2tEurDvenAEyCzym1;ed,lvest2;aj,e9V;anFeDuC;!aA;fan17phEQvCwaA;e77ie;!islaCl9;v,w;lom1rBuC;leymaDHta;dDgmu9UlCm1yabonga;as,v8B;!dhart8Yn9;aEeClo75;lCrm0;d1t1;h9Jne,qu1Jun,wn,yne;aDbastiEDk2Yl5Mpp,rgCth,ymoCU;e1Dio;m4n;!tC;!ie,y;eDPlFmEnCq67tosCMul;dCj2UtiA5;e01ro;!iATkeB6mC4u5;!ik,vato9K;aZeUheC8iRoGuDyC;an,ou;b99dDf4peAssC;!elEG;ol00y;an,bLc7MdJel,geIh0lHmGnEry,sDyC;!ce;ar7Ocoe,s;!aCnBU;ld,n;an,eo;a7Ef;l7Jr;e3Eg2n9olfo,riC;go;bBNeDH;cCl9;ar87c86h54kCo;!ey,ie,y;cFeA3gDid,ubByCza;an8Ln06;g85iC;naC6s;ep;ch8Kfa5hHin2je8HlGmFndEoHpha5sDul,wi36yC;an,mo8O;h9Im4;alDSol3O;iD0on;f,ph;ul;e9CinC;cy,t1;aOeLhilJiFrCyoG;aDeC;m,st1;ka85v2O;eDoC;tr;r8GtC;er,ro;!ipCl6H;!p6U;dCLrcy,tC;ar,e9JrC;!o7;b9Udra8So9UscAHtri62ulCv8I;!ie,o7;ctav6Ji2lImHndrBRrGsDtCum6wB;is,to;aDc6k6m0vCwaBE;al79;ma;i,vR;ar,er;aDeksandr,ivC;er,i2;f,v;aNeLguyBiFoCu3O;aDel,j4l0ma0rC;beAm0;h,m;cFels,g5i9EkDlC;es,s;!au,h96l78olaC;!i,y;hCkCol76;ol75;al,d,il,ls1vC;ilAF;hom,tC;e,hC;anCy;!a5i5;aYeViLoGuDyC;l4Nr1;hamDr84staC;fa,p6E;ed,mG;di10e,hamEis4JntDritz,sCussa;es,he;e,y;ad,ed,mC;ad,ed;cGgu5hai,kFlEnDtchC;!e8O;a9Pik;house,o7t1;ae73eC3ha8Iolaj;ah,hDkC;!ey,y;aDeC;al,l;el,l;hDlv3rC;le,ri8Ev4T;di,met;ay0c00gn4hWjd,ks2NlTmadZnSrKsXtDuric7VxC;imilBKwe8B;eHhEi69tCus,y69;!eo,hCia7;ew,i67;eDiC;as,eu,s;us,w;j,o;cHiGkFlEqu8Qsha83tCv3;iCy;!m,n;in,on;el,o7us;a6Yo7us;!elCin,o7us;!l8o;frAEi5Zny,u5;achDcoCik;lm;ai,y;amDdi,e5VmC;oud;adCm6W;ou;aulCi9P;ay;aWeOiMloyd,oJuDyC;le,nd1;cFdEiDkCth2uk;a7e;gi,s,z;ov7Cv6Hw6H;!as,iC;a6Een;g0nn52renDuCvA4we7D;!iS;!zo;am,n4oC;n5r;a9Yevi,la5KnHoFst2thaEvC;eCi;nte;bo;nCpo8V;!a82el,id;!nC;aAy;mEnd1rDsz73urenCwr6K;ce,t;ry,s;ar,beAont;aOeIhalHiFla4onr63rDu5SylC;e,s;istCzysztof;i0oph2;er0ngsl9p,rC;ilA9k,ollos;ed,id;en0iGnDrmCv4Z;it;!dDnCt1;e2Ny;ri4Z;r,th;cp2j4mEna8BrDsp6them,uC;ri;im,l;al,il;a03eXiVoFuC;an,lCst3;en,iC;an,en,o,us;aQeOhKkub4AnIrGsDzC;ef;eDhCi9Wue;!ua;!f,ph;dCge;i,on;!aCny;h,s,th6J;anDnC;!ath6Hie,n72;!nC;!es;!l,sCy;ph;o,qu3;an,mC;!i,m6V;d,ffFns,rCs4;a7JemDmai7QoCry;me,ni1H;i9Dy;!e73rC;ey,y;cKdBkImHrEsDvi2yC;dBs1;on,p2;ed,oDrCv67;e6Qod;d,s61;al,es5Wis1;a,e,oCub;b,v;ob,qu13;aTbNchiMgLke53lija,nuKonut,rIsEtCv0;ai,suC;ki;aDha0i8XmaCsac;el,il;ac,iaC;h,s;a,vinCw3;!g;k,nngu6X;nac1Xor;ka;ai,rahC;im;aReLoIuCyd6;beAgGmFsC;eyDsC;a3e3;in,n;ber5W;h,o;m2raDsse3wC;a5Pie;c49t1K;a0Qct3XiGnDrC;beAman08;dr7VrC;iCy2N;!k,q1R;n0Tt3S;bKlJmza,nIo,rEsDyC;a5KdB;an,s0;lEo67r2IuCv9;hi5Hki,tC;a,o;an,ey;k,s;!im;ib;a08e00iUlenToQrMuCyorgy;iHnFsC;!taC;f,vC;!e,o;n6tC;er,h2;do,lC;herDlC;auCerQ;me;aEegCov2;!g,orC;!io,y;dy,h7C;dfr9nza3XrDttfC;ri6C;an,d47;!n;acoGlEno,oCuseppe;rgiCvan6O;!o,s;be6Ies,lC;es;mo;oFrC;aDha4HrC;it,y;ld,rd8;ffErgC;!e7iCy;!os;!r9;bElBrCv3;eCla1Nr4Hth,y;th;e,rC;e3YielC;!i4;aXeSiQlOorrest,rCyod2E;aHedFiC;edDtC;s,z;ri18;!d42eri11riC;ck,k;nCs2;cEkC;ie,lC;in,yn;esLisC;!co,z3M;etch2oC;ri0yd;d5lConn;ip;deriFliEng,rC;dinaCg4nan0B;nd8;pe,x;co;bCdi,hd;iEriC;ce,zC;io;an,en,o;benez2dZfrYit0lTmMnJo3rFsteb0th0ugenEvCymBzra;an,eCge4D;ns,re3K;!e;gi,iDnCrol,v3w3;est8ie,st;cCk;!h,k;o0DriCzo;co,qC;ue;aHerGiDmC;aGe3A;lCrh0;!iC;a10o,s;s1y;nu5;beAd1iEliDm2t1viCwood;n,s;ot28s;!as,j5Hot,sC;ha;a3en;!dGg6mFoDua2QwC;a2Pin;arC;do;oZuZ;ie;a04eTiOmitrNoFrag0uEwDylC;an,l0;ay3Hig4D;a3Gdl9nc0st3;minFnDri0ugCvydGy2S;!lF;!a36nCov0;e1Eie,y;go,iDykC;as;cCk;!k;i,y;armuFetDll1mitri7neCon,rk;sh;er,m6riC;ch;id;andLepak,j0lbeAmetri4nIon,rGsEvDwCxt2;ay30ey;en,in;hawn,moC;nd;ek,riC;ck;is,nC;is,y;rt;re;an,le,mKnIrEvC;e,iC;!d;en,iEne0PrCyl;eCin,yl;l45n;n,o,us;!iCny;el,lo;iCon;an,en,on;a0Fe0Ch03iar0lRoJrFuDyrC;il,us;rtC;!is;aEistC;iaCob12;no;ig;dy,lInErC;ey,neliCy;s,us;nEor,rDstaC;nt3;ad;or;by,e,in,l3t1;aHeEiCyde;fCnt,ve;fo0Xt1;menDt4;us;s,t;rFuDyC;!t1;dCs;e,io;enC;ce;aHeGrisC;!toC;phCs;!eC;!r;st2t;d,rCs;b5leC;s,y;cDdrCs6;ic;il;lHmFrC;ey,lDroCy;ll;!o7t1;er1iC;lo;!eb,v3;a09eZiVjorn,laUoSrEuCyr1;ddy,rtKst2;er;aKeFiEuDyC;an,ce,on;ce,no;an,ce;nDtC;!t;dDtC;!on;an,on;dFnC;dDisC;lav;en,on;!foOl9y;bby,gd0rCyd;is;i0Lke;bElDshC;al;al,lL;ek;nIrCshoi;at,nEtC;!raC;m,nd;aDhaCie;rd;rd8;!iDjam3nCs1;ie,y;to;kaMlazs,nHrC;n9rDtC;!holomew;eCy;tt;ey;dCeD;ar,iC;le;ar1Nb1Dd16fon15gust3hm12i0Zja0Yl0Bm07nTputsiSrGsaFugustEveDyCziz;a0kh0;ry;o,us;hi;aMchiKiJjun,mHnEon,tCy0;em,hCie,ur8;ur;aDoC;!ld;ud,v;aCin;an,nd8;!el,ki;baCe;ld;ta;aq;aMdHgel8tCw6;hoFoC;iDnC;!i8y;ne;ny;er7rCy;eDzC;ej;!as,i,j,s,w;!s;s,tolC;iCy;!y;ar,iEmaCos;nu5r;el;ne,r,t;aVbSdBeJfHiGl01onFphonsEt1vC;aPin;on;e,o;so,zo;!sR;!onZrC;ed;c,jaHksFssaHxC;!andC;er,rC;e,os,u;andCei;ar,er,r;ndC;ro;en;eDrecC;ht;rt8;dd3in,n,sC;taC;ir;ni;dDm6;ar;an,en;ad,eC;d,t;in;so;aGi,olErDvC;ik;ian8;f8ph;!o;mCn;!a;dGeFraDuC;!bakr,lfazl;hCm;am;!l;allFel,oulaye,ulC;!lDrahm0;an;ah,o;ah;av,on",
    "Uncountable": "true\xa60:2E;1:2L;2:33;a2Ub2Lc29d22e1Rf1Ng1Eh16i11j0Yk0Wl0Rm0Hn0Do0Cp03rZsLt9uran2Jv7w3you gu0E;a5his17i4oo3;d,l;ldlife,ne;rm8t1;apor,ernacul29i3;neg28ol1Otae;eDhBiAo8r4un3yranny;a,gst1B;aff2Oea1Ko4ue nor3;th;o08u3;bleshoot2Ose1Tt;night,othpas1Vwn3;foEsfoE;me off,n;er3und1;e,mod2S;a,nnis;aDcCeBhAi9ki8o7p6t4u3weepstak0;g1Unshi2Hshi;ati08e3;am,el;ace2Keci0;ap,cc1meth2C;n,ttl0;lk;eep,ingl0or1C;lf,na1Gri0;ene1Kisso1C;d0Wfe2l4nd,t3;i0Iurn;m1Ut;abi0e4ic3;e,ke15;c3i01laxa11search;ogni10rea10;a9e8hys7luto,o5re3ut2;amble,mis0s3ten20;en1Zs0L;l3rk;i28l0EyH; 16i28;a24tr0F;nt3ti0M;i0s;bstetri24vercrowd1Qxyg09;a5e4owada3utella;ys;ptu1Ows;il poliZtional securi2;aAe8o5u3;m3s1H;ps;n3o1K;ey,o3;gamy;a3cha0Elancholy,rchandi1Htallurgy;sl0t;chine3g1Aj1Hrs,thema1Q; learn1Cry;aught1e6i5ogi4u3;ck,g12;c,s1M;ce,ghtn18nguis1LteratWv1;ath1isVss;ara0EindergartPn3;icke0Aowled0Y;e3upit1;a3llyfiGwel0G;ns;ce,gnor6mp5n3;forma00ter3;net,sta07;atiSort3rov;an18;a7e6isto09o3ung1;ckey,mework,ne4o3rseradi8spitali2use arrest;ky;s2y;adquarteXre;ir,libut,ppiHs3;hi3te;sh;ene8l6o5r3um,ymnas11;a3eZ;niUss;lf,re;ut3yce0F;en; 3ti0W;edit0Hpo3;ol;aNicFlour,o4urnit3;ure;od,rgive3uri1wl;ness;arCcono0LducaBlectr9n7quip8thi0Pvery6x3;ist4per3;ti0B;en0J;body,o08th07;joy3tertain3;ment;ici2o3;ni0H;tiS;nings,th;emi02i6o4raugh3ynas2;ts;pe,wnstai3;rs;abet0ce,s3;honZrepu3;te;aDelciChAivi07l8o3urrency;al,ld w6mmenta5n3ral,ttIuscoB;fusiHt 3;ed;ry;ar;assi01oth0;es;aos,e3;eMwK;us;d,rO;a8i6lood,owlHread5u3;ntGtt1;er;!th;lliarJs3;on;g3ss;ga3;ge;cKdviJeroGirFmBn6ppeal court,r4spi3thleL;rin;ithmet3sen3;ic;i6y3;o4th3;ing;ne;se;en5n3;es2;ty;ds;craft;bi8d3nau7;yna3;mi6;ce;id,ous3;ti3;cs",
    "Infinitive": "true\xa60:9G;1:9T;2:AD;3:90;4:9Z;5:84;6:AH;7:A9;8:92;9:A0;A:AG;B:AI;C:9V;D:8R;E:8O;F:97;G:6H;H:7D;a94b8Hc7Jd68e4Zf4Mg4Gh4Ai3Qj3Nk3Kl3Bm34nou48o2Vp2Equ2Dr1Es0CtZuTvRwI;aOeNiLors5rI;eJiI;ng,te;ak,st3;d5e8TthI;draw,er;a2d,ep;i2ke,nIrn;d1t;aIie;liADniAry;nJpI;ho8Llift;cov1dJear8Hfound8DlIplug,rav82tie,ve94;eaAo3X;erIo;cut,go,staAFvalA3w2G;aSeQhNoMrIu73;aIe72;ffi3Smp3nsI;aBfo7CpI;i8oD;pp3ugh5;aJiJrIwaD;eat5i2;nk;aImA0;ch,se;ck3ilor,keImp1r8L;! paD;a0Ic0He0Fh0Bi0Al08mugg3n07o05p02qu01tUuLwI;aJeeIim;p,t5;ll7Wy;bNccMffLggeCmmKppJrI;mouFpa6Zvi2;o0re6Y;ari0on;er,i4;e7Numb;li9KmJsiIveD;de,st;er9it;aMe8MiKrI;ang3eIi2;ng27w;fIng;f5le;b,gg1rI;t3ve;a4AiA;a4UeJit,l7DoI;il,of;ak,nd;lIot7Kw;icEve;atGeak,i0O;aIi6;m,y;ft,ng,t;aKi6CoJriIun;nk,v6Q;ot,rt5;ke,rp5tt1;eIll,nd,que8Gv1w;!k,m;aven9ul8W;dd5tis1Iy;a0FeKiJoI;am,t,ut;d,p5;a0Ab08c06d05f01group,hea00iZjoi4lXmWnVpTq3MsOtMup,vI;amp,eJiIo3B;sEve;l,rI;e,t;i8rI;ie2ofE;eLiKpo8PtIurfa4;o24rI;aHiBuctu8;de,gn,st;mb3nt;el,hra0lIreseF;a4e71;d1ew,o07;aHe3Fo2;a7eFiIo6Jy;e2nq41ve;mbur0nf38;r0t;inKleBocus,rJuI;el,rbiA;aBeA;an4e;aBu4;ei2k8Bla43oIyc3;gni39nci3up,v1;oot,uI;ff;ct,d,liIp;se,ze;tt3viA;aAenGit,o7;aWerUinpoiFlumm1LoTrLuI;b47ke,niArIt;poDsuI;aFe;eMoI;cKd,fe4XhibEmo7noJpo0sp1tru6vI;e,i6o5L;un4;la3Nu8;aGclu6dJf1occupy,sup0JvI;a6BeF;etermi4TiB;aGllu7rtr5Ksse4Q;cei2fo4NiAmea7plex,sIva6;eve8iCua6;mp1rItrol,ve;a6It6E;bOccuNmEpMutLverIwe;l07sJtu6Yu0wI;helm;ee,h1F;gr5Cnu2Cpa4;era7i4Ipo0;py,r;ey,seItaH;r2ss;aMe0ViJoIultiply;leCu6Pw;micJnIspla4;ce,g3us;!k;iIke,na9;m,ntaH;aPeLiIo0u3N;e,ke,ng1quIv5;eIi6S;fy;aKnIss5;d,gI;th5;rn,ve;ng2Gu1N;eep,idnJnI;e4Cow;ap;oHuI;gg3xtaI;po0;gno8mVnIrk;cTdRfQgeChPitia7ju8q1CsNtKun6EvI;a6eIo11;nt,rt,st;erJimi6BoxiPrI;odu4u6;aBn,pr03ru6C;iCpi8tIu8;all,il,ruB;abEibE;eCo3Eu0;iIul9;ca7;i7lu6;b5Xmer0pI;aLer4Uin9ly,oJrI;e3Ais6Bo2;rt,se,veI;riA;le,rt;aLeKiIoiCuD;de,jaInd1;ck;ar,iT;mp1ng,pp5raIve;ng5Mss;ath1et,iMle27oLrI;aJeIow;et;b,pp3ze;!ve5A;gg3ve;aTer45i5RlSorMrJuI;lf4Cndrai0r48;eJiIolic;ght5;e0Qsh5;b3XeLfeEgJsI;a3Dee;eIi2;!t;clo0go,shIwa4Z;ad3F;att1ee,i36;lt1st5;a0OdEl0Mm0FnXquip,rWsVtGvTxI;aRcPeDhOiNpJtIu6;ing0Yol;eKi8lIo0un9;aHoI;it,re;ct,di7l;st,t;a3oDu3B;e30lI;a10u6;lt,mi28;alua7oI;ke,l2;chew,pou0tab19;a0u4U;aYcVdTfSgQhan4joy,lPqOrNsuMtKvI;e0YisI;a9i50;er,i4rI;aHenGuC;e,re;iGol0F;ui8;ar9iC;a9eIra2ulf;nd1;or4;ang1oIu8;r0w;irc3lo0ou0ErJuI;mb1;oaGy4D;b3ct;bKer9pI;hasiIow1;ze;aKody,rI;a4oiI;d1l;lm,rk;ap0eBuI;ci40de;rIt;ma0Rn;a0Re04iKo,rIwind3;aw,ed9oI;wn;agno0e,ff1g,mi2Kne,sLvI;eIul9;rIst;ge,t;aWbVcQlod9mant3pNru3TsMtI;iIoDu37;lJngI;uiA;!l;ol2ua6;eJlIo0ro2;a4ea0;n0r0;a2Xe36lKoIu0S;uIv1;ra9;aIo0;im;a3Kur0;b3rm;af5b01cVduBep5fUliTmQnOpMrLsiCtaGvI;eIol2;lop;ch;a20i2;aDiBloIoD;re,y;oIy;te,un4;eJoI;liA;an;mEv1;a4i0Ao06raud,y;ei2iMla8oKrI;ee,yI;!pt;de,mIup3;missi34po0;de,ma7ph1;aJrief,uI;g,nk;rk;mp5rk5uF;a0Dea0h0Ai09l08oKrIurta1G;a2ea7ipp3uI;mb3;ales4e04habEinci6ll03m00nIrro6;cXdUfQju8no7qu1sLtKvI;eIin4;ne,r9y;aHin2Bribu7;er2iLoli2Epi8tJuI;lt,me;itu7raH;in;d1st;eKiJoIroFu0;rm;de,gu8rm;ss;eJoI;ne;mn,n0;eIlu6ur;al,i2;buCe,men4pI;eIi3ly;l,te;eBi6u6;r4xiC;ean0iT;rcumveFte;eJirp,oI;o0p;riAw;ncIre5t1ulk;el;a02eSi6lQoPrKuI;iXrIy;st,y;aLeaKiJoad5;en;ng;stfeLtX;ke;il,l11mba0WrrMth1;eIow;ed;!coQfrie1LgPhMliLqueaKstJtrIwild1;ay;ow;th;e2tt3;a2eJoI;ld;ad;!in,ui3;me;bysEckfi8ff3tI;he;b15c0Rd0Iff0Ggree,l0Cm09n03ppZrXsQttOuMvJwaE;it;eDoI;id;rt;gIto0X;meF;aIeCraB;ch,in;pi8sJtoI;niA;aKeIi04u8;mb3rt,ss;le;il;re;g0Hi0ou0rI;an9i2;eaKly,oiFrI;ai0o2;nt;r,se;aMi0GnJtI;icipa7;eJoIul;un4y;al;ly0;aJu0;se;lga08ze;iKlI;e9oIu6;t,w;gn;ix,oI;rd;a03jNmiKoJsoI;rb;pt,rn;niIt;st1;er;ouJuC;st;rn;cLhie2knowled9quiItiva7;es4re;ce;ge;eQliOoKrJusI;e,tom;ue;mIst;moJpI;any,liA;da7;ma7;te;pt;andPduBet,i6oKsI;coKol2;ve;liArt,uI;nd;sh;de;ct;on",
    "Person": "true\xa60:1Q;a29b1Zc1Md1Ee18f15g13h0Ri0Qj0Nk0Jl0Gm09n06o05p00rPsItCusain bolt,v9w4xzibit,y1;anni,oko on2uji,v1;an,es;en,o;a3ednesday adams,i2o1;lfram,o0Q;ll ferrell,z khalifa;lt disn1Qr1;hol,r0G;a2i1oltai06;n dies0Zrginia wo17;lentino rossi,n goG;a4h3i2ripp,u1yra banks;lZpac shakur;ger woods,mba07;eresa may,or;kashi,t1ylor;um,ya1B;a5carlett johanss0h4i3lobodan milosevic,no2ocr1Lpider1uperm0Fwami; m0Em0E;op dogg,w whi1H;egfried,nbad;akespeaTerlock holm1Sia labeouf;ddam hussa16nt1;a cla11ig9;aAe6i5o3u1za;mi,n dmc,paul,sh limbau1;gh;bin hood,d stew16nald1thko;in0Mo;han0Yngo starr,valdo;ese witherspo0i1mbrandt;ll2nh1;old;ey,y;chmaninoff,ffi,iJshid,y roma1H;a4e3i2la16o1uff daddy;cahont0Ie;lar,p19;le,rZ;lm17ris hilt0;leg,prah winfr0Sra;a2e1iles cra1Bostradam0J; yo,l5tt06wmQ;pole0s;a5e4i2o1ubar03;by,lie5net,rriss0N;randa ju1tt romn0M;ly;rl0GssiaB;cklemo1rkov,s0ta hari,ya angelou;re;ady gaga,e1ibera0Pu;bron jam0Xch wale1e;sa;anye west,e3i1obe bryant;d cudi,efer suther1;la0P;ats,sha;a2effers0fk,k rowling,rr tolki1;en;ck the ripp0Mwaharlal nehru,y z;liTnez,ron m7;a7e5i3u1;lk hog5mphrey1sa01;! bog05;l1tl0H;de; m1dwig,nry 4;an;ile selassFlle ber4m3rrison1;! 1;ford;id,mo09;ry;ast0iannis,o1;odwPtye;ergus0lorence nightinga08r1;an1ederic chopN;s,z;ff5m2nya,ustaXzeki1;el;eril lagasse,i1;le zatop1nem;ek;ie;a6e4i2octor w1rake;ho;ck w1ego maradoC;olf;g1mi lovaOnzel washingt0;as;l1nHrth vadR;ai lNt0;a8h5lint0o1thulhu;n1olio;an,fuci1;us;on;aucKop2ristian baMy1;na;in;millo,ptain beefhe4r1;dinal wols2son1;! palmF;ey;art;a8e5hatt,i3oHro1;ck,n1;te;ll g1ng crosby;atB;ck,nazir bhut2rtil,yon1;ce;to;nksy,rack ob1;ama;l 6r3shton kutch2vril lavig8yn ra1;nd;er;chimed2istot1;le;es;capo2paci1;no;ne",
    "Adjective": "true\xa60:AI;1:BS;2:BI;3:BA;4:A8;5:84;6:AV;7:AN;8:AF;9:7H;A:BQ;B:AY;C:BC;D:BH;E:9Y;aA2b9Ec8Fd7We79f6Ng6Eh61i4Xj4Wk4Tl4Im41n3Po36p2Oquart7Pr2Ds1Dt14uSvOwFye29;aMeKhIiHoF;man5oFrth7G;dADzy;despreB1n w97s86;acked1UoleF;!sa6;ather1PeFll o70ste1D;!k5;nt1Ist6Ate4;aHeGiFola5T;bBUce versa,gi3Lle;ng67rsa5R;ca1gBSluAV;lt0PnLpHrGsFttermoBL;ef9Ku3;b96ge1; Hb32pGsFtiAH;ca6ide d4R;er,i85;f52to da2;a0Fbeco0Hc0Bd04e02f01gu1XheaBGiXkn4OmUnTopp06pRrNsJtHus0wF;aFiel3K;nt0rra0P;app0eXoF;ld,uS;eHi37o5ApGuF;perv06spec39;e1ok9O;en,ttl0;eFu5;cogn06gul2RlGqu84sF;erv0olv0;at0en33;aFrecede0E;id,rallel0;am0otic0;aFet;rri0tF;ch0;nFq26vers3;sur0terFv7U;eFrupt0;st0;air,inish0orese98;mploy0n7Ov97xpF;ect0lain0;eHisFocume01ue;clFput0;os0;cid0rF;!a8Scov9ha8Jlyi8nea8Gprivileg0sMwF;aFei9I;t9y;hGircumcFonvin2U;is0;aFeck0;lleng0rt0;b20ppea85ssuGttend0uthorF;iz0;mi8;i4Ara;aLeIhoHip 25oGrF;anspare1encha1i2;geth9leADp notch,rpB;rny,ugh6H;ena8DmpGrFs6U;r49tia4;eCo8P;leFst4M;nt0;a0Dc09e07h06i04ki03l01mug,nobbi4XoVpRqueami4XtKuFymb94;bHccinAi generis,pFr5;erFre7N;! dup9b,vi70;du0li7Lp6IsFurb7J;eq9Atanda9X;aKeJi16o2QrGubboFy4Q;rn;aightFin5GungS; fFfF;or7V;adfa9Pri6;lwa6Ftu82;arHeGir6NlendBot Fry;on;c3Qe1S;k5se; call0lImb9phistic16rHuFviV;ndFth1B;proof;dBry;dFub6; o2A;e60ipF;pe4shod;ll0n d7R;g2HnF;ceEg6ist9;am3Se9;co1Zem5lfFn6Are7; suf4Xi43;aGholFient3A;ar5;rlFt4A;et;cr0me,tisfac7F;aOeIheumatoBiGoF;bu8Ztt7Gy3;ghtFv3; 1Sf6X;cJdu8PlInown0pro69sGtF;ard0;is47oF;lu2na1;e1Suc45;alcit8Xe1ondi2;bBci3mpa1;aSePicayu7laOoNrGuF;bl7Tnjabi;eKiIoF;b7VfGmi49pFxi2M;er,ort81;a7uD;maFor,sti7va2;!ry;ciDexis0Ima2CpaB;in55puli8G;cBid;ac2Ynt 3IrFti2;ma40tFv7W;!i3Z;i2YrFss7R;anoBtF; 5XiF;al,s5V;bSffQkPld OnMrLth9utKverF;!aIbMdHhGni75seas,t,wF;ei74rou74;a63e7A;ue;ll;do1Ger,si6A;d3Qg2Aotu5Z; bFbFe on o7g3Uli7;oa80;fashion0school;!ay; gua7XbFha5Uli7;eat;eHligGsF;ce7er0So1C;at0;diFse;a1e1;aOeNiMoGuF;anc0de; moEnHrthFt6V;!eFwe7L;a7Krn;chaGdescri7Iprof30sF;top;la1;ght5;arby,cessa4ighbor5wlyw0xt;k0usiaFv3;ti8;aQeNiLoHuF;dIltiF;facet0p6;deHlGnFot,rbBst;ochro4Xth5;dy;rn,st;ddle ag0nF;dbloZi,or;ag9diocEga,naGrFtropolit4Q;e,ry;ci8;cIgenta,inHj0Fkeshift,mmGnFri4Oscu61ver18;da5Dy;ali4Lo4U;!stream;abEho;aOeLiIoFumberi8;ngFuti1R;stan3RtF;erm,i4H;ghtGteraF;l,ry,te;heart0wei5O;ft JgFss9th3;al,eFi0M;nda4;nguBps0te5;apGind5noF;wi8;ut;ad0itte4uniW;ce co0Hgno6Mll0Cm04nHpso 2UrF;a2releF;va1; ZaYcoWdReQfOgrNhibi4Ri05nMoLsHtFvalu5M;aAeF;nDrdepe2K;a7iGolFuboI;ub6ve1;de,gF;nifica1;rdi5N;a2er;own;eriIiLluenVrF;ar0eq5H;pt,rt;eHiGoFul1O;or;e,reA;fiFpe26termi5E;ni2;mpFnsideCrreA;le2;ccuCdeq5Ene,ppr4J;fFsitu,vitro;ro1;mJpF;arHeGl15oFrop9;li2r11;n2LrfeA;ti3;aGeFi18;d4BnD;tuE;egGiF;c0YteC;al,iF;tiF;ma2;ld;aOelNiLoFuma7;a4meInHrrGsFur5;ti6;if4E;e58o3U; ma3GsF;ick;ghfalut2HspF;an49;li00pf33;i4llow0ndGrdFtM; 05coEworki8;sy,y;aLener44iga3Blob3oKrGuF;il1Nng ho;aFea1Fizzl0;cGtF;ef2Vis;ef2U;ld3Aod;iFuc2D;nf2R;aVeSiQlOoJrF;aGeFil5ug3;q43tf2O;gFnt3S;i6ra1;lk13oHrF; keeps,eFge0Vm9tu41;g0Ei2Ds3R;liF;sh;ag4Mowe4uF;e1or45;e4nF;al,i2;d Gmini7rF;ti6ve1;up;bl0lDmIr Fst pac0ux;oGreacF;hi8;ff;ed,ili0R;aXfVlTmQnOqu3rMthere3veryday,xF;aApIquisi2traHuF;be48lF;ta1;!va2L;edRlF;icF;it;eAstF;whi6; Famor0ough,tiE;rou2sui2;erGiF;ne1;ge1;dFe2Aoq34;er5;ficF;ie1;g9sF;t,ygF;oi8;er;aWeMiHoGrFue;ea4owY;ci6mina1ne,r31ti8ubQ;dact2Jfficult,m,sGverF;ge1se;creGePjoi1paCtF;a1inA;et,te; Nadp0WceMfiLgeneCliJmuEpeIreliAsGvoF;id,ut;pFtitu2ul1L;eCoF;nde1;ca2ghF;tf13;a1ni2;as0;facto;i5ngero0I;ar0Ce09h07i06l05oOrIuF;rmudgeon5stoma4teF;sy;ly;aIeHu1EystalF; cleFli7;ar;epy;fFv17z0;ty;erUgTloSmPnGrpoCunterclVveFy;rt;cLdJgr21jIsHtrF;aFi2;dic0Yry;eq1Yta1;oi1ug3;escenFuN;di8;a1QeFiD;it0;atoDmensuCpF;ass1SulF;so4;ni3ss3;e1niza1;ci1J;ockwiD;rcumspeAvil;eFintzy;e4wy;leGrtaF;in;ba2;diac,ef00;a00ePiLliJoGrFuck nak0;and new,isk,on22;gGldface,naF; fi05fi05;us;nd,tF;he;gGpartisFzarE;an;tiF;me;autifOhiNlLnHsFyoN;iWtselF;li8;eGiFt;gn;aFfi03;th;at0oF;v0w;nd;ul;ckwards,rF;e,rT; priori,b13c0Zd0Tf0Ng0Ihe0Hl09mp6nt06pZrTsQttracti0MuLvIwF;aGkF;wa1B;ke,re;ant garGeraF;ge;de;diIsteEtF;heFoimmu7;nt07;re;to4;hGlFtu2;eep;en;bitIchiv3roHtF;ifiFsy;ci3;ga1;ra4;ry;pFt;aHetizi8rF;oprF;ia2;llFre1;ed,i8;ng;iquFsy;at0e;ed;cohKiJkaHl,oGriFterX;ght;ne,of;li7;ne;ke,ve;olF;ic;ad;ain07gressiIi6rF;eeF;ab6;le;ve;fGraB;id;ectGlF;ue1;ioF;na2; JaIeGvF;erD;pt,qF;ua2;ma1;hoc,infinitum;cuCquiGtu3u2;al;esce1;ra2;erSjeAlPoNrKsGuF;nda1;e1olu2trF;aAuD;se;te;eaGuF;pt;st;aFve;rd;aFe;ze;ct;ra1;nt",
    "Pronoun": "true\xa6elle,h3i2me,she,th0us,we,you;e0ou;e,m,y;!l,t;e,im",
    "Preposition": "true\xa6aPbMcLdKexcept,fIinGmid,notwithstandiWoDpXqua,sCt7u4v2w0;/o,hereSith0;! whHin,oW;ersus,i0;a,s a vis;n1p0;!on;like,til;h1ill,oward0;!s;an,ereby,r0;ough0u;!oM;ans,ince,o that,uch G;f1n0ut;!to;!f;! 0to;effect,part;or,r0;om;espite,own,u3;hez,irca;ar1e0oBy;sides,tween;ri7;bo8cross,ft7lo6m4propos,round,s1t0;!op;! 0;a whole,long 0;as;id0ong0;!st;ng;er;ut",
    "SportsTeam": "true\xa60:18;1:1E;2:1D;3:14;a1Db15c0Sd0Kfc dallas,g0Ihouston 0Hindiana0Gjacksonville jagua0k0El0Am01new UoRpKqueens parkJreal salt lake,sBt6utah jazz,vancouver whitecaps,w4yW;ashington 4h10;natio1Mredski2wizar0W;ampa bay 7e6o4;ronto 4ttenham hotspur;blue ja0Mrapto0;nnessee tita2xasD;buccanee0ra0K;a8eattle 6porting kansas0Wt4; louis 4oke0V;c1Drams;marine0s4;eah13ounH;cramento Rn 4;antonio spu0diego 4francisco gJjose earthquak1;char08paB; ran07;a9h6ittsburgh 5ortland t4;imbe0rail blaze0;pirat1steele0;il4oenix su2;adelphia 4li1;eagl1philNunE;dr1;akland 4klahoma city thunder,rlando magic;athle0Lrai4;de0;england 8orleans 7york 4;g5je3knYme3red bul0Xy4;anke1;ian3;pelica2sain3;patrio3revolut4;ion;anchEeAi4ontreal impact;ami 8lwaukee b7nnesota 4;t5vi4;kings;imberwolv1wi2;rewe0uc0J;dolphi2heat,marli2;mphis grizz4ts;li1;a6eic5os angeles 4;clippe0dodFlaB;esterV; galaxy,ke0;ansas city 4nF;chiefs,roya0D; pace0polis col3;astr05dynamo,rocke3texa2;olden state warrio0reen bay pac4;ke0;allas 8e4i04od6;nver 6troit 4;lio2pisto2ti4;ge0;broncYnugge3;cowbo5maver4;icZ;ys;arEelLhAincinnati 8leveland 6ol4;orado r4umbus crew sc;api7ocki1;brow2cavalie0guar4in4;dia2;bengaVre4;ds;arlotte horAicago 4;b5cubs,fire,wh4;iteB;ea0ulQ;diff4olina panthe0; city;altimore Alackburn rove0oston 6rooklyn 4uffalo bilN;ne3;ts;cel5red4; sox;tics;rs;oriol1rave2;rizona Ast8tlanta 4;brav1falco2h4;awA;ns;es;on villa,r4;os;c6di4;amondbac4;ks;ardi4;na4;ls",
    "Unit": "true\xa6a09b06cZdYexXfTgRhePin00joule0DkMlJmDnan0AoCp9quart0Dsq ft,t7volts,w6y2ze3\xb01\xb50;g,s;c,f,n;dXear1o0;ttT; 0s 0;old;att,b;erPon0;!ne04;ascals,e1i0;cZnt02;rcent,tL;hms,uI;/s,e4i0m\xb2,\xb2,\xb3;/h,cro2l0;e0liM;!\xb2;grNsT;gEtL;it1u0;menSx;erRreR;b5elvins,ilo1m0notQ;/h,ph,\xb2;!byIgrGmEs;ct0rtzN;aLogrE;allonLb0ig5rD;ps;a2emtGl0t6; oz,uid ou0;nceH;hrenheit,radG;aby9;eci3m1;aratDe1m0oulombD;\xb2,\xb3;lsius,nti0;gr2lit1m0;et0;er8;am7;b1y0;te5;l,ps;c2tt0;os0;econd1;re0;!s",
    "Noun|Gerund": "true\xa60:3O;1:3M;2:3N;3:3D;4:32;5:2V;6:3E;7:3K;8:36;9:3J;A:3B;a3Pb37c2Jd27e23f1Vg1Sh1Mi1Ij1Gk1Dl18m13n11o0Wp0Pques0Sr0EsTtNunderMvKwFyDzB;eroi0oB;ni0o3P;aw2eB;ar2l3;aEed4hispe5i5oCrB;ap8est3i1;n0ErB;ki0r31;i1r2s9tc9;isualizi0oB;lunt1Vti0;stan4ta6;aFeDhin6iCraBy8;c6di0i2vel1M;mi0p8;aBs1;c9si0;l6n2s1;aUcReQhOiMkatKl2Wmo6nowJpeItFuCwB;ea5im37;b35f0FrB;fi0vB;e2Mi2J;aAoryt1KrCuB;d2KfS;etc9ugg3;l3n4;bCi0;ebBi0;oar4;gnBnAt1;a3i0;ip8oB;p8rte2u1;a1r27t1;hCo5reBulp1;a2Qe2;edu3oo3;i3yi0;aKeEi4oCuB;li0n2;oBwi0;fi0;aFcEhear7laxi0nDpor1sB;pon4tructB;r2Iu5;de5;or4yc3;di0so2;p8ti0;aFeacek20laEoCrBublis9;a1Teten4in1oces7;iso2siB;tio2;n2yi0;ckaAin1rB;ki0t1O;fEpeDrganiCvB;erco24ula1;si0zi0;ni0ra1;fe5;avi0QeBur7;gotia1twor6;aDeCi2oB;de3nito5;a2dita1e1ssaA;int0XnBrke1;ifUufactu5;aEeaDiBodAyi0;cen7f1mi1stB;e2i0;r2si0;n4ug9;iCnB;ea4it1;c6l3;ogAuB;dAgg3stif12;ci0llust0VmDnBro2;nova1sp0NterBven1;ac1vie02;agi2plo4;aDea1iCoBun1;l4w3;ki0ri0;nd3rB;roWvB;es1;aCene0Lli4rBui4;ee1ie0N;rde2the5;aHeGiDlCorBros1un4;e0Pmat1;ir1oo4;gh1lCnBs9;anZdi0;i0li0;e3nX;r0Zscina1;a1du01nCxB;erci7plo5;chan1di0ginB;ee5;aLeHiGoub1rCum8wB;el3;aDeCiB;bb3n6vi0;a0Qs7;wi0;rTscoDvi0;ba1coZlBvelo8;eCiB;ve5;ga1;nGti0;aVelebUhSlPoDrBur3yc3;aBos7yi0;f1w3;aLdi0lJmFnBo6pi0ve5;dDsCvinB;ci0;trBul1;uc1;muniDpB;lBo7;ai2;ca1;lBo5;ec1;c9ti0;ap8eaCimToBubT;ni0t9;ni0ri0;aBee5;n1t1;ra1;m8rCs1te5;ri0;vi0;aPeNitMlLoGrDuB;dge1il4llBr8;yi0;an4eat9oadB;cas1;di0;a1mEokB;i0kB;ee8;pi0;bi0;es7oa1;c9i0;gin2lonAt1;gi0;bysit1c6ki0tt3;li0;ki0;bando2cGdverti7gi0pproac9rgDssuCtB;trac1;mi0;ui0;hi0;si0;coun1ti0;ti0;ni0;ng",
    "PhrasalVerb": "true\xa60:92;1:96;2:8H;3:8V;4:8A;5:83;6:85;7:98;8:90;9:8G;A:8X;B:8R;C:8U;D:8S;E:70;F:97;G:8Y;H:81;I:7H;J:79;a9Fb7Uc6Rd6Le6Jf5Ig50h4Biron0j47k40l3Em31n2Yo2Wp2Cquiet Hr1Xs0KtZuXvacuu6QwNyammerBzK;ero Dip LonK;e0k0;by,ov9up;aQeMhLiKor0Mrit19;mp0n3Fpe0r5s5;ackAeel Di0S;aLiKn33;gh 3Wrd0;n Dr K;do1in,oJ;it 79k5lk Lrm 69sh Kt83v60;aw3do1o7up;aw3in,oC;rgeBsK;e 2herE;a00eYhViRoQrMuKypP;ckErn K;do1in,oJup;aLiKot0y 30;ckl7Zp F;ck HdK;e 5Y;n7Wp 3Es5K;ck MdLe Kghten 6me0p o0Rre0;aw3ba4do1in,up;e Iy 2;by,oG;ink Lrow K;aw3ba4in,up;ba4ov9up;aKe 77ll62;m 2r 5M;ckBke Llk K;ov9shit,u47;aKba4do1in,leave,o4Dup;ba4ft9pa69w3;a0Vc0Te0Mh0Ii0Fl09m08n07o06p01quar5GtQuOwK;earMiK;ngLtch K;aw3ba4o8K; by;cKi6Bm 2ss0;k 64;aReQiPoNrKud35;aigh2Det75iK;ke 7Sng K;al6Yup;p Krm2F;by,in,oG;c3Ln3Lr 2tc4O;p F;c3Jmp0nd LrKveAy 2O;e Ht 2L;ba4do1up;ar3GeNiMlLrKurB;ead0ingBuc5;a49it 6H;c5ll o3Cn 2;ak Fe1Xll0;a3Bber 2rt0und like;ap 5Vow Duggl5;ash 6Noke0;eep NiKow 6;cLp K;o6Dup;e 68;in,oK;ff,v9;de19gn 4NnKt 6Gz5;gKkE; al6Ale0;aMoKu5W;ot Kut0w 7M;aw3ba4f48oC;c2WdeEk6EveA;e Pll1Nnd Orv5tK; Ktl5J;do1foLin,o7upK;!on;ot,r5Z;aw3ba4do1in,o33up;oCto;al66out0rK;ap65ew 6J;ilAv5;aXeUiSoOuK;b 5Yle0n Kstl5;aLba4do1inKo2Ith4Nu5P;!to;c2Xr8w3;ll Mot LpeAuK;g3Ind17;a2Wf3Po7;ar8in,o7up;ng 68p oKs5;ff,p18;aKelAinEnt0;c6Hd K;o4Dup;c27t0;aZeYiWlToQrOsyc35uK;ll Mn5Kt K;aKba4do1in,oJto47up;pa4Dw3;a3Jdo1in,o21to45up;attleBess KiNop 2;ah2Fon;iLp Kr4Zu1Gwer 6N;do1in,o6Nup;nt0;aLuK;gEmp 6;ce u20y 6D;ck Kg0le 4An 6p5B;oJup;el 5NncilE;c53ir 39n0ss MtLy K;ba4oG; Hc2R;aw3ba4in,oJ;pKw4Y;e4Xt D;aLerd0oK;dAt53;il Hrrow H;aTeQiPoLuK;ddl5ll I;c1FnkeyMp 6uthAve K;aKdo1in,o4Lup;l4Nw3; wi4K;ss0x 2;asur5e3SlLss K;a21up;t 6;ke Ln 6rKs2Ax0;k 6ryA;do,fun,oCsure,up;a02eViQoLuK;ck0st I;aNc4Fg MoKse0;k Kse4D;aft9ba4do1forw37in56o0Zu46;in,oJ;d 6;e NghtMnLsKve 00;ten F;e 2k 2; 2e46;ar8do1in;aMt LvelK; oC;do1go,in,o7up;nEve K;in,oK;pKut;en;c5p 2sh LtchBughAy K;do1o59;in4Po7;eMick Lnock K;do1oCup;oCup;eLy K;in,up;l Ip K;aw3ba4do1f04in,oJto,up;aMoLuK;ic5mpE;ke3St H;c43zz 2;a01eWiToPuK;nLrrKsh 6;y 2;keLt K;ar8do1;r H;lKneErse3K;d Ke 2;ba4dKfast,o0Cup;ear,o1;de Lt K;ba4on,up;aw3o7;aKlp0;d Ml Ir Kt 2;fKof;rom;f11in,o03uW;cPm 2nLsh0ve Kz2P;at,it,to;d Lg KkerP;do1in,o2Tup;do1in,oK;ut,v9;k 2;aZeTive Rloss IoMrLunK; f0S;ab hold,in43ow 2U; Kof 2I;aMb1Mit,oLr8th1IuK;nd9;ff,n,v9;bo7ft9hQw3;aw3bKdo1in,oJrise,up,w3;a4ir2H;ar 6ek0t K;aLb1Fdo1in,oKr8up;ff,n,ut,v9;cLhKl2Fr8t,w3;ead;ross;d aKng 2;bo7;a0Ee07iYlUoQrMuK;ck Ke2N;ar8up;eLighten KownBy 2;aw3oG;eKshe27; 2z5;g 2lMol Krk I;aKwi20;bo7r8;d 6low 2;aLeKip0;sh0;g 6ke0mKrKtten H;e F;gRlPnNrLsKzzle0;h F;e Km 2;aw3ba4up;d0isK;h 2;e Kl 1T;aw3fPin,o7;ht ba4ure0;ePnLsK;s 2;cMd K;fKoG;or;e D;d04l 2;cNll Krm0t1G;aLbKdo1in,o09sho0Eth08victim;a4ehi2O;pa0C;e K;do1oGup;at Kdge0nd 12y5;in,o7up;aOi1HoNrK;aLess 6op KuN;aw3b03in,oC;gBwB; Ile0ubl1B;m 2;a0Ah05l02oOrLut K;aw3ba4do1oCup;ackBeep LoKy0;ss Dwd0;by,do1in,o0Uup;me NoLuntK; o2A;k 6l K;do1oG;aRbQforOin,oNtKu0O;hLoKrue;geth9;rough;ff,ut,v9;th,wK;ard;a4y;paKr8w3;rt;eaLose K;in,oCup;n 6r F;aNeLiK;ll0pE;ck Der Kw F;on,up;t 2;lRncel0rOsMtch LveE; in;o1Nup;h Dt K;doubt,oG;ry LvK;e 08;aw3oJ;l Km H;aLba4do1oJup;ff,n,ut;r8w3;a0Ve0MiteAl0Fo04rQuK;bblNckl05il0Dlk 6ndl05rLsKtMy FzzA;t 00;n 0HsK;t D;e I;ov9;anWeaUiLush K;oGup;ghQng K;aNba4do1forMin,oLuK;nd9p;n,ut;th;bo7lKr8w3;ong;teK;n 2;k K;do1in,o7up;ch0;arTg 6iRn5oPrNssMttlLunce Kx D;aw3ba4;e 6; ar8;e H;do1;k Dt 2;e 2;l 6;do1up;d 2;aPeed0oKurt0;cMw K;aw3ba4do1o7up;ck;k K;in,oC;ck0nk0stA; oQaNef 2lt0nd K;do1ov9up;er;up;r Lt K;do1in,oCup;do1o7;ff,nK;to;ck Pil0nMrgLsK;h D;ainBe D;g DkB; on;in,o7;aw3do1in,oCup;ff,ut;ay;ct FdQir0sk MuctionA; oG;ff;ar8o7;ouK;nd; o7;d K;do1oKup;ff,n;wn;o7up;ut",
    "ProperNoun": "true\xa6abid,barbie,c3e2f1iron maiden,kirby,m0nis,riel;cgill,ercedes,issy;lorence,ranco;lmo,uro;atalina,hristi",
    "Person|Place": "true\xa6a8d6h4jordan,k3orlando,s1vi0;ctor9rgin9;a0ydney;lvador,mara,ntia4;ent,obe;amil0ous0;ton;arw2ie0;go;lexandr1ust0;in;ia",
    "LastName": "true\xa60:BR;1:BF;2:B5;3:BH;4:AX;5:9Y;6:B6;7:BK;8:B0;9:AV;A:AL;B:8Q;C:8G;D:7K;E:BM;F:AH;aBDb9Zc8Wd88e81f7Kg6Wh64i60j5Lk4Vl4Dm39n2Wo2Op25quispe,r1Ls0Pt0Ev03wTxSyKzG;aIhGimmerm6A;aGou,u;ng,o;khar5ytsE;aKeun9BiHoGun;koya32shiBU;!lG;diGmaz;rim,z;maGng;da,g52mo83sGzaC;aChiBV;iao,u;aLeJiHoGright,u;jcA5lff,ng;lGmm0nkl0sniewsC;kiB1liams33s3;bGiss,lt0;b,er,st0;a6Vgn0lHtG;anabe,s3;k0sh,tG;e2Non;aLeKiHoGukD;gt,lk5roby5;dHllalGnogr3Kr1Css0val3S;ba,ob1W;al,ov4;lasHsel8W;lJn dIrgBEsHzG;qu7;ilyEqu7siljE;en b6Aijk,yk;enzueAIverde;aPeix1VhKi2j8ka43oJrIsui,uG;om5UrG;c2n0un1;an,emblA7ynisC;dorAMlst3Km4rrAth;atch0i8UoG;mHrG;are84laci79;ps3sG;en,on;hirDkah9Mnaka,te,varA;a06ch01eYhUiRmOoMtIuHvGzabo;en9Jobod3N;ar7bot4lliv2zuC;aIeHoG;i7Bj4AyanAB;ele,in2FpheBvens25;l8rm0;kol5lovy5re7Tsa,to,uG;ng,sa;iGy72;rn5tG;!h;l71mHnGrbu;at9cla9Egh;moBo7M;aIeGimizu;hu,vchG;en8Luk;la,r1G;gu9infe5YmGoh,pulveA7rra5P;jGyG;on5;evi6iltz,miHneid0roed0uGwarz;be3Elz;dHtG;!t,z;!t;ar4Th8ito,ka4OlJnGr4saCto,unde19v4;ch7dHtGz;a5Le,os;b53e16;as,ihDm4Po0Y;aVeSiPoJuHyG;a6oo,u;bio,iz,sG;so,u;bKc8Fdrigue67ge10j9YmJosevelt,sItHux,wG;e,li6;a9Ch;enb4Usi;a54e4L;erts15i93;bei4JcHes,vGzzo;as,e9;ci,hards12;ag2es,iHut0yG;es,nol5N;s,t0;dImHnGsmu97v6C;tan1;ir7os;ic,u;aUeOhMiJoHrGut8;asad,if6Zochazk27;lishc2GpGrti72u10we76;e3Aov51;cHe45nG;as,to;as70hl0;aGillips;k,m,n6I;a3Hde3Wete0Bna,rJtG;ersHrovGters54;!a,ic;!en,on;eGic,kiBss3;i9ra,tz,z;h86k,padopoulIrk0tHvG;ic,l4N;el,te39;os;bMconn2Ag2TlJnei6PrHsbor6XweBzG;dem7Rturk;ella4DtGwe6N;ega,iz;iGof7Hs8I;vGyn1R;ei9;aSri1;aPeNiJoGune50ym2;rHvGwak;ak4Qik5otn66;odahl,r4S;cholsZeHkolGls4Jx3;ic,ov84;ls1miG;!n1;ils3mG;co4Xec;gy,kaGray2sh,var38;jiGmu9shiG;ma;a07c04eZiWoMuHyeG;rs;lJnIrGssoli6S;atGp03r7C;i,ov4;oz,te58;d0l0;h2lOnNo0RrHsGza1A;er,s;aKeJiIoz5risHtG;e56on;!on;!n7K;au,i9no,t5J;!lA;r1Btgome59;i3El0;cracFhhail5kkeHlG;l0os64;ls1;hmeJiIj30lHn3Krci0ssiGyer2N;!er;n0Po;er,j0;dDti;cartHlG;aughl8e2;hy;dQe7Egnu68i0jer3TkPmNnMrItHyG;er,r;ei,ic,su21thews;iHkDquAroqu8tinG;ez,s;a5Xc,nG;!o;ci5Vn;a5UmG;ad5;ar5e6Kin1;rig77s1;aVeOiLoJuHyG;!nch;k4nGo;d,gu;mbarGpe3Fvr4we;di;!nGu,yana2B;coln,dG;b21holm,strom;bedEfeKhIitn0kaHn8rGw35;oy;!j;m11tG;in1on1;bvGvG;re;iGmmy,ng,rs2Qu,voie,ws3;ne,t1F;aZeYh2iWlUnez50oNrJuHvar2woG;k,n;cerGmar68znets5;a,o34;aHem0isGyeziu;h23t3O;m0sni4Fus3KvG;ch4O;bay57ch,rh0Usk16vaIwalGzl5;czGsC;yk;cIlG;!cGen4K;huk;!ev4ic,s;e8uiveG;rt;eff0kGl4mu9nnun1;ucF;ll0nnedy;hn,llKminsCne,pIrHstra3Qto,ur,yGzl5;a,s0;j0Rls22;l2oG;or;oe;aPenOha6im14oHuG;ng,r4;e32hInHrge32u6vG;anD;es,ss3;anHnsG;en,on,t3;nesGs1R;en,s1;kiBnings,s1;cJkob4EnGrv0E;kDsG;en,sG;en0Ion;ks3obs2A;brahimDglesi5Nke5Fl0Qno07oneIshikHto,vanoG;u,v54;awa;scu;aVeOiNjaltal8oIrist50uG;!aGb0ghAynh;m2ng;a6dz4fIjgaa3Hk,lHpUrGwe,x3X;ak1Gvat;mAt;er,fm3WmG;ann;ggiBtchcock;iJmingw4BnHrGss;nand7re9;deGriks1;rs3;kkiHnG;on1;la,n1;dz4g1lvoQmOns0ZqNrMsJuIwHyG;asFes;kiB;g1ng;anHhiG;mo14;i,ov0J;di6p0r10t;ue;alaG;in1;rs1;aVeorgUheorghe,iSjonRoLrJuGw3;errGnnar3Co,staf3Ctierr7zm2;a,eG;ro;ayli6ee2Lg4iffithGub0;!s;lIme0UnHodGrbachE;e,m2;calvAzale0S;dGubE;bGs0E;erg;aj,i;bs3l,mGordaO;en7;iev3U;gnMlJmaIndFo,rGsFuthi0;cGdn0za;ia;ge;eaHlG;agh0i,o;no;e,on;aVerQiLjeldsted,lKoIrHuG;chs,entAji41ll0;eem2iedm2;ntaGrt8urni0wl0;na;emi6orA;lipIsHtzgeraG;ld;ch0h0;ovG;!ic;hatDnanIrG;arGei9;a,i;deY;ov4;b0rre1D;dKinsJriksIsGvaB;cob3GpGtra3D;inoza,osiQ;en,s3;te8;er,is3warG;ds;aXePiNjurhuMoKrisco15uHvorakG;!oT;arte,boHmitru,nn,rGt3C;and,ic;is;g2he0Omingu7nErd1ItG;to;us;aGcki2Hmitr2Ossanayake,x3;s,z; JbnaIlHmirGrvisFvi,w2;!ov4;gado,ic;th;bo0groot,jo6lHsilGvriA;va;a cruz,e3uG;ca;hl,mcevsCnIt2WviG;dGes,s;ov,s3;ielsGku22;!en;ki;a0Be06hRiobQlarkPoIrGunningh1H;awfo0RivGuz;elli;h1lKntJoIrGs2Nx;byn,reG;a,ia;ke,p0;i,rer2K;em2liB;ns;!e;anu;aOeMiu,oIristGu6we;eGiaG;ns1;i,ng,p9uHwGy;!dH;dGng;huJ;!n,onGu6;!g;kJnIpm2ttHudhGv7;ry;erjee,o14;!d,g;ma,raboG;rty;bJl0Cng4rG;eghetHnG;a,y;ti;an,ota1C;cerAlder3mpbeLrIstGvadi0B;iGro;llo;doHl0Er,t0uGvalho;so;so,zo;ll;a0Fe01hYiXlUoNrKuIyG;rLtyG;qi;chan2rG;ke,ns;ank5iem,oGyant;oks,wG;ne;gdan5nIruya,su,uchaHyKziG;c,n5;rd;darGik;enG;ko;ov;aGond15;nco,zG;ev4;ancFshw16;a08oGuiy2;umGwmG;ik;ckRethov1gu,ktPnNrG;gJisInG;ascoGds1;ni;ha;er,mG;anG;!n;gtGit7nP;ss3;asF;hi;er,hG;am;b4ch,ez,hRiley,kk0ldw8nMrIshHtAu0;es;ir;bInHtlGua;ett;es,i0;ieYosa;dGik;a9yoG;padhyG;ay;ra;k,ng;ic;bb0Acos09d07g04kht05lZnPrLsl2tJyG;aHd8;in;la;chis3kiG;ns3;aImstro6sl2;an;ng;ujo,ya;dJgelHsaG;ri;ovG;!a;ersJov,reG;aGjEws;ss1;en;en,on,s3;on;eksejEiyEmeiIvG;ar7es;ez;da;ev;arwHuilG;ar;al;ams,l0;er;ta;as",
    "Ordinal": "true\xa6eBf7nin5s3t0zeroE;enDhir1we0;lfCn7;d,t3;e0ixt8;cond,vent7;et0th;e6ie7;i2o0;r0urt3;tie4;ft1rst;ight0lev1;e0h,ie1;en0;th",
    "Cardinal": "true\xa6bEeBf5mEnine7one,s4t0zero;en,h2rDw0;e0o;lve,n5;irt6ousands,ree;even2ix2;i3o0;r1ur0;!t2;ty;ft0ve;e2y;ight0lev1;!e0y;en;illions",
    "Multiple": "true\xa6b3hundred,m3qu2se1t0;housand,r2;pt1xt1;adr0int0;illion",
    "City": "true\xa60:74;1:61;2:6G;3:6J;4:5S;a68b53c4Id48e44f3Wg3Hh39i31j2Wk2Fl23m1Mn1Co19p0Wq0Ur0Os05tRuQvLwDxiBy9z5;a7h5i4Muri4O;a5e5ongsh0;ng3H;greb,nzib5G;ang2e5okoha3Sunfu;katerin3Hrev0;a5n0Q;m5Hn;arsBeAi6roclBu5;h0xi,zh5P;c7n5;d5nipeg,terth4;hoek,s1L;hi5Zkl3A;l63xford;aw;a8e6i5ladivost5Molgogr6L;en3lni6S;ni22r5;o3saill4N;lenc4Wncouv3Sr3ughn;lan bat1Crumqi,trecht;aFbilisi,eEheDiBo9r7u5;l21n63r5;in,ku;i5ondh62;es51poli;kyo,m2Zron1Pulo5;n,uS;an5jua3l2Tmisoa6Bra3;j4Tshui; hag62ssaloni2H;gucigal26hr0l av1U;briz,i6llinn,mpe56ng5rtu,shk2R;i3Esh0;an,chu1n0p2Eyu0;aEeDh8kopje,owe1Gt7u5;ra5zh4X;ba0Ht;aten is55ockholm,rasbou67uttga2V;an8e6i5;jiazhua1llo1m5Xy0;f50n5;ya1zh4H;gh3Kt4Q;att45o1Vv44;cramen16int ClBn5o paulo,ppo3Rrajevo; 7aa,t5;a 5o domin3E;a3fe,m1M;antonio,die3Cfrancisco,j5ped3Nsalvad0J;o5u0;se;em,t lake ci5Fz25;lou58peters24;a9e8i6o5;me,t59;ga,o5yadh;! de janei3F;cife,ims,nn3Jykjavik;b4Sip4lei2Inc2Pwalpindi;ingdao,u5;ez2i0Q;aFeEhDiCo9r7u6yong5;ya1;eb59ya1;a5etor3M;g52to;rt5zn0; 5la4Co;au prin0Melizabe24sa03;ls3Prae5Atts26;iladelph3Gnom pe1Aoenix;ki1r21tah tik3E;dua,lerYnaji,r4Ot5;na,r32;ak44des0Km1Mr6s5ttawa;a3Vlo;an,d06;a7ew5ing2Fovosibir1Jyc; 5cast36;del24orlea44taip14;g8iro4Wn5pl2Wshv33v0;ch6ji1t5;es,o1;a1o1;a6o5p4;ya;no,sa0W;aEeCi9o6u5;mb2Ani26sc3Y;gadishu,nt6s5;c13ul;evideo,pelli1Rre2Z;ami,l6n14s5;kolc,sissauga;an,waukee;cca,d5lbour2Mmph41ndo1Cssi3;an,ell2Xi3;cau,drAkass2Sl9n8r5shh4A;aca6ib5rakesh,se2L;or;i1Sy;a4EchFdal0Zi47;mo;id;aDeAi8o6u5vSy2;anMckn0Odhia3;n5s angel26;d2g bea1N;brev2Be3Lma5nz,sb2verpo28;!ss27; ma39i5;c5pzig;est16; p6g5ho2Wn0Cusan24;os;az,la33;aHharFiClaipeBo9rak0Du7y5;iv,o5;to;ala lump4n5;mi1sh0;hi0Hlka2Xpavog4si5wlo2;ce;da;ev,n5rkuk;gst2sha5;sa;k5toum;iv;bHdu3llakuric0Qmpa3Fn6ohsiu1ra5un1Iwaguc0Q;c0Pj;d5o,p4;ah1Ty;a7e6i5ohannesV;l1Vn0;dd36rusalem;ip4k5;ar2H;bad0mph1OnArkutUs7taXz5;mir,tapala5;pa;fah0l6tanb5;ul;am2Zi2H;che2d5;ianap2Mo20;aAe7o5yder2W; chi mi5ms,nolulu;nh;f6lsin5rakli2;ki;ei;ifa,lifax,mCn5rb1Dva3;g8nov01oi;aFdanEenDhCiPlasgBo9raz,u5;a5jr23;dal6ng5yaquil;zh1J;aja2Oupe;ld coa1Bthen5;bu2S;ow;ent;e0Uoa;sk;lw7n5za;dhi5gt1E;nag0U;ay;aisal29es,o8r6ukuya5;ma;ankfu5esno;rt;rt5sh0; wor6ale5;za;th;d5indhov0Pl paso;in5mont2;bur5;gh;aBe8ha0Xisp4o7resd0Lu5;b5esseldorf,nkirk,rb0shanbe;ai,l0I;ha,nggu0rtmu13;hradSl6nv5troit;er;hi;donghIe6k09l5masc1Zr es sala1KugavpiY;i0lU;gu,je2;aJebu,hAleve0Vo5raio02uriti1Q;lo7n6penhag0Ar5;do1Ok;akKst0V;gUm5;bo;aBen8i6ongqi1ristchur5;ch;ang m7ca5ttago1;go;g6n5;ai;du,zho1;ng5ttogr14;ch8sha,zh07;gliari,i9lga8mayenJn6pe town,r5tanO;acCdiff;ber1Ac5;un;ry;ro;aWeNhKirmingh0WoJr9u5;chareTdapeTenos air7r5s0tu0;g5sa;as;es;a9is6usse5;ls;ba6t5;ol;ne;sil8tisla7zzav5;il5;le;va;ia;goZst2;op6ubaneshw5;ar;al;iCl9ng8r5;g6l5n;in;en;aluru,hazi;fa6grade,o horizon5;te;st;ji1rut;ghd0BkFn9ot8r7s6yan n4;ur;el,r07;celo3i,ranquil09;ou;du1g6ja lu5;ka;alo6k5;ok;re;ng;ers5u;field;a05b02cc01ddis aba00gartaZhmedXizawl,lSmPnHqa00rEsBt7uck5;la5;nd;he7l5;an5;ta;ns;h5unci2;dod,gab5;at;li5;ngt2;on;a8c5kaOtwerp;hora6o3;na;ge;h7p5;ol5;is;eim;aravati,m0s5;terd5;am; 7buquerq6eppo,giers,ma5;ty;ue;basrah al qadim5mawsil al jadid5;ah;ab5;ad;la;ba;ra;idj0u dha5;bi;an;lbo6rh5;us;rg",
    "Region": "true\xa60:2K;1:2Q;2:2H;3:2B;a2Ob2Bc1Xd1Ses1Rf1Pg1Kh1Gi1Bj17k12l0Zm0On06o04pYqVrSsJtEuBverAw6y4zacatec2S;akut0o0Cu4;cat2k06;a5est 4isconsin,yomi1K;bengal,virgin0;rwick3shington4;! dc;acruz,mont;dmurt0t4;ah,tar4; 2La0Y;a6e5laxca1Rripu1Xu4;scaEva;langa1nnessee,x2F;bas0Wm4smOtar25;aulip2Dil nadu;a9i7o5taf12u4ylh1F;ffZrr05s1A;me1Cno1Quth 4;cWdV;ber0c4kkim,naloa;hu2ily;n5skatchew2xo4;ny; luis potosi,ta catari1;a4hodeA;j4ngp08;asth2shahi;ingh25u4;e4intana roo;bec,en6retaro;ara8e6rince edward4unjab; i4;sl0C;i,nnsylv4rnambu0C;an0;!na;axa0Ydisha,h4klaho20ntar4reg7ss0Cx0H;io;aKeEo6u4;evo le4nav0W;on;r4tt17va scot0;f9mandy,th4; 4ampton3;c6d5yo4;rk3;ako1N;aroli1;olk;bras1Mva0Cw4; 5foundland4;! and labrador;brunswick,hamp3jers5mexiTyork4;! state;ey;galPyarit;aAeghala0Mi6o4;nta1r4;dov0elos;ch6dlanDn5ss4zor11;issippi,ouri;as geraPneso18;ig2oac2;dhy12harasht0Gine,ni5r4ssachusetts;anhao,i el,ylG;p4toba;ur;anca3e4incoln3ouisI;e4iR;ds;a6e5h4omi;aka06ul1;ntucky,ra01;bardino,lmyk0ns0Qr4;achay,el0nata0X;alis6har4iangxi;kh4;and;co;daho,llino7n4owa;d5gush4;et0;ia1;is;a6ert5i4un2;dalFm0D;ford3;mp3rya1waii;ansu,eorg0lou7oa,u4;an4izhou,jarat;ajuato,gdo4;ng;cester3;lori4uji2;da;sex;ageUe7o5uran4;go;rs4;et;lawaMrby3;aFeaEh9o4rim08umbr0;ahui7l6nnectic5rsi4ventry;ca;ut;i03orado;la;e5hattisgarh,i4uvash0;apRhuahua;chn5rke4;ss0;ya;ra;lGm4;bridge3peche;a9ihar,r8u4;ck4ryat0;ingham3;shi4;re;emen,itish columb0;h0ja cal8lk7s4v7;hkorto4que;st2;an;ar0;iforn0;ia;dygHguascalientes,lBndhr9r5ss4;am;izo1kans5un4;achal 7;as;na;a 4;pradesh;a6ber5t4;ai;ta;ba5s4;ka;ma;ea",
    "Country": "true\xa60:38;1:2L;2:3B;a2Xb2Ec22d1Ye1Sf1Mg1Ch1Ai14j12k0Zl0Um0Gn05om2pZqat1KrXsKtCu7v5wal4yemTz3;a25imbabwe;es,lis and futu2Y;a3enezue32ietnam;nuatu,tican city;gTk6nited 4ruXs3zbeE; 2Ca,sr;arab emirat0Kkingdom,states3;! of am2Y;!raiV;a8haCimor les0Co7rinidad 5u3;nis0rk3valu;ey,me2Zs and caic1V;and t3t3;oba1L;go,kel10nga;iw2ji3nz2T;ki2V;aDcotl1eCi9lov8o6pa2Dri lanka,u5w3yr0;az3edAitzerl1;il1;d2riname;lomon1Xmal0uth 3;afr2KkMsud2;ak0en0;erra leoFn3;gapo1Yt maart3;en;negLrb0ychellZ;int 3moa,n marino,udi arab0;hele26luc0mart21;epublic of ir0Eom2Euss0w3;an27;a4eIhilippinUitcairn1Mo3uerto riN;l1rtugF;ki2Dl4nama,pua new0Vra3;gu7;au,esti3;ne;aBe9i7or3;folk1Ith4w3;ay; k3ern mariana1D;or0O;caragua,ger3ue;!ia;p3ther1Aw zeal1;al;mib0u3;ru;a7exi6icro0Bo3yanm06;ldova,n3roc5zambA;a4gol0t3;enegro,serrat;co;cAdagasc01l7r5urit4yot3;te;an0i16;shall0Xtin3;ique;a4div3i,ta;es;wi,ys0;ao,ed02;a6e5i3uxembourg;b3echtenste12thu1G;er0ya;ban0Isotho;os,tv0;azakh1Fe4iriba04o3uwait,yrgyz1F;rXsovo;eling0Knya;a3erG;ma16p2;c7nd6r4s3taly,vory coast;le of m2rael;a3el1;n,q;ia,oJ;el1;aiTon3ungary;dur0Ng kong;aBermany,ha0QibraltAre8u3;a6ern5inea3ya0P;! biss3;au;sey;deloupe,m,tema0Q;e3na0N;ce,nl1;ar;bUmb0;a7i6r3;ance,ench 3;guia0Epoly3;nes0;ji,nl1;lklandUroeU;ast tim7cu6gypt,l salv6ngl1quatorial4ritr5st3thiop0;on0; guin3;ea;ad3;or;enmark,jibou5ominica4r con3;go;!n C;ti;aBentral african Ah8o5roat0u4yprRzech3; 9ia;ba,racao;c4lo3morQngo brazzaville,okGsta r04te de ivoiL;mb0;osE;i3ristmasG;le,na;republic;m3naUpe verde,ymanA;bod0ero3;on;aGeDhut2o9r5u3;lgar0r3;kina faso,ma,undi;azil,itish 3unei;virgin3; is3;lands;liv0nai5snia and herzegoviHtswaHuvet3; isl1;and;re;l3n8rmuG;ar3gium,ize;us;h4ngladesh,rbad3;os;am4ra3;in;as;fghaGlDmBn6r4ustr3zerbaij2;al0ia;genti3men0uba;na;dorra,g5t3;arct7igua and barbu3;da;o3uil3;la;er3;ica;b3ger0;an0;ia;ni3;st2;an",
    "Place": "true\xa6a0Gb0Bc03d02e01f00gWhUiSkQlNmLnIorHpDrCsAt5u4v3w2y0;a0yz;kutPngtze;ake isHupatki;irgin islands,ostok;laanbaatar,p02;a3eotihuac0Hh1onto,sarskoe selo,u0;lXzigoot;am09e 0;bronx,hamptons;hiti,j mahE;a0cotts bluff,eine,fo,oho,under9;int lawrence river,khalY;ed s3io grande;a1ek,h0itcairn,ompeii;l,x;cif05pahanaumokuak0rthenX;ea;ange county,d,inoco;e0ile;uschwansteQw eng0;land;a0co,ekong,idLuc;chu picchu,gad00libu,nhatt00;a1gw,hr,incoln memori0;al;s,x;azan kremlJosrae,rasnoyar0ul;sk;ax,cn,nd0st;ianSochina;arlem,kg,nd,ov0;d,enweep;a2odavari,re0;at 0enwich;britaBlakI;ngHy village;co,ra;urope,vergladF;anube,en,fw,own4xb;arrizo pla6dg,edar 5gk,h1lt,olosse0;um;a2i0uuk;chen itza,mney rock,na0ricahua;town;morro,tham;breaks,fa5;in;cn,e2kk,ro0;oklyn,wns cany0;on;l air,verly hi0;lls;driadic,frica,lhambra,m7n3rc2sia,tl1zor0;es;!ant2; de triomphe,t1;adyr,tarct0;ic0; oce0;an;ericas,s",
    "FirstName": "true\xa6aTblair,cQdOfrancoZgabMhinaLilya,jHkClBm6ni4quinn,re3s0;h0umit,yd;ay,e0iloh;a,lby;g9ne;co,ko0;!s;a1el0ina,org6;!okuhF;ds,naia,r1tt0xiB;i,y;ion,lo;ashawn,eif,uca;a3e1ir0rM;an;lsFn0rry;dall,yat5;i,sD;a0essIie,ude;i1m0;ie,mG;me;ta;rie0y;le;arcy,ev0;an,on;as1h0;arl8eyenne;ey,sidy;drien,kira,l4nd1ubr0vi;ey;i,r0;a,e0;a,y;ex2f1o0;is;ie;ei,is",
    "WeekDay": "true\xa6fri2mon2s1t0wednesd3;hurs1ues1;aturd1und1;!d0;ay0;!s",
    "Month": "true\xa6dec0february,july,nov0octo1sept0;em0;ber",
    "Date": "true\xa6ago,on4som4t1week0yesterd5; end,ends;mr1o0;d2morrow;!w;ed0;ay",
    "Duration": "true\xa6centurAd8h7m5q4se3w1y0;ear8r8;eek0k7;!end,s;ason,c5;tr,uarter;i0onth3;llisecond2nute2;our1r1;ay0ecade0;!s;ies,y",
    "FemaleName": "true\xa60:J7;1:JB;2:IJ;3:IK;4:J1;5:IO;6:JS;7:JO;8:HB;9:JK;A:H4;B:I2;C:IT;D:JH;E:IX;F:BA;G:I4;aGTbFLcDRdD0eBMfB4gADh9Ti9Gj8Dk7Cl5Wm48n3Lo3Hp33qu32r29s15t0Eu0Cv02wVxiTyOzH;aLeIineb,oHsof3;e3Sf3la,ra;h2iKlIna,ynH;ab,ep;da,ma;da,h2iHra;nab;aKeJi0FolB7uIvH;et8onDP;i0na;le0sen3;el,gm3Hn,rGLs8W;aoHme0nyi;m5XyAD;aMendDZhiDGiH;dele9lJnH;if48niHo0;e,f47;a,helmi0lHma;a,ow;ka0nB;aNeKiHusa5;ck84kIl8oleAviH;anFenJ4;ky,toriBK;da,lA8rHs0;a,nHoniH9;a,iFR;leHnesH9;nILrH;i1y;g9rHs6xHA;su5te;aYeUhRiNoLrIuHy2;i,la;acJ3iHu0J;c3na,sH;hFta;nHr0F;iFya;aJffaEOnHs6;a,gtiH;ng;!nFSra;aIeHomasi0;a,l9Oo8Ares1;l3ndolwethu;g9Fo88rIssH;!a,ie;eHi,ri7;sa,za;bOlMmKnIrHs6tia0wa0;a60yn;iHya;a,ka,s6;arFe2iHm77ra;!ka;a,iH;a,t6;at6it6;a0Ecarlett,e0AhWiSkye,neza0oQri,tNuIyH;bIGlvi1;ha,mayIJniAsIzH;an3Net8ie,y;anHi7;!a,e,nH;aCe;aIeH;fan4l5Dphan6E;cI5r5;b3fiAAm0LnHphi1;d2ia,ja,ya;er2lJmon1nIobh8QtH;a,i;dy;lETv3;aMeIirHo0risFDy5;a,lDM;ba,e0i5lJrH;iHr6Jyl;!d8Ifa;ia,lDZ;hd,iMki2nJrIu0w0yH;la,ma,na;i,le9on,ron,yn;aIda,ia,nHon;a,on;!ya;k6mH;!aa;lJrItaye82vH;da,inj;e0ife;en1i0ma;anA9bLd5Oh1SiBkKlJmInd2rHs6vannaC;aCi0;ant6i2;lDOma,ome;ee0in8Tu2;in1ri0;a05eZhXiUoHuthDM;bScRghQl8LnPsJwIxH;anB3ie,y;an,e0;aIeHie,lD;ann7ll1marDGtA;!lHnn1;iHyn;e,nH;a,dF;da,i,na;ayy8G;hel67io;bDRerAyn;a,cIkHmas,nFta,ya;ki,o;h8Xki;ea,iannGMoH;da,n1P;an0bJemFgi0iInHta,y0;a8Bee;han86na;a,eH;cHkaC;a,ca;bi0chIe,i0mo0nHquETy0;di,ia;aERelHiB;!e,le;een4ia0;aPeOhMiLoJrHute6A;iHudenCV;scil3LyamvaB;lHrt3;i0ly;a,paluk;ilome0oebe,ylH;is,lis;ggy,nelope,r5t2;ige,m0VnKo5rvaDMtIulH;a,et8in1;ricHt4T;a,e,ia;do2i07;ctav3dIfD3is6ksa0lHphD3umC5yunbileg;a,ga,iv3;eHvAF;l3t8;aWeUiMoIurHy5;!ay,ul;a,eJor,rIuH;f,r;aCeEma;ll1mi;aNcLhariBQkKlaJna,sHta,vi;anHha;ur;!y;a,iDZki;hoGk9YolH;a,e4P;!mh;hir,lHna,risDEsreE;!a,lBV;asuMdLh3i6Dl5nKomi7rgEVtH;aHhal4;lHs6;i1ya;cy,et8;e9iF0ya;nngu2X;a0Ackenz4e02iMoJrignayani,uriDJyH;a,rH;a,iOlNna,tG;bi0i2llBJnH;a,iH;ca,ka,qD9;a,cUdo4ZkaTlOmi,nMrItzi,yH;ar;aJiIlH;anET;am;!l,nB;dy,eHh,n4;nhGrva;aKdJe0iCUlH;iHy;cent,e;red;!gros;!e5;ae5hH;ae5el3Z;ag5DgNi,lKrH;edi7AiIjem,on,yH;em,l;em,sCG;an4iHliCF;nHsCJ;a,da;!an,han;b09cASd07e,g05ha,i04ja,l02n00rLsoum5YtKuIv84xBKyHz4;bell,ra,soBB;d7rH;a,eE;h8Gild1t4;a,cUgQiKjor4l7Un4s6tJwa,yH;!aHbe6Xja9lAE;m,nBL;a,ha,in1;!aJbCGeIja,lDna,sHt63;!a,ol,sa;!l1D;!h,mInH;!a,e,n1;!awit,i;arJeIie,oHr48ueri8;!t;!ry;et46i3B;el4Xi7Cy;dHon,ue5;akranAy;ak,en,iHlo3S;a,ka,nB;a,re,s4te;daHg4;!l3E;alDd4elHge,isDJon0;ei9in1yn;el,le;a0Ne0CiXoQuLyH;d3la,nH;!a,dIe2OnHsCT;!a,e2N;a,sCR;aD4cJel0Pis1lIna,pHz;e,iA;a,u,wa;iHy;a0Se,ja,l2NnB;is,l1UrItt1LuHvel4;el5is1;aKeIi7na,rH;aADi7;lHn1tA;ei;!in1;aTbb9HdSepa,lNnKsJvIzH;!a,be5Ret8z4;!ia;a,et8;!a,dH;a,sHy;ay,ey,i,y;a,iJja,lH;iHy;aA8e;!aH;!nF;ia,ya;!nH;!a,ne;aPda,e0iNjYla,nMoKsJtHx93y5;iHt4;c3t3;e2PlCO;la,nHra;a,ie,o2;a,or1;a,gh,laH;!ni;!h,nH;a,d2e,n5V;cOdon9DiNkes6mi9Gna,rMtJurIvHxmi,y5;ern1in3;a,e5Aie,yn;as6iIoH;nya,ya;fa,s6;a,isA9;a,la;ey,ie,y;a04eZhXiOlASoNrJyH;lHra;a,ee,ie;istHy6I;a,en,iIyH;!na;!e,n5F;nul,ri,urtnB8;aOerNlB7mJrHzzy;a,stH;en,in;!berlImernH;aq;eHi,y;e,y;a,stE;!na,ra;aHei2ongordzol;dij1w5;el7UiKjsi,lJnIrH;a,i,ri;d2na,za;ey,i,lBLs4y;ra,s6;biAcARdiat7MeBAiSlQmPnyakuma1DrNss6NtKviAyH;!e,lH;a,eH;e,i8T;!a6HeIhHi4TlDri0y;ar8Her8Hie,leErBAy;!lyn8Ori0;a,en,iHl5Xoli0yn;!ma,nFs95;a5il1;ei8Mi,lH;e,ie;a,tl6O;a0AeZiWoOuH;anMdLlHst88;es,iH;a8NeHs8X;!n9tH;!a,te;e5Mi3My;a,iA;!anNcelDdMelGhan7VleLni,sIva0yH;a,ce;eHie;fHlDph7Y;a,in1;en,n1;i7y;!a,e,n45;lHng;!i1DlH;!i1C;anNle0nKrJsH;i8JsH;!e,i8I;i,ri;!a,elGif2CnH;a,et8iHy;!e,f2A;a,eJiInH;a,eIiH;e,n1;!t8;cMda,mi,nIque4YsminFvie2y9zH;min7;a7eIiH;ce,e,n1s;!lHs82t0F;e,le;inIk6HlDquelH;in1yn;da,ta;da,lRmPnOo0rNsIvaHwo0zaro;!a0lu,na;aJiIlaHob89;!n9R;do2;belHdo2;!a,e,l3B;a7Ben1i0ma;di2es,gr72ji;a9elBogH;en1;a,e9iHo0se;a0na;aSeOiJoHus7Kyacin2C;da,ll4rten24snH;a,i9U;lImaH;ri;aIdHlaI;a,egard;ry;ath1BiJlInrietArmi9sH;sa,t1A;en2Uga,mi;di;bi2Fil8MlNnMrJsItHwa,yl8M;i5Tt4;n60ti;iHmo51ri53;etH;!te;aCnaC;a,ey,l4;a02eWiRlPoNrKunJwH;enHyne1R;!dolD;ay,el;acieIetHiselB;a,chE;!la;ld1CogooH;sh;adys,enHor3yn2K;a,da,na;aKgi,lIna,ov8EselHta;a,e,le;da,liH;an;!n0;mLnJorgIrH;ald5Si,m3Etrud7;et8i4X;a,eHna;s29vieve;ma;bIle,mHrnet,yG;al5Si5;iIrielH;a,l1;!ja;aTeQiPlorOoz3rH;anJeIiH;da,eB;da,ja;!cH;esIiHoi0P;n1s66;!ca;a,enc3;en,o0;lIn0rnH;anB;ec3ic3;jr,nArKtHy7;emIiHma,oumaA;ha,ma,n;eh;ah,iBrah,za0;cr4Rd0Re0Qi0Pk0Ol07mXn54rUsOtNuMvHwa;aKelIiH;!e,ta;inFyn;!a;!ngel4V;geni1ni47;h5Yien9ta;mLperanKtH;eIhHrel5;er;l31r7;za;a,eralB;iHma,ne4Lyn;cHka,n;a,ka;aPeNiKmH;aHe21ie,y;!li9nuH;elG;lHn1;e7iHy;a,e,ja;lHrald;da,y;!nue5;aWeUiNlMma,no2oKsJvH;a,iH;na,ra;a,ie;iHuiH;se;a,en,ie,y;a0c3da,e,f,nMsJzaH;!betHveA;e,h;aHe,ka;!beH;th;!a,or;anor,nH;!a,i;!in1na;ate1Rta;leEs6;vi;eIiHna,wi0;e,th;l,n;aYeMh3iLjeneKoH;lor5Vminiq4Ln3FrHtt4;a,eEis,la,othHthy;ea,y;ba;an09naCon9ya;anQbPde,eOiMlJmetr3nHsir5M;a,iH;ce,se;a,iIla,orHphi9;es,is;a,l6F;dHrdH;re;!d5Ena;!b2ForaCraC;a,d2nH;!a,e;hl3i0l0GmNnLphn1rIvi1WyH;le,na;a,by,cIia,lH;a,en1;ey,ie;a,et8iH;!ca,el1Aka,z;arHia;is;a0Re0Nh04i02lUoJristIynH;di,th3;al,i0;lPnMrIurH;tn1D;aJd2OiHn2Ori9;!nH;a,e,n1;!l4;cepci5Cn4sH;tanHuelo;ce,za;eHleE;en,t8;aJeoIotH;il54;!pat2;ir7rJudH;et8iH;a,ne;a,e,iH;ce,sZ;a2er2ndH;i,y;aReNloe,rH;isJyH;stH;al;sy,tH;a1Sen,iHy;an1e,n1;deJlseIrH;!i7yl;a,y;li9;nMrH;isKlImH;ai9;a,eHot8;n1t8;!sa;d2elGtH;al,elG;cIlH;es8i47;el3ilH;e,ia,y;itlYlXmilWndVrMsKtHy5;aIeIhHri0;er1IleErDy;ri0;a38sH;a37ie;a,iOlLmeJolIrH;ie,ol;!e,in1yn;lHn;!a,la;a,eIie,otHy;a,ta;ne,y;na,s1X;a0Ii0I;a,e,l1;isAl4;in,yn;a0Ke02iZlXoUrH;andi7eRiJoIyH;an0nn;nwDoke;an3HdgMgiLtH;n31tH;!aInH;ey,i,y;ny;d,t8;etH;!t7;an0e,nH;da,na;bbi7glarIlo07nH;iAn4;ka;ancHythe;a,he;an1Clja0nHsm3M;iAtH;ou;aWcVlinUniArPssOtJulaCvH;!erlH;ey,y;hJsy,tH;e,iHy7;e,na;!anH;ie,y;!ie;nItHyl;ha,ie;adIiH;ce;et8i9;ay,da;ca,ky;!triH;ce,z;rbJyaH;rmH;aa;a2o2ra;a2Ub2Od25g21i1Sj5l18m0Zn0Boi,r06sWtVuPvOwa,yIzH;ra,u0;aKes6gJlIn,seH;!l;in;un;!nH;a,na;a,i2K;drLguJrIsteH;ja;el3;stH;in1;a,ey,i,y;aahua,he0;hIi2Gja,miAs2DtrH;id;aMlIraqHt21;at;eIi7yH;!n;e,iHy;gh;!nH;ti;iJleIo6piA;ta;en,n1t8;aHelG;!n1J;a01dje5eZgViTjRnKohito,toHya;inet8nH;el5ia;te;!aKeIiHmJ;e,ka;!mHtt7;ar4;!belIliHmU;sa;!l1;a,eliH;ca;ka,sHta;a,sa;elHie;a,iH;a,ca,n1qH;ue;!tH;a,te;!bImHstasiMya;ar3;el;aLberKeliJiHy;e,l3naH;!ta;a,ja;!ly;hGiIl3nB;da;a,ra;le;aWba,ePiMlKthJyH;a,c3sH;a,on,sa;ea;iHys0N;e,s0M;a,cIn1sHza;a,e,ha,on,sa;e,ia,ja;c3is6jaKksaKna,sJxH;aHia;!nd2;ia,saH;nd2;ra;ia;i0nIyH;ah,na;a,is,naCoud;la;c6da,leEmNnLsH;haClH;inHyY;g,n;!h;a,o,slH;ey;ee;en;at6g4nIusH;ti0;es;ie;aWdiTelMrH;eJiH;anMenH;a,e,ne;an0;na;!aLeKiIyH;nn;a,n1;a,e;!ne;!iH;de;e,lDsH;on;yn;!lH;i9yn;ne;aKbIiHrL;!e,gaK;ey,i7y;!e;gaH;il;dKliyJradhIs6;ha;ya;ah;a,ya",
    "Honorific": "true\xa6director1field marsh2lieutenant1rear0sergeant major,vice0; admir1; gener0;al",
    "Adj|Gerund": "true\xa60:3E;1:3G;2:30;3:2W;4:34;5:32;6:3B;7:2Y;a30b2Qc28d1Qe1Gf17g10h0Xi0Pl0Lm0Enu0Do08p02rWsItCu9v8w18yiel3;ar6e06;n9p8;l1Os09;fol3n1Wsett2;aCeBhr9i4ouc7r8wis0;e09if2oub2us0yi1;ea1Pi8;l2vi1;l2mp0rr1G;nt1Sxi1;aKcreec7enten2KhJkyrocke0lo0Tmi2oHpFtBu9we8;e0Sl2;pp27r8;gi1pri5roun3;a9ea2Xi8ri2Eun20;mula0r4;gge4r8;t2vi1;ark2e8raw2;e3llb2C;a8ot7;ki1ri1;i1Soc26;dWtisf6;aCe9ive0o8us7;a4l2;assu4defi1Ofres7ig1Ojuve05mai1Os0v8war3;ea2itali8ol1D;si1zi1;gi1ll6mb2vi1;a6eBier20lun1Sr8un29;e9o8;mi5vo1W;ce3s5vai2;n3rple8;xi1;ffApUut9ver8wi1;arc7lap02p0Mri3whel2A;goi1l6st1G;en3s8;et0;m2Grtu4;aCeBiAo9u8yst0I;mb2;t1Gvi1;s5tiga0;an1Ol0n3smeri23;d8tu4;de12;aAea9i8o0R;fesa0Qvi1;di1ni1;c1Cg16s0;llumiEmDn8rri0O;cBfurFsAt9vi8;go20ti1;e1Limi1Yoxica0rig0S;pi4ul0;orpo1Xr0H;po5;na0;ea9orrZumil8;ia0;li1rtwar1K;lDr8;atiBipAo9uel8;i1li1;undbrea0Xwi1;pi1;f6ng;a4ea1D;a3etc7it0lCoAr9ulf8;il2;ee1CighUust1I;r8un3;ebo3thco18;aAo8;a0w8;e4i1;mi1tte4;lectrGmEnCx8;aAci0h9is0p8;an3lo3;aLila18;c0spe17;ab2coura09du4ergi10ga09live01ric7sZt8;hral2i0G;barras5er07p8;owe4;if6;aOeGi9r8;if0;s8zz6;aCgBhearAsen0t8;r8ur0Z;ac0es5;teQ;us0;ppoin0r0L;biliEcBfiNgra3ligh0m9pres5s8vasE;erC;an3eaLor8;ali0J;a6ei9liJr8;ea5;vi1;ta0;maNri1s7un0zz2;aNhKlo5o8ripp2ut0;mEn8rrespon3;cerCfBspi4t8;in9r8;as0ibu0ol2;ui1;lic0u5;ni1;fBmAp8;e8romi5;l2ti1;an3;or0;a8il2;llen8n8rX;gi1;lVpt8ri1;iva0;aff2eEin3lDoBr9u8;d3st2;eathta8ui5;ki1;gg2i2oPri1un8;ci1;in3;coMwi8;l8tc7;de4;bsorTcMgonKlHmFnno6ppea2rDs8;pi4su4to8;n9un3;di1;is7;hi1;res0;li1;aDu5;si1;ar9lu4;ri1;mi1;i8zi1;zi1;c8hi1;eleBom8;mo9pan6;yi1;da0;ra0;ti1;bi1;ng",
    "Adverb": "true\xa6a08b05d00eYfSheQinPjustOkinda,likewiZmMnJoEpCquite,r9s5t2u0very,well;ltima01p0; to,wards5;h1iny bit,o0wiO;o,t6;en,us;eldom,o0uch;!me1rt0; of;how,times,w0C;a1e0;alS;ndomRth05;ar excellenEer0oint blank; Lhaps;f3n0utright;ce0ly;! 0;ag05moX; courGten;ewJo0; longWt 0;onHwithstand9;aybe,eanwhiNore0;!ovT;! aboX;deed,steY;lla,n0;ce;or3u0;ck1l9rther0;!moK;ing; 0evK;exampCgood,suH;n mas0vI;se;e0irect2; 2fini0;te0;ly;juAtrop;ackward,y 0;far,no0; means,w; GbroFd nauseam,gEl7ny5part,s4t 2w0;ay,hi0;le;be7l0mo7wor7;arge,ea6; soon,i4;mo0way;re;l 3mo2ongsi1ready,so,togeth0ways;er;de;st;b1t0;hat;ut;ain;ad;lot,posteriori",
    "Conjunction": "true\xa6aXbTcReNhowMiEjust00noBo9p8supposing,t5wh0yet;e1il0o3;e,st;n1re0thN; if,by,vM;evL;h0il,o;erefOo0;!uU;lus,rovided th9;r0therwiM;! not; mattEr,w0;! 0;since,th4w7;f4n0; 0asmuch;as mIcaForder t0;h0o;at;! 0;only,t0w0;hen;!ev3;ith2ven0;! 0;if,tB;er;o0uz;s,z;e0ut,y the time;cau1f0;ore;se;lt3nd,s 0;far1if,m0soon1t2;uch0; as;hou0;gh",
    "Currency": "true\xa6$,aud,bQcOdJeurIfHgbp,hkd,iGjpy,kElDp8r7s3usd,x2y1z0\xa2,\xa3,\xa5,\u0434\u0435\u043D,\u043B\u0432,\u0440\u0443\u0431,\u0E3F,\u20A1,\u20A8,\u20AC,\u20AD,\uFDFC;lotyQ\u0142;en,uanP;af,of;h0t5;e0il5;k0q0;elK;oubleJp,upeeJ;e2ound st0;er0;lingG;n0soF;ceEnies;empi7i7;n,r0wanzaCyatC;!onaBw;ls,nr;ori7ranc9;!os;en3i2kk,o0;b0ll2;ra5;me4n0rham4;ar3;e0ny;nt1;aht,itcoin0;!s",
    "Determiner": "true\xa6aBboth,d9e6few,le5mu8neiDplenty,s4th2various,wh0;at0ich0;evC;a0e4is,ose;!t;everal,ome;!ast,s;a1l0very;!se;ch;e0u;!s;!n0;!o0y;th0;er",
    "Adj|Present": "true\xa6a07b04cVdQeNfJhollIidRlEmCnarrIoBp9qua8r7s3t2uttFw0;aKet,ro0;ng,u08;endChin;e2hort,l1mooth,our,pa9tray,u0;re,speU;i2ow;cu6da02leSpaN;eplica01i02;ck;aHerfePr0;eseUime,omV;bscu1pen,wn;atu0e3odeH;re;a2e1ive,ow0;er;an;st,y;ow;a2i1oul,r0;ee,inge;rm;iIke,ncy,st;l1mpty,x0;emHpress;abo4ic7;amp,e2i1oub0ry,ull;le;ffu9re6;fu8libe0;raE;alm,l5o0;mpleCn3ol,rr1unterfe0;it;e0u7;ct;juga8sum7;ea1o0;se;n,r;ankru1lu0;nt;pt;li2pproxi0rticula1;ma0;te;ght",
    "Comparable": "true\xa60:3B;1:3P;2:3E;3:2H;a3Tb3Cc33d2Ue2Nf2Bg1Xh1Mi1Gj1Fk1Cl14m0Yn0To0Sp0Jqu0Hr08sItDug0vBw5y4za0R;el11ouO;ary,e7hi6i4ry;ck0Dde,l4n1ry,se;d,y;ny,te;a4i3R;k,ry;a4erda2ulgar;gue,in,st;a7en2Xhi6i5ou00r4;anqu2Den1ue;dy,g36me0ny;ck,rs29;ll,me,rt,wd3I;aScaQePhNiMkin0ClJmHoFpEt7u5w4;eet,ift;b4dd0Xperfi22rre29;sta27t3;a9e8iff,r5u4;pVr1;a5ict,o4;ng;ig2Vn0O;a1ep,rn;le,rk,te0;e1Ti2Vright0;ci1Zft,l4on,re;emn,id;a4el0;ll,rt;e5i4y;g2Mm10;ek,nd2T;ck24l0mp3;a4iSrill,y;dy,l02rp;ve0Kxy;n1Kr4;ce,y;d,fe,int0l1Iv0W;a9e7i6o4ude;mantic,o1Asy,u4;gh;pe,t1P;a4d,mo0B;dy,l;gg5iGndom,p4re,w;id;ed;ai2i4;ck,et;hoBink,lAo9r6u4;ny,r4;e,p3;egna2ic5o4;fouTud;ey,k0;liYor;ain,easa2;ny;dd,i0ld,ranM;aive,e6i5o4u15;b3isy,rm0Zsy;bb0ce,mb3;a4r1w;r,t;ad,e6ild,o5u4;nda12te;ist,o1;a5ek,l4;low;s0ty;a9e8i7o4ucky;f0Kn5o15u4ve0w10y0O;d,sy;e0g;ke0l,mp,tt3ve0;e1Qwd;me,r4te;ge;e5i4;nd;en;ol0ui19;cy,ll,n4;secu7t4;e4ima5;llege2rmedia4;te;re;aBe8i7o6u4;ge,m4ng1C;b3id;me0t;gh,l0;a4fYsita2;dy,rXv4;en0y;nd13ppy,r4;d4sh;!y;aGenFhDiClBoofy,r4;a9e7i6o4ue0Z;o4ss;vy;m,s0;at,e4y;dy,n;nd,y;ad,ib,ooE;a2d1;a4o4;st0;t3uiS;u1y;aDeeb3iAl9o7r6u4;ll,n4r0N;!ny;aDesh,iend0;a4nd,rmE;my;at,ir8;erce,nan4;ciA;le;r,ul4;ty;a7erie,sse5v4xtre0B;il;nti4;al;r5s4;tern,y;ly,th0;appZe9i5u4;mb;r6vi5z4;zy;ne;e,ty;a4ep,nA;d4f,r;!ly;agey,h9l8o6r5u4;dd0r0te;isp,uel;ar4ld,mmon,st0ward0zy;se;evLou1;e4il0;ap,e4;sy;aIiGlDoBr6u4;ff,r0sy;ly;a7i4oad;g5llia2;nt;ht;sh,ve;ld,un4;cy;a5o4ue;nd,o1;ck,nd;g,tt4;er;d,ld,w1;dy;bsu7ng6we4;so4;me;ry;rd",
    "Person|Adj": "true\xa6b3du2earnest,frank,mi2r0san1woo1;an0ich,u1;dy;sty;ella,rown",
    "Modal": "true\xa6c5lets,m4ought3sh1w0;ill,o5;a0o4;ll,nt;! to,a;ight,ust;an,o0;uld",
    "Verb": "true\xa6born,cannot,gonna,has,keep tabs,msg",
    "Person|Verb": "true\xa6b8ch7dr6foster,gra5ja9lan4ma2ni9ollie,p1rob,s0wade;kip,pike,t5ue;at,eg,ier2;ck,r0;k,shal;ce;ce,nt;ew;ase,u1;iff,l1ob,u0;ck;aze,ossom",
    "Person|Date": "true\xa6a2j0sep;an0une;!uary;p0ugust,v0;ril"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fAVpb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// export pack
parcelHelpers.export(exports, "pack", ()=>(0, _indexJsDefault.default));
parcelHelpers.export(exports, "unpack", ()=>(0, _indexJsDefault1.default));
parcelHelpers.export(exports, "version", ()=>(0, _versionJsDefault.default));
var _indexJs = require("./pack/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./unpack/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _versionJs = require("./_version.js");
var _versionJsDefault = parcelHelpers.interopDefault(_versionJs);

},{"./pack/index.js":false,"./unpack/index.js":"gwrfI","./_version.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gwrfI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _traverseJs = require("./traverse.js");
var _traverseJsDefault = parcelHelpers.interopDefault(_traverseJs);
const unpack = function(str) {
    if (!str) return {};
    //turn the weird string into a key-value object again
    const obj = str.split("|").reduce((h, s)=>{
        const arr = s.split("\xa6");
        h[arr[0]] = arr[1];
        return h;
    }, {});
    const all = {};
    Object.keys(obj).forEach(function(cat) {
        const arr = (0, _traverseJsDefault.default)(obj[cat]);
        //special case, for botched-boolean
        if (cat === "true") cat = true;
        for(let i = 0; i < arr.length; i++){
            const k = arr[i];
            if (all.hasOwnProperty(k) === true) {
                if (Array.isArray(all[k]) === false) all[k] = [
                    all[k],
                    cat
                ];
                else all[k].push(cat);
            } else all[k] = cat;
        }
    });
    return all;
};
exports.default = unpack;

},{"./traverse.js":"dnfKu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dnfKu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _symbolsJs = require("./symbols.js");
var _symbolsJsDefault = parcelHelpers.interopDefault(_symbolsJs);
var _encodingJs = require("../encoding.js");
var _encodingJsDefault = parcelHelpers.interopDefault(_encodingJs);
// References are either absolute (symbol) or relative (1 - based)
const indexFromRef = function(trie, ref, index) {
    const dnode = (0, _encodingJsDefault.default).fromAlphaCode(ref);
    if (dnode < trie.symCount) return trie.syms[dnode];
    return index + dnode + 1 - trie.symCount;
};
const toArray = function(trie) {
    const all = [];
    const crawl = (index, pref)=>{
        let node = trie.nodes[index];
        if (node[0] === "!") {
            all.push(pref);
            node = node.slice(1) //ok, we tried. remove it.
            ;
        }
        const matches = node.split(/([A-Z0-9,]+)/g);
        for(let i = 0; i < matches.length; i += 2){
            const str = matches[i];
            const ref = matches[i + 1];
            if (!str) continue;
            const have = pref + str;
            //branch's end
            if (ref === "," || ref === undefined) {
                all.push(have);
                continue;
            }
            const newIndex = indexFromRef(trie, ref, index);
            crawl(newIndex, have);
        }
    };
    crawl(0, "");
    return all;
};
//PackedTrie - Trie traversal of the Trie packed-string representation.
const unpack = function(str) {
    const trie = {
        nodes: str.split(";"),
        syms: [],
        symCount: 0
    };
    //process symbols, if they have them
    if (str.match(":")) (0, _symbolsJsDefault.default)(trie);
    return toArray(trie);
};
exports.default = unpack;

},{"./symbols.js":"cqdMD","../encoding.js":"ejGps","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cqdMD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _encodingJs = require("../encoding.js");
var _encodingJsDefault = parcelHelpers.interopDefault(_encodingJs);
const symbols = function(t) {
    //... process these lines
    const reSymbol = new RegExp("([0-9A-Z]+):([0-9A-Z]+)");
    for(let i = 0; i < t.nodes.length; i++){
        const m = reSymbol.exec(t.nodes[i]);
        if (!m) {
            t.symCount = i;
            break;
        }
        t.syms[(0, _encodingJsDefault.default).fromAlphaCode(m[1])] = (0, _encodingJsDefault.default).fromAlphaCode(m[2]);
    }
    //remove from main node list
    t.nodes = t.nodes.slice(t.symCount, t.nodes.length);
};
exports.default = symbols;

},{"../encoding.js":"ejGps","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ejGps":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const BASE = 36;
const seq = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const cache = seq.split("").reduce(function(h, c, i) {
    h[c] = i;
    return h;
}, {});
// 0, 1, 2, ..., A, B, C, ..., 00, 01, ... AA, AB, AC, ..., AAA, AAB, ...
const toAlphaCode = function(n) {
    if (seq[n] !== undefined) return seq[n];
    let places = 1;
    let range = BASE;
    let s = "";
    for(; n >= range; n -= range, places++, range *= BASE);
    while(places--){
        const d = n % BASE;
        s = String.fromCharCode((d < 10 ? 48 : 55) + d) + s;
        n = (n - d) / BASE;
    }
    return s;
};
const fromAlphaCode = function(s) {
    if (cache[s] !== undefined) return cache[s];
    let n = 0;
    let places = 1;
    let range = BASE;
    let pow = 1;
    for(; places < s.length; n += range, places++, range *= BASE);
    for(let i = s.length - 1; i >= 0; i--, pow *= BASE){
        let d = s.charCodeAt(i) - 48;
        if (d > 10) d -= 7;
        n += d * pow;
    }
    return n;
};
exports.default = {
    toAlphaCode,
    fromAlphaCode
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dnVVm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const prp = [
    "Possessive",
    "Pronoun"
];
//words that can't be compressed, for whatever reason
let misc = {
    // numbers
    "20th century fox": "Organization",
    "7 eleven": "Organization",
    "motel 6": "Organization",
    g8: "Organization",
    vh1: "Organization",
    "76ers": "SportsTeam",
    "49ers": "SportsTeam",
    q1: "Date",
    q2: "Date",
    q3: "Date",
    q4: "Date",
    km2: "Unit",
    m2: "Unit",
    dm2: "Unit",
    cm2: "Unit",
    mm2: "Unit",
    mile2: "Unit",
    in2: "Unit",
    yd2: "Unit",
    ft2: "Unit",
    m3: "Unit",
    dm3: "Unit",
    cm3: "Unit",
    in3: "Unit",
    ft3: "Unit",
    yd3: "Unit",
    // ampersands
    "at&t": "Organization",
    "black & decker": "Organization",
    "h & m": "Organization",
    "johnson & johnson": "Organization",
    "procter & gamble": "Organization",
    "ben & jerry's": "Organization",
    "&": "Conjunction",
    //pronouns
    i: [
        "Pronoun",
        "Singular"
    ],
    he: [
        "Pronoun",
        "Singular"
    ],
    she: [
        "Pronoun",
        "Singular"
    ],
    it: [
        "Pronoun",
        "Singular"
    ],
    they: [
        "Pronoun",
        "Plural"
    ],
    we: [
        "Pronoun",
        "Plural"
    ],
    was: [
        "Copula",
        "PastTense"
    ],
    is: [
        "Copula",
        "PresentTense"
    ],
    are: [
        "Copula",
        "PresentTense"
    ],
    am: [
        "Copula",
        "PresentTense"
    ],
    were: [
        "Copula",
        "PastTense"
    ],
    // possessive pronouns
    her: prp,
    his: prp,
    hers: prp,
    their: prp,
    theirs: prp,
    themselves: prp,
    your: prp,
    our: prp,
    ours: prp,
    my: prp,
    its: prp,
    // misc
    vs: [
        "Conjunction",
        "Abbreviation"
    ],
    if: [
        "Condition",
        "Preposition"
    ],
    closer: "Comparative",
    closest: "Superlative",
    much: "Adverb",
    may: "Modal",
    // irregular conjugations with two forms
    babysat: "PastTense",
    blew: "PastTense",
    drank: "PastTense",
    drove: "PastTense",
    forgave: "PastTense",
    skiied: "PastTense",
    spilt: "PastTense",
    stung: "PastTense",
    swam: "PastTense",
    swung: "PastTense",
    guaranteed: "PastTense",
    shrunk: "PastTense",
    // support 'near', 'nears', 'nearing'
    nears: "PresentTense",
    nearing: "Gerund",
    neared: "PastTense",
    no: [
        "Negative",
        "Expression"
    ]
};
exports.default = misc;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cQ8ge":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    "20th century fox": "Organization",
    "7 eleven": "Organization",
    "motel 6": "Organization",
    "excuse me": "Expression",
    "financial times": "Organization",
    "guns n roses": "Organization",
    "la z boy": "Organization",
    "labour party": "Organization",
    "new kids on the block": "Organization",
    "new york times": "Organization",
    "the guess who": "Organization",
    "thin lizzy": "Organization",
    "prime minister": "Actor",
    "free market": "Singular",
    "lay up": "Singular",
    "living room": "Singular",
    "spin off": "Singular",
    "appeal court": "Uncountable",
    "cold war": "Uncountable",
    "gene pool": "Uncountable",
    "machine learning": "Uncountable",
    "nail polish": "Uncountable",
    "time off": "Uncountable",
    "take part": "Infinitive",
    "bill gates": "Person",
    "doctor who": "Person",
    "he man": "Person",
    "iron man": "Person",
    "kid cudi": "Person",
    "run dmc": "Person",
    "rush limbaugh": "Person",
    "snow white": "Person",
    "tiger woods": "Person",
    "brand new": "Adjective",
    "en route": "Adjective",
    "left wing": "Adjective",
    "off guard": "Adjective",
    "on board": "Adjective",
    "part time": "Adjective",
    "right wing": "Adjective",
    "so called": "Adjective",
    "spot on": "Adjective",
    "straight forward": "Adjective",
    "super duper": "Adjective",
    "tip top": "Adjective",
    "top notch": "Adjective",
    "up to date": "Adjective",
    "win win": "Adjective",
    "brooklyn nets": "SportsTeam",
    "chicago bears": "SportsTeam",
    "houston astros": "SportsTeam",
    "houston dynamo": "SportsTeam",
    "houston rockets": "SportsTeam",
    "houston texans": "SportsTeam",
    "minnesota twins": "SportsTeam",
    "orlando magic": "SportsTeam",
    "san antonio spurs": "SportsTeam",
    "san diego chargers": "SportsTeam",
    "san diego padres": "SportsTeam",
    "iron maiden": "ProperNoun",
    "isle of man": "Country",
    "united states": "Country",
    "united states of america": "Country",
    "prince edward island": "Region",
    "cedar breaks": "Place",
    "cedar falls": "Place",
    "point blank": "Adverb",
    "tiny bit": "Adverb",
    "by the time": "Conjunction",
    "no matter": "Conjunction",
    "civil wars": "Plural",
    "credit cards": "Plural",
    "default rates": "Plural",
    "free markets": "Plural",
    "head starts": "Plural",
    "home runs": "Plural",
    "lay ups": "Plural",
    "phone calls": "Plural",
    "press releases": "Plural",
    "record labels": "Plural",
    "soft serves": "Plural",
    "student loans": "Plural",
    "tax returns": "Plural",
    "tv shows": "Plural",
    "video games": "Plural",
    "took part": "PastTense",
    "takes part": "PresentTense",
    "taking part": "Gerund",
    "taken part": "Participle"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"77h12":[function(require,module,exports) {
//just some of the most common emoticons
//faster than
//http://stackoverflow.com/questions/28077049/regex-matching-emoticons
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    ":(",
    ":)",
    ":P",
    ":p",
    ":O",
    ";(",
    ";)",
    ";P",
    ";p",
    ";O",
    ":3",
    ":|",
    ":/",
    ":\\",
    ":$",
    ":*",
    ":@",
    ":-(",
    ":-)",
    ":-P",
    ":-p",
    ":-O",
    ":-3",
    ":-|",
    ":-/",
    ":-\\",
    ":-$",
    ":-*",
    ":-@",
    ":^(",
    ":^)",
    ":^P",
    ":^p",
    ":^O",
    ":^3",
    ":^|",
    ":^/",
    ":^\\",
    ":^$",
    ":^*",
    ":^@",
    "):",
    "(:",
    "$:",
    "*:",
    ")-:",
    "(-:",
    "$-:",
    "*-:",
    ")^:",
    "(^:",
    "$^:",
    "*^:",
    "<3",
    "</3",
    "<\\3",
    "=("
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iAp4R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rulesJs = require("./_rules.js");
var _rulesJsDefault = parcelHelpers.interopDefault(_rulesJs);
const addE = /([xsz]|ch|sh)$/;
const trySuffix = function(str) {
    let c = str[str.length - 1];
    if ((0, _rulesJsDefault.default).hasOwnProperty(c) === true) for(let i = 0; i < (0, _rulesJsDefault.default)[c].length; i += 1){
        let reg = (0, _rulesJsDefault.default)[c][i][0];
        if (reg.test(str) === true) return str.replace(reg, (0, _rulesJsDefault.default)[c][i][1]);
    }
    return null;
};
/** Turn a singular noun into a plural
 * assume the given string is singular
 */ const pluralize = function(str = "", model) {
    let { irregularPlurals, uncountable } = model.two;
    // is it a word without a plural form?
    if (uncountable.hasOwnProperty(str)) return str;
    // check irregulars list
    if (irregularPlurals.hasOwnProperty(str)) return irregularPlurals[str];
    //we have some rules to try-out
    let plural = trySuffix(str);
    if (plural !== null) return plural;
    //like 'church'
    if (addE.test(str)) return str + "es";
    // ¯\_(ツ)_/¯
    return str + "s";
};
exports.default = pluralize;

},{"./_rules.js":"5DBNS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5DBNS":[function(require,module,exports) {
/** patterns for turning 'bus' to 'buses'*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const suffixes = {
    a: [
        [
            /(antenn|formul|nebul|vertebr|vit)a$/i,
            "$1ae"
        ],
        [
            /ia$/i,
            "ia"
        ]
    ],
    e: [
        [
            /(kn|l|w)ife$/i,
            "$1ives"
        ],
        [
            /(hive)$/i,
            "$1s"
        ],
        [
            /([m|l])ouse$/i,
            "$1ice"
        ],
        [
            /([m|l])ice$/i,
            "$1ice"
        ]
    ],
    f: [
        [
            /^(dwar|handkerchie|hoo|scar|whar)f$/i,
            "$1ves"
        ],
        [
            /^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)f$/i,
            "$1ves"
        ]
    ],
    i: [
        [
            /(octop|vir)i$/i,
            "$1i"
        ]
    ],
    m: [
        [
            /([ti])um$/i,
            "$1a"
        ]
    ],
    n: [
        [
            /^(oxen)$/i,
            "$1"
        ]
    ],
    o: [
        [
            /(al|ad|at|er|et|ed)o$/i,
            "$1oes"
        ]
    ],
    s: [
        [
            /(ax|test)is$/i,
            "$1es"
        ],
        [
            /(alias|status)$/i,
            "$1es"
        ],
        [
            /sis$/i,
            "ses"
        ],
        [
            /(bu)s$/i,
            "$1ses"
        ],
        [
            /(sis)$/i,
            "ses"
        ],
        [
            /^(?!talis|.*hu)(.*)man$/i,
            "$1men"
        ],
        [
            /(octop|vir|radi|nucle|fung|cact|stimul)us$/i,
            "$1i"
        ]
    ],
    x: [
        [
            /(matr|vert|ind|cort)(ix|ex)$/i,
            "$1ices"
        ],
        [
            /^(ox)$/i,
            "$1en"
        ]
    ],
    y: [
        [
            /([^aeiouy]|qu)y$/i,
            "$1ies"
        ]
    ],
    z: [
        [
            /(quiz)$/i,
            "$1zes"
        ]
    ]
};
exports.default = suffixes;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lHQUO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _actorVerbJs = require("./actor-verb.js");
var _actorVerbJsDefault = parcelHelpers.interopDefault(_actorVerbJs);
var _adjGerundJs = require("./adj-gerund.js");
var _adjGerundJsDefault = parcelHelpers.interopDefault(_adjGerundJs);
var _adjNounJs = require("./adj-noun.js");
var _adjNounJsDefault = parcelHelpers.interopDefault(_adjNounJs);
var _adjPastJs = require("./adj-past.js");
var _adjPastJsDefault = parcelHelpers.interopDefault(_adjPastJs);
var _adjPresentJs = require("./adj-present.js");
var _adjPresentJsDefault = parcelHelpers.interopDefault(_adjPresentJs);
var _nounGerundJs = require("./noun-gerund.js");
var _nounGerundJsDefault = parcelHelpers.interopDefault(_nounGerundJs);
var _nounVerbJs = require("./noun-verb.js");
var _nounVerbJsDefault = parcelHelpers.interopDefault(_nounVerbJs);
var _personDateJs = require("./person-date.js");
var _personDateJsDefault = parcelHelpers.interopDefault(_personDateJs);
var _personNounJs = require("./person-noun.js");
var _personNounJsDefault = parcelHelpers.interopDefault(_personNounJs);
var _personVerbJs = require("./person-verb.js");
var _personVerbJsDefault = parcelHelpers.interopDefault(_personVerbJs);
var _personPlaceJs = require("./person-place.js");
var _personPlaceJsDefault = parcelHelpers.interopDefault(_personPlaceJs);
var _personAdjJs = require("./person-adj.js");
var _personAdjJsDefault = parcelHelpers.interopDefault(_personAdjJs);
var _unitNounJs = require("./unit-noun.js");
var _unitNounJsDefault = parcelHelpers.interopDefault(_unitNounJs);
const clues = {
    "Actor|Verb": (0, _actorVerbJsDefault.default),
    "Adj|Gerund": (0, _adjGerundJsDefault.default),
    "Adj|Noun": (0, _adjNounJsDefault.default),
    "Adj|Past": (0, _adjPastJsDefault.default),
    "Adj|Present": (0, _adjPresentJsDefault.default),
    "Noun|Verb": (0, _nounVerbJsDefault.default),
    "Noun|Gerund": (0, _nounGerundJsDefault.default),
    "Person|Noun": (0, _personNounJsDefault.default),
    "Person|Date": (0, _personDateJsDefault.default),
    "Person|Verb": (0, _personVerbJsDefault.default),
    "Person|Place": (0, _personPlaceJsDefault.default),
    "Person|Adj": (0, _personAdjJsDefault.default),
    "Unit|Noun": (0, _unitNounJsDefault.default)
};
const copy = (obj, more)=>{
    let res = Object.keys(obj).reduce((h, k)=>{
        h[k] = obj[k] === "Infinitive" ? "PresentTense" : "Plural";
        return h;
    }, {});
    return Object.assign(res, more);
};
// make a copy of this one
clues["Plural|Verb"] = {
    beforeWords: copy(clues["Noun|Verb"].beforeWords, {
        had: "Plural",
        have: "Plural"
    }),
    afterWords: copy(clues["Noun|Verb"].afterWords, {
        his: "PresentTense",
        her: "PresentTense",
        its: "PresentTense",
        in: null,
        to: null,
        is: "PresentTense",
        by: "PresentTense"
    }),
    beforeTags: copy(clues["Noun|Verb"].beforeTags, {
        Conjunction: "PresentTense",
        Noun: undefined,
        ProperNoun: "PresentTense" //john plays
    }),
    afterTags: copy(clues["Noun|Verb"].afterTags, {
        Gerund: "Plural",
        Noun: "PresentTense",
        Value: "PresentTense" //changes seven gears
    })
};
// add some custom plural clues
exports.default = clues;

},{"./actor-verb.js":"kKUYs","./adj-gerund.js":"imtEw","./adj-noun.js":"iXm0O","./adj-past.js":"aB1By","./adj-present.js":"2OwVR","./noun-gerund.js":"hVNkx","./noun-verb.js":"9wltT","./person-date.js":"8T5MF","./person-noun.js":"l3q0u","./person-verb.js":"1Z2MC","./person-place.js":"1hLE6","./person-adj.js":"8tuo9","./unit-noun.js":"1qV8L","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kKUYs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nounJs = require("./_noun.js");
var _nounJsDefault = parcelHelpers.interopDefault(_nounJs);
var _verbJs = require("./_verb.js");
var _verbJsDefault = parcelHelpers.interopDefault(_verbJs);
// 'the pilot' vs 'pilot the plane'
const clue = {
    beforeTags: Object.assign({}, (0, _verbJsDefault.default).beforeTags, (0, _nounJsDefault.default).beforeTags, {}),
    afterTags: Object.assign({}, (0, _verbJsDefault.default).afterTags, (0, _nounJsDefault.default).afterTags, {}),
    beforeWords: Object.assign({}, (0, _verbJsDefault.default).beforeWords, (0, _nounJsDefault.default).beforeWords, {}),
    afterWords: Object.assign({}, (0, _verbJsDefault.default).afterWords, (0, _nounJsDefault.default).afterWords, {})
};
exports.default = clue;

},{"./_noun.js":"7Esns","./_verb.js":"2QGCe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Esns":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const n = "Singular";
exports.default = {
    beforeTags: {
        Determiner: n,
        Possessive: n,
        Acronym: n,
        // ProperNoun:n,
        Noun: n,
        Adjective: n,
        // Verb:true, //save storm victims
        PresentTense: n,
        Gerund: n,
        PastTense: n,
        Infinitive: n,
        Date: n,
        Ordinal: n,
        Demonym: n
    },
    afterTags: {
        Value: n,
        Modal: n,
        Copula: n,
        PresentTense: n,
        PastTense: n,
        // Noun:n, //talking therapy, planning process
        Demonym: n,
        Actor: n //dance therapist
    },
    // ownTags: { ProperNoun: n },
    beforeWords: {
        the: n,
        with: n,
        without: n,
        // was:n, //was time  -- was working
        // is:n, //
        of: n,
        for: n,
        any: n,
        all: n,
        on: n,
        // thing-ish verbs
        cut: n,
        cuts: n,
        increase: n,
        decrease: n,
        raise: n,
        drop: n,
        // give: n,//give parents
        save: n,
        saved: n,
        saves: n,
        make: n,
        makes: n,
        made: n,
        minus: n,
        plus: n,
        than: n,
        another: n,
        versus: n,
        neither: n,
        about: n,
        // strong adjectives
        favorite: n,
        best: n,
        daily: n,
        weekly: n,
        linear: n,
        binary: n,
        mobile: n,
        lexical: n,
        technical: n,
        computer: n,
        scientific: n,
        security: n,
        government: n,
        popular: n,
        formal: n,
        no: n,
        more: n,
        one: n,
        let: n,
        her: n,
        his: n,
        their: n,
        our: n,
        us: n
    },
    afterWords: {
        of: n,
        system: n,
        aid: n,
        method: n,
        utility: n,
        tool: n,
        reform: n,
        therapy: n,
        philosophy: n,
        room: n,
        authority: n,
        says: n,
        said: n,
        wants: n,
        wanted: n,
        is: n,
        did: n,
        do: n,
        can: n,
        wise: n
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2QGCe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const v = "Infinitive";
exports.default = {
    beforeTags: {
        Modal: v,
        Adverb: v,
        Negative: v,
        Plural: v
    },
    afterTags: {
        Determiner: v,
        Adverb: v,
        Possessive: v,
        Reflexive: v,
        // Noun:true, //date spencer
        Preposition: v,
        // Conjunction: v, // dip to, dip through
        Cardinal: v,
        Comparative: v,
        Superlative: v
    },
    beforeWords: {
        i: v,
        we: v,
        you: v,
        they: v,
        to: v,
        please: v,
        will: v,
        have: v,
        had: v,
        would: v,
        could: v,
        should: v,
        do: v,
        did: v,
        does: v,
        can: v,
        must: v,
        us: v,
        me: v,
        let: v,
        even: v,
        when: v,
        help: v,
        // them: v,
        he: v,
        she: v,
        it: v,
        being: v,
        // prefixes
        bi: v,
        co: v,
        contra: v,
        de: v,
        inter: v,
        intra: v,
        mis: v,
        pre: v,
        out: v,
        counter: v,
        nobody: v,
        somebody: v,
        anybody: v,
        everybody: v
    },
    afterWords: {
        the: v,
        me: v,
        you: v,
        him: v,
        us: v,
        her: v,
        his: v,
        them: v,
        they: v,
        it: v,
        himself: v,
        herself: v,
        itself: v,
        myself: v,
        ourselves: v,
        themselves: v,
        something: v,
        anything: v,
        a: v,
        an: v,
        // from: v, //ranges from
        up: v,
        down: v,
        by: v,
        // in: v, //bob in
        out: v,
        // on: v,
        off: v,
        under: v,
        what: v,
        // when: v,//starts when
        // for:true, //settled for
        all: v,
        // conjunctions
        to: v,
        because: v,
        although: v,
        after: v,
        before: v,
        how: v,
        otherwise: v,
        together: v,
        though: v,
        into: v,
        yet: v,
        more: v,
        here: v,
        there: v,
        away: v
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"imtEw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _adjJs = require("./_adj.js");
var _adjJsDefault = parcelHelpers.interopDefault(_adjJs);
var _gerundJs = require("./_gerund.js");
var _gerundJsDefault = parcelHelpers.interopDefault(_gerundJs);
// rallying the troops
// her rallying cry
const clue = {
    beforeTags: Object.assign({}, (0, _adjJsDefault.default).beforeTags, (0, _gerundJsDefault.default).beforeTags, {
        // Copula: 'Adjective', 
        Imperative: "Gerund",
        Infinitive: "Adjective",
        PresentTense: "Gerund",
        Plural: "Gerund" //kids cutting
    }),
    afterTags: Object.assign({}, (0, _adjJsDefault.default).afterTags, (0, _gerundJsDefault.default).afterTags, {
        Singular: "Adjective" //shocking ignorance
    }),
    beforeWords: Object.assign({}, (0, _adjJsDefault.default).beforeWords, (0, _gerundJsDefault.default).beforeWords, {
        is: "Adjective",
        was: "Adjective",
        of: "Adjective",
        suggest: "Gerund",
        recommend: "Gerund"
    }),
    afterWords: Object.assign({}, (0, _adjJsDefault.default).afterWords, (0, _gerundJsDefault.default).afterWords, {
        to: "Gerund",
        not: "Gerund",
        the: "Gerund" //sweeping the country
    })
};
// console.log(clue)
exports.default = clue;

},{"./_adj.js":"5tD49","./_gerund.js":"c1QGn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5tD49":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const jj = "Adjective";
exports.default = {
    beforeTags: {
        Determiner: jj,
        // Copula: jj, //is detailed
        Possessive: jj,
        Hyphenated: jj
    },
    afterTags: {
        // Noun: jj, //detailed plan, overwhelming evidence
        Adjective: jj
    },
    beforeWords: {
        seem: jj,
        seemed: jj,
        seems: jj,
        feel: jj,
        feels: jj,
        felt: jj,
        stay: jj,
        appear: jj,
        appears: jj,
        appeared: jj,
        also: jj,
        over: jj,
        under: jj,
        too: jj,
        it: jj,
        but: jj,
        still: jj,
        // adverbs that are adjective-ish
        really: jj,
        quite: jj,
        well: jj,
        very: jj,
        how: jj,
        deeply: jj,
        hella: jj,
        // always: jj,
        // never: jj,
        profoundly: jj,
        extremely: jj,
        so: jj,
        badly: jj,
        mostly: jj,
        totally: jj,
        awfully: jj,
        rather: jj,
        nothing: jj,
        something: jj,
        anything: jj,
        not: jj,
        me: jj,
        is: jj
    },
    afterWords: {
        too: jj,
        also: jj,
        or: jj,
        enough: jj
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c1QGn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const g = "Gerund";
// Adj|Gerund
// Noun|Gerund
exports.default = {
    beforeTags: {
        // Verb: g, // loves shocking
        Adverb: g,
        Preposition: g,
        Conjunction: g
    },
    afterTags: {
        Adverb: g,
        Possessive: g,
        Person: g,
        Pronoun: g,
        Determiner: g,
        Copula: g,
        Preposition: g,
        Conjunction: g,
        Comparative: g
    },
    beforeWords: {
        been: g,
        keep: g,
        continue: g,
        stop: g,
        am: g,
        be: g,
        me: g,
        // action-words
        began: g,
        start: g,
        starts: g,
        started: g,
        stops: g,
        stopped: g,
        help: g,
        helps: g,
        avoid: g,
        avoids: g,
        love: g,
        loves: g,
        loved: g,
        hate: g,
        hates: g,
        hated: g
    },
    afterWords: {
        you: g,
        me: g,
        her: g,
        him: g,
        his: g,
        them: g,
        their: g,
        it: g,
        this: g,
        there: g,
        on: g,
        about: g,
        for: g,
        up: g,
        down: g
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iXm0O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _adjJs = require("./_adj.js");
var _adjJsDefault = parcelHelpers.interopDefault(_adjJs);
var _nounJs = require("./_noun.js");
var _nounJsDefault = parcelHelpers.interopDefault(_nounJs);
// the commercial market
// watching the commercial
const misc = {
    beforeTags: {
        Determiner: undefined,
        Cardinal: "Noun",
        PhrasalVerb: "Adjective" //starts out fine
    },
    afterTags: {
    }
};
const clue = {
    beforeTags: Object.assign({}, (0, _adjJsDefault.default).beforeTags, (0, _nounJsDefault.default).beforeTags, misc.beforeTags),
    afterTags: Object.assign({}, (0, _adjJsDefault.default).afterTags, (0, _nounJsDefault.default).afterTags, misc.afterTags),
    beforeWords: Object.assign({}, (0, _adjJsDefault.default).beforeWords, (0, _nounJsDefault.default).beforeWords, {
        // are representative
        are: "Adjective",
        is: "Adjective",
        was: "Adjective",
        be: "Adjective",
        // phrasals
        off: "Adjective",
        out: "Adjective"
    }),
    afterWords: Object.assign({}, (0, _adjJsDefault.default).afterWords, (0, _nounJsDefault.default).afterWords)
};
exports.default = clue;

},{"./_adj.js":"5tD49","./_noun.js":"7Esns","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aB1By":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _adjJs = require("./_adj.js");
var _adjJsDefault = parcelHelpers.interopDefault(_adjJs);
// the boiled egg
// boiled the water
let past = "PastTense";
const adjPast = {
    beforeTags: {
        Adverb: past,
        Pronoun: past,
        ProperNoun: past,
        Auxiliary: past,
        Noun: past
    },
    afterTags: {
        Possessive: past,
        Pronoun: past,
        Determiner: past,
        Adverb: past,
        Comparative: past,
        Date: past,
        Gerund: past
    },
    beforeWords: {
        be: past,
        who: past,
        get: "Adjective",
        had: past,
        has: past,
        have: past,
        been: past,
        it: past,
        as: past,
        for: "Adjective",
        more: "Adjective"
    },
    afterWords: {
        by: past,
        back: past,
        out: past,
        in: past,
        up: past,
        down: past,
        before: past,
        after: past,
        for: past,
        the: past,
        with: past,
        as: past,
        on: past,
        at: past,
        between: past,
        to: past,
        into: past,
        us: past,
        them: past,
        his: past,
        her: past,
        their: past,
        our: past,
        me: past,
        about: "Adjective"
    }
};
exports.default = {
    beforeTags: Object.assign({}, (0, _adjJsDefault.default).beforeTags, adjPast.beforeTags),
    afterTags: Object.assign({}, (0, _adjJsDefault.default).afterTags, adjPast.afterTags),
    beforeWords: Object.assign({}, (0, _adjJsDefault.default).beforeWords, adjPast.beforeWords),
    afterWords: Object.assign({}, (0, _adjJsDefault.default).afterWords, adjPast.afterWords)
};

},{"./_adj.js":"5tD49","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2OwVR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _adjJs = require("./_adj.js");
var _adjJsDefault = parcelHelpers.interopDefault(_adjJs);
var _verbJs = require("./_verb.js");
var _verbJsDefault = parcelHelpers.interopDefault(_verbJs);
// 'would mean' vs 'is mean'
const misc = {
    afterTags: {
        Noun: "Adjective",
        Conjunction: undefined //clean and excellent
    }
};
const clue = {
    beforeTags: Object.assign({}, (0, _adjJsDefault.default).beforeTags, (0, _verbJsDefault.default).beforeTags, {
        // always clean
        Adverb: undefined,
        Negative: undefined
    }),
    afterTags: Object.assign({}, (0, _adjJsDefault.default).afterTags, (0, _verbJsDefault.default).afterTags, misc.afterTags),
    beforeWords: Object.assign({}, (0, _adjJsDefault.default).beforeWords, (0, _verbJsDefault.default).beforeWords, {
        // have seperate contracts
        have: undefined,
        had: undefined,
        not: undefined,
        //went wrong, got wrong
        went: "Adjective",
        goes: "Adjective",
        got: "Adjective",
        // be sure
        be: "Adjective"
    }),
    afterWords: Object.assign({}, (0, _adjJsDefault.default).afterWords, (0, _verbJsDefault.default).afterWords, {
        to: undefined,
        as: "Adjective"
    })
};
// console.log(clue.beforeWords)
// console.log(clue)
exports.default = clue;

},{"./_adj.js":"5tD49","./_verb.js":"2QGCe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hVNkx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nounJs = require("./_noun.js");
var _nounJsDefault = parcelHelpers.interopDefault(_nounJs);
var _gerundJs = require("./_gerund.js");
var _gerundJsDefault = parcelHelpers.interopDefault(_gerundJs);
// 'operating the crane', or 'operating room'
const misc = {
    beforeTags: {
        Copula: "Gerund",
        PastTense: "Gerund",
        PresentTense: "Gerund",
        Infinitive: "Gerund"
    },
    afterTags: {
        Value: "Gerund"
    },
    beforeWords: {
        are: "Gerund",
        were: "Gerund",
        be: "Gerund",
        no: "Gerund",
        without: "Gerund",
        //are you playing
        you: "Gerund",
        we: "Gerund",
        they: "Gerund",
        he: "Gerund",
        she: "Gerund",
        //stop us playing
        us: "Gerund",
        them: "Gerund"
    },
    afterWords: {
        // offering the
        the: "Gerund",
        this: "Gerund",
        that: "Gerund",
        //got me thinking
        me: "Gerund",
        us: "Gerund",
        them: "Gerund"
    }
};
const clue = {
    beforeTags: Object.assign({}, (0, _gerundJsDefault.default).beforeTags, (0, _nounJsDefault.default).beforeTags, misc.beforeTags),
    afterTags: Object.assign({}, (0, _gerundJsDefault.default).afterTags, (0, _nounJsDefault.default).afterTags, misc.afterTags),
    beforeWords: Object.assign({}, (0, _gerundJsDefault.default).beforeWords, (0, _nounJsDefault.default).beforeWords, misc.beforeWords),
    afterWords: Object.assign({}, (0, _gerundJsDefault.default).afterWords, (0, _nounJsDefault.default).afterWords, misc.afterWords)
};
exports.default = clue;

},{"./_noun.js":"7Esns","./_gerund.js":"c1QGn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9wltT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nounJs = require("./_noun.js");
var _nounJsDefault = parcelHelpers.interopDefault(_nounJs);
var _verbJs = require("./_verb.js");
var _verbJsDefault = parcelHelpers.interopDefault(_verbJs);
const nn = "Singular";
const vb = "Infinitive";
// 'boot the ball'   -  'the red boot'
// 'boots the ball'  -   'the red boots'
const clue = {
    beforeTags: Object.assign({}, (0, _verbJsDefault.default).beforeTags, (0, _nounJsDefault.default).beforeTags, {
        // Noun: undefined
        Adjective: nn,
        Particle: nn //brought under control
    }),
    afterTags: Object.assign({}, (0, _verbJsDefault.default).afterTags, (0, _nounJsDefault.default).afterTags, {
        ProperNoun: vb,
        Gerund: vb,
        Adjective: vb,
        Copula: nn
    }),
    beforeWords: Object.assign({}, (0, _verbJsDefault.default).beforeWords, (0, _nounJsDefault.default).beforeWords, {
        // is time
        is: nn,
        was: nn,
        //balance of power
        of: nn,
        have: null //have cash
    }),
    afterWords: Object.assign({}, (0, _verbJsDefault.default).afterWords, (0, _nounJsDefault.default).afterWords, {
        // for: vb,//work for
        instead: vb,
        // that: nn,//subject that was
        // for: vb,//work for
        about: vb,
        his: vb,
        her: vb,
        to: null,
        by: null,
        in: null
    })
};
exports.default = clue;

},{"./_noun.js":"7Esns","./_verb.js":"2QGCe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8T5MF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _personJs = require("./_person.js");
var _personJsDefault = parcelHelpers.interopDefault(_personJs);
// 'april o'neil'  -  'april 1st'
const m = "Month";
const p = "Person";
const month = {
    beforeTags: {
        Date: m,
        Value: m
    },
    afterTags: {
        Date: m,
        Value: m
    },
    beforeWords: {
        by: m,
        in: m,
        on: m,
        during: m,
        after: m,
        before: m,
        between: m,
        until: m,
        til: m,
        sometime: m,
        of: m,
        this: m,
        next: m,
        last: m,
        previous: m,
        following: m,
        with: p
    },
    afterWords: {
        sometime: m,
        in: m,
        of: m,
        until: m,
        the: m
    }
};
exports.default = {
    beforeTags: Object.assign({}, (0, _personJsDefault.default).beforeTags, month.beforeTags),
    afterTags: Object.assign({}, (0, _personJsDefault.default).afterTags, month.afterTags),
    beforeWords: Object.assign({}, (0, _personJsDefault.default).beforeWords, month.beforeWords),
    afterWords: Object.assign({}, (0, _personJsDefault.default).afterWords, month.afterWords)
};

},{"./_person.js":"78EMB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"78EMB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const p = "Person";
exports.default = {
    beforeTags: {
        Honorific: p,
        Person: p
    },
    afterTags: {
        Person: p,
        ProperNoun: p,
        Verb: p
    },
    ownTags: {
        ProperNoun: p
    },
    beforeWords: {
        hi: p,
        hey: p,
        yo: p,
        dear: p,
        hello: p
    },
    afterWords: {
        // person-usually verbs
        said: p,
        says: p,
        told: p,
        tells: p,
        feels: p,
        felt: p,
        seems: p,
        thinks: p,
        thought: p,
        spends: p,
        spendt: p,
        plays: p,
        played: p,
        sing: p,
        sang: p,
        learn: p,
        learned: p,
        wants: p,
        wanted: p
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l3q0u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _personJs = require("./_person.js");
var _personJsDefault = parcelHelpers.interopDefault(_personJs);
var _nounJs = require("./_noun.js");
var _nounJsDefault = parcelHelpers.interopDefault(_nounJs);
// 'babling brook' vs 'brook sheilds'
const clue = {
    beforeTags: Object.assign({}, (0, _nounJsDefault.default).beforeTags, (0, _personJsDefault.default).beforeTags),
    afterTags: Object.assign({}, (0, _nounJsDefault.default).afterTags, (0, _personJsDefault.default).afterTags),
    beforeWords: Object.assign({}, (0, _nounJsDefault.default).beforeWords, (0, _personJsDefault.default).beforeWords, {
        i: "Infinitive",
        we: "Infinitive"
    }),
    afterWords: Object.assign({}, (0, _nounJsDefault.default).afterWords, (0, _personJsDefault.default).afterWords)
};
exports.default = clue;

},{"./_person.js":"78EMB","./_noun.js":"7Esns","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Z2MC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _personJs = require("./_person.js");
var _personJsDefault = parcelHelpers.interopDefault(_personJs);
var _verbJs = require("./_verb.js");
var _verbJsDefault = parcelHelpers.interopDefault(_verbJs);
var _nounJs = require("./_noun.js");
var _nounJsDefault = parcelHelpers.interopDefault(_nounJs);
// 'rob the store'   -  'rob lowe'
// can be a noun too - 'losing hope'
const clues = {
    beforeTags: Object.assign({}, (0, _nounJsDefault.default).beforeTags, (0, _personJsDefault.default).beforeTags, (0, _verbJsDefault.default).beforeTags),
    afterTags: Object.assign({}, (0, _nounJsDefault.default).afterTags, (0, _personJsDefault.default).afterTags, (0, _verbJsDefault.default).afterTags),
    beforeWords: Object.assign({}, (0, _nounJsDefault.default).beforeWords, (0, _personJsDefault.default).beforeWords, (0, _verbJsDefault.default).beforeWords),
    afterWords: Object.assign({}, (0, _nounJsDefault.default).afterWords, (0, _personJsDefault.default).afterWords, (0, _verbJsDefault.default).afterWords)
};
exports.default = clues;

},{"./_person.js":"78EMB","./_verb.js":"2QGCe","./_noun.js":"7Esns","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1hLE6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _personJs = require("./_person.js");
var _personJsDefault = parcelHelpers.interopDefault(_personJs);
const p = "Place";
// 'paris hilton' vs 'paris france'
const place = {
    beforeTags: {
        Place: p
    },
    afterTags: {
        Place: p,
        Abbreviation: p
    },
    beforeWords: {
        in: p,
        by: p,
        near: p,
        from: p,
        to: p
    },
    afterWords: {
        in: p,
        by: p,
        near: p,
        from: p,
        to: p,
        government: p,
        council: p,
        region: p,
        city: p
    }
};
const clue = {
    beforeTags: Object.assign({}, place.beforeTags, (0, _personJsDefault.default).beforeTags),
    afterTags: Object.assign({}, place.afterTags, (0, _personJsDefault.default).afterTags),
    beforeWords: Object.assign({}, place.beforeWords, (0, _personJsDefault.default).beforeWords),
    afterWords: Object.assign({}, place.afterWords, (0, _personJsDefault.default).afterWords)
};
exports.default = clue;

},{"./_person.js":"78EMB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8tuo9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _personJs = require("./_person.js");
var _personJsDefault = parcelHelpers.interopDefault(_personJs);
var _adjJs = require("./_adj.js");
var _adjJsDefault = parcelHelpers.interopDefault(_adjJs);
// 'rusty nail'   -  'rusty smith'
const clues = {
    beforeTags: Object.assign({}, (0, _personJsDefault.default).beforeTags, (0, _adjJsDefault.default).beforeTags),
    afterTags: Object.assign({}, (0, _personJsDefault.default).afterTags, (0, _adjJsDefault.default).afterTags),
    beforeWords: Object.assign({}, (0, _personJsDefault.default).beforeWords, (0, _adjJsDefault.default).beforeWords),
    afterWords: Object.assign({}, (0, _personJsDefault.default).afterWords, (0, _adjJsDefault.default).afterWords)
};
exports.default = clues;

},{"./_person.js":"78EMB","./_adj.js":"5tD49","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1qV8L":[function(require,module,exports) {
// '5 oz'   -  'dr oz'
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let un = "Unit";
const clues = {
    beforeTags: {
        Value: un
    },
    afterTags: {},
    beforeWords: {
        per: un,
        every: un,
        each: un,
        square: un,
        cubic: un,
        sq: un,
        metric: un //metric ton
    },
    afterWords: {
        per: un,
        squared: un,
        cubed: un,
        long: un //foot long
    }
};
exports.default = clues;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jfysp":[function(require,module,exports) {
//just a foolish lookup of known suffixes
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const Adj = "Adjective";
const Inf = "Infinitive";
const Pres = "PresentTense";
const Sing = "Singular";
const Past = "PastTense";
const Avb = "Adverb";
const Plrl = "Plural";
const Actor = "Actor";
const Vb = "Verb";
const Noun = "Noun";
const Last = "LastName";
const Modal = "Modal";
const Place = "Place";
const Prt = "Participle";
exports.default = [
    null,
    null,
    {
        //2-letter
        ea: Sing,
        ia: Noun,
        ic: Adj,
        ly: Avb,
        "'n": Vb,
        "'t": Vb
    },
    {
        //3-letter
        oed: Past,
        ued: Past,
        xed: Past,
        " so": Avb,
        "'ll": Modal,
        "'re": "Copula",
        azy: Adj,
        eer: Noun,
        end: Vb,
        ped: Past,
        ffy: Adj,
        ify: Inf,
        ing: "Gerund",
        ize: Inf,
        ibe: Inf,
        lar: Adj,
        mum: Adj,
        nes: Pres,
        nny: Adj,
        // oid: Adj,
        ous: Adj,
        que: Adj,
        ger: Noun,
        ber: Noun,
        rol: Sing,
        sis: Sing,
        ogy: Sing,
        oid: Sing,
        ian: Sing,
        zes: Pres,
        eld: Past,
        ken: Prt,
        ven: Prt,
        ten: Prt,
        ect: Inf,
        ict: Inf,
        // ide: Inf,
        ign: Inf,
        oze: Inf,
        ful: Adj,
        bal: Adj,
        ton: Noun
    },
    {
        //4-letter
        amed: Past,
        aped: Past,
        ched: Past,
        lked: Past,
        rked: Past,
        reed: Past,
        nded: Past,
        mned: Adj,
        cted: Past,
        dged: Past,
        ield: Sing,
        akis: Last,
        cede: Inf,
        chuk: Last,
        czyk: Last,
        ects: Pres,
        iend: Sing,
        ends: Vb,
        enko: Last,
        ette: Sing,
        iary: Sing,
        wner: Sing,
        fies: Pres,
        fore: Avb,
        gate: Inf,
        gone: Adj,
        ices: Plrl,
        ints: Plrl,
        ruct: Inf,
        ines: Plrl,
        ions: Plrl,
        ners: Plrl,
        pers: Plrl,
        lers: Plrl,
        less: Adj,
        llen: Adj,
        made: Adj,
        nsen: Last,
        oses: Pres,
        ould: Modal,
        some: Adj,
        sson: Last,
        ians: Plrl,
        // tage: Inf,
        tion: Sing,
        tage: Noun,
        ique: Sing,
        tive: Adj,
        tors: Noun,
        vice: Sing,
        lier: Sing,
        fier: Sing,
        wned: Past,
        gent: Sing,
        tist: Actor,
        pist: Actor,
        rist: Actor,
        mist: Actor,
        yist: Actor,
        vist: Actor,
        ists: Actor,
        lite: Sing,
        site: Sing,
        rite: Sing,
        mite: Sing,
        bite: Sing,
        mate: Sing,
        date: Sing,
        ndal: Sing,
        vent: Sing,
        uist: Actor,
        gist: Actor,
        note: Sing,
        cide: Sing,
        ence: Sing,
        wide: Adj,
        // side: Adj,//alongside
        vide: Inf,
        ract: Inf,
        duce: Inf,
        pose: Inf,
        eive: Inf,
        lyze: Inf,
        lyse: Inf,
        iant: Adj,
        nary: Adj,
        ghty: Adj,
        uent: Adj,
        erer: Actor,
        bury: Place,
        dorf: Noun,
        esty: Noun,
        wych: Place,
        dale: Place,
        folk: Place
    },
    {
        //5-letter
        elist: Actor,
        holic: Sing,
        phite: Sing,
        tized: Past,
        urned: Past,
        eased: Past,
        ances: Plrl,
        bound: Adj,
        ettes: Plrl,
        fully: Avb,
        ishes: Pres,
        ities: Plrl,
        marek: Last,
        nssen: Last,
        ology: Noun,
        osome: Sing,
        tment: Sing,
        ports: Plrl,
        rough: Adj,
        tches: Pres,
        tieth: "Ordinal",
        tures: Plrl,
        wards: Avb,
        where: Avb,
        archy: Noun,
        pathy: Noun,
        opoly: Noun,
        embly: Noun,
        phate: Noun,
        ndent: Sing,
        scent: Sing,
        onist: Actor,
        anist: Actor,
        alist: Actor,
        olist: Actor,
        icist: Actor,
        ounce: Inf,
        iable: Adj,
        borne: Adj,
        gnant: Adj,
        inant: Adj,
        igent: Adj,
        atory: Adj,
        // ctory: Adj,
        rient: Sing,
        dient: Sing,
        maker: Actor,
        burgh: Place,
        mouth: Place,
        ceter: Place,
        ville: Place,
        worth: Noun
    },
    {
        //6-letter
        auskas: Last,
        parent: Sing,
        cedent: Sing,
        ionary: Sing,
        cklist: Sing,
        keeper: Actor,
        logist: Actor,
        teenth: "Value",
        worker: Actor,
        master: Actor,
        writer: Actor,
        brough: Place,
        cester: Place
    },
    {
        //7-letter
        logists: Actor,
        opoulos: Last,
        borough: Place,
        sdottir: Last
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ajUtP":[function(require,module,exports) {
//prefixes give very-little away, in general.
// more-often for scientific terms, etc.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const Adj = "Adjective";
const Noun = "Noun";
const Verb = "Verb";
exports.default = [
    null,
    null,
    {
    },
    {
        // 3-letter
        neo: Noun,
        bio: Noun,
        // pre: Noun,
        "de-": Verb,
        "re-": Verb,
        "un-": Verb,
        "ex-": Noun
    },
    {
        // 4-letter
        anti: Noun,
        auto: Noun,
        faux: Adj,
        hexa: Noun,
        kilo: Noun,
        mono: Noun,
        nano: Noun,
        octa: Noun,
        poly: Noun,
        semi: Adj,
        tele: Noun,
        "pro-": Adj,
        "mis-": Verb,
        "dis-": Verb,
        "pre-": Adj
    },
    {
        // 5-letter
        anglo: Noun,
        centi: Noun,
        ethno: Noun,
        ferro: Noun,
        grand: Noun,
        hepta: Noun,
        hydro: Noun,
        intro: Noun,
        macro: Noun,
        micro: Noun,
        milli: Noun,
        nitro: Noun,
        penta: Noun,
        quasi: Adj,
        radio: Noun,
        tetra: Noun,
        "omni-": Adj,
        "post-": Adj
    },
    {
        // 6-letter
        pseudo: Adj,
        "extra-": Adj,
        "hyper-": Adj,
        "inter-": Adj,
        "intra-": Adj,
        "deca-": Adj
    },
    {
        // 7-letter
        electro: Noun
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7n5E9":[function(require,module,exports) {
//regex suffix patterns and their most common parts of speech,
//built using wordnet, by spencer kelly.
//this mapping shrinks-down the uglified build
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const Adj = "Adjective";
const Inf = "Infinitive";
const Pres = "PresentTense";
const Sing = "Singular";
const Past = "PastTense";
const Adverb = "Adverb";
const Exp = "Expression";
const Actor = "Actor";
const Verb = "Verb";
const Noun = "Noun";
const Last = "LastName";
exports.default = {
    a: [
        [
            /.[aeiou]na$/,
            Noun,
            "tuna"
        ],
        [
            /.[oau][wvl]ska$/,
            Last
        ],
        [
            /.[^aeiou]ica$/,
            Sing,
            "harmonica"
        ],
        [
            /^([hyj]a+)+$/,
            Exp,
            "haha"
        ]
    ],
    c: [
        [
            /.[^aeiou]ic$/,
            Adj
        ]
    ],
    d: [
        //==-ed==
        //double-consonant
        [
            /[aeiou](pp|ll|ss|ff|gg|tt|rr|bb|nn|mm)ed$/,
            Past,
            "popped"
        ],
        //double-vowel
        [
            /.[aeo]{2}[bdgmnprvz]ed$/,
            Past,
            "rammed"
        ],
        //-hed
        [
            /.[aeiou][sg]hed$/,
            Past,
            "gushed"
        ],
        //-rd
        [
            /.[aeiou]red$/,
            Past,
            "hired"
        ],
        [
            /.[aeiou]r?ried$/,
            Past,
            "hurried"
        ],
        // ard
        [
            /[^aeiou]ard$/,
            Sing,
            "steward"
        ],
        // id
        [
            /[aeiou][^aeiou]id$/,
            Adj,
            ""
        ],
        [
            /.[vrl]id$/,
            Adj,
            "livid"
        ],
        // ===== -ed ======
        //-led
        [
            /..led$/,
            Past,
            "hurled"
        ],
        //-sed
        [
            /.[iao]sed$/,
            Past,
            ""
        ],
        [
            /[aeiou]n?[cs]ed$/,
            Past,
            ""
        ],
        //-med
        [
            /[aeiou][rl]?[mnf]ed$/,
            Past,
            ""
        ],
        //-ked
        [
            /[aeiou][ns]?c?ked$/,
            Past,
            "bunked"
        ],
        //-gned
        [
            /[aeiou]gned$/,
            Past
        ],
        //-ged
        [
            /[aeiou][nl]?ged$/,
            Past
        ],
        //-ted
        [
            /.[tdbwxyz]ed$/,
            Past
        ],
        [
            /[^aeiou][aeiou][tvx]ed$/,
            Past
        ],
        //-ied
        [
            /.[cdflmnprstv]ied$/,
            Past,
            "emptied"
        ]
    ],
    e: [
        [
            /.[lnr]ize$/,
            Inf,
            "antagonize"
        ],
        [
            /.[^aeiou]ise$/,
            Inf,
            "antagonise"
        ],
        [
            /.[aeiou]te$/,
            Inf,
            "bite"
        ],
        [
            /.[^aeiou][ai]ble$/,
            Adj,
            "fixable"
        ],
        [
            /.[^aeiou]eable$/,
            Adj,
            "maleable"
        ],
        [
            /.[ts]ive$/,
            Adj,
            "festive"
        ],
        [
            /[a-z]-like$/,
            Adj,
            "woman-like"
        ]
    ],
    h: [
        [
            /.[^aeiouf]ish$/,
            Adj,
            "cornish"
        ],
        [
            /.v[iy]ch$/,
            Last,
            "..ovich"
        ],
        [
            /^ug?h+$/,
            Exp,
            "ughh"
        ],
        [
            /^uh[ -]?oh$/,
            Exp,
            "uhoh"
        ],
        [
            /[a-z]-ish$/,
            Adj,
            "cartoon-ish"
        ]
    ],
    i: [
        [
            /.[oau][wvl]ski$/,
            Last,
            "polish-male"
        ]
    ],
    k: [
        [
            /^(k){2}$/,
            Exp,
            "kkkk"
        ]
    ],
    l: [
        [
            /.[gl]ial$/,
            Adj,
            "familial"
        ],
        [
            /.[^aeiou]ful$/,
            Adj,
            "fitful"
        ],
        [
            /.[nrtumcd]al$/,
            Adj,
            "natal"
        ],
        [
            /.[^aeiou][ei]al$/,
            Adj,
            "familial"
        ]
    ],
    m: [
        [
            /.[^aeiou]ium$/,
            Sing,
            "magnesium"
        ],
        [
            /[^aeiou]ism$/,
            Sing,
            "schism"
        ],
        [
            /^[hu]m+$/,
            Exp,
            "hmm"
        ],
        [
            /^\d+ ?[ap]m$/,
            "Date",
            "3am"
        ]
    ],
    n: [
        [
            /.[lsrnpb]ian$/,
            Adj,
            "republican"
        ],
        [
            /[^aeiou]ician$/,
            Actor,
            "musician"
        ],
        [
            /[aeiou][ktrp]in'$/,
            "Gerund",
            "cookin'"
        ]
    ],
    o: [
        [
            /^no+$/,
            Exp,
            "noooo"
        ],
        [
            /^(yo)+$/,
            Exp,
            "yoo"
        ],
        [
            /^wo{2,}[pt]?$/,
            Exp,
            "woop"
        ]
    ],
    r: [
        [
            /.[bdfklmst]ler$/,
            "Noun"
        ],
        [
            /[aeiou][pns]er$/,
            Sing
        ],
        [
            /[^i]fer$/,
            Inf
        ],
        [
            /.[^aeiou][ao]pher$/,
            Actor
        ],
        [
            /.[lk]er$/,
            "Noun"
        ],
        [
            /.ier$/,
            "Comparative"
        ]
    ],
    t: [
        [
            /.[di]est$/,
            "Superlative"
        ],
        [
            /.[icldtgrv]ent$/,
            Adj
        ],
        [
            /[aeiou].*ist$/,
            Adj
        ],
        [
            /^[a-z]et$/,
            Verb
        ]
    ],
    s: [
        [
            /.[^aeiou]ises$/,
            Pres
        ],
        [
            /.[rln]ates$/,
            Pres
        ],
        [
            /.[^z]ens$/,
            Verb
        ],
        [
            /.[lstrn]us$/,
            Sing
        ],
        [
            /.[aeiou]sks$/,
            Pres
        ],
        [
            /.[aeiou]kes$/,
            Pres
        ],
        [
            /[aeiou][^aeiou]is$/,
            Sing
        ],
        [
            /[a-z]'s$/,
            Noun
        ],
        [
            /^yes+$/,
            Exp
        ]
    ],
    v: [
        [
            /.[^aeiou][ai][kln]ov$/,
            Last
        ]
    ],
    y: [
        [
            /.[cts]hy$/,
            Adj
        ],
        [
            /.[st]ty$/,
            Adj
        ],
        [
            /.[tnl]ary$/,
            Adj
        ],
        [
            /.[oe]ry$/,
            Sing
        ],
        [
            /[rdntkbhs]ly$/,
            Adverb
        ],
        [
            /.(gg|bb|zz)ly$/,
            Adj
        ],
        [
            /...lly$/,
            Adverb
        ],
        [
            /.[gk]y$/,
            Adj
        ],
        [
            /[bszmp]{2}y$/,
            Adj
        ],
        [
            /.[ai]my$/,
            Adj
        ],
        [
            /[ea]{2}zy$/,
            Adj
        ],
        [
            /.[^aeiou]ity$/,
            Sing
        ]
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5EXtj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const vb = "Verb";
const nn = "Noun";
exports.default = {
    // looking at the previous word's tags:
    leftTags: [
        [
            "Adjective",
            nn
        ],
        [
            "Possessive",
            nn
        ],
        [
            "Determiner",
            nn
        ],
        [
            "Adverb",
            vb
        ],
        [
            "Pronoun",
            vb
        ],
        [
            "Value",
            nn
        ],
        [
            "Ordinal",
            nn
        ],
        [
            "Modal",
            vb
        ],
        [
            "Superlative",
            nn
        ],
        [
            "Demonym",
            nn
        ],
        [
            "Honorific",
            "Person"
        ]
    ],
    // looking at the previous word:
    leftWords: [
        [
            "i",
            vb
        ],
        [
            "first",
            nn
        ],
        [
            "it",
            vb
        ],
        [
            "there",
            vb
        ],
        [
            "not",
            vb
        ],
        [
            "because",
            nn
        ],
        [
            "if",
            nn
        ],
        [
            "but",
            nn
        ],
        [
            "who",
            vb
        ],
        [
            "this",
            nn
        ],
        [
            "his",
            nn
        ],
        [
            "when",
            nn
        ],
        [
            "you",
            vb
        ],
        [
            "very",
            "Adjective"
        ],
        [
            "old",
            nn
        ],
        [
            "never",
            vb
        ],
        [
            "before",
            nn
        ],
        [
            "a",
            nn
        ],
        [
            "the",
            nn
        ],
        [
            "been",
            vb
        ]
    ],
    // looking at the next word's tags:
    rightTags: [
        [
            "Copula",
            nn
        ],
        [
            "PastTense",
            nn
        ],
        [
            "Conjunction",
            nn
        ],
        [
            "Modal",
            nn
        ]
    ],
    // looking at the next word:
    rightWords: [
        [
            "there",
            vb
        ],
        [
            "me",
            vb
        ],
        [
            "man",
            "Adjective"
        ],
        // ['only', vb],
        [
            "him",
            vb
        ],
        [
            "it",
            vb
        ],
        [
            "were",
            nn
        ],
        [
            "took",
            nn
        ],
        [
            "himself",
            vb
        ],
        [
            "went",
            nn
        ],
        [
            "who",
            nn
        ],
        [
            "jr",
            "Person"
        ]
    ]
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cwapb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dataJs = require("./_data.js");
var _dataJsDefault = parcelHelpers.interopDefault(_dataJs);
var _suffixThumb = require("suffix-thumb");
// import { reverse, uncompress } from '/Users/spencer/mountain/suffix-thumb'
// const uncompress = function () { }
// const reverse = function () { }
const fromPast = (0, _suffixThumb.uncompress)((0, _dataJsDefault.default).PastTense);
const fromPresent = (0, _suffixThumb.uncompress)((0, _dataJsDefault.default).PresentTense);
const fromGerund = (0, _suffixThumb.uncompress)((0, _dataJsDefault.default).Gerund);
const fromParticiple = (0, _suffixThumb.uncompress)((0, _dataJsDefault.default).Participle);
const toPast = (0, _suffixThumb.reverse)(fromPast);
const toPresent = (0, _suffixThumb.reverse)(fromPresent);
const toGerund = (0, _suffixThumb.reverse)(fromGerund);
const toParticiple = (0, _suffixThumb.reverse)(fromParticiple);
const toComparative = (0, _suffixThumb.uncompress)((0, _dataJsDefault.default).Comparative);
const toSuperlative = (0, _suffixThumb.uncompress)((0, _dataJsDefault.default).Superlative);
const fromComparative = (0, _suffixThumb.reverse)(toComparative);
const fromSuperlative = (0, _suffixThumb.reverse)(toSuperlative);
const adjToNoun = (0, _suffixThumb.uncompress)((0, _dataJsDefault.default).AdjToNoun);
exports.default = {
    fromPast,
    fromPresent,
    fromGerund,
    fromParticiple,
    toPast,
    toPresent,
    toGerund,
    toParticiple,
    // adjectives
    toComparative,
    toSuperlative,
    fromComparative,
    fromSuperlative,
    adjToNoun
} // console.log(convert('collide', toPast))
;

},{"./_data.js":"ce3BH","suffix-thumb":"21rKx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ce3BH":[function(require,module,exports) {
// generated in ./lib/pairs
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    "Comparative": {
        "fwd": "3:ser,ier\xa61er:h,t,f,l,n\xa61r:e\xa62er:ss,or,om",
        "both": "3er:ver,ear,alm\xa63ner:hin\xa63ter:lat\xa62mer:im\xa62er:ng,rm,mb\xa62ber:ib\xa62ger:ig\xa61er:w,p,k,d\xa6ier:y",
        "rev": "1:tter,yer\xa62:uer,ver,ffer,oner,eler,ller,iler,ster,cer,uler,sher,ener,gher,aner,adder,nter,eter,rter,hter,rner,fter\xa63:oser,ooler,eafer,user,airer,bler,maler,tler,eater,uger,rger,ainer,urer,ealer,icher,pler,emner,icter,nser,iser\xa64:arser,viner,ucher,rosser,somer,ndomer,moter,oother,uarer,hiter\xa65:nuiner,esser,emier\xa6ar:urther",
        "ex": "worse:bad\xa6better:good\xa64er:fair,gray,poor\xa61urther:far\xa63ter:fat,hot,wet\xa63er:lay,shy,fun\xa63der:mad,sad\xa64der:glad\xa6:\xa64r:cute,dire,fake,fine,free,lame,late,pale,rare,ripe,rude,safe,sore,tame,wide\xa65r:eerie,stale"
    },
    "Gerund": {
        "fwd": "1:nning,tting,rring,pping,eing,mming,gging,dding,bbing,kking\xa62:eking,oling,eling,eming\xa63:velling,siting,uiting,fiting,loting,geting,ialing,celling\xa64:graming",
        "both": "1:aing,iing,fing,xing,ying,oing,hing,wing\xa62:tzing,rping,izzing,bting,mning,sping,wling,rling,wding,rbing,uping,lming,wning,mping,oning,lting,mbing,lking,fting,hting,sking,gning,pting,cking,ening,nking,iling,eping,ering,rting,rming,cting,lping,ssing,nting,nding,lding,sting,rning,rding,rking\xa63:belling,siping,toming,yaking,uaking,oaning,auling,ooping,aiding,naping,euring,tolling,uzzing,ganing,haning,ualing,halling,iasing,auding,ieting,ceting,ouling,voring,ralling,garing,joring,oaming,oaking,roring,nelling,ooring,uelling,eaming,ooding,eaping,eeting,ooting,ooming,xiting,keting,ooking,ulling,airing,oaring,biting,outing,oiting,earing,naling,oading,eeding,ouring,eaking,aiming,illing,oining,eaning,onging,ealing,aining,eading\xa64:thoming,melling,aboring,ivoting,weating,dfilling,onoring,eriting,imiting,tialling,rgining,otoring,linging,winging,lleting,louding,spelling,mpelling,heating,feating,opelling,choring,welling,ymaking,ctoring,calling,peating,iloring,laiting,utoring,uditing,mmaking,loating,iciting,waiting,mbating,voiding,otalling,nsoring,nselling,ocusing,itoring,eloping\xa65:rselling,umpeting,atrolling,treating,tselling,rpreting,pringing,ummeting,ossoming,elmaking,eselling,rediting,totyping,onmaking,rfeiting,ntrolling\xa65e:chmaking,dkeeping,severing,erouting,ecreting,ephoning,uthoring,ravening,reathing,pediting,erfering,eotyping,fringing,entoring,ombining,ompeting\xa64e:emaking,eething,twining,rruling,chuting,xciting,rseding,scoping,edoring,pinging,lunging,agining,craping,pleting,eleting,nciting,nfining,ncoding,tponing,ecoding,writing,esaling,nvening,gnoring,evoting,mpeding,rvening,dhering,mpiling,storing,nviting,ploring\xa63e:tining,nuring,saking,miring,haling,ceding,xuding,rining,nuting,laring,caring,miling,riding,hoking,piring,lading,curing,uading,noting,taping,futing,paring,hading,loding,siring,guring,vading,voking,during,niting,laning,caping,luting,muting,ruding,ciding,juring,laming,caling,hining,uoting,liding,ciling,duling,tuting,puting,cuting,coring,uiding,tiring,turing,siding,rading,enging,haping,buting,lining,taking,anging,haring,uiring,coming,mining,moting,suring,viding,luding\xa62e:tring,zling,uging,oging,gling,iging,vring,fling,lging,obing,psing,pling,ubing,cling,dling,wsing,iking,rsing,dging,kling,ysing,tling,rging,eging,nsing,uning,osing,uming,using,ibing,bling,aging,ising,asing,ating\xa62ie:rlying\xa61e:zing,uing,cing,ving",
        "rev": "ying:ie\xa61ing:se,ke,te,we,ne,re,de,pe,me,le,c,he\xa62ing:ll,ng,dd,ee,ye,oe,rg,us\xa62ning:un\xa62ging:og,ag,ug,ig,eg\xa62ming:um\xa62bing:ub,ab,eb,ob\xa63ning:lan,can,hin,pin,win\xa63ring:cur,lur,tir,tar,pur,car\xa63ing:ait,del,eel,fin,eat,oat,eem,lel,ool,ein,uin\xa63ping:rop,rap,top,uip,wap,hip,hop,lap,rip,cap\xa63ming:tem,wim,rim,kim,lim\xa63ting:mat,cut,pot,lit,lot,hat,set,pit,put\xa63ding:hed,bed,bid\xa63king:rek\xa63ling:cil,pel\xa63bing:rib\xa64ning:egin\xa64ing:isit,ruit,ilot,nsit,dget,rkel,ival,rcel\xa64ring:efer,nfer\xa64ting:rmit,mmit,ysit,dmit,emit,bmit,tfit,gret\xa64ling:evel,xcel,ivel\xa64ding:hred\xa65ing:arget,posit,rofit\xa65ring:nsfer\xa65ting:nsmit,orget,cquit\xa65ling:ancel,istil",
        "ex": "3:adding,eating,aiming,aiding,airing,outing,gassing,setting,getting,putting,cutting,winning,sitting,betting,mapping,tapping,letting,bidding,hitting,tanning,netting,popping,fitting,capping,lapping,barring,banning,vetting,topping,rotting,tipping,potting,wetting,pitting,dipping,budding,hemming,pinning,jetting,kidding,padding,podding,sipping,wedding,bedding,donning,warring,penning,gutting,cueing,wadding,petting,ripping,napping,matting,tinning,binning,dimming,hopping,mopping,nodding,panning,rapping,ridding,sinning\xa64:selling,falling,calling,waiting,editing,telling,rolling,heating,boating,hanging,beating,coating,singing,tolling,felling,polling,discing,seating,voiding,gelling,yelling,baiting,reining,ruining,seeking,spanning,stepping,knitting,emitting,slipping,quitting,dialing,omitting,clipping,shutting,skinning,abutting,flipping,trotting,cramming,fretting,suiting\xa65:bringing,treating,spelling,stalling,trolling,expelling,rivaling,wringing,deterring,singeing,befitting,refitting\xa66:enrolling,distilling,scrolling,strolling,caucusing,travelling\xa67:installing,redefining,stencilling,recharging,overeating,benefiting,unraveling,programing\xa69:reprogramming\xa6is:being\xa62e:using,aging,owing\xa63e:making,taking,coming,noting,hiring,filing,coding,citing,doping,baking,coping,hoping,lading,caring,naming,voting,riding,mining,curing,lining,ruling,typing,boring,dining,firing,hiding,piling,taping,waning,baling,boning,faring,honing,wiping,luring,timing,wading,piping,fading,biting,zoning,daring,waking,gaming,raking,ceding,tiring,coking,wining,joking,paring,gaping,poking,pining,coring,liming,toting,roping,wiring,aching\xa64e:writing,storing,eroding,framing,smoking,tasting,wasting,phoning,shaking,abiding,braking,flaking,pasting,priming,shoring,sloping,withing,hinging\xa65e:defining,refining,renaming,swathing,fringing,reciting\xa61ie:dying,tying,lying,vying\xa67e:sunbathing"
    },
    "Participle": {
        "fwd": "1:mt\xa62:llen\xa63:iven,aken\xa6:ne\xa6y:in",
        "both": "1:wn\xa62:me,aten\xa63:seen,bidden,isen\xa64:roven,asten\xa63l:pilt\xa63d:uilt\xa62e:itten\xa61im:wum\xa61eak:poken\xa61ine:hone\xa61ose:osen\xa61in:gun\xa61ake:woken\xa6ear:orn\xa6eal:olen\xa6eeze:ozen\xa6et:otten\xa6ink:unk\xa6ing:ung",
        "rev": "2:un\xa6oken:eak\xa6ought:eek\xa6oven:eave\xa61ne:o\xa61own:ly\xa61den:de\xa61in:ay\xa62t:am\xa62n:ee\xa63en:all\xa64n:rive,sake,take\xa65n:rgive",
        "ex": "2:been\xa63:seen,run\xa64:given,taken\xa65:shaken\xa62eak:broken\xa61ive:dove\xa62y:flown\xa63e:hidden,ridden\xa61eek:sought\xa61ake:woken\xa61eave:woven"
    },
    "PastTense": {
        "fwd": "1:tted,wed,gged,nned,een,rred,pped,yed,bbed,oed,dded,rd,wn,mmed\xa62:eed,nded,et,hted,st,oled,ut,emed,eled,lded,ken,rt,nked,apt,ant,eped,eked\xa63:eared,eat,eaded,nelled,ealt,eeded,ooted,eaked,eaned,eeted,mited,bid,uit,ead,uited,ealed,geted,velled,ialed,belled\xa64:ebuted,hined,comed\xa6y:ied\xa6ome:ame\xa6ear:ore\xa6ind:ound\xa6ing:ung,ang\xa6ep:pt\xa6ink:ank,unk\xa6ig:ug\xa6all:ell\xa6ee:aw\xa6ive:ave\xa6eeze:oze\xa6old:eld\xa6ave:ft\xa6ake:ook\xa6ell:old\xa6ite:ote\xa6ide:ode\xa6ine:one\xa6in:un,on\xa6eal:ole\xa6im:am\xa6ie:ay\xa6and:ood\xa61ise:rose\xa61eak:roke\xa61ing:rought\xa61ive:rove\xa61el:elt\xa61id:bade\xa61et:got\xa61y:aid\xa61it:sat\xa63e:lid\xa63d:pent",
        "both": "1:aed,fed,xed,hed\xa62:sged,xted,wled,rped,lked,kied,lmed,lped,uped,bted,rbed,rked,wned,rled,mped,fted,mned,mbed,zzed,omed,ened,cked,gned,lted,sked,ued,zed,nted,ered,rted,rmed,ced,sted,rned,ssed,rded,pted,ved,cted\xa63:cled,eined,siped,ooned,uked,ymed,jored,ouded,ioted,oaned,lged,asped,iged,mured,oided,eiled,yped,taled,moned,yled,lit,kled,oaked,gled,naled,fled,uined,oared,valled,koned,soned,aided,obed,ibed,meted,nicked,rored,micked,keted,vred,ooped,oaded,rited,aired,auled,filled,ouled,ooded,ceted,tolled,oited,bited,aped,tled,vored,dled,eamed,nsed,rsed,sited,owded,pled,sored,rged,osed,pelled,oured,psed,oated,loned,aimed,illed,eured,tred,ioned,celled,bled,wsed,ooked,oiled,itzed,iked,iased,onged,ased,ailed,uned,umed,ained,auded,nulled,ysed,eged,ised,aged,oined,ated,used,dged,doned\xa64:ntied,efited,uaked,caded,fired,roped,halled,roked,himed,culed,tared,lared,tuted,uared,routed,pited,naked,miled,houted,helled,hared,cored,caled,tired,peated,futed,ciled,called,tined,moted,filed,sided,poned,iloted,honed,lleted,huted,ruled,cured,named,preted,vaded,sured,talled,haled,peded,gined,nited,uided,ramed,feited,laked,gured,ctored,unged,pired,cuted,voked,eloped,ralled,rined,coded,icited,vided,uaded,voted,mined,sired,noted,lined,nselled,luted,jured,fided,puted,piled,pared,olored,cided,hoked,enged,tured,geoned,cotted,lamed,uiled,waited,udited,anged,luded,mired,uired,raded\xa65:modelled,izzled,eleted,umpeted,ailored,rseded,treated,eduled,ecited,rammed,eceded,atrolled,nitored,basted,twined,itialled,ncited,gnored,ploded,xcited,nrolled,namelled,plored,efeated,redited,ntrolled,nfined,pleted,llided,lcined,eathed,ibuted,lloted,dhered,cceded\xa63ad:sled\xa62aw:drew\xa62ot:hot\xa62ke:made\xa62ow:hrew,grew\xa62ose:hose\xa62d:ilt\xa62in:egan\xa61un:ran\xa61ink:hought\xa61ick:tuck\xa61ike:ruck\xa61eak:poke,nuck\xa61it:pat\xa61o:did\xa61ow:new\xa61ake:woke\xa6go:went",
        "rev": "3:rst,hed,hut,cut,set\xa64:tbid\xa65:dcast,eread,pread,erbid\xa6ought:uy,eek\xa61ied:ny,ly,dy,ry,fy,py,vy,by,ty,cy\xa61ung:ling,ting,wing\xa61pt:eep\xa61ank:rink\xa61ore:bear,wear\xa61ave:give\xa61oze:reeze\xa61ound:rind,wind\xa61ook:take,hake\xa61aw:see\xa61old:sell\xa61ote:rite\xa61ole:teal\xa61unk:tink\xa61am:wim\xa61ay:lie\xa61ood:tand\xa61eld:hold\xa62d:he,ge,re,le,leed,ne,reed,be,ye,lee,pe,we\xa62ed:dd,oy,or,ey,gg,rr,us,ew,to\xa62ame:ecome,rcome\xa62ped:ap\xa62ged:ag,og,ug,eg\xa62bed:ub,ab,ib,ob\xa62lt:neel\xa62id:pay\xa62ang:pring\xa62ove:trive\xa62med:um\xa62ode:rride\xa62at:ysit\xa63ted:mit,hat,mat,lat,pot,rot,bat\xa63ed:low,end,tow,und,ond,eem,lay,cho,dow,xit,eld,ald,uld,law,lel,eat,oll,ray,ank,fin,oam,out,how,iek,tay,haw,ait,vet,say,cay,bow\xa63d:ste,ede,ode,ete,ree,ude,ame,oke,ote,ime,ute,ade\xa63red:lur,cur,pur,car\xa63ped:hop,rop,uip,rip,lip,tep,top\xa63ded:bed,rod,kid\xa63ade:orbid\xa63led:uel\xa63ned:lan,can,kin,pan,tun\xa63med:rim,lim\xa64ted:quit,llot\xa64ed:pear,rrow,rand,lean,mand,anel,pand,reet,link,abel,evel,imit,ceed,ruit,mind,peal,veal,hool,head,pell,well,mell,uell,band,hear,weak\xa64led:nnel,qual,ebel,ivel\xa64red:nfer,efer,sfer\xa64n:sake,trew\xa64d:ntee\xa64ded:hred\xa64ned:rpin\xa65ed:light,nceal,right,ndear,arget,hread,eight,rtial,eboot\xa65d:edite,nvite\xa65ted:egret\xa65led:ravel",
        "ex": "2:been,upped\xa63:added,aged,aided,aimed,aired,bid,died,dyed,egged,erred,eyed,fit,gassed,hit,lied,owed,pent,pied,tied,used,vied,oiled,outed,banned,barred,bet,canned,cut,dipped,donned,ended,feed,inked,jarred,let,manned,mowed,netted,padded,panned,pitted,popped,potted,put,set,sewn,sowed,tanned,tipped,topped,vowed,weed,bowed,jammed,binned,dimmed,hopped,mopped,nodded,pinned,rigged,sinned,towed,vetted\xa64:ached,baked,baled,boned,bored,called,caned,cared,ceded,cited,coded,cored,cubed,cured,dared,dined,edited,exited,faked,fared,filed,fined,fired,fuelled,gamed,gelled,hired,hoped,joked,lined,mined,named,noted,piled,poked,polled,pored,pulled,reaped,roamed,rolled,ruled,seated,shed,sided,timed,tolled,toned,voted,waited,walled,waned,winged,wiped,wired,zoned,yelled,tamed,lubed,roped,faded,mired,caked,honed,banged,culled,heated,raked,welled,banded,beat,cast,cooled,cost,dealt,feared,folded,footed,handed,headed,heard,hurt,knitted,landed,leaked,leapt,linked,meant,minded,molded,neared,needed,peaked,plodded,plotted,pooled,quit,read,rooted,sealed,seeded,seeped,shipped,shunned,skimmed,slammed,sparred,stemmed,stirred,suited,thinned,twinned,swayed,winked,dialed,abutted,blotted,fretted,healed,heeded,peeled,reeled\xa65:basted,cheated,equalled,eroded,exiled,focused,opined,pleated,primed,quoted,scouted,shored,sloped,smoked,sniped,spelled,spouted,routed,staked,stored,swelled,tasted,treated,wasted,smelled,dwelled,honored,prided,quelled,eloped,scared,coveted,sweated,breaded,cleared,debuted,deterred,freaked,modeled,pleaded,rebutted,speeded\xa66:anchored,defined,endured,impaled,invited,refined,revered,strolled,cringed,recast,thrust,unfolded\xa67:authored,combined,competed,conceded,convened,excreted,extruded,redefined,restored,secreted,rescinded,welcomed\xa68:expedited,infringed\xa69:interfered,intervened,persevered\xa610:contravened\xa6eat:ate\xa6is:was\xa6go:went\xa6are:were\xa63d:bent,lent,rent,sent\xa63e:bit,fled,hid,lost\xa63ed:bled,bred\xa62ow:blew,grew\xa61uy:bought\xa62tch:caught\xa61o:did\xa61ive:dove,gave\xa62aw:drew\xa62ed:fed\xa62y:flew,laid,paid,said\xa61ight:fought\xa61et:got\xa62ve:had\xa61ang:hung\xa62ad:led\xa62ght:lit\xa62ke:made\xa62et:met\xa61un:ran\xa61ise:rose\xa61it:sat\xa61eek:sought\xa61each:taught\xa61ake:woke,took\xa61eave:wove\xa62ise:arose\xa61ear:bore,tore,wore\xa61ind:bound,found,wound\xa62eak:broke\xa62ing:brought,wrung\xa61ome:came\xa62ive:drove\xa61ig:dug\xa61all:fell\xa62el:felt\xa64et:forgot\xa61old:held\xa62ave:left\xa61ing:rang,sang\xa61ide:rode\xa61ink:sank\xa61ee:saw\xa62ine:shone\xa64e:slid\xa61ell:sold,told\xa64d:spent\xa62in:spun\xa61in:won"
    },
    "PresentTense": {
        "fwd": "1:oes\xa61ve:as",
        "both": "1:xes\xa62:zzes,ches,shes,sses\xa63:iases\xa62y:llies,plies\xa61y:cies,bies,ties,vies,nies,pies,dies,ries,fies\xa6:s",
        "rev": "1ies:ly\xa62es:us,go,do\xa63es:cho,eto",
        "ex": "2:does,goes\xa63:gasses\xa65:focuses\xa6is:are\xa63y:relies\xa62y:flies\xa62ve:has"
    },
    "Superlative": {
        "fwd": "1st:e\xa61est:l,m,f,s\xa61iest:cey\xa62est:or,ir\xa63est:ver",
        "both": "4:east\xa65:hwest\xa65lest:erful\xa64est:weet,lgar,tter,oung\xa64most:uter\xa63est:ger,der,rey,iet,ong,ear\xa63test:lat\xa63most:ner\xa62est:pt,ft,nt,ct,rt,ht\xa62test:it\xa62gest:ig\xa61est:b,k,n,p,h,d,w\xa6iest:y",
        "rev": "1:ttest,nnest,yest\xa62:sest,stest,rmest,cest,vest,lmest,olest,ilest,ulest,ssest,imest,uest\xa63:rgest,eatest,oorest,plest,allest,urest,iefest,uelest,blest,ugest,amest,yalest,ealest,illest,tlest,itest\xa64:cerest,eriest,somest,rmalest,ndomest,motest,uarest,tiffest\xa65:leverest,rangest\xa6ar:urthest\xa63ey:riciest",
        "ex": "best:good\xa6worst:bad\xa65est:great\xa64est:fast,full,fair,dull\xa63test:hot,wet,fat\xa64nest:thin\xa61urthest:far\xa63est:gay,shy,ill\xa64test:neat\xa64st:late,wide,fine,safe,cute,fake,pale,rare,rude,sore,ripe,dire\xa66st:severe"
    },
    "AdjToNoun": {
        "fwd": "1:tistic,eable,lful,sful,ting,tty\xa62:onate,rtable,geous,ced,seful,ctful\xa63:ortive,ented\xa6arity:ear\xa6y:etic\xa6fulness:begone\xa61ity:re\xa61y:tiful,gic\xa62ity:ile,imous,ilous,ime\xa62ion:ated\xa62eness:iving\xa62y:trious\xa62ation:iring\xa62tion:vant\xa63ion:ect\xa63ce:mant,mantic\xa63tion:irable\xa63y:est,estic\xa63m:mistic,listic\xa63ess:ning\xa64n:utious\xa64on:rative,native,vative,ective\xa64ce:erant",
        "both": "1:king,wing\xa62:alous,ltuous,oyful,rdous\xa63:gorous,ectable,werful,amatic\xa64:oised,usical,agical,raceful,ocused,lined,ightful\xa65ness:stful,lding,itous,nuous,ulous,otous,nable,gious,ayful,rvous,ntous,lsive,peful,entle,ciful,osive,leful,isive,ncise,reful,mious\xa65ty:ivacious\xa65ties:ubtle\xa65ce:ilient,adiant,atient\xa65cy:icient\xa65sm:gmatic\xa65on:sessive,dictive\xa65ity:pular,sonal,eative,entic\xa65sity:uminous\xa65ism:conic\xa65nce:mperate\xa65ility:mitable\xa65ment:xcited\xa65n:bitious\xa64cy:brant,etent,curate\xa64ility:erable,acable,icable,ptable\xa64ty:nacious,aive,oyal,dacious\xa64n:icious\xa64ce:vient,erent,stent,ndent,dient,quent,ident\xa64ness:adic,ound,hing,pant,sant,oing,oist,tute\xa64icity:imple\xa64ment:fined,mused\xa64ism:otic\xa64ry:dantic\xa64ity:tund,eral\xa64edness:hand\xa64on:uitive\xa64lity:pitable\xa64sm:eroic,namic\xa64sity:nerous\xa63th:arm\xa63ility:pable,bable,dable,iable\xa63cy:hant,nant,icate\xa63ness:red,hin,nse,ict,iet,ite,oud,ind,ied,rce\xa63ion:lute\xa63ity:ual,gal,volous,ial\xa63ce:sent,fensive,lant,gant,gent,lent,dant\xa63on:asive\xa63m:fist,sistic,iastic\xa63y:terious,xurious,ronic,tastic\xa63ur:amorous\xa63e:tunate\xa63ation:mined\xa63sy:rteous\xa63ty:ain\xa63ry:ave\xa63ment:azed\xa62ness:de,on,ue,rn,ur,ft,rp,pe,om,ge,rd,od,ay,ss,er,ll,oy,ap,ht,ld,ad,rt\xa62inousness:umous\xa62ity:neous,ene,id,ane\xa62cy:bate,late\xa62ation:ized\xa62ility:oble,ible\xa62y:odic\xa62e:oving,aring\xa62s:ost\xa62itude:pt\xa62dom:ee\xa62ance:uring\xa62tion:reet\xa62ion:oted\xa62sion:ending\xa62liness:an\xa62or:rdent\xa61th:ung\xa61e:uable\xa61ness:w,h,k,f\xa61ility:mble\xa61or:vent\xa61ement:ging\xa61tiquity:ncient\xa61ment:hed\xa6verty:or\xa6ength:ong\xa6eat:ot\xa6pth:ep\xa6iness:y",
        "rev": "",
        "ex": "5:forceful,humorous\xa68:charismatic\xa613:understanding\xa65ity:active\xa611ness:adventurous,inquisitive,resourceful\xa68on:aggressive,automatic,perceptive\xa67ness:amorous,fatuous,furtive,ominous,serious\xa65ness:ample,sweet\xa612ness:apprehensive,cantankerous,contemptuous,ostentatious\xa613ness:argumentative,conscientious\xa69ness:assertive,facetious,imperious,inventive,oblivious,rapacious,receptive,seditious,whimsical\xa610ness:attractive,expressive,impressive,loquacious,salubrious,thoughtful\xa63edom:boring\xa64ness:calm,fast,keen,tame\xa68ness:cheerful,gracious,specious,spurious,timorous,unctuous\xa65sity:curious\xa69ion:deliberate\xa68ion:desperate\xa66e:expensive\xa67ce:fragrant\xa63y:furious\xa69ility:ineluctable\xa66ism:mystical\xa68ity:physical,proactive,sensitive,vertical\xa65cy:pliant\xa67ity:positive\xa69ity:practical\xa612ism:professional\xa66ce:prudent\xa63ness:red\xa66cy:vagrant\xa63dom:wise"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"21rKx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// import again from './again/index.js'
parcelHelpers.export(exports, "learn", ()=>(0, _indexJsDefault3.default));
parcelHelpers.export(exports, "convert", ()=>(0, _indexJsDefault.default));
parcelHelpers.export(exports, "compress", ()=>(0, _packJsDefault.default));
parcelHelpers.export(exports, "uncompress", ()=>(0, _unpackJsDefault.default));
parcelHelpers.export(exports, "reverse", ()=>(0, _indexJsDefault1.default));
parcelHelpers.export(exports, "validate", ()=>(0, _indexJsDefault2.default));
parcelHelpers.export(exports, "test", ()=>(0, _indexJsDefault4.default));
var _indexJs = require("./convert/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
// import compress from './compress/index.js'
// import uncompress from './compress/uncompress.js'
var _indexJs1 = require("./reverse/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
// import test from './test/index.js'
// import old from './learn/index.js'
var _indexJs2 = require("./validate/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
// import classify from './classify/index.js'
// import fingerprint from './fingerprint/index.js'
var _indexJs3 = require("./learn/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var _packJs = require("./compress/pack.js");
var _packJsDefault = parcelHelpers.interopDefault(_packJs);
var _unpackJs = require("./compress/unpack.js");
var _unpackJsDefault = parcelHelpers.interopDefault(_unpackJs);
var _indexJs4 = require("./test/index.js");
var _indexJsDefault4 = parcelHelpers.interopDefault(_indexJs4);

},{"./convert/index.js":"9nc63","./reverse/index.js":"lES97","./validate/index.js":false,"./learn/index.js":false,"./compress/pack.js":false,"./compress/unpack.js":"1DfPZ","./test/index.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9nc63":[function(require,module,exports) {
// 01- full-word exceptions
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const checkEx = function(str, ex = {}) {
    if (ex.hasOwnProperty(str)) return ex[str];
    return null;
};
// 02- suffixes that pass our word through
const checkSame = function(str, same = []) {
    for(let i = 0; i < same.length; i += 1){
        if (str.endsWith(same[i])) return str;
    }
    return null;
};
// 03- check rules - longest first
const checkRules = function(str, fwd, both = {}) {
    fwd = fwd || {};
    let max = str.length - 1;
    // look for a matching suffix
    for(let i = max; i >= 1; i -= 1){
        let size = str.length - i;
        let suff = str.substring(size, str.length);
        // check fwd rules, first
        if (fwd.hasOwnProperty(suff) === true) return str.slice(0, size) + fwd[suff];
        // check shared rules
        if (both.hasOwnProperty(suff) === true) return str.slice(0, size) + both[suff];
    }
    // try a fallback transform
    if (fwd.hasOwnProperty("")) return str += fwd[""];
    if (both.hasOwnProperty("")) return str += both[""];
    return null;
};
//sweep-through all suffixes
const convert = function(str = "", model = {}) {
    // 01- check exceptions
    let out = checkEx(str, model.ex);
    // 02 - check same
    out = out || checkSame(str, model.same);
    // check forward and both rules
    out = out || checkRules(str, model.fwd, model.both);
    //return unchanged
    out = out || str;
    return out;
};
exports.default = convert;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lES97":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const flipObj = function(obj) {
    return Object.entries(obj).reduce((h, a)=>{
        h[a[1]] = a[0];
        return h;
    }, {});
};
const reverse = function(model = {}) {
    return {
        reversed: true,
        // keep these two
        both: flipObj(model.both),
        ex: flipObj(model.ex),
        // swap this one in
        fwd: model.rev || {}
    };
};
exports.default = reverse;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1DfPZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const prefix = /^([0-9]+)/;
const toObject = function(txt) {
    let obj = {};
    txt.split("\xa6").forEach((str)=>{
        let [key, vals] = str.split(":");
        vals = (vals || "").split(",");
        vals.forEach((val)=>{
            obj[val] = key;
        });
    });
    return obj;
};
const growObject = function(key = "", val = "") {
    val = String(val);
    let m = val.match(prefix);
    if (m === null) return val;
    let num = Number(m[1]) || 0;
    let pre = key.substring(0, num);
    let full = pre + val.replace(prefix, "");
    return full;
};
const unpackOne = function(str) {
    let obj = toObject(str);
    return Object.keys(obj).reduce((h, k)=>{
        h[k] = growObject(k, obj[k]);
        return h;
    }, {});
};
const uncompress = function(model = {}) {
    if (typeof model === "string") model = JSON.parse(model);
    model.fwd = unpackOne(model.fwd || "");
    model.both = unpackOne(model.both || "");
    model.rev = unpackOne(model.rev || "");
    model.ex = unpackOne(model.ex || "");
    return model;
};
exports.default = uncompress;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g2VUh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    //web tags
    [
        /^[\w.]+@[\w.]+\.[a-z]{2,3}$/,
        "Email"
    ],
    [
        /^(https?:\/\/|www\.)+\w+\.[a-z]{2,3}/,
        "Url",
        "http.."
    ],
    [
        /^[a-z0-9./].+\.(com|net|gov|org|ly|edu|info|biz|dev|ru|jp|de|in|uk|br|io|ai)/,
        "Url",
        ".com"
    ],
    // timezones
    [
        /^[PMCE]ST$/,
        "Timezone",
        "EST"
    ],
    //names
    [
        /^ma?c'[a-z]{3}/,
        "LastName",
        "mc'neil"
    ],
    [
        /^o'[a-z]{3}/,
        "LastName",
        "o'connor"
    ],
    [
        /^ma?cd[aeiou][a-z]{3}/,
        "LastName",
        "mcdonald"
    ],
    //slang things
    [
        /^(lol)+[sz]$/,
        "Expression",
        "lol"
    ],
    [
        /^wo{2,}a*h?$/,
        "Expression",
        "wooah"
    ],
    [
        /^(hee?){2,}h?$/,
        "Expression",
        "hehe"
    ],
    [
        /^(un|de|re)\\-[a-z\u00C0-\u00FF]{2}/,
        "Verb",
        "un-vite"
    ],
    // m/h
    [
        /^(m|k|cm|km)\/(s|h|hr)$/,
        "Unit",
        "5 k/m"
    ],
    // μg/g
    [
        /^(ug|ng|mg)\/(l|m3|ft3)$/,
        "Unit",
        "ug/L"
    ]
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dA6kH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // #coolguy
    [
        /^#[\p{Number}_]*\p{Letter}/u,
        "HashTag"
    ],
    // @spencermountain
    [
        /^@\w{2,}$/,
        "AtMention"
    ],
    // period-ones acronyms - f.b.i.
    [
        /^([A-Z]\.){2}[A-Z]?/i,
        [
            "Acronym",
            "Noun"
        ],
        "F.B.I"
    ],
    // ending-apostrophes
    [
        /.{3}[lkmnp]in['‘’‛‵′`´]$/,
        "Gerund",
        "chillin'"
    ],
    [
        /.{4}s['‘’‛‵′`´]$/,
        "Possessive",
        "flanders'"
    ],
    //from https://www.regextester.com/106421
    // [/^([\u00a9\u00ae\u2319-\u3300]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff])/, 'Emoji', 'emoji-range']
    // unicode character range
    [
        /^[\p{Emoji_Presentation}\p{Extended_Pictographic}]/u,
        "Emoji",
        "emoji-class"
    ]
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5N04K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    [
        /^@1?[0-9](am|pm)$/i,
        "Time",
        "3pm"
    ],
    [
        /^@1?[0-9]:[0-9]{2}(am|pm)?$/i,
        "Time",
        "3:30pm"
    ],
    [
        /^'[0-9]{2}$/,
        "Year"
    ],
    // times
    [
        /^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])$/,
        "Time",
        "3:12:31"
    ],
    [
        /^[012]?[0-9](:[0-5][0-9])?(:[0-5][0-9])? ?(am|pm)$/i,
        "Time",
        "1:12pm"
    ],
    [
        /^[012]?[0-9](:[0-5][0-9])(:[0-5][0-9])? ?(am|pm)?$/i,
        "Time",
        "1:12:31pm"
    ],
    // iso-dates
    [
        /^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}/i,
        "Date",
        "iso-date"
    ],
    [
        /^[0-9]{1,4}-[0-9]{1,2}-[0-9]{1,4}$/,
        "Date",
        "iso-dash"
    ],
    [
        /^[0-9]{1,4}\/[0-9]{1,2}\/([0-9]{4}|[0-9]{2})$/,
        "Date",
        "iso-slash"
    ],
    [
        /^[0-9]{1,4}\.[0-9]{1,2}\.[0-9]{1,4}$/,
        "Date",
        "iso-dot"
    ],
    [
        /^[0-9]{1,4}-[a-z]{2,9}-[0-9]{1,4}$/i,
        "Date",
        "12-dec-2019"
    ],
    // timezones
    [
        /^utc ?[+-]?[0-9]+$/,
        "Timezone",
        "utc-9"
    ],
    [
        /^(gmt|utc)[+-][0-9]{1,2}$/i,
        "Timezone",
        "gmt-3"
    ],
    //phone numbers
    [
        /^[0-9]{3}-[0-9]{4}$/,
        "PhoneNumber",
        "421-0029"
    ],
    [
        /^(\+?[0-9][ -])?[0-9]{3}[ -]?[0-9]{3}-[0-9]{4}$/,
        "PhoneNumber",
        "1-800-"
    ],
    //money
    //like $5.30
    [
        /^[-+]?\p{Currency_Symbol}[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?([kmb]|bn)?\+?$/u,
        [
            "Money",
            "Value"
        ],
        "$5.30"
    ],
    //like 5.30$
    [
        /^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?\p{Currency_Symbol}\+?$/u,
        [
            "Money",
            "Value"
        ],
        "5.30\xa3"
    ],
    //like
    [
        /^[-+]?[$£]?[0-9]([0-9,.])+(usd|eur|jpy|gbp|cad|aud|chf|cny|hkd|nzd|kr|rub)$/i,
        [
            "Money",
            "Value"
        ],
        "$400usd"
    ],
    //numbers
    // 50 | -50 | 3.23  | 5,999.0  | 10+
    [
        /^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?\+?$/,
        [
            "Cardinal",
            "NumericValue"
        ],
        "5,999"
    ],
    [
        /^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?(st|nd|rd|r?th)$/,
        [
            "Ordinal",
            "NumericValue"
        ],
        "53rd"
    ],
    // .73th
    [
        /^\.[0-9]+\+?$/,
        [
            "Cardinal",
            "NumericValue"
        ],
        ".73th"
    ],
    //percent
    [
        /^[-+]?[0-9]+(,[0-9]{3})*(\.[0-9]+)?%\+?$/,
        [
            "Percent",
            "Cardinal",
            "NumericValue"
        ],
        "-4%"
    ],
    [
        /^\.[0-9]+%$/,
        [
            "Percent",
            "Cardinal",
            "NumericValue"
        ],
        ".3%"
    ],
    //fraction
    [
        /^[0-9]{1,4}\/[0-9]{1,4}(st|nd|rd|th)?s?$/,
        [
            "Fraction",
            "NumericValue"
        ],
        "2/3rds"
    ],
    //range
    [
        /^[0-9.]{1,3}[a-z]{0,2}[-–—][0-9]{1,3}[a-z]{0,2}$/,
        [
            "Value",
            "NumberRange"
        ],
        "3-4"
    ],
    //time-range
    [
        /^[0-9]{1,2}(:[0-9][0-9])?(am|pm)? ?[-–—] ?[0-9]{1,2}(:[0-9][0-9])?(am|pm)$/,
        [
            "Time",
            "NumberRange"
        ],
        "3-4pm"
    ],
    //number with unit
    [
        /^[0-9.]+([a-z°]{1,4})$/,
        "NumericValue",
        "9km"
    ]
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6TrGN":[function(require,module,exports) {
//nouns that also signal the title of an unknown organization
//todo remove/normalize plural forms
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    "academy",
    "administration",
    "agence",
    "agences",
    "agencies",
    "agency",
    "airlines",
    "airways",
    "army",
    "assoc",
    "associates",
    "association",
    "assurance",
    "authority",
    "autorite",
    "aviation",
    "bank",
    "banque",
    "board",
    "boys",
    "brands",
    "brewery",
    "brotherhood",
    "brothers",
    "bureau",
    "cafe",
    "co",
    "caisse",
    "capital",
    "care",
    "cathedral",
    "center",
    "centre",
    "chemicals",
    "choir",
    "chronicle",
    "church",
    "circus",
    "clinic",
    "clinique",
    "club",
    "co",
    "coalition",
    "coffee",
    "collective",
    "college",
    "commission",
    "committee",
    "communications",
    "community",
    "company",
    "comprehensive",
    "computers",
    "confederation",
    "conference",
    "conseil",
    "consulting",
    "containers",
    "corporation",
    "corps",
    "corp",
    "council",
    "crew",
    "data",
    "departement",
    "department",
    "departments",
    "design",
    "development",
    "directorate",
    "division",
    "drilling",
    "education",
    "eglise",
    "electric",
    "electricity",
    "energy",
    "ensemble",
    "enterprise",
    "enterprises",
    "entertainment",
    "estate",
    "etat",
    "faculty",
    "faction",
    "federation",
    "financial",
    "fm",
    "foundation",
    "fund",
    "gas",
    "gazette",
    "girls",
    "government",
    "group",
    "guild",
    "herald",
    "holdings",
    "hospital",
    "hotel",
    "hotels",
    "inc",
    "industries",
    "institut",
    "institute",
    "institutes",
    "insurance",
    "international",
    "interstate",
    "investment",
    "investments",
    "investors",
    "journal",
    "laboratory",
    "labs",
    "llc",
    "ltd",
    "limited",
    "machines",
    "magazine",
    "management",
    "marine",
    "marketing",
    "markets",
    "media",
    "memorial",
    "ministere",
    "ministry",
    "military",
    "mobile",
    "motor",
    "motors",
    "musee",
    "museum",
    "news",
    "observatory",
    "office",
    "oil",
    "optical",
    "orchestra",
    "organization",
    "partners",
    "partnership",
    "petrol",
    "petroleum",
    "pharmacare",
    "pharmaceutical",
    "pharmaceuticals",
    "pizza",
    "plc",
    "police",
    "politburo",
    "polytechnic",
    "post",
    "power",
    "press",
    "productions",
    "quartet",
    "radio",
    "reserve",
    "resources",
    "restaurant",
    "restaurants",
    "savings",
    "school",
    "securities",
    "service",
    "services",
    "societe",
    "subsidiary",
    "society",
    "sons",
    // 'standard',
    "subcommittee",
    "syndicat",
    "systems",
    "telecommunications",
    "telegraph",
    "television",
    "times",
    "tribunal",
    "tv",
    "union",
    "university",
    "utilities",
    "workers"
].reduce((h, str)=>{
    h[str] = true;
    return h;
}, {});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bcpgj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // geology
    "atoll",
    "basin",
    "bay",
    "beach",
    "bluff",
    "bog",
    "camp",
    "canyon",
    "canyons",
    "cape",
    "cave",
    "caves",
    // 'cliff',
    "cliffs",
    "coast",
    "cove",
    "coves",
    "crater",
    "creek",
    "desert",
    "dune",
    "dunes",
    "escarpment",
    "estuary",
    "falls",
    "fjord",
    "fjords",
    "forest",
    "forests",
    "glacier",
    "gorge",
    "gorges",
    "gulf",
    "gully",
    "highland",
    "hill",
    "hills",
    "inlet",
    "island",
    "islands",
    "isthmus",
    "knoll",
    "lagoon",
    "lake",
    "marsh",
    "marshes",
    "mount",
    "mountain",
    "mountains",
    "narrows",
    "peninsula",
    "plains",
    "plateau",
    "pond",
    "rapids",
    "ravine",
    "reef",
    "reefs",
    "ridge",
    // 'river delta',
    "river",
    "rivers",
    "sandhill",
    "shoal",
    "shore",
    "shoreline",
    "shores",
    "strait",
    "straits",
    "stream",
    "swamp",
    "tombolo",
    "trail",
    "trails",
    "trench",
    "valley",
    "vallies",
    "volcano",
    "waterfall",
    "watershed",
    "wetland",
    "woods",
    // districts
    "burough",
    "county",
    "district",
    "municipality",
    "prefecture",
    "province",
    "region",
    "reservation",
    "state",
    "territory",
    "borough",
    "metropolis",
    "downtown",
    "uptown",
    "midtown",
    "city",
    "town",
    "township",
    "hamlet",
    "country",
    "kingdom",
    "enclave",
    "neighbourhood",
    "neighborhood",
    "kingdom",
    "ward",
    "zone",
    // 'range',
    //building/ complex
    "airport",
    "amphitheater",
    "arch",
    "arena",
    "auditorium",
    "bar",
    "barn",
    "basilica",
    "battlefield",
    "bridge",
    "building",
    "castle",
    "centre",
    "coliseum",
    "cineplex",
    "complex",
    "dam",
    "farm",
    "field",
    "fort",
    "garden",
    "gardens",
    // 'grounds',
    "gymnasium",
    "hall",
    "house",
    "levee",
    "library",
    "memorial",
    "monument",
    "museum",
    "gallery",
    "palace",
    "pillar",
    "pits",
    // 'pit',
    // 'place',
    // 'point',
    // 'room',
    "plantation",
    "playhouse",
    "quarry",
    // 'ruins',
    "sportsfield",
    "sportsplex",
    "stadium",
    // 'statue',
    "terrace",
    "terraces",
    "theater",
    "tower",
    "park",
    "parks",
    "site",
    "raceway",
    "sportsplex",
    // 'sports centre',
    // 'sports field',
    // 'soccer complex',
    // 'soccer centre',
    // 'sports complex',
    // 'civic centre',
    // roads
    "st",
    "street",
    "rd",
    "road",
    "crescent",
    "cr",
    "way",
    "tr",
    "terrace",
    "avenue",
    "ave"
].reduce((h, str)=>{
    h[str] = true;
    return h;
}, {});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4zXBH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../../methods/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _irregularsJs = require("./irregulars.js");
var _irregularsJsDefault = parcelHelpers.interopDefault(_irregularsJs);
var _indexJs1 = require("../../methods/transform/nouns/toPlural/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("../../methods/transform/verbs/conjugate/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _inflectJs = require("../../methods/transform/adjectives/inflect.js");
var _indexJs3 = require("../../methods/transform/verbs/toInfinitive/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var _indexJs4 = require("../models/index.js");
var _indexJsDefault4 = parcelHelpers.interopDefault(_indexJs4);
let tmpModel = {
    one: {
        lexicon: {}
    },
    two: {
        models: (0, _indexJsDefault4.default)
    }
};
// defaults for switches
const switchDefaults = {
    // 'pilot'
    "Actor|Verb": "Actor",
    // 'amusing'
    "Adj|Gerund": "Adjective",
    // 'standard'
    "Adj|Noun": "Adjective",
    // 'boiled'
    "Adj|Past": "Adjective",
    // 'smooth'
    "Adj|Present": "Adjective",
    // 'box'
    "Noun|Verb": "Singular",
    //'singing'
    "Noun|Gerund": "Gerund",
    // 'hope'
    "Person|Noun": "Noun",
    // 'April'
    "Person|Date": "Month",
    // 'rob'
    "Person|Verb": "FirstName",
    // 'victoria'
    "Person|Place": "Person",
    // 'rusty'
    "Person|Adj": "Comparative",
    // 'boxes'
    "Plural|Verb": "Plural",
    // 'miles'
    "Unit|Noun": "Noun"
};
const expandLexicon = function(words, model) {
    // do clever tricks to grow the words
    const world = {
        model,
        methods: (0, _indexJsDefault.default)
    };
    let { lex, _multi } = (0, _indexJsDefault.default).two.expandLexicon(words, world);
    // store multiple-word terms in a cache
    Object.assign(model.one.lexicon, lex);
    Object.assign(model.one._multiCache, _multi);
    return model;
};
// these words have no singular/plural conjugation
const addUncountables = function(words, model) {
    Object.keys(words).forEach((k)=>{
        if (words[k] === "Uncountable") {
            model.two.uncountable[k] = true;
            words[k] = "Uncountable";
        }
    });
    return model;
};
const expandVerb = function(str, words, doPresent) {
    let obj = (0, _indexJsDefault2.default)(str, tmpModel);
    words[obj.PastTense] = words[obj.PastTense] || "PastTense";
    words[obj.Gerund] = words[obj.Gerund] || "Gerund";
    if (doPresent === true) // is this plural noun, or present-tense?
    words[obj.PresentTense] = words[obj.PresentTense] || "PresentTense";
};
const expandAdjective = function(str, words, model) {
    let sup = (0, _inflectJs.toSuperlative)(str, model);
    words[sup] = words[sup] || "Superlative";
    let comp = (0, _inflectJs.toComparative)(str, model);
    words[comp] = words[comp] || "Comparative";
};
const expandNoun = function(str, words, model) {
    let plur = (0, _indexJsDefault1.default)(str, model);
    words[plur] = words[plur] || "Plural";
};
// harvest ambiguous words for any conjugations
const expandVariable = function(switchWords, model) {
    let words = {};
    const lex = model.one.lexicon;
    //add first tag as an assumption for each variable word
    Object.keys(switchWords).forEach((w)=>{
        const name = switchWords[w];
        words[w] = switchDefaults[name];
        // conjugate some verbs
        if (name === "Noun|Verb" || name === "Person|Verb" || name === "Actor|Verb") expandVerb(w, lex, false);
        if (name === "Adj|Present") {
            expandVerb(w, lex, true);
            expandAdjective(w, lex, model);
        }
        if (name === "Person|Adj") expandAdjective(w, lex, model);
        // add infinitives for gerunds
        if (name === "Adj|Gerund" || name === "Noun|Gerund") {
            let inf = (0, _indexJsDefault3.default)(w, tmpModel, "Gerund");
            if (!lex[inf]) words[inf] = "Infinitive" //expand it later
            ;
        }
        // add plurals for nouns
        if (name === "Noun|Gerund" || name === "Adj|Noun" || name === "Person|Noun") expandNoun(w, lex, model);
        if (name === "Adj|Past") {
            let inf = (0, _indexJsDefault3.default)(w, tmpModel, "PastTense");
            if (!lex[inf]) words[inf] = "Infinitive" //expand it later
            ;
        }
    });
    // add conjugations
    model = expandLexicon(words, model);
    return model;
};
const expand = function(model) {
    model = expandLexicon(model.one.lexicon, model);
    model = addUncountables(model.one.lexicon, model);
    model = expandVariable(model.two.switches, model);
    model = (0, _irregularsJsDefault.default)(model);
    return model;
};
exports.default = expand;

},{"../../methods/index.js":"6Zd6V","./irregulars.js":"8bvxG","../../methods/transform/nouns/toPlural/index.js":"iAp4R","../../methods/transform/verbs/conjugate/index.js":"81uuE","../../methods/transform/adjectives/inflect.js":"1GxTI","../../methods/transform/verbs/toInfinitive/index.js":"62jae","../models/index.js":"cwapb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Zd6V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./transform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./expand/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _quickSplitJs = require("./quickSplit.js");
var _quickSplitJsDefault = parcelHelpers.interopDefault(_quickSplitJs);
var _looksPluralJs = require("./looksPlural.js");
var _looksPluralJsDefault = parcelHelpers.interopDefault(_looksPluralJs);
exports.default = {
    two: {
        quickSplit: (0, _quickSplitJsDefault.default),
        expandLexicon: (0, _indexJsDefault1.default),
        transform: (0, _indexJsDefault.default),
        looksPlural: (0, _looksPluralJsDefault.default)
    }
};

},{"./transform/index.js":"7U7vW","./expand/index.js":"4gKsm","./quickSplit.js":"h6stu","./looksPlural.js":"jlGwY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7U7vW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./nouns/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./verbs/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("./adjectives/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
exports.default = {
    noun: (0, _indexJsDefault.default),
    verb: (0, _indexJsDefault1.default),
    adjective: (0, _indexJsDefault2.default)
};

},{"./nouns/index.js":"dnIe4","./verbs/index.js":"78Jb0","./adjectives/index.js":"gG49G","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dnIe4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./toPlural/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./toSingular/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
const all = function(str, model) {
    let arr = [
        str
    ];
    let p = (0, _indexJsDefault.default)(str, model);
    if (p !== str) arr.push(p);
    let s = (0, _indexJsDefault1.default)(str, model);
    if (s !== str) arr.push(s);
    return arr;
};
exports.default = {
    toPlural: (0, _indexJsDefault.default),
    toSingular: (0, _indexJsDefault1.default),
    all
};

},{"./toPlural/index.js":"iAp4R","./toSingular/index.js":"imocp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"imocp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rulesJs = require("./_rules.js");
var _rulesJsDefault = parcelHelpers.interopDefault(_rulesJs);
const invertObj = function(obj) {
    return Object.keys(obj).reduce((h, k)=>{
        h[obj[k]] = k;
        return h;
    }, {});
};
const toSingular = function(str, model) {
    const { irregularPlurals } = model.two;
    let invert = invertObj(irregularPlurals) //(not very efficient)
    ;
    // check irregulars list
    if (invert.hasOwnProperty(str)) return invert[str];
    // go through our regexes
    for(let i = 0; i < (0, _rulesJsDefault.default).length; i++)if ((0, _rulesJsDefault.default)[i][0].test(str) === true) {
        // console.log(rules[i])
        str = str.replace((0, _rulesJsDefault.default)[i][0], (0, _rulesJsDefault.default)[i][1]);
        return str;
    }
    return str;
};
exports.default = toSingular;

},{"./_rules.js":"9JsxX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9JsxX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    [
        /([^v])ies$/i,
        "$1y"
    ],
    [
        /(ise)s$/i,
        "$1"
    ],
    [
        /(kn|[^o]l|w)ives$/i,
        "$1ife"
    ],
    [
        /^((?:ca|e|ha|(?:our|them|your)?se|she|wo)l|lea|loa|shea|thie)ves$/i,
        "$1f"
    ],
    [
        /^(dwar|handkerchie|hoo|scar|whar)ves$/i,
        "$1f"
    ],
    [
        /(antenn|formul|nebul|vertebr|vit)ae$/i,
        "$1a"
    ],
    [
        /(octop|vir|radi|nucle|fung|cact|stimul)(i)$/i,
        "$1us"
    ],
    [
        /(buffal|tomat|tornad)(oes)$/i,
        "$1o"
    ],
    [
        /(ause)s$/i,
        "$1"
    ],
    [
        /(ease)s$/i,
        "$1"
    ],
    [
        /(ious)es$/i,
        "$1"
    ],
    [
        /(ouse)s$/i,
        "$1"
    ],
    [
        /(ose)s$/i,
        "$1"
    ],
    [
        /(..ase)s$/i,
        "$1"
    ],
    [
        /(..[aeiu]s)es$/i,
        "$1"
    ],
    [
        /(vert|ind|cort)(ices)$/i,
        "$1ex"
    ],
    [
        /(matr|append)(ices)$/i,
        "$1ix"
    ],
    [
        /([xo]|ch|ss|sh)es$/i,
        "$1"
    ],
    [
        /men$/i,
        "man"
    ],
    [
        /(n)ews$/i,
        "$1ews"
    ],
    [
        /([ti])a$/i,
        "$1um"
    ],
    [
        /([^aeiouy]|qu)ies$/i,
        "$1y"
    ],
    [
        /(s)eries$/i,
        "$1eries"
    ],
    [
        /(m)ovies$/i,
        "$1ovie"
    ],
    [
        /(cris|ax|test)es$/i,
        "$1is"
    ],
    [
        /(alias|status)es$/i,
        "$1"
    ],
    [
        /(ss)$/i,
        "$1"
    ],
    [
        /(ic)s$/i,
        "$1"
    ],
    [
        /s$/i,
        ""
    ]
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"78Jb0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./toInfinitive/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./conjugate/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
const all = function(str, model) {
    let res = (0, _indexJsDefault1.default)(str, model);
    delete res.FutureTense;
    return Object.values(res).filter((s)=>s);
};
exports.default = {
    toInfinitive: (0, _indexJsDefault.default),
    conjugate: (0, _indexJsDefault1.default),
    all
};

},{"./toInfinitive/index.js":"62jae","./conjugate/index.js":"81uuE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"62jae":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _suffixThumb = require("suffix-thumb");
var _indexJs = require("../getTense/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
const toParts = function(str, model) {
    let prefix = "";
    let prefixes = {};
    if (model.one && model.one.prefixes) prefixes = model.one.prefixes;
    // pull-apart phrasal verb 'fall over'
    let [verb, particle] = str.split(/ /);
    // support 'over cleaned'
    if (particle && prefixes[verb] === true) {
        prefix = verb;
        verb = particle;
        particle = "";
    }
    return {
        prefix,
        verb,
        particle
    };
};
// dunno about these..
const copulaMap = {
    are: "be",
    were: "be",
    been: "be",
    is: "be",
    am: "be",
    was: "be",
    be: "be",
    being: "be"
};
const toInfinitive = function(str, model, tense) {
    const { fromPast, fromPresent, fromGerund, fromParticiple } = model.two.models;
    let { prefix, verb, particle } = toParts(str, model);
    let inf = "";
    if (!tense) tense = (0, _indexJsDefault.default)(str);
    if (copulaMap.hasOwnProperty(str)) inf = copulaMap[str];
    else if (tense === "Participle") inf = (0, _suffixThumb.convert)(verb, fromParticiple);
    else if (tense === "PastTense") inf = (0, _suffixThumb.convert)(verb, fromPast);
    else if (tense === "PresentTense") inf = (0, _suffixThumb.convert)(verb, fromPresent);
    else if (tense === "Gerund") inf = (0, _suffixThumb.convert)(verb, fromGerund);
    else return str;
    // stitch phrasal back on
    if (particle) inf += " " + particle;
    // stitch prefix back on
    if (prefix) inf = prefix + " " + inf;
    return inf;
};
exports.default = toInfinitive // console.log(toInfinitive('snarled', { one: {} }))
 // console.log(convert('snarled', fromPast))
;

},{"suffix-thumb":"21rKx","../getTense/index.js":"inXrA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"inXrA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _guessJs = require("./_guess.js");
var _guessJsDefault = parcelHelpers.interopDefault(_guessJs);
/** it helps to know what we're conjugating from */ const getTense = function(str) {
    let three = str.substring(str.length - 3);
    if ((0, _guessJsDefault.default).hasOwnProperty(three) === true) return (0, _guessJsDefault.default)[three];
    let two = str.substring(str.length - 2);
    if ((0, _guessJsDefault.default).hasOwnProperty(two) === true) return (0, _guessJsDefault.default)[two];
    let one = str.substring(str.length - 1);
    if (one === "s") return "PresentTense";
    return null;
};
exports.default = getTense;

},{"./_guess.js":"g16M6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g16M6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let guessVerb = {
    Gerund: [
        "ing"
    ],
    Actor: [
        "erer"
    ],
    Infinitive: [
        "ate",
        "ize",
        "tion",
        "rify",
        "then",
        "ress",
        "ify",
        "age",
        "nce",
        "ect",
        "ise",
        "ine",
        "ish",
        "ace",
        "ash",
        "ure",
        "tch",
        "end",
        "ack",
        "and",
        "ute",
        "ade",
        "ock",
        "ite",
        "ase",
        "ose",
        "use",
        "ive",
        "int",
        "nge",
        "lay",
        "est",
        "ain",
        "ant",
        "ent",
        "eed",
        "er",
        "le",
        "unk",
        "ung",
        "upt",
        "en"
    ],
    PastTense: [
        "ept",
        "ed",
        "lt",
        "nt",
        "ew",
        "ld"
    ],
    PresentTense: [
        "rks",
        "cks",
        "nks",
        "ngs",
        "mps",
        "tes",
        "zes",
        "ers",
        "les",
        "acks",
        "ends",
        "ands",
        "ocks",
        "lays",
        "eads",
        "lls",
        "els",
        "ils",
        "ows",
        "nds",
        "ays",
        "ams",
        "ars",
        "ops",
        "ffs",
        "als",
        "urs",
        "lds",
        "ews",
        "ips",
        "es",
        "ts",
        "ns"
    ],
    Participle: [
        "ken",
        "wn"
    ]
};
//flip it into a lookup object
guessVerb = Object.keys(guessVerb).reduce((h, k)=>{
    guessVerb[k].forEach((a)=>h[a] = k);
    return h;
}, {});
exports.default = guessVerb;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"81uuE":[function(require,module,exports) {
// import { toPast, toPresent, toGerund, toParticiple } from '../../../../model/models/index.js'
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _suffixThumb = require("suffix-thumb");
// pull-apart phrasal verb 'fall over'
const parse = (inf)=>{
    if (/ /.test(inf)) return inf.split(/ /);
    return [
        inf,
        ""
    ];
};
//we run this on every verb in the lexicon, so please keep it fast
//we assume the input word is a proper infinitive
const conjugate = function(inf, model) {
    const { toPast, toPresent, toGerund, toParticiple } = model.two.models;
    // ad-hoc Copula response
    if (inf === "be") return {
        Infinitive: inf,
        Gerund: "being",
        PastTense: "was",
        PresentTense: "is"
    };
    let [str, particle] = parse(inf);
    let found = {
        Infinitive: str,
        PastTense: (0, _suffixThumb.convert)(str, toPast),
        PresentTense: (0, _suffixThumb.convert)(str, toPresent),
        Gerund: (0, _suffixThumb.convert)(str, toGerund),
        FutureTense: "will " + str
    };
    // add past-participle if it's interesting
    // drive -> driven (not drove)
    let pastPrt = (0, _suffixThumb.convert)(str, toParticiple);
    if (pastPrt !== inf && pastPrt !== found.PastTense) {
        // ensure it's a known participle
        let lex = model.one.lexicon || {};
        if (lex[pastPrt] === "Participle" || lex[pastPrt] === "Adjective") {
            // one exception
            if (inf === "play") pastPrt = "played";
            found.Participle = pastPrt;
        }
    }
    // put phrasal-verbs back together again
    if (particle) Object.keys(found).forEach((k)=>{
        found[k] += " " + particle;
    });
    return found;
};
exports.default = conjugate // console.log(toPresent.rules.y)
 // console.log(convert('buy', toPresent))
;

},{"suffix-thumb":"21rKx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gG49G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _inflectJs = require("./inflect.js");
var _fromAdverbJs = require("./conjugate/fromAdverb.js");
var _fromAdverbJsDefault = parcelHelpers.interopDefault(_fromAdverbJs);
var _toAdverbJs = require("./conjugate/toAdverb.js");
var _toAdverbJsDefault = parcelHelpers.interopDefault(_toAdverbJs);
// import toNoun from './conjugate/toNoun.js'
const all = function(str, model) {
    let arr = [
        str
    ];
    arr.push((0, _inflectJs.toSuperlative)(str, model));
    arr.push((0, _inflectJs.toComparative)(str, model));
    arr.push((0, _toAdverbJsDefault.default)(str));
    arr = arr.filter((s)=>s);
    arr = new Set(arr);
    return Array.from(arr);
};
exports.default = {
    toSuperlative: (0, _inflectJs.toSuperlative),
    toComparative: (0, _inflectJs.toComparative),
    toAdverb: (0, _toAdverbJsDefault.default),
    toNoun: (0, _inflectJs.toNoun),
    fromAdverb: (0, _fromAdverbJsDefault.default),
    fromSuperlative: (0, _inflectJs.fromSuperlative),
    fromComparative: (0, _inflectJs.fromComparative),
    all
};

},{"./inflect.js":"1GxTI","./conjugate/fromAdverb.js":"c2Ntm","./conjugate/toAdverb.js":"152XA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1GxTI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toSuperlative", ()=>toSuperlative);
parcelHelpers.export(exports, "toComparative", ()=>toComparative);
parcelHelpers.export(exports, "fromComparative", ()=>fromComparative);
parcelHelpers.export(exports, "fromSuperlative", ()=>fromSuperlative);
parcelHelpers.export(exports, "toNoun", ()=>toNoun);
var _suffixThumb = require("suffix-thumb");
// import toAdverb from './adverbs/toAdverb.js'
const toSuperlative = function(adj, model) {
    const mod = model.two.models.toSuperlative;
    return (0, _suffixThumb.convert)(adj, mod);
};
const toComparative = function(adj, model) {
    const mod = model.two.models.toComparative;
    return (0, _suffixThumb.convert)(adj, mod);
};
const fromComparative = function(adj, model) {
    const mod = model.two.models.fromComparative;
    return (0, _suffixThumb.convert)(adj, mod);
};
const fromSuperlative = function(adj, model) {
    const mod = model.two.models.fromSuperlative;
    return (0, _suffixThumb.convert)(adj, mod);
};
const toNoun = function(adj, model) {
    const mod = model.two.models.adjToNoun;
    return (0, _suffixThumb.convert)(adj, mod);
};

},{"suffix-thumb":"21rKx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c2Ntm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("./lib.js");
var _libJsDefault = parcelHelpers.interopDefault(_libJs);
const s = "ically";
const ical = new Set([
    "analyt" + s,
    "chem" + s,
    "class" + s,
    "clin" + s,
    "crit" + s,
    "ecolog" + s,
    "electr" + s,
    "empir" + s,
    "frant" + s,
    "grammat" + s,
    "ident" + s,
    "ideolog" + s,
    "log" + s,
    "mag" + s,
    "mathemat" + s,
    "mechan" + s,
    "med" + s,
    "method" + s,
    "method" + s,
    "mus" + s,
    "phys" + s,
    "phys" + s,
    "polit" + s,
    "pract" + s,
    "rad" + s,
    "satir" + s,
    "statist" + s,
    "techn" + s,
    "technolog" + s,
    "theoret" + s,
    "typ" + s,
    "vert" + s,
    "whims" + s
]);
const suffixes = [
    null,
    {},
    {
        "ly": ""
    },
    {
        "ily": "y",
        "bly": "ble",
        "ply": "ple"
    },
    {
        "ally": "al",
        "rply": "rp"
    },
    {
        "ually": "ual",
        "ially": "ial",
        "cally": "cal",
        "eally": "eal",
        "rally": "ral",
        "nally": "nal",
        "mally": "mal",
        "eeply": "eep",
        "eaply": "eap"
    },
    {
        ically: "ic"
    }
];
const noAdj = new Set([
    "early",
    "only",
    "hourly",
    "daily",
    "weekly",
    "monthly",
    "yearly",
    "mostly",
    "duly",
    "unduly",
    "especially",
    "undoubtedly",
    "conversely",
    "namely",
    "exceedingly",
    "presumably",
    "accordingly",
    "overly",
    "best",
    "latter",
    "little",
    "long",
    "low"
]);
// exceptions to rules
const exceptions = {
    wholly: "whole",
    fully: "full",
    truly: "true",
    gently: "gentle",
    singly: "single",
    customarily: "customary",
    idly: "idle",
    publically: "public",
    quickly: "quick",
    superbly: "superb",
    cynically: "cynical",
    well: "good"
};
const toAdjective = function(str) {
    if (!str.endsWith("ly")) return null;
    // 'electronic' vs 'electronical'
    if (ical.has(str)) return str.replace(/ically/, "ical");
    if (noAdj.has(str)) return null;
    if (exceptions.hasOwnProperty(str)) return exceptions[str];
    return (0, _libJsDefault.default)(str, suffixes) || str;
};
exports.default = toAdjective // console.log(toAdjective('emphatically'))
 // console.log(toAdjective('usually'))
 // console.log(toAdjective('mechanically'))
 // console.log(toAdjective('vertically'))
;

},{"./lib.js":"jP4c1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jP4c1":[function(require,module,exports) {
//sweep-through all suffixes
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const suffixLoop = function(str = "", suffixes = []) {
    const len = str.length;
    let max = len <= 6 ? len - 1 : 6;
    for(let i = max; i >= 1; i -= 1){
        let suffix = str.substring(len - i, str.length);
        if (suffixes[suffix.length].hasOwnProperty(suffix) === true) {
            let pre = str.slice(0, len - i);
            let post = suffixes[suffix.length][suffix];
            return pre + post;
        }
    }
    return null;
};
exports.default = suffixLoop;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"152XA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("./lib.js");
var _libJsDefault = parcelHelpers.interopDefault(_libJs);
const suffixes = [
    null,
    {
        y: "ily"
    },
    {
        ly: "ly",
        ic: "ically"
    },
    {
        ial: "ially",
        ual: "ually",
        tle: "tly",
        ble: "bly",
        ple: "ply",
        ary: "arily"
    },
    {},
    {},
    {}
];
const exceptions = {
    cool: "cooly",
    whole: "wholly",
    full: "fully",
    good: "well",
    idle: "idly",
    public: "publicly",
    single: "singly",
    special: "especially"
};
// a lot of adjectives *don't really* have a adverb
// 'roomy' -> 'roomily'
// but here, conjugate what it would be, if it made sense to
const toAdverb = function(str) {
    if (exceptions.hasOwnProperty(str)) return exceptions[str];
    let adv = (0, _libJsDefault.default)(str, suffixes);
    if (!adv) adv = str + "ly";
    // only return this if it exists in lexicon?
    // console.log(model.one.lexicon[adv])
    return adv;
};
exports.default = toAdverb // console.log(toAdverb('unsightly'))
;

},{"./lib.js":"jP4c1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4gKsm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _byTagJs = require("./byTag.js");
var _byTagJsDefault = parcelHelpers.interopDefault(_byTagJs);
// derive clever things from our lexicon key-value pairs
// this method runs as the pre-tagger plugin gets loaded
const expand = function(words, world) {
    const { methods, model } = world;
    let lex = {};
    // console.log('start:', Object.keys(lex).length)
    let _multi = {};
    // go through each word in this key-value obj:
    Object.keys(words).forEach((word)=>{
        let tag = words[word];
        // normalize lexicon a little bit
        word = word.toLowerCase().trim();
        word = word.replace(/'s\b/, "");
        // cache multi-word terms
        let split = word.split(/ /);
        if (split.length > 1) // prefer longer ones
        {
            if (_multi[split[0]] === undefined || split.length > _multi[split[0]]) _multi[split[0]] = split.length;
        }
        // do any clever-business, by it's tag
        if ((0, _byTagJsDefault.default).hasOwnProperty(tag) === true) (0, _byTagJsDefault.default)[tag](word, lex, methods, model);
        lex[word] = lex[word] || tag;
    });
    // cleanup
    delete lex[""];
    delete lex[null];
    delete lex[" "];
    return {
        lex,
        _multi
    };
};
exports.default = expand;

},{"./byTag.js":"9h4Vr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9h4Vr":[function(require,module,exports) {
// transformations to make on our lexicon
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    // add plural forms of singular nouns
    Singular: (word, lex, methods, model)=>{
        let already = model.one.lexicon;
        let plural = methods.two.transform.noun.toPlural(word, model);
        if (!already[plural]) lex[plural] = lex[plural] || "Plural";
    },
    // 'lawyer', 'manager' plural forms
    Actor: (word, lex, methods, model)=>{
        let already = model.one.lexicon;
        let plural = methods.two.transform.noun.toPlural(word, model);
        if (!already[plural]) lex[plural] = lex[plural] || [
            "Plural",
            "Actor"
        ];
    },
    // superlative/ comparative forms for adjectives
    Comparable: (word, lex, methods, model)=>{
        let already = model.one.lexicon;
        let { toSuperlative, toComparative } = methods.two.transform.adjective;
        // fast -> fastest
        let sup = toSuperlative(word, model);
        if (!already[sup]) lex[sup] = lex[sup] || "Superlative";
        // fast -> faster
        let comp = toComparative(word, model);
        if (!already[comp]) lex[comp] = lex[comp] || "Comparative";
        // overwrite
        lex[word] = "Adjective";
    },
    // 'german' -> 'germans'
    Demonym: (word, lex, methods, model)=>{
        let plural = methods.two.transform.noun.toPlural(word, model);
        lex[plural] = lex[plural] || [
            "Demonym",
            "Plural"
        ];
    },
    // conjugate all forms of these verbs
    Infinitive: (word, lex, methods, model)=>{
        let already = model.one.lexicon;
        let all = methods.two.transform.verb.conjugate(word, model);
        Object.entries(all).forEach((a)=>{
            if (!already[a[1]] && !lex[a[1]] && a[0] !== "FutureTense") lex[a[1]] = a[0];
        });
    },
    // 'walk up' should conjugate, too
    PhrasalVerb: (word, lex, methods, model)=>{
        let already = model.one.lexicon;
        lex[word] = [
            "PhrasalVerb",
            "Infinitive"
        ];
        let _multi = model.one._multiCache;
        let [inf, rest] = word.split(" ");
        // add root verb
        if (!already[inf]) lex[inf] = lex[inf] || "Infinitive";
        // conjugate it
        let all = methods.two.transform.verb.conjugate(inf, model);
        delete all.FutureTense;
        Object.entries(all).forEach((a)=>{
            // not 'walker up', or 'had taken up'
            if (a[0] === "Actor" || a[1] === "") return;
            // add the root verb, alone
            if (!lex[a[1]] && !already[a[1]]) lex[a[1]] = a[0];
            _multi[a[1]] = 2;
            let str = a[1] + " " + rest;
            lex[str] = lex[str] || [
                a[0],
                "PhrasalVerb"
            ];
        });
    },
    // expand 'million'
    Multiple: (word, lex)=>{
        lex[word] = [
            "Multiple",
            "Cardinal"
        ];
        // 'millionth'
        lex[word + "th"] = [
            "Multiple",
            "Ordinal"
        ];
        // 'millionths'
        lex[word + "ths"] = [
            "Multiple",
            "Fraction"
        ];
    },
    // expand number-words
    Cardinal: (word, lex)=>{
        lex[word] = [
            "TextValue",
            "Cardinal"
        ];
    },
    // 'millionth'
    Ordinal: (word, lex)=>{
        lex[word] = [
            "TextValue",
            "Ordinal"
        ];
        lex[word + "s"] = [
            "TextValue",
            "Fraction"
        ];
    },
    // 'thames'
    Place: (word, lex)=>{
        lex[word] = [
            "Place",
            "ProperNoun"
        ];
    },
    // 'ontario'
    Region: (word, lex)=>{
        lex[word] = [
            "Region",
            "ProperNoun"
        ];
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h6stu":[function(require,module,exports) {
// roughly, split a document by comma or semicolon
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const splitOn = function(terms, i) {
    const isNum = /^[0-9]+$/;
    let term = terms[i];
    // early on, these may not be dates yet:
    if (!term) return false;
    const maybeDate = new Set([
        "may",
        "april",
        "august",
        "jan"
    ]);
    // veggies, like figs
    if (term.normal === "like" || maybeDate.has(term.normal)) return false;
    // toronto, canada  - tuesday, march
    if (term.tags.has("Place") || term.tags.has("Date")) return false;
    if (terms[i - 1]) {
        let lastTerm = terms[i - 1];
        // thursday, june
        if (lastTerm.tags.has("Date") || maybeDate.has(lastTerm.normal)) return false;
        // pretty, nice, and fun
        if (lastTerm.tags.has("Adjective") || term.tags.has("Adjective")) return false;
    }
    // don't split numbers, yet
    let str = term.normal;
    if (str.length === 1 || str.length === 2 || str.length === 4) {
        if (isNum.test(str)) return false;
    }
    return true;
};
// kind-of a dirty sentence chunker
const quickSplit = function(document) {
    const splitHere = /[,:;]/;
    let arr = [];
    document.forEach((terms)=>{
        let start = 0;
        terms.forEach((term, i)=>{
            // does it have a comma/semicolon ?
            if (splitHere.test(term.post) && splitOn(terms, i + 1)) {
                arr.push(terms.slice(start, i + 1));
                start = i + 1;
            }
        });
        if (start < terms.length) arr.push(terms.slice(start, terms.length));
    });
    return arr;
};
exports.default = quickSplit;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jlGwY":[function(require,module,exports) {
//similar to plural/singularize rules, but not the same
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isPlural = {
    e: [
        "mice",
        "louse",
        "antennae",
        "formulae",
        "nebulae",
        "vertebrae",
        "vitae"
    ],
    i: [
        "tia",
        "octopi",
        "viri",
        "radii",
        "nuclei",
        "fungi",
        "cacti",
        "stimuli"
    ],
    n: [
        "men"
    ],
    t: [
        "feet"
    ]
};
// plural words as exceptions to suffix-rules
const exceptions = new Set([
    // 'formulas',
    // 'umbrellas',
    // 'gorillas',
    // 'koalas',
    "israelis",
    "menus",
    "logos"
]);
const notPlural = [
    "bus",
    "mas",
    "was",
    // 'las',
    "ias",
    "xas",
    "vas",
    "cis",
    "lis",
    "nis",
    "ois",
    "ris",
    "sis",
    "tis",
    "xis",
    "aus",
    "cus",
    "eus",
    "fus",
    "gus",
    "ius",
    "lus",
    "nus",
    "das",
    "ous",
    "pus",
    "rus",
    "sus",
    "tus",
    "xus",
    "aos",
    "igos",
    "ados",
    "ogos",
    "'s",
    "ss"
];
const looksPlural = function(str) {
    // not long enough to be plural
    if (!str || str.length <= 3) return false;
    // 'menus' etc
    if (exceptions.has(str)) return true;
    let end = str[str.length - 1];
    // look at 'firemen'
    if (isPlural.hasOwnProperty(end)) return isPlural[end].find((suff)=>str.endsWith(suff));
    if (end !== "s") return false;
    // look for 'virus'
    if (notPlural.find((suff)=>str.endsWith(suff))) return false;
    // ends with an s, seems plural i guess.
    return true;
};
exports.default = looksPlural;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8bvxG":[function(require,module,exports) {
// import irregularVerbs from './conjugations.js'
// harvest list of irregulars for any juicy word-data
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const expandIrregulars = function(model) {
    const { irregularPlurals } = model.two;
    const { lexicon } = model.one;
    Object.entries(irregularPlurals).forEach((a)=>{
        lexicon[a[0]] = lexicon[a[0]] || "Singular";
        lexicon[a[1]] = lexicon[a[1]] || "Plural";
    });
    return model;
};
exports.default = expandIrregulars;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gpW0x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./tagger/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _rootJs = require("./root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
var _pennJs = require("./penn.js");
var _pennJsDefault = parcelHelpers.interopDefault(_pennJs);
exports.default = {
    preTagger: (0, _indexJsDefault.default),
    root: (0, _rootJsDefault.default),
    penn: (0, _pennJsDefault.default)
};

},{"./tagger/index.js":"3rHzY","./root.js":"kWDbE","./penn.js":"aI8RV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3rHzY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _01ColonsJs = require("./1st-pass/01-colons.js");
var _01ColonsJsDefault = parcelHelpers.interopDefault(_01ColonsJs);
var _02HyphensJs = require("./1st-pass/02-hyphens.js");
var _02HyphensJsDefault = parcelHelpers.interopDefault(_02HyphensJs);
var _00TagSwitchJs = require("./2nd-pass/00-tagSwitch.js");
var _00TagSwitchJsDefault = parcelHelpers.interopDefault(_00TagSwitchJs);
var _01CaseJs = require("./2nd-pass/01-case.js");
var _01CaseJsDefault = parcelHelpers.interopDefault(_01CaseJs);
var _02SuffixJs = require("./2nd-pass/02-suffix.js");
var _02SuffixJsDefault = parcelHelpers.interopDefault(_02SuffixJs);
var _03RegexJs = require("./2nd-pass/03-regex.js");
var _03RegexJsDefault = parcelHelpers.interopDefault(_03RegexJs);
var _04PrefixJs = require("./2nd-pass/04-prefix.js");
var _04PrefixJsDefault = parcelHelpers.interopDefault(_04PrefixJs);
var _05YearJs = require("./2nd-pass/05-year.js");
var _05YearJsDefault = parcelHelpers.interopDefault(_05YearJs);
var _07VerbTypeJs = require("./3rd-pass/07-verb-type.js");
var _07VerbTypeJsDefault = parcelHelpers.interopDefault(_07VerbTypeJs);
var _fillTagsJs = require("./3rd-pass/_fillTags.js");
var _fillTagsJsDefault = parcelHelpers.interopDefault(_fillTagsJs);
var _01AcronymJs = require("./3rd-pass/01-acronym.js");
var _01AcronymJsDefault = parcelHelpers.interopDefault(_01AcronymJs);
var _02NeighboursJs = require("./3rd-pass/02-neighbours.js");
var _02NeighboursJsDefault = parcelHelpers.interopDefault(_02NeighboursJs);
var _03OrgWordsJs = require("./3rd-pass/03-orgWords.js");
var _03OrgWordsJsDefault = parcelHelpers.interopDefault(_03OrgWordsJs);
var _04PlaceWordsJs = require("./3rd-pass/04-placeWords.js");
var _04PlaceWordsJsDefault = parcelHelpers.interopDefault(_04PlaceWordsJs);
var _05FallbackJs = require("./3rd-pass/05-fallback.js");
var _05FallbackJsDefault = parcelHelpers.interopDefault(_05FallbackJs);
var _06SwitchesJs = require("./3rd-pass/06-switches.js");
var _06SwitchesJsDefault = parcelHelpers.interopDefault(_06SwitchesJs);
var _08ImperativeJs = require("./3rd-pass/08-imperative.js");
var _08ImperativeJsDefault = parcelHelpers.interopDefault(_08ImperativeJs);
// is it all yelling-case?
const ignoreCase = function(terms) {
    // allow 'John F Kennedy'
    if (terms.filter((t)=>!t.tags.has("ProperNoun")).length <= 3) return false;
    const lowerCase = /^[a-z]/;
    return terms.every((t)=>!lowerCase.test(t.text));
};
// taggers with no clause-splitting
const firstPass = function(docs, model, world) {
    docs.forEach((terms)=>{
        // check whitespace/punctuation
        (0, _01ColonsJsDefault.default)(terms, 0, model, world);
    });
};
// these methods don't care about word-neighbours
const secondPass = function(terms, model, world, isYelling) {
    for(let i = 0; i < terms.length; i += 1){
        // skip frozen terms, for now
        if (terms[i].frozen === true) continue;
        // mark Noun|Verb on term metadata
        (0, _00TagSwitchJsDefault.default)(terms, i, model);
        //  is it titlecased?
        if (isYelling === false) (0, _01CaseJsDefault.default)(terms, i, model);
        // look at word ending
        (0, _02SuffixJsDefault.default)(terms, i, model);
        // try look-like rules
        (0, _03RegexJsDefault.default)(terms, i, model, world);
        // check for recognized prefix, like 'micro-'
        (0, _04PrefixJsDefault.default)(terms, i, model);
        // turn '1993' into a year
        (0, _05YearJsDefault.default)(terms, i, model);
    }
};
// neighbour-based tagging
const thirdPass = function(terms, model, world, isYelling) {
    for(let i = 0; i < terms.length; i += 1){
        // let these tags get layered
        let found = (0, _01AcronymJsDefault.default)(terms, i, model);
        // deduce parent tags
        (0, _fillTagsJsDefault.default)(terms, i, model);
        // look left+right for hints
        found = found || (0, _02NeighboursJsDefault.default)(terms, i, model);
        //  ¯\_(ツ)_/¯ - found nothing
        found = found || (0, _05FallbackJsDefault.default)(terms, i, model);
    }
    for(let i = 0; i < terms.length; i += 1){
        // skip these
        if (terms[i].frozen === true) continue;
        // Johnson LLC
        (0, _03OrgWordsJsDefault.default)(terms, i, world, isYelling);
        // Wawel Castle
        (0, _04PlaceWordsJsDefault.default)(terms, i, world, isYelling);
        // verb-noun disambiguation, etc
        (0, _06SwitchesJsDefault.default)(terms, i, world);
        // give bare verbs more tags
        (0, _07VerbTypeJsDefault.default)(terms, i, model, world);
        // hard-nosed
        (0, _02HyphensJsDefault.default)(terms, i, model, world);
    }
    // place tea bags
    (0, _08ImperativeJsDefault.default)(terms, world);
};
const preTagger = function(view) {
    const { methods, model, world } = view;
    let docs = view.docs;
    // try some early stuff
    firstPass(docs, model, world);
    // roughly split sentences up by clause
    let document = methods.two.quickSplit(docs);
    // start with all terms
    for(let n = 0; n < document.length; n += 1){
        let terms = document[n];
        // is it all upper-case?
        const isYelling = ignoreCase(terms);
        // guess by the letters
        secondPass(terms, model, world, isYelling);
        // guess by the neighbours
        thirdPass(terms, model, world, isYelling);
    }
    return document;
};
exports.default = preTagger;

},{"./1st-pass/01-colons.js":"f2Yai","./1st-pass/02-hyphens.js":"jxNVe","./2nd-pass/00-tagSwitch.js":"hRG3D","./2nd-pass/01-case.js":"4v1ai","./2nd-pass/02-suffix.js":"fYeEg","./2nd-pass/03-regex.js":"aWZ0W","./2nd-pass/04-prefix.js":"l2oN2","./2nd-pass/05-year.js":"aOYHI","./3rd-pass/07-verb-type.js":"WX2Do","./3rd-pass/_fillTags.js":"8P204","./3rd-pass/01-acronym.js":"1I1ud","./3rd-pass/02-neighbours.js":"1S6gn","./3rd-pass/03-orgWords.js":"f0IoA","./3rd-pass/04-placeWords.js":"jlaWA","./3rd-pass/05-fallback.js":"bDpgu","./3rd-pass/06-switches.js":"3Zqts","./3rd-pass/08-imperative.js":"76meH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f2Yai":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const byPunctuation = function(terms, i, model, world) {
    const setTag = world.methods.one.setTag;
    // colon following first word
    // edit: foo
    // breaking: foobar
    if (i === 0 && terms.length >= 3) {
        const hasColon = /:/;
        let post = terms[0].post;
        if (post.match(hasColon)) {
            // phone: 555-2938
            let nextTerm = terms[1];
            if (nextTerm.tags.has("Value") || nextTerm.tags.has("Email") || nextTerm.tags.has("PhoneNumber")) return;
            //
            setTag([
                terms[0]
            ], "Expression", world, null, `2-punct-colon''`);
        }
    }
};
exports.default = byPunctuation;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jxNVe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const byHyphen = function(terms, i, model, world) {
    const setTag = world.methods.one.setTag;
    // two words w/ a dash
    if (terms[i].post === "-" && terms[i + 1]) setTag([
        terms[i],
        terms[i + 1]
    ], "Hyphenated", world, null, `1-punct-hyphen''`);
};
exports.default = byHyphen;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hRG3D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const prefix = /^(under|over|mis|re|un|dis|semi)-?/;
const tagSwitch = function(terms, i, model) {
    const switches = model.two.switches;
    let term = terms[i];
    if (switches.hasOwnProperty(term.normal)) {
        term.switch = switches[term.normal];
        return;
    }
    // support 'restrike' -> 'strike'
    if (prefix.test(term.normal)) {
        let stem = term.normal.replace(prefix, "");
        if (stem.length > 3 && switches.hasOwnProperty(stem)) term.switch = switches[stem];
    }
};
exports.default = tagSwitch;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4v1ai":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fastTagJs = require("../_fastTag.js");
var _fastTagJsDefault = parcelHelpers.interopDefault(_fastTagJs);
var _fillTagsJs = require("../3rd-pass/_fillTags.js");
var _fillTagsJsDefault = parcelHelpers.interopDefault(_fillTagsJs);
const titleCase = /^\p{Lu}[\p{Ll}'’]/u;
const hasNumber = /[0-9]/;
const notProper = [
    "Date",
    "Month",
    "WeekDay",
    "Unit",
    "Expression"
];
// roman numeral by regex
const hasIVX = /[IVX]/ // does it ~look like~ a roman numeral?
;
// quick-version
const romanNumeral = /^[IVXLCDM]{2,}$/;
// https://stackoverflow.com/a/267405/168877
const romanNumValid = /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/;
const nope = {
    li: true,
    dc: true,
    md: true,
    dm: true,
    ml: true
};
// if it's a unknown titlecase word, it's a propernoun
const checkCase = function(terms, i, model) {
    let term = terms[i];
    // assume terms are already indexed
    term.index = term.index || [
        0,
        0
    ];
    let index = term.index[1];
    let str = term.text || "" //need case info
    ;
    // titlecase and not first word of sentence
    if (index !== 0 && titleCase.test(str) === true && hasNumber.test(str) === false) {
        // skip Dates and stuff
        if (notProper.find((tag)=>term.tags.has(tag))) return null;
        // first word in a quotation?
        if (term.pre.match(/["']$/)) return null;
        if (term.normal === "the") return null;
        (0, _fillTagsJsDefault.default)(terms, i, model);
        if (!term.tags.has("Noun") && !term.frozen) term.tags.clear();
        (0, _fastTagJsDefault.default)(term, "ProperNoun", "2-titlecase");
        return true;
    }
    //roman numberals - XVII
    if (str.length >= 2 && romanNumeral.test(str) && hasIVX.test(str) && romanNumValid.test(str) && !nope[term.normal]) {
        (0, _fastTagJsDefault.default)(term, "RomanNumeral", "2-xvii");
        return true;
    }
    return null;
};
exports.default = checkCase;

},{"../_fastTag.js":"3bfyU","../3rd-pass/_fillTags.js":"8P204","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3bfyU":[function(require,module,exports) {
// verbose-mode tagger debuging
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var process = require("79ffd3ec0ff4920d");
const log = (term, tag, reason = "")=>{
    const yellow = (str)=>"\x1b[33m\x1b[3m" + str + "\x1b[0m";
    const i = (str)=>"\x1b[3m" + str + "\x1b[0m";
    let word = term.text || "[" + term.implicit + "]";
    if (typeof tag !== "string" && tag.length > 2) tag = tag.slice(0, 2).join(", #") + " +" //truncate the list of tags
    ;
    tag = typeof tag !== "string" ? tag.join(", #") : tag;
    console.log(` ${yellow(word).padEnd(24)} \x1b[32m\u{2192}\x1b[0m #${tag.padEnd(22)}  ${i(reason)}`) // eslint-disable-line
    ;
};
// a faster version than the user-facing one in ./methods
const fastTag = function(term, tag, reason) {
    if (!tag || tag.length === 0) return;
    if (term.frozen === true) return;
    // some logging for debugging
    const env = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
    if (env && env.DEBUG_TAGS) log(term, tag, reason);
    term.tags = term.tags || new Set();
    if (typeof tag === "string") term.tags.add(tag);
    else tag.forEach((tg)=>term.tags.add(tg));
};
exports.default = fastTag;

},{"79ffd3ec0ff4920d":"d5jf4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8P204":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fastTagJs = require("../_fastTag.js");
var _fastTagJsDefault = parcelHelpers.interopDefault(_fastTagJs);
var _looksPluralJs = require("../../../methods/looksPlural.js");
var _looksPluralJsDefault = parcelHelpers.interopDefault(_looksPluralJs);
var _indexJs = require("../../../methods/transform/verbs/getTense/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
// tags that are neither plural or singular
const uncountable = [
    "Acronym",
    "Abbreviation",
    "ProperNoun",
    "Uncountable",
    "Possessive",
    "Pronoun",
    "Activity",
    "Honorific",
    "Month"
];
// try to guess if each noun is a plural/singular
const setPluralSingular = function(term) {
    if (!term.tags.has("Noun") || term.tags.has("Plural") || term.tags.has("Singular")) return;
    if (uncountable.find((tag)=>term.tags.has(tag))) return;
    if ((0, _looksPluralJsDefault.default)(term.normal)) (0, _fastTagJsDefault.default)(term, "Plural", "3-plural-guess");
    else (0, _fastTagJsDefault.default)(term, "Singular", "3-singular-guess");
};
// try to guess the tense of a naked verb
const setTense = function(term) {
    let tags = term.tags;
    if (tags.has("Verb") && tags.size === 1) {
        let guess = (0, _indexJsDefault.default)(term.normal);
        if (guess) (0, _fastTagJsDefault.default)(term, guess, "3-verb-tense-guess");
    }
};
//add deduced parent tags to our terms
const fillTags = function(terms, i, model) {
    let term = terms[i];
    //there is probably just one tag, but we'll allow more
    let tags = Array.from(term.tags);
    for(let k = 0; k < tags.length; k += 1)if (model.one.tagSet[tags[k]]) {
        let toAdd = model.one.tagSet[tags[k]].parents;
        (0, _fastTagJsDefault.default)(term, toAdd, ` -inferred by #${tags[k]}`);
    }
    // turn 'Noun' into Plural/Singular
    setPluralSingular(term);
    // turn 'Verb' into Present/PastTense
    setTense(term, model);
};
exports.default = fillTags;

},{"../_fastTag.js":"3bfyU","../../../methods/looksPlural.js":"jlGwY","../../../methods/transform/verbs/getTense/index.js":"inXrA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fYeEg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fastTagJs = require("../_fastTag.js");
var _fastTagJsDefault = parcelHelpers.interopDefault(_fastTagJs);
//sweep-through all suffixes
const suffixLoop = function(str = "", suffixes = []) {
    const len = str.length;
    let max = 7;
    if (len <= max) max = len - 1;
    for(let i = max; i > 1; i -= 1){
        let suffix = str.substring(len - i, len);
        if (suffixes[suffix.length].hasOwnProperty(suffix) === true) {
            // console.log(suffix)
            let tag = suffixes[suffix.length][suffix];
            return tag;
        }
    }
    return null;
};
// decide tag from the ending of the word
const tagBySuffix = function(terms, i, model) {
    let term = terms[i];
    if (term.tags.size === 0) {
        let tag = suffixLoop(term.normal, model.two.suffixPatterns);
        if (tag !== null) {
            (0, _fastTagJsDefault.default)(term, tag, "2-suffix");
            term.confidence = 0.7;
            return true;
        }
        // try implicit form of word, too
        if (term.implicit) {
            tag = suffixLoop(term.implicit, model.two.suffixPatterns);
            if (tag !== null) {
                (0, _fastTagJsDefault.default)(term, tag, "2-implicit-suffix");
                term.confidence = 0.7;
                return true;
            }
        }
    // Infinitive suffix + 's' can be PresentTense
    // if (term.normal[term.normal.length - 1] === 's') {
    //   let str = term.normal.replace(/s$/, '')
    //   if (suffixLoop(str, model.two.suffixPatterns) === 'Infinitive') {
    //     console.log(str)
    //     fastTag(term, 'PresentTense', '2-implied-present')
    //     term.confidence = 0.5
    //     return true
    //   }
    // }
    }
    return null;
};
exports.default = tagBySuffix;

},{"../_fastTag.js":"3bfyU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aWZ0W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const hasApostrophe = /['‘’‛‵′`´]/;
// normal regexes
const doRegs = function(str, regs) {
    for(let i = 0; i < regs.length; i += 1){
        if (regs[i][0].test(str) === true) return regs[i];
    }
    return null;
};
// suffix-regexes, indexed by last-character
const doEndsWith = function(str = "", byEnd) {
    let char = str[str.length - 1];
    if (byEnd.hasOwnProperty(char) === true) {
        let regs = byEnd[char] || [];
        for(let r = 0; r < regs.length; r += 1){
            if (regs[r][0].test(str) === true) return regs[r];
        }
    }
    return null;
};
const checkRegex = function(terms, i, model, world) {
    const setTag = world.methods.one.setTag;
    let { regexText, regexNormal, regexNumbers, endsWith } = model.two;
    let term = terms[i];
    let normal = term.machine || term.normal;
    let text = term.text;
    // keep dangling apostrophe?
    if (hasApostrophe.test(term.post) && !hasApostrophe.test(term.pre)) text += term.post.trim();
    let arr = doRegs(text, regexText) || doRegs(normal, regexNormal);
    // hide a bunch of number regexes behind this one
    if (!arr && /[0-9]/.test(normal)) arr = doRegs(normal, regexNumbers);
    // only run endsWith if we're desperate
    if (!arr && term.tags.size === 0) arr = doEndsWith(normal, endsWith);
    if (arr) {
        // console.log(arr)
        setTag([
            term
        ], arr[1], world, null, `2-regex-'${arr[2] || arr[0]}'`);
        term.confidence = 0.6;
        return true;
    }
    return null;
};
exports.default = checkRegex;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l2oN2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fastTagJs = require("../_fastTag.js");
var _fastTagJsDefault = parcelHelpers.interopDefault(_fastTagJs);
// const prefixes = /^(anti|re|un|non|extra|inter|intra|over)([a-z-]{3})/
//sweep-through all prefixes
const prefixLoop = function(str = "", prefixes = []) {
    const len = str.length;
    let max = 7;
    if (max > len - 3) max = len - 3;
    for(let i = max; i > 2; i -= 1){
        let prefix = str.substring(0, i);
        if (prefixes[prefix.length].hasOwnProperty(prefix) === true) {
            let tag = prefixes[prefix.length][prefix];
            return tag;
        }
    }
    return null;
};
// give 'overwork' the same tag as 'work'
const checkPrefix = function(terms, i, model) {
    let term = terms[i];
    if (term.tags.size === 0) {
        let tag = prefixLoop(term.normal, model.two.prefixPatterns);
        if (tag !== null) {
            // console.log(term.normal, '->', tag)
            (0, _fastTagJsDefault.default)(term, tag, "2-prefix");
            term.confidence = 0.5;
            return true;
        }
    }
    return null;
};
exports.default = checkPrefix;

},{"../_fastTag.js":"3bfyU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aOYHI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fastTagJs = require("../_fastTag.js");
var _fastTagJsDefault = parcelHelpers.interopDefault(_fastTagJs);
const min = 1400;
const max = 2100;
const dateWords = new Set([
    "in",
    "on",
    "by",
    "until",
    "for",
    "to",
    "during",
    "throughout",
    "through",
    "within",
    "before",
    "after",
    "of",
    "this",
    "next",
    "last",
    "circa",
    "around",
    "post",
    "pre",
    "budget",
    "classic",
    "plan",
    "may"
]);
const seemsGood = function(term) {
    if (!term) return false;
    let str = term.normal || term.implicit;
    if (dateWords.has(str)) return true;
    if (term.tags.has("Date") || term.tags.has("Month") || term.tags.has("WeekDay") || term.tags.has("Year")) return true;
    // 1999 Film Festival
    if (term.tags.has("ProperNoun")) return true;
    return false;
};
const seemsOkay = function(term) {
    if (!term) return false;
    if (term.tags.has("Ordinal")) return true;
    // untagged 'june 13 2007'
    if (term.tags.has("Cardinal") && term.normal.length < 3) return true;
    // 2020 was ..
    if (term.normal === "is" || term.normal === "was") return true;
    return false;
};
const seemsFine = function(term) {
    return term && (term.tags.has("Date") || term.tags.has("Month") || term.tags.has("WeekDay") || term.tags.has("Year"));
};
// recognize '1993' as a year
const tagYear = function(terms, i) {
    const term = terms[i];
    if (term.tags.has("NumericValue") && term.tags.has("Cardinal") && term.normal.length === 4) {
        let num = Number(term.normal);
        // number between 1400 and 2100
        if (num && !isNaN(num)) {
            if (num > min && num < max) {
                let lastTerm = terms[i - 1];
                let nextTerm = terms[i + 1];
                if (seemsGood(lastTerm) || seemsGood(nextTerm)) return (0, _fastTagJsDefault.default)(term, "Year", "2-tagYear");
                // or is it really-close to a year?
                if (num >= 1920 && num < 2025) {
                    // look at neighbours
                    if (seemsOkay(lastTerm) || seemsOkay(nextTerm)) return (0, _fastTagJsDefault.default)(term, "Year", "2-tagYear-close");
                    // look at far-neighbours
                    if (seemsFine(terms[i - 2]) || seemsFine(terms[i + 2])) return (0, _fastTagJsDefault.default)(term, "Year", "2-tagYear-far");
                    // 'the 2002 hit', 'my 1950 convertable'
                    if (lastTerm && (lastTerm.tags.has("Determiner") || lastTerm.tags.has("Possessive"))) {
                        if (nextTerm && nextTerm.tags.has("Noun") && !nextTerm.tags.has("Plural")) return (0, _fastTagJsDefault.default)(term, "Year", "2-tagYear-noun");
                    }
                }
            }
        }
    }
    return null;
};
exports.default = tagYear;

},{"../_fastTag.js":"3bfyU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"WX2Do":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const verbType = function(terms, i, model, world) {
    const setTag = world.methods.one.setTag;
    const term = terms[i];
    const types = [
        "PastTense",
        "PresentTense",
        "Auxiliary",
        "Modal",
        "Particle"
    ];
    if (term.tags.has("Verb")) {
        let type = types.find((typ)=>term.tags.has(typ));
        // is it a bare #Verb tag?
        if (!type) setTag([
            term
        ], "Infinitive", world, null, `2-verb-type''`);
    }
};
exports.default = verbType;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1I1ud":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fastTagJs = require("../_fastTag.js");
var _fastTagJsDefault = parcelHelpers.interopDefault(_fastTagJs);
const oneLetterAcronym = /^[A-Z]('s|,)?$/;
const isUpperCase = /^[A-Z-]+$/;
const upperThenS = /^[A-Z]+s$/;
const periodAcronym = /([A-Z]\.)+[A-Z]?,?$/;
const noPeriodAcronym = /[A-Z]{2,}('s|,)?$/;
const lowerCaseAcronym = /([a-z]\.)+[a-z]\.?$/;
const oneLetterWord = {
    I: true,
    A: true
};
// only assume these are places if they are uppercased
const places = {
    la: true,
    ny: true,
    us: true,
    dc: true,
    gb: true
};
// just uppercase acronyms, no periods - 'UNOCHA'
const isNoPeriodAcronym = function(term, model) {
    let str = term.text;
    // ensure it's all upper-case
    if (isUpperCase.test(str) === false) {
        // allow lower-case plural - 'MMVAs'
        if (str.length > 3 && upperThenS.test(str) === true) str = str.replace(/s$/, "");
        else return false;
    }
    // long capitalized words are not usually either
    if (str.length > 5) return false;
    // 'I' is not a acronym
    if (oneLetterWord.hasOwnProperty(str)) return false;
    // known-words, like 'PIZZA' is not an acronym.
    if (model.one.lexicon.hasOwnProperty(term.normal)) return false;
    //like N.D.A
    if (periodAcronym.test(str) === true) return true;
    //like c.e.o
    if (lowerCaseAcronym.test(str) === true) return true;
    //like 'F.'
    if (oneLetterAcronym.test(str) === true) return true;
    //like NDA
    if (noPeriodAcronym.test(str) === true) return true;
    return false;
};
const isAcronym = function(terms, i, model) {
    let term = terms[i];
    //these are not acronyms
    if (term.tags.has("RomanNumeral") || term.tags.has("Acronym") || term.frozen) return null;
    //non-period ones are harder
    if (isNoPeriodAcronym(term, model)) {
        term.tags.clear();
        (0, _fastTagJsDefault.default)(term, [
            "Acronym",
            "Noun"
        ], "3-no-period-acronym");
        // ny, la
        if (places[term.normal] === true) (0, _fastTagJsDefault.default)(term, "Place", "3-place-acronym");
        // UFOs
        if (upperThenS.test(term.text) === true) (0, _fastTagJsDefault.default)(term, "Plural", "3-plural-acronym");
        // if(term.normal
        return true;
    }
    // one-letter acronyms
    if (!oneLetterWord.hasOwnProperty(term.text) && oneLetterAcronym.test(term.text)) {
        term.tags.clear();
        (0, _fastTagJsDefault.default)(term, [
            "Acronym",
            "Noun"
        ], "3-one-letter-acronym");
        return true;
    }
    //if it's a very-short organization?
    if (term.tags.has("Organization") && term.text.length <= 3) {
        (0, _fastTagJsDefault.default)(term, "Acronym", "3-org-acronym");
        return true;
    }
    // upper-case org, like UNESCO
    if (term.tags.has("Organization") && isUpperCase.test(term.text) && term.text.length <= 6) {
        (0, _fastTagJsDefault.default)(term, "Acronym", "3-titlecase-acronym");
        return true;
    }
    return null;
};
exports.default = isAcronym;

},{"../_fastTag.js":"3bfyU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1S6gn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fastTagJs = require("../_fastTag.js");
var _fastTagJsDefault = parcelHelpers.interopDefault(_fastTagJs);
var _fillTagsJs = require("./_fillTags.js");
var _fillTagsJsDefault = parcelHelpers.interopDefault(_fillTagsJs);
const lookAtWord = function(term, words) {
    if (!term) return null;
    // look at prev word <-
    let found = words.find((a)=>term.normal === a[0]);
    if (found) return found[1];
    return null;
};
const lookAtTag = function(term, tags) {
    if (!term) return null;
    let found = tags.find((a)=>term.tags.has(a[0]));
    if (found) return found[1];
    return null;
};
// look at neighbours for hints on unknown words
const neighbours = function(terms, i, model) {
    const { leftTags, leftWords, rightWords, rightTags } = model.two.neighbours;
    let term = terms[i];
    if (term.tags.size === 0) {
        let tag = null;
        // look left <-
        tag = tag || lookAtWord(terms[i - 1], leftWords);
        // look right ->
        tag = tag || lookAtWord(terms[i + 1], rightWords);
        // look left <-
        tag = tag || lookAtTag(terms[i - 1], leftTags);
        // look right ->
        tag = tag || lookAtTag(terms[i + 1], rightTags);
        if (tag) {
            (0, _fastTagJsDefault.default)(term, tag, "3-[neighbour]");
            (0, _fillTagsJsDefault.default)(terms, i, model);
            terms[i].confidence = 0.2;
            return true;
        }
    }
    return null;
};
exports.default = neighbours;

},{"../_fastTag.js":"3bfyU","./_fillTags.js":"8P204","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f0IoA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isTitleCase = (str)=>/^\p{Lu}[\p{Ll}'’]/u.test(str);
const isOrg = function(term, i, yelling) {
    if (!term) return false;
    if (term.tags.has("FirstName") || term.tags.has("Place")) return false;
    if (term.tags.has("ProperNoun") || term.tags.has("Organization") || term.tags.has("Acronym")) return true;
    // allow anything titlecased to be an org
    if (!yelling && isTitleCase(term.text)) {
        // only tag a titlecased first-word, if it checks-out
        if (i === 0) return term.tags.has("Singular");
        return true;
    }
    return false;
};
const tagOrgs = function(terms, i, world, yelling) {
    const orgWords = world.model.two.orgWords;
    const setTag = world.methods.one.setTag;
    let term = terms[i];
    let str = term.machine || term.normal;
    if (orgWords[str] === true && isOrg(terms[i - 1], i - 1, yelling)) {
        setTag([
            terms[i]
        ], "Organization", world, null, "3-[org-word]");
        // loop backwards, tag organization-like things
        for(let t = i; t >= 0; t -= 1){
            if (isOrg(terms[t], t, yelling)) setTag([
                terms[t]
            ], "Organization", world, null, "3-[org-word]");
            else break;
        }
    }
    return null;
};
exports.default = tagOrgs;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jlaWA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isTitleCase = (str)=>/^\p{Lu}[\p{Ll}'’]/u.test(str);
const isPossessive = /'s$/;
// words that can fit inside a place
const placeCont = new Set([
    "athletic",
    "city",
    "community",
    "eastern",
    "federal",
    "financial",
    "great",
    "historic",
    "historical",
    "local",
    "memorial",
    "municipal",
    "national",
    "northern",
    "provincial",
    "southern",
    "state",
    "western"
]);
// center of...
const noBefore = new Set([
    "center",
    "centre",
    "way",
    "range",
    "bar",
    "bridge",
    "field",
    "pit"
]);
const isPlace = function(term, i, yelling) {
    if (!term) return false;
    let tags = term.tags;
    if (tags.has("Organization") || tags.has("Possessive") || isPossessive.test(term.normal)) return false;
    if (tags.has("ProperNoun") || tags.has("Place")) return true;
    // allow anything titlecased to be an org
    if (!yelling && isTitleCase(term.text)) {
        // only tag a titlecased first-word, if it checks-out
        if (i === 0) return tags.has("Singular");
        return true;
    }
    return false;
};
const tagOrgs = function(terms, i, world, yelling) {
    const placeWords = world.model.two.placeWords;
    const setTag = world.methods.one.setTag;
    let term = terms[i];
    let str = term.machine || term.normal;
    // 'river', delta, street, etc
    if (placeWords[str] === true) {
        //loop backward - 'Foo River ...'
        for(let n = i - 1; n >= 0; n -= 1){
            // 'municipal ...'
            if (placeCont.has(terms[n].normal)) continue;
            if (isPlace(terms[n], n, yelling)) {
                setTag(terms.slice(n, i + 1), "Place", world, null, "3-[place-of-foo]");
                continue;
            }
            break;
        }
        //loop forward - 'River of Foo...'
        // 'center of x'
        if (noBefore.has(str)) return false;
        for(let n = i + 1; n < terms.length; n += 1){
            if (isPlace(terms[n], n, yelling)) {
                setTag(terms.slice(i, n + 1), "Place", world, null, "3-[foo-place]");
                return true;
            }
            // 'municipal ...'
            if (terms[n].normal === "of" || placeCont.has(terms[n].normal)) continue;
            break;
        }
    }
    return null;
};
exports.default = tagOrgs;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bDpgu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fastTagJs = require("../_fastTag.js");
var _fastTagJsDefault = parcelHelpers.interopDefault(_fastTagJs);
var _fillTagsJs = require("./_fillTags.js");
var _fillTagsJsDefault = parcelHelpers.interopDefault(_fillTagsJs);
const nounFallback = function(terms, i, model) {
    let isEmpty = false;
    let tags = terms[i].tags;
    if (tags.size === 0) isEmpty = true;
    else if (tags.size === 1) // weaker tags to ignore
    {
        if (tags.has("Hyphenated") || tags.has("HashTag") || tags.has("Prefix")) isEmpty = true;
    }
    if (isEmpty) {
        (0, _fastTagJsDefault.default)(terms[i], "Noun", "3-[fallback]");
        // try to give it singluar/plural tags, too
        (0, _fillTagsJsDefault.default)(terms, i, model);
        terms[i].confidence = 0.1;
    }
};
exports.default = nounFallback;

},{"../_fastTag.js":"3bfyU","./_fillTags.js":"8P204","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Zqts":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fillTagsJs = require("./_fillTags.js");
var _fillTagsJsDefault = parcelHelpers.interopDefault(_fillTagsJs);
var _adhocJs = require("./_adhoc.js");
var _adhocJsDefault = parcelHelpers.interopDefault(_adhocJs);
var process = require("c926ce5b056a8403");
const env = typeof process === "undefined" || !process.env ? self.env || {} : process.env // eslint-disable-line
;
const prefix = /^(under|over|mis|re|un|dis|semi)-?/;
const checkWord = (term, obj)=>{
    if (!term || !obj) return null;
    let str = term.normal || term.implicit;
    let found = null;
    if (obj.hasOwnProperty(str)) found = obj[str];
    if (found && env.DEBUG_TAGS) console.log(`
  \x1b[2m\x1b[3m     \u{2193} - '${str}' \x1b[0m`) //eslint-disable-line
    ;
    return found;
};
const checkTag = (term, obj = {}, tagSet)=>{
    if (!term || !obj) return null;
    // rough sort, so 'Noun' is after ProperNoun, etc
    let tags = Array.from(term.tags).sort((a, b)=>{
        let numA = tagSet[a] ? tagSet[a].parents.length : 0;
        let numB = tagSet[b] ? tagSet[b].parents.length : 0;
        return numA > numB ? -1 : 1;
    });
    let found = tags.find((tag)=>obj[tag]);
    if (found && env.DEBUG_TAGS) console.log(`  \x1b[2m\x1b[3m      \u{2193} - '${term.normal || term.implicit}' (#${found})  \x1b[0m`) //eslint-disable-line
    ;
    found = obj[found];
    return found;
};
const pickTag = function(terms, i, clues, model) {
    if (!clues) return null;
    const beforeIndex = terms[i - 1]?.text !== "also" ? i - 1 : Math.max(0, i - 2);
    const tagSet = model.one.tagSet;
    // look -> right word, first
    let tag = checkWord(terms[i + 1], clues.afterWords);
    // look <- left word, second
    tag = tag || checkWord(terms[beforeIndex], clues.beforeWords);
    // look <- left tag
    tag = tag || checkTag(terms[beforeIndex], clues.beforeTags, tagSet);
    // look -> right tag
    tag = tag || checkTag(terms[i + 1], clues.afterTags, tagSet);
    // console.log(clues)
    return tag;
};
// words like 'bob' that can change between two tags
const doSwitches = function(terms, i, world) {
    const model = world.model;
    const setTag = world.methods.one.setTag;
    const { switches, clues } = model.two;
    const term = terms[i];
    let str = term.normal || term.implicit || "";
    // support prefixes for switching words
    if (prefix.test(str) && !switches[str]) str = str.replace(prefix, "") // could use some guards, here
    ;
    if (term.switch) {
        let form = term.switch;
        // skip propernouns, acronyms, etc
        if (term.tags.has("Acronym") || term.tags.has("PhrasalVerb")) return;
        let tag = pickTag(terms, i, clues[form], model);
        // lean-harder on some variable forms
        if ((0, _adhocJsDefault.default)[form]) tag = (0, _adhocJsDefault.default)[form](terms, i) || tag;
        // did we find anything?
        if (tag) {
            // tag it
            setTag([
                term
            ], tag, world, null, `3-[switch] (${form})`);
            // add plural/singular etc.
            (0, _fillTagsJsDefault.default)(terms, i, model);
        } else if (env.DEBUG_TAGS) console.log(`\n -> X  - '${str}'  : (${form})  `) //eslint-disable-line
        ;
    }
};
exports.default = doSwitches;

},{"c926ce5b056a8403":"d5jf4","./_fillTags.js":"8P204","./_adhoc.js":"gxn6O","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gxn6O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isTitleCase = /^[A-Z][a-z]/;
const isCapital = (terms, i)=>{
    if (terms[i].tags.has("ProperNoun") && isTitleCase.test(terms[i].text)) return "Noun";
    return null;
};
const isAlone = (terms, i, tag)=>{
    if (i === 0 && !terms[1]) return tag;
    return null;
};
// 'a rental'
const isEndNoun = function(terms, i) {
    if (!terms[i + 1] && terms[i - 1] && terms[i - 1].tags.has("Determiner")) return "Noun";
    return null;
};
// the first word in the sentence
const isStart = function(terms, i, tag) {
    if (i === 0 && terms.length > 3) return tag;
    return null;
};
const adhoc = {
    "Adj|Gerund": (terms, i)=>{
        return isCapital(terms, i);
    },
    "Adj|Noun": (terms, i)=>{
        return isCapital(terms, i) || isEndNoun(terms, i);
    },
    "Actor|Verb": (terms, i)=>{
        return isCapital(terms, i);
    },
    "Adj|Past": (terms, i)=>{
        return isCapital(terms, i);
    },
    "Adj|Present": (terms, i)=>{
        return isCapital(terms, i);
    },
    "Noun|Gerund": (terms, i)=>{
        return isCapital(terms, i);
    },
    "Noun|Verb": (terms, i)=>{
        return i > 0 && isCapital(terms, i) || isAlone(terms, i, "Infinitive");
    },
    "Plural|Verb": (terms, i)=>{
        return isCapital(terms, i) || isAlone(terms, i, "PresentTense") || isStart(terms, i, "Plural");
    },
    "Person|Noun": (terms, i)=>{
        return isCapital(terms, i);
    },
    "Person|Verb": (terms, i)=>{
        if (i !== 0) return isCapital(terms, i);
        return null;
    },
    "Person|Adj": (terms, i)=>{
        if (i === 0 && terms.length > 1) return "Person";
        return isCapital(terms, i) ? "Person" : null;
    }
};
exports.default = adhoc;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"76meH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const beside = {
    there: true,
    this: true,
    it: true,
    him: true,
    her: true,
    us: true
};
// '[place] tea bags in hot water'
const imperative = function(terms, world) {
    const setTag = world.methods.one.setTag;
    const multiWords = world.model.one._multiCache || {};
    let t = terms[0];
    let isRight = t.switch === "Noun|Verb" || t.tags.has("Infinitive");
    if (isRight && terms.length >= 2) {
        // ensure rest of sentence is ok
        if (terms.length < 4 && !beside[terms[1].normal]) return;
        // avoid multi-noun words like '[board] room'
        if (!t.tags.has("PhrasalVerb") && multiWords.hasOwnProperty(t.normal)) return;
        // is the next word a noun? - 'compile information ..'
        let nextNoun = terms[1].tags.has("Noun") || terms[1].tags.has("Determiner");
        if (nextNoun) {
            // ensure no soon-verb -  'waste materials are ..'
            let soonVerb = terms.slice(1, 3).some((term)=>term.tags.has("Verb"));
            if (!soonVerb || t.tags.has("#PhrasalVerb")) setTag([
                t
            ], "Imperative", world, null, "3-[imperative]");
        }
    }
};
exports.default = imperative;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kWDbE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const toRoot = {
    // 'spencer's' -> 'spencer'
    "Possessive": (term)=>{
        let str = term.machine || term.normal || term.text;
        str = str.replace(/'s$/, "");
        return str;
    },
    // 'drinks' -> 'drink'
    "Plural": (term, world)=>{
        let str = term.machine || term.normal || term.text;
        return world.methods.two.transform.noun.toSingular(str, world.model);
    },
    // ''
    "Copula": ()=>{
        return "is";
    },
    // 'walked' -> 'walk'
    "PastTense": (term, world)=>{
        let str = term.machine || term.normal || term.text;
        return world.methods.two.transform.verb.toInfinitive(str, world.model, "PastTense");
    },
    // 'walking' -> 'walk'
    "Gerund": (term, world)=>{
        let str = term.machine || term.normal || term.text;
        return world.methods.two.transform.verb.toInfinitive(str, world.model, "Gerund");
    },
    // 'walks' -> 'walk'
    "PresentTense": (term, world)=>{
        let str = term.machine || term.normal || term.text;
        if (term.tags.has("Infinitive")) return str;
        return world.methods.two.transform.verb.toInfinitive(str, world.model, "PresentTense");
    },
    // 'quieter' -> 'quiet'
    "Comparative": (term, world)=>{
        let str = term.machine || term.normal || term.text;
        return world.methods.two.transform.adjective.fromComparative(str, world.model);
    },
    // 'quietest' -> 'quiet'
    "Superlative": (term, world)=>{
        let str = term.machine || term.normal || term.text;
        return world.methods.two.transform.adjective.fromSuperlative(str, world.model);
    },
    // 'suddenly' -> 'sudden'
    "Adverb": (term, world)=>{
        const { fromAdverb } = world.methods.two.transform.adjective;
        let str = term.machine || term.normal || term.text;
        return fromAdverb(str);
    }
};
const getRoot = function(view) {
    const world = view.world;
    const keys = Object.keys(toRoot);
    view.docs.forEach((terms)=>{
        for(let i = 0; i < terms.length; i += 1){
            const term = terms[i];
            for(let k = 0; k < keys.length; k += 1)if (term.tags.has(keys[k])) {
                const fn = toRoot[keys[k]];
                let root = fn(term, world);
                if (term.normal !== root) term.root = root;
                break;
            }
        }
    });
};
exports.default = getRoot;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aI8RV":[function(require,module,exports) {
// rough connection between compromise tagset and Penn Treebank
// https://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const mapping = {
    // adverbs
    // 'Comparative': 'RBR',
    // 'Superlative': 'RBS',
    "Adverb": "RB",
    // adjectives
    "Comparative": "JJR",
    "Superlative": "JJS",
    "Adjective": "JJ",
    "TO": "Conjunction",
    // verbs
    "Modal": "MD",
    "Auxiliary": "MD",
    "Gerund": "VBG",
    "PastTense": "VBD",
    "Participle": "VBN",
    "PresentTense": "VBZ",
    "Infinitive": "VB",
    "Particle": "RP",
    "Verb": "VB",
    // pronouns
    "Pronoun": "PRP",
    // misc
    "Cardinal": "CD",
    "Conjunction": "CC",
    "Determiner": "DT",
    "Preposition": "IN",
    // 'Determiner': 'WDT',
    // 'Expression': 'FW',
    "QuestionWord": "WP",
    "Expression": "UH",
    //nouns
    "Possessive": "POS",
    "ProperNoun": "NNP",
    "Person": "NNP",
    "Place": "NNP",
    "Organization": "NNP",
    "Singular": "NNP",
    "Plural": "NNS",
    "Noun": "NN",
    "There": "EX"
};
const toPenn = function(term) {
    // try some ad-hoc ones
    if (term.tags.has("ProperNoun") && term.tags.has("Plural")) return "NNPS";
    if (term.tags.has("Possessive") && term.tags.has("Pronoun")) return "PRP$";
    if (term.normal === "there") return "EX";
    if (term.normal === "to") return "TO";
    // run through an ordered list of tags
    let arr = term.tagRank || [];
    for(let i = 0; i < arr.length; i += 1){
        if (mapping.hasOwnProperty(arr[i])) return mapping[arr[i]];
    }
    return null;
};
const pennTag = function(view) {
    view.compute("tagRank");
    view.docs.forEach((terms)=>{
        terms.forEach((term)=>{
            term.penn = toPenn(term);
        });
    });
};
exports.default = pennTag;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dtblM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nounsJs = require("./nouns.js");
var _nounsJsDefault = parcelHelpers.interopDefault(_nounsJs);
var _verbsJs = require("./verbs.js");
var _verbsJsDefault = parcelHelpers.interopDefault(_verbsJs);
var _valuesJs = require("./values.js");
var _valuesJsDefault = parcelHelpers.interopDefault(_valuesJs);
var _datesJs = require("./dates.js");
var _datesJsDefault = parcelHelpers.interopDefault(_datesJs);
var _miscJs = require("./misc.js");
var _miscJsDefault = parcelHelpers.interopDefault(_miscJs);
let allTags = Object.assign({}, (0, _nounsJsDefault.default), (0, _verbsJsDefault.default), (0, _valuesJsDefault.default), (0, _datesJsDefault.default), (0, _miscJsDefault.default));
// const tagSet = compute(allTags)
exports.default = allTags;

},{"./nouns.js":"iVVng","./verbs.js":"iZath","./values.js":"3nvn8","./dates.js":"5qYXC","./misc.js":"hKQuo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iVVng":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const entity = [
    "Person",
    "Place",
    "Organization"
];
exports.default = {
    Noun: {
        not: [
            "Verb",
            "Adjective",
            "Adverb",
            "Value",
            "Determiner"
        ]
    },
    Singular: {
        is: "Noun",
        not: [
            "Plural",
            "Uncountable"
        ]
    },
    // 'Canada'
    ProperNoun: {
        is: "Noun"
    },
    Person: {
        is: "Singular",
        also: [
            "ProperNoun"
        ],
        not: [
            "Place",
            "Organization",
            "Date"
        ]
    },
    FirstName: {
        is: "Person"
    },
    MaleName: {
        is: "FirstName",
        not: [
            "FemaleName",
            "LastName"
        ]
    },
    FemaleName: {
        is: "FirstName",
        not: [
            "MaleName",
            "LastName"
        ]
    },
    LastName: {
        is: "Person",
        not: [
            "FirstName"
        ]
    },
    // 'dr.'
    Honorific: {
        is: "Person",
        not: [
            "FirstName",
            "LastName",
            "Value"
        ]
    },
    Place: {
        is: "Singular",
        not: [
            "Person",
            "Organization"
        ]
    },
    Country: {
        is: "Place",
        also: [
            "ProperNoun"
        ],
        not: [
            "City"
        ]
    },
    City: {
        is: "Place",
        also: [
            "ProperNoun"
        ],
        not: [
            "Country"
        ]
    },
    // 'california'
    Region: {
        is: "Place",
        also: [
            "ProperNoun"
        ]
    },
    Address: {
    },
    Organization: {
        is: "ProperNoun",
        not: [
            "Person",
            "Place"
        ]
    },
    SportsTeam: {
        is: "Organization"
    },
    School: {
        is: "Organization"
    },
    Company: {
        is: "Organization"
    },
    Plural: {
        is: "Noun",
        not: [
            "Singular",
            "Uncountable"
        ]
    },
    // 'gravity'
    Uncountable: {
        is: "Noun"
    },
    // 'it'
    Pronoun: {
        is: "Noun",
        not: entity
    },
    // 'swimmer'
    Actor: {
        is: "Noun",
        not: [
            "Place",
            "Organization"
        ]
    },
    // walking
    Activity: {
        is: "Noun",
        not: [
            "Person",
            "Place"
        ]
    },
    // kilometres
    Unit: {
        is: "Noun",
        not: entity
    },
    // canadian
    Demonym: {
        is: "Noun",
        also: [
            "ProperNoun"
        ],
        not: entity
    },
    // [spencer's] hat
    Possessive: {
        is: "Noun"
    },
    // 'yourself'
    Reflexive: {
        is: "Pronoun"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iZath":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    Verb: {
        not: [
            "Noun",
            "Adjective",
            "Adverb",
            "Value",
            "Expression"
        ]
    },
    // 'he [walks]'
    PresentTense: {
        is: "Verb",
        not: [
            "PastTense",
            "FutureTense"
        ]
    },
    // 'will [walk]'
    Infinitive: {
        is: "PresentTense",
        not: [
            "Gerund"
        ]
    },
    // '[walk] now!'
    Imperative: {
        is: "Verb",
        not: [
            "PastTense",
            "Gerund",
            "Copula"
        ]
    },
    // walking
    Gerund: {
        is: "PresentTense",
        not: [
            "Copula"
        ]
    },
    // walked
    PastTense: {
        is: "Verb",
        not: [
            "PresentTense",
            "Gerund",
            "FutureTense"
        ]
    },
    // will walk
    FutureTense: {
        is: "Verb",
        not: [
            "PresentTense",
            "PastTense"
        ]
    },
    // is/was
    Copula: {
        is: "Verb"
    },
    // '[could] walk'
    Modal: {
        is: "Verb",
        not: [
            "Infinitive"
        ]
    },
    // 'awaken'
    Participle: {
        is: "PastTense"
    },
    // '[will have had] walked'
    Auxiliary: {
        is: "Verb",
        not: [
            "PastTense",
            "PresentTense",
            "Gerund",
            "Conjunction"
        ]
    },
    // 'walk out'
    PhrasalVerb: {
        is: "Verb"
    },
    // 'walk [out]'
    Particle: {
        is: "PhrasalVerb",
        not: [
            "PastTense",
            "PresentTense",
            "Copula",
            "Gerund"
        ]
    },
    // 'walked by'
    Passive: {
        is: "Verb"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3nvn8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    Value: {
        not: [
            "Verb",
            "Adjective",
            "Adverb"
        ]
    },
    Ordinal: {
        is: "Value",
        not: [
            "Cardinal"
        ]
    },
    Cardinal: {
        is: "Value",
        not: [
            "Ordinal"
        ]
    },
    Fraction: {
        is: "Value",
        not: [
            "Noun"
        ]
    },
    Multiple: {
        is: "TextValue"
    },
    RomanNumeral: {
        is: "Cardinal",
        not: [
            "TextValue"
        ]
    },
    TextValue: {
        is: "Value",
        not: [
            "NumericValue"
        ]
    },
    NumericValue: {
        is: "Value",
        not: [
            "TextValue"
        ]
    },
    Money: {
        is: "Cardinal"
    },
    Percent: {
        is: "Value"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5qYXC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    Date: {
        not: [
            "Verb",
            "Adverb",
            "Adjective"
        ]
    },
    Month: {
        is: "Date",
        also: [
            "Noun"
        ],
        not: [
            "Year",
            "WeekDay",
            "Time"
        ]
    },
    WeekDay: {
        is: "Date",
        also: [
            "Noun"
        ]
    },
    Year: {
        is: "Date",
        not: [
            "RomanNumeral"
        ]
    },
    FinancialQuarter: {
        is: "Date",
        not: "Fraction"
    },
    // 'easter'
    Holiday: {
        is: "Date",
        also: [
            "Noun"
        ]
    },
    // 'summer'
    Season: {
        is: "Date"
    },
    Timezone: {
        is: "Date",
        also: [
            "Noun"
        ],
        not: [
            "ProperNoun"
        ]
    },
    Time: {
        is: "Date",
        not: [
            "AtMention"
        ]
    },
    // 'months'
    Duration: {
        is: "Date",
        also: [
            "Noun"
        ]
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hKQuo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const anything = [
    "Noun",
    "Verb",
    "Adjective",
    "Adverb",
    "Value",
    "QuestionWord"
];
exports.default = {
    Adjective: {
        not: [
            "Noun",
            "Verb",
            "Adverb",
            "Value"
        ]
    },
    Comparable: {
        is: "Adjective"
    },
    Comparative: {
        is: "Adjective"
    },
    Superlative: {
        is: "Adjective",
        not: [
            "Comparative"
        ]
    },
    NumberRange: {},
    Adverb: {
        not: [
            "Noun",
            "Verb",
            "Adjective",
            "Value"
        ]
    },
    Determiner: {
        not: [
            "Noun",
            "Verb",
            "Adjective",
            "Adverb",
            "QuestionWord",
            "Conjunction"
        ]
    },
    Conjunction: {
        not: anything
    },
    Preposition: {
        not: [
            "Noun",
            "Verb",
            "Adjective",
            "Adverb",
            "QuestionWord",
            "Determiner"
        ]
    },
    QuestionWord: {
        not: [
            "Determiner"
        ]
    },
    Currency: {
        is: "Noun"
    },
    Expression: {
        not: [
            "Noun",
            "Adjective",
            "Verb",
            "Adverb"
        ]
    },
    Abbreviation: {},
    Url: {
        not: [
            "HashTag",
            "PhoneNumber",
            "Verb",
            "Adjective",
            "Value",
            "AtMention",
            "Email"
        ]
    },
    PhoneNumber: {
        not: [
            "HashTag",
            "Verb",
            "Adjective",
            "Value",
            "AtMention",
            "Email"
        ]
    },
    HashTag: {},
    AtMention: {
        is: "Noun",
        not: [
            "HashTag",
            "Email"
        ]
    },
    Emoji: {
        not: [
            "HashTag",
            "Verb",
            "Adjective",
            "Value",
            "AtMention"
        ]
    },
    Emoticon: {
        not: [
            "HashTag",
            "Verb",
            "Adjective",
            "Value",
            "AtMention"
        ]
    },
    Email: {
        not: [
            "HashTag",
            "Verb",
            "Adjective",
            "Value",
            "AtMention"
        ]
    },
    Acronym: {
        not: [
            "Plural",
            "RomanNumeral",
            "Pronoun",
            "Date"
        ]
    },
    Negative: {
        not: [
            "Noun",
            "Adjective",
            "Value",
            "Expression"
        ]
    },
    Condition: {
        not: [
            "Verb",
            "Adjective",
            "Noun",
            "Value"
        ]
    },
    // existential 'there'
    There: {
        not: [
            "Verb",
            "Adjective",
            "Noun",
            "Value",
            "Conjunction",
            "Preposition"
        ]
    },
    // 'co-wrote'
    Prefix: {
        not: [
            "Abbreviation",
            "Acronym",
            "ProperNoun"
        ]
    },
    // hard-nosed, bone-headed
    Hyphenated: {}
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dOxY6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./api/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./compute/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
exports.default = {
    compute: (0, _indexJsDefault1.default),
    api: (0, _indexJsDefault.default),
    hooks: [
        "contractionTwo"
    ]
};

},{"./api/index.js":"4nvUo","./compute/index.js":"gXnow","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4nvUo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _contractJs = require("./contract.js");
var _contractJsDefault = parcelHelpers.interopDefault(_contractJs);
const titleCase = /^\p{Lu}[\p{Ll}'’]/u //upercase, then lowercase
;
const toTitleCase = function(str = "") {
    str = str.replace(/^ *[a-z\u00C0-\u00FF]/, (x)=>x.toUpperCase()) //TODO: support unicode
    ;
    return str;
};
const api = function(View) {
    /** */ class Contractions extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Contraction";
        }
        /** i've -> 'i have' */ expand() {
            this.docs.forEach((terms)=>{
                let isTitleCase = titleCase.test(terms[0].text);
                terms.forEach((t, i)=>{
                    t.text = t.implicit || "";
                    delete t.implicit;
                    //add whitespace
                    if (i < terms.length - 1 && t.post === "") t.post += " ";
                    // flag it as dirty
                    t.dirty = true;
                });
                // make the first word title-case?
                if (isTitleCase) terms[0].text = toTitleCase(terms[0].text);
            });
            this.compute("normal") //re-set normalized text
            ;
            return this;
        }
    }
    // add fn to View
    View.prototype.contractions = function() {
        let m = this.match("@hasContraction+");
        return new Contractions(this.document, m.pointer);
    };
    View.prototype.contract = (0, _contractJsDefault.default);
};
exports.default = api;

},{"./contract.js":"fcsyr","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fcsyr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const postPunct = /[,)"';:\-–—.…]/;
const setContraction = function(m, suffix) {
    if (!m.found) return;
    let terms = m.termList();
    //avoid any problematic punctuation
    for(let i = 0; i < terms.length - 1; i++){
        const t = terms[i];
        if (postPunct.test(t.post)) return;
    }
    // set first word as full text
    terms[0].implicit = terms[0].normal;
    terms[0].text += suffix;
    terms[0].normal += suffix;
    // clean-up the others
    terms.slice(1).forEach((t)=>{
        t.implicit = t.normal;
        t.text = "";
        t.normal = "";
    });
    for(let i = 0; i < terms.length - 1; i++)terms[i].post = terms[i].post.replace(/ /, "");
};
/** turn 'i am' into i'm */ const contract = function() {
    let doc = this.not("@hasContraction");
    // we are -> we're
    let m = doc.match("(we|they|you) are");
    setContraction(m, `'re`);
    // they will -> they'll
    m = doc.match("(he|she|they|it|we|you) will");
    setContraction(m, `'ll`);
    // she is -> she's
    m = doc.match("(he|she|they|it|we) is");
    setContraction(m, `'s`);
    // spencer is -> spencer's
    m = doc.match("#Person is");
    setContraction(m, `'s`);
    // spencer would -> spencer'd
    m = doc.match("#Person would");
    setContraction(m, `'d`);
    // would not -> wouldn't
    m = doc.match("(is|was|had|would|should|could|do|does|have|has|can) not");
    setContraction(m, `n't`);
    // i have -> i've
    m = doc.match("(i|we|they) have");
    setContraction(m, `'ve`);
    // would have -> would've
    m = doc.match("(would|should|could) have");
    setContraction(m, `'ve`);
    // i am -> i'm
    m = doc.match("i am");
    setContraction(m, `'m`);
    // going to -> gonna
    m = doc.match("going to");
    return this;
};
exports.default = contract;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gXnow":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _spliceJs = require("./_splice.js");
var _spliceJsDefault = parcelHelpers.interopDefault(_spliceJs);
var _apostropheSJs = require("./apostrophe-s.js");
var _apostropheSJsDefault = parcelHelpers.interopDefault(_apostropheSJs);
var _apostropheDJs = require("./apostrophe-d.js");
var _apostropheDJsDefault = parcelHelpers.interopDefault(_apostropheDJs);
var _apostropheTJs = require("./apostrophe-t.js");
var _apostropheTJsDefault = parcelHelpers.interopDefault(_apostropheTJs);
var _isPossessiveJs = require("./isPossessive.js");
var _isPossessiveJsDefault = parcelHelpers.interopDefault(_isPossessiveJs);
const byApostrophe = /'/;
// poor-mans reindexing of this sentence only
const reIndex = function(terms) {
    terms.forEach((t, i)=>{
        if (t.index) t.index[1] = i;
    });
};
// run tagger on our new implicit terms
const reTag = function(terms, view, start, len) {
    let tmp = view.update();
    tmp.document = [
        terms
    ];
    // offer to re-tag neighbours, too
    let end = start + len;
    if (start > 0) start -= 1;
    if (terms[end]) end += 1;
    tmp.ptrs = [
        [
            0,
            start,
            end
        ]
    ];
    tmp.compute([
        "lexicon",
        "preTagger"
    ]);
    // don't for a reindex of the whole document
    reIndex(terms);
};
const byEnd = {
    // how'd
    d: (terms, i)=>(0, _apostropheDJsDefault.default)(terms, i),
    // we ain't
    t: (terms, i)=>(0, _apostropheTJsDefault.default)(terms, i),
    // bob's
    s: (terms, i, world)=>{
        // [bob's house] vs [bob's cool]
        if ((0, _isPossessiveJsDefault.default)(terms, i)) return world.methods.one.setTag([
            terms[i]
        ], "Possessive", world, null, "2-contraction");
        return (0, _apostropheSJsDefault.default)(terms, i);
    }
};
const toDocs = function(words, view) {
    let doc = view.fromText(words.join(" "));
    doc.compute("id");
    return doc.docs[0];
};
//really easy ones
const contractionTwo = (view)=>{
    let { world, document } = view;
    // each sentence
    document.forEach((terms, n)=>{
        // loop through terms backwards
        for(let i = terms.length - 1; i >= 0; i -= 1){
            // is it already a contraction
            if (terms[i].implicit) return;
            let after = null;
            if (byApostrophe.test(terms[i].normal) === true) after = terms[i].normal.split(byApostrophe)[1];
            let words = null;
            // any known-ones, like 'dunno'?
            if (byEnd.hasOwnProperty(after)) words = byEnd[after](terms, i, world);
            // actually insert the new terms
            if (words) {
                words = toDocs(words, view);
                (0, _spliceJsDefault.default)(document, [
                    n,
                    i
                ], words);
                reTag(document[n], view, i, words.length);
                continue;
            }
        }
    });
};
exports.default = {
    contractionTwo
};

},{"./_splice.js":"e2v9e","./apostrophe-s.js":"fRnkR","./apostrophe-d.js":"9luX8","./apostrophe-t.js":"cX3VX","./isPossessive.js":"fq6YH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e2v9e":[function(require,module,exports) {
// put n new words where 1 word was
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const insertContraction = function(document, point, words) {
    let [n, w] = point;
    if (!words || words.length === 0) return;
    words = words.map((word, i)=>{
        word.implicit = word.text;
        word.machine = word.text;
        word.pre = "";
        word.post = "";
        word.text = "";
        word.normal = "";
        word.index = [
            n,
            w + i
        ];
        return word;
    });
    if (words[0]) {
        // move whitespace over
        words[0].pre = document[n][w].pre;
        words[words.length - 1].post = document[n][w].post;
        // add the text/normal to the first term
        words[0].text = document[n][w].text;
        words[0].normal = document[n][w].normal // move tags too?
        ;
    }
    // do the splice
    document[n].splice(w, 1, ...words);
};
exports.default = insertContraction;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fRnkR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const hasContraction = /'/;
const hasWords = new Set([
    "been",
    "become"
]);
const isWords = new Set([
    "what",
    "how",
    "when",
    "if",
    "too"
]);
let adjLike = new Set([
    "too",
    "also",
    "enough"
]);
// the big clue is the tense of the following verb
const isOrHas = (terms, i)=>{
    // scan ahead for the next verb or adjective
    for(let o = i + 1; o < terms.length; o += 1){
        let t = terms[o];
        if (hasWords.has(t.normal)) return "has";
        if (isWords.has(t.normal)) return "is";
        // the cat's sleeping
        if (t.tags.has("Gerund")) return "is";
        // she's the one
        if (t.tags.has("Determiner")) return "is";
        // the food's ready
        if (t.tags.has("Adjective")) return "is";
        // the car's parked
        if (t.switch === "Adj|Past") {
            if (terms[o + 1]) {
                // car's parked too ..
                if (adjLike.has(terms[o + 1].normal)) return "is";
                // car's parked on ..
                if (terms[o + 1].tags.has("Preposition")) return "is";
            }
        }
        // The meeting's scheduled vs The plane's landed
        if (t.tags.has("PastTense")) {
            // meeting's scheduled for
            if (terms[o + 1] && terms[o + 1].normal === "for") return "is";
            return "has";
        }
    }
    return "is";
};
// 's -> [possessive, 'has', 'is', 'are', 'us']
const apostropheS = function(terms, i) {
    // possessive, is/has
    let before = terms[i].normal.split(hasContraction)[0];
    // let's - >[let, us]
    if (before === "let") return [
        before,
        "us"
    ];
    // allow slang "there's cookies" -> there are
    if (before === "there") {
        let t = terms[i + 1];
        if (t && t.tags.has("Plural")) return [
            before,
            "are"
        ];
    }
    // spencer's got -> spencer has got
    if (isOrHas(terms, i) === "has") return [
        before,
        "has"
    ];
    return [
        before,
        "is"
    ];
};
exports.default = apostropheS;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9luX8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const hasContraction = /'/;
const hadWords = new Set([
    "better",
    "done",
    "before",
    "it",
    "had"
]);
const wouldWords = new Set([
    "have",
    "be"
]);
//look for a past-tense verb
// You'd mentioned -> you had mentioned
// You'd mention -> you would mention
const hadOrWould = (terms, i)=>{
    // scan ahead
    for(let o = i + 1; o < terms.length; o += 1){
        let t = terms[o];
        // you'd better go
        if (hadWords.has(t.normal)) return "had";
        // we'd have
        if (wouldWords.has(t.normal)) return "would";
        // You'd mentioned -> you had mentioned
        if (t.tags.has("PastTense") || t.switch === "Adj|Past") return "had";
        // You'd mention -> you would mention
        if (t.tags.has("PresentTense") || t.tags.has("Infinitive")) return "would";
        // i'd an issue
        if (t.tags.has("#Determiner")) return "had";
        if (t.tags.has("Adjective")) return "would";
    }
    return false;
};
// he'd walked -> had
// how'd -> did
// he'd go -> would
const _apostropheD = function(terms, i) {
    let before = terms[i].normal.split(hasContraction)[0];
    // what'd, how'd
    if (before === "how" || before === "what") return [
        before,
        "did"
    ];
    if (hadOrWould(terms, i) === "had") return [
        before,
        "had"
    ];
    // had/would/did
    return [
        before,
        "would"
    ];
};
exports.default = _apostropheD;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cX3VX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const lastNoun = function(terms, i) {
    for(let n = i - 1; n >= 0; n -= 1){
        if (terms[n].tags.has("Noun") || terms[n].tags.has("Pronoun") || terms[n].tags.has("Plural") || terms[n].tags.has("Singular")) return terms[n];
    }
    return null;
};
//ain't -> are/is not
const apostropheT = function(terms, i) {
    if (terms[i].normal === "ain't" || terms[i].normal === "aint") {
        // "ain't never" -> have never (?)
        if (terms[i + 1] && terms[i + 1].normal === "never") return [
            "have"
        ];
        // we aint -> are not,   she aint -> is not
        let noun = lastNoun(terms, i);
        if (noun) {
            // plural/singular pronouns
            if (noun.normal === "we" || noun.normal === "they") return [
                "are",
                "not"
            ];
            if (noun.normal === "i") return [
                "am",
                "not"
            ];
            // plural/singular tags
            if (noun.tags && noun.tags.has("Plural")) return [
                "are",
                "not"
            ];
        }
        return [
            "is",
            "not"
        ];
    }
    let before = terms[i].normal.replace(/n't/, "");
    return [
        before,
        "not"
    ];
};
exports.default = apostropheT;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fq6YH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const banList = {
    that: true,
    there: true,
    let: true,
    here: true,
    everywhere: true
};
const beforePossessive = {
    in: true,
    by: true,
    for: true
};
let adjLike = new Set([
    "too",
    "also",
    "enough",
    "about"
]);
let nounLike = new Set([
    "is",
    "are",
    "did",
    "were",
    "could",
    "should",
    "must",
    "had",
    "have"
]);
const isPossessive = (terms, i)=>{
    let term = terms[i];
    // these can't be possessive
    if (banList.hasOwnProperty(term.machine || term.normal)) return false;
    // if we already know it
    if (term.tags.has("Possessive")) return true;
    // who's
    if (term.tags.has("QuestionWord")) return false;
    // some pronouns are never possessive
    if (term.normal === `he's` || term.normal === `she's`) return false;
    //if end of sentence, it is possessive - "was spencer's"
    let nextTerm = terms[i + 1];
    if (!nextTerm) return true;
    // "it's a life" vs "run it's business"
    if (term.normal === `it's`) {
        if (nextTerm.tags.has("#Noun")) return true;
        return false;
    }
    // the sun's setting vs the artist's painting
    // gerund = is,  noun = possessive
    // (we are doing some dupe-work of the switch classifier here)
    if (nextTerm.switch == "Noun|Gerund") {
        let next2 = terms[i + 2];
        // the artist's painting.
        if (!next2) {
            if (term.tags.has("Actor") || term.tags.has("ProperNoun")) return true;
            return false;
        }
        // the artist's painting is..
        if (next2.tags.has("Copula")) return true;
        // the cat's sleeping on ..
        if (next2.normal === "on" || next2.normal === "in") return false;
        return false;
    }
    //a gerund suggests 'is walking'
    if (nextTerm.tags.has("Verb")) {
        //fix 'jamie's bite'
        if (nextTerm.tags.has("Infinitive")) return true;
        //'jamaica's growing'
        if (nextTerm.tags.has("Gerund")) return false;
        //fix 'spencer's runs'
        if (nextTerm.tags.has("PresentTense")) return true;
        return false;
    }
    // john's nuts
    if (nextTerm.switch === "Adj|Noun") {
        let twoTerm = terms[i + 2];
        if (!twoTerm) return false //adj
        ;
        // john's nuts were..
        if (nounLike.has(twoTerm.normal)) return true;
        // john's nuts about..
        if (adjLike.has(twoTerm.normal)) return false //adj
        ;
    }
    //spencer's house
    if (nextTerm.tags.has("Noun")) {
        let nextStr = nextTerm.machine || nextTerm.normal;
        // 'spencer's here'
        if (nextStr === "here" || nextStr === "there" || nextStr === "everywhere") return false;
        // the chair's his
        if (nextTerm.tags.has("Possessive")) return false;
        // the captain's John
        if (nextTerm.tags.has("ProperNoun") && !term.tags.has("ProperNoun")) return false;
        return true;
    }
    // by sunday's final
    if (terms[i - 1] && beforePossessive[terms[i - 1].normal] === true) return true;
    // spencer's tired
    if (nextTerm.tags.has("Adjective")) {
        let twoTerm = terms[i + 2];
        //the rocket's red
        if (!twoTerm) return false;
        // rocket's red nozzle
        if (twoTerm.tags.has("Noun") && !twoTerm.tags.has("Pronoun")) {
            //project's behind schedule
            let str = nextTerm.normal;
            if (str === "above" || str === "below" || str === "behind") return false;
            return true;
        }
        // rocket's red glare
        if (twoTerm.switch === "Noun|Verb") return true;
        //othwerwise, an adjective suggests 'is good'
        return false;
    }
    // baby's first steps
    if (nextTerm.tags.has("Value")) return true;
    // otherwise not possessive
    return false;
};
exports.default = isPossessive;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9nqPx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./model/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./compute/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _apiJs = require("./api.js");
var _apiJsDefault = parcelHelpers.interopDefault(_apiJs);
const plugin = {
    api: (0, _apiJsDefault.default),
    compute: (0, _indexJsDefault1.default),
    model: (0, _indexJsDefault.default),
    hooks: [
        "postTagger"
    ]
};
exports.default = plugin;

},{"./model/index.js":"8VsCx","./compute/index.js":"2jLJz","./api.js":"fXnP3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8VsCx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _adjectiveJs = require("./adjective/adjective.js");
var _adjectiveJsDefault = parcelHelpers.interopDefault(_adjectiveJs);
var _adjAdverbJs = require("./adjective/adj-adverb.js");
var _adjAdverbJsDefault = parcelHelpers.interopDefault(_adjAdverbJs);
var _adjGerundJs = require("./adjective/adj-gerund.js");
var _adjGerundJsDefault = parcelHelpers.interopDefault(_adjGerundJs);
var _adjNounJs = require("./adjective/adj-noun.js");
var _adjNounJsDefault = parcelHelpers.interopDefault(_adjNounJs);
var _adjVerbJs = require("./adjective/adj-verb.js");
var _adjVerbJsDefault = parcelHelpers.interopDefault(_adjVerbJs);
var _adverbJs = require("./adverb.js");
var _adverbJsDefault = parcelHelpers.interopDefault(_adverbJs);
var _datePhraseJs = require("./dates/date-phrase.js");
var _datePhraseJsDefault = parcelHelpers.interopDefault(_datePhraseJs);
var _dateJs = require("./dates/date.js");
var _dateJsDefault = parcelHelpers.interopDefault(_dateJs);
var _nounsJs = require("./nouns/nouns.js");
var _nounsJsDefault = parcelHelpers.interopDefault(_nounsJs);
var _nounGerundJs = require("./verbs/noun-gerund.js");
var _nounGerundJsDefault = parcelHelpers.interopDefault(_nounGerundJs);
var _verbNounJs = require("./verbs/verb-noun.js");
var _verbNounJsDefault = parcelHelpers.interopDefault(_verbNounJs);
var _moneyJs = require("./numbers/money.js");
var _moneyJsDefault = parcelHelpers.interopDefault(_moneyJs);
var _fractionsJs = require("./numbers/fractions.js");
var _fractionsJsDefault = parcelHelpers.interopDefault(_fractionsJs);
var _numbersJs = require("./numbers/numbers.js");
var _numbersJsDefault = parcelHelpers.interopDefault(_numbersJs);
var _personPhraseJs = require("./person/person-phrase.js");
var _personPhraseJsDefault = parcelHelpers.interopDefault(_personPhraseJs);
var _ambigNameJs = require("./person/ambig-name.js");
var _ambigNameJsDefault = parcelHelpers.interopDefault(_ambigNameJs);
var _verbsJs = require("./verbs/verbs.js");
var _verbsJsDefault = parcelHelpers.interopDefault(_verbsJs);
var _auxiliaryJs = require("./verbs/auxiliary.js");
var _auxiliaryJsDefault = parcelHelpers.interopDefault(_auxiliaryJs);
var _phrasalJs = require("./verbs/phrasal.js");
var _phrasalJsDefault = parcelHelpers.interopDefault(_phrasalJs);
var _imperativeJs = require("./verbs/imperative.js");
var _imperativeJsDefault = parcelHelpers.interopDefault(_imperativeJs);
var _adjGerundJs1 = require("./verbs/adj-gerund.js");
var _adjGerundJsDefault1 = parcelHelpers.interopDefault(_adjGerundJs1);
var _passiveJs = require("./verbs/passive.js");
var _passiveJsDefault = parcelHelpers.interopDefault(_passiveJs);
var _miscJs = require("./_misc.js");
var _miscJsDefault = parcelHelpers.interopDefault(_miscJs);
var _organizationsJs = require("./nouns/organizations.js");
var _organizationsJsDefault = parcelHelpers.interopDefault(_organizationsJs);
var _placesJs = require("./nouns/places.js");
var _placesJsDefault = parcelHelpers.interopDefault(_placesJs);
var _conjunctionsJs = require("./conjunctions.js");
var _conjunctionsJsDefault = parcelHelpers.interopDefault(_conjunctionsJs);
var _expressionsJs = require("./expressions.js");
var _expressionsJsDefault = parcelHelpers.interopDefault(_expressionsJs);
let matches = [].concat(// order matters top-matches can get overwritten
(0, _passiveJsDefault.default), (0, _adjectiveJsDefault.default), (0, _adjAdverbJsDefault.default), (0, _adjGerundJsDefault.default), (0, _adjNounJsDefault.default), (0, _adverbJsDefault.default), (0, _dateJsDefault.default), (0, _datePhraseJsDefault.default), (0, _nounsJsDefault.default), (0, _nounGerundJsDefault.default), (0, _verbNounJsDefault.default), (0, _moneyJsDefault.default), (0, _fractionsJsDefault.default), (0, _numbersJsDefault.default), (0, _personPhraseJsDefault.default), (0, _ambigNameJsDefault.default), (0, _verbsJsDefault.default), (0, _adjVerbJsDefault.default), (0, _auxiliaryJsDefault.default), (0, _phrasalJsDefault.default), (0, _imperativeJsDefault.default), (0, _adjGerundJsDefault1.default), (0, _miscJsDefault.default), (0, _organizationsJsDefault.default), (0, _placesJsDefault.default), (0, _conjunctionsJsDefault.default), (0, _expressionsJsDefault.default));
exports.default = {
    two: {
        matches
    }
};

},{"./adjective/adjective.js":"7efAz","./adjective/adj-adverb.js":"JSav0","./adjective/adj-gerund.js":"jLaNm","./adjective/adj-noun.js":"j9vsI","./adjective/adj-verb.js":"9rAhb","./adverb.js":"gDed7","./dates/date-phrase.js":"iKMdO","./dates/date.js":"1Fpkw","./nouns/nouns.js":"9dGTS","./verbs/noun-gerund.js":"4DT40","./verbs/verb-noun.js":"lhx8B","./numbers/money.js":"ldRTY","./numbers/fractions.js":"eZfrx","./numbers/numbers.js":"cRv8N","./person/person-phrase.js":"ltTxJ","./person/ambig-name.js":"8YJwh","./verbs/verbs.js":"kXYMe","./verbs/auxiliary.js":"404yk","./verbs/phrasal.js":"3pcVs","./verbs/imperative.js":"77RD5","./verbs/adj-gerund.js":"lGbvK","./verbs/passive.js":"lhq7x","./_misc.js":"lCWzM","./nouns/organizations.js":"farKF","./nouns/places.js":"34MN7","./conjunctions.js":"52isX","./expressions.js":"7abZ7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7efAz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // all fell apart
    {
        match: "[(all|both)] #Determiner #Noun",
        group: 0,
        tag: "Noun",
        reason: "all-noun"
    },
    //sometimes not-adverbs
    {
        match: "#Copula [(just|alone)]$",
        group: 0,
        tag: "Adjective",
        reason: "not-adverb"
    },
    //jack is guarded
    {
        match: "#Singular is #Adverb? [#PastTense$]",
        group: 0,
        tag: "Adjective",
        reason: "is-filled"
    },
    // smoked poutine is
    {
        match: "[#PastTense] #Singular is",
        group: 0,
        tag: "Adjective",
        reason: "smoked-poutine"
    },
    // baked onions are
    {
        match: "[#PastTense] #Plural are",
        group: 0,
        tag: "Adjective",
        reason: "baked-onions"
    },
    // well made
    {
        match: "well [#PastTense]",
        group: 0,
        tag: "Adjective",
        reason: "well-made"
    },
    // is f*ed up
    {
        match: "#Copula [fucked up?]",
        group: 0,
        tag: "Adjective",
        reason: "swears-adjective"
    },
    //jack seems guarded
    {
        match: "#Singular (seems|appears) #Adverb? [#PastTense$]",
        group: 0,
        tag: "Adjective",
        reason: "seems-filled"
    },
    // jury is out - preposition ➔ adjective
    {
        match: "#Copula #Adjective? [(out|in|through)]$",
        group: 0,
        tag: "Adjective",
        reason: "still-out"
    },
    // shut the door
    {
        match: "^[#Adjective] (the|your) #Noun",
        group: 0,
        notIf: "(all|even)",
        tag: "Infinitive",
        reason: "shut-the"
    },
    // the said card
    {
        match: "the [said] #Noun",
        group: 0,
        tag: "Adjective",
        reason: "the-said-card"
    },
    // faith-based, much-appreciated, soft-boiled
    {
        match: "[#Hyphenated (#Hyphenated && #PastTense)] (#Noun|#Conjunction)",
        group: 0,
        tag: "Adjective",
        notIf: "#Adverb",
        reason: "faith-based"
    },
    //self-driving
    {
        match: "[#Hyphenated (#Hyphenated && #Gerund)] (#Noun|#Conjunction)",
        group: 0,
        tag: "Adjective",
        notIf: "#Adverb",
        reason: "self-driving"
    },
    //dammed-up
    {
        match: "[#PastTense (#Hyphenated && #PhrasalVerb)] (#Noun|#Conjunction)",
        group: 0,
        tag: "Adjective",
        reason: "dammed-up"
    },
    //two-fold
    {
        match: "(#Hyphenated && #Value) fold",
        tag: "Adjective",
        reason: "two-fold"
    },
    //must-win
    {
        match: "must (#Hyphenated && #Infinitive)",
        tag: "Adjective",
        reason: "must-win"
    },
    // vacuum-sealed
    {
        match: `(#Hyphenated && #Infinitive) #Hyphenated`,
        tag: "Adjective",
        notIf: "#PhrasalVerb",
        reason: "vacuum-sealed"
    },
    {
        match: "too much",
        tag: "Adverb Adjective",
        reason: "bit-4"
    },
    {
        match: "a bit much",
        tag: "Determiner Adverb Adjective",
        reason: "bit-3"
    },
    // adjective-prefixes - 'un skilled'
    {
        match: "[(un|contra|extra|inter|intra|macro|micro|mid|mis|mono|multi|pre|sub|tri|ex)] #Adjective",
        group: 0,
        tag: [
            "Adjective",
            "Prefix"
        ],
        reason: "un-skilled"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"JSav0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const adverbAdj = `(dark|bright|flat|light|soft|pale|dead|dim|faux|little|wee|sheer|most|near|good|extra|all)`;
const noLy = "(hard|fast|late|early|high|right|deep|close|direct)";
exports.default = [
    // kinda sparkly
    {
        match: `#Adverb [#Adverb] (and|or|then)`,
        group: 0,
        tag: "Adjective",
        reason: "kinda-sparkly-and"
    },
    // dark green
    {
        match: `[${adverbAdj}] #Adjective`,
        group: 0,
        tag: "Adverb",
        reason: "dark-green"
    },
    // far too
    {
        match: `#Copula [far too] #Adjective`,
        group: 0,
        tag: "Adverb",
        reason: "far-too"
    },
    // was still in 
    {
        match: `#Copula [still] (in|#Gerund|#Adjective)`,
        group: 0,
        tag: "Adverb",
        reason: "was-still-walking"
    },
    // studies hard
    {
        match: `#Plural ${noLy}`,
        tag: "#PresentTense #Adverb",
        reason: "studies-hard"
    },
    // shops direct
    {
        match: `#Verb [${noLy}] !#Noun?`,
        group: 0,
        notIf: "(#Copula|get|got|getting|become|became|becoming|feel|feels|feeling)",
        tag: "Adverb",
        reason: "shops-direct"
    },
    // studies a lot
    {
        match: `[#Plural] a lot`,
        tag: "PresentTense",
        reason: "studies-a-lot"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jLaNm":[function(require,module,exports) {
// Gerund-Adjectives - 'amusing, annoying'
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    //a staggering cost
    // { match: '(a|an) [#Gerund]', group: 0, tag: 'Adjective', reason: 'a|an' },
    //as amusing as
    {
        match: "as [#Gerund] as",
        group: 0,
        tag: "Adjective",
        reason: "as-gerund-as"
    },
    // more amusing than
    {
        match: "more [#Gerund] than",
        group: 0,
        tag: "Adjective",
        reason: "more-gerund-than"
    },
    // very amusing
    {
        match: "(so|very|extremely) [#Gerund]",
        group: 0,
        tag: "Adjective",
        reason: "so-gerund"
    },
    // found it amusing
    {
        match: "(found|found) it #Adverb? [#Gerund]",
        group: 0,
        tag: "Adjective",
        reason: "found-it-gerund"
    },
    // a bit amusing
    {
        match: "a (little|bit|wee) bit? [#Gerund]",
        group: 0,
        tag: "Adjective",
        reason: "a-bit-gerund"
    },
    // looking annoying
    {
        match: "#Gerund [#Gerund]",
        group: 0,
        tag: "Adjective",
        notIf: "(impersonating|practicing|considering|assuming)",
        reason: "looking-annoying"
    },
    // looked amazing
    {
        match: "(looked|look|looks) #Adverb? [%Adj|Gerund%]",
        group: 0,
        tag: "Adjective",
        notIf: "(impersonating|practicing|considering|assuming)",
        reason: "looked-amazing"
    },
    // were really amazing
    // { match: '(looked|look|looks) #Adverb [%Adj|Gerund%]', group: 0, tag: 'Adjective', notIf: '(impersonating|practicing|considering|assuming)', reason: 'looked-amazing' },
    // developing a
    {
        match: "[%Adj|Gerund%] #Determiner",
        group: 0,
        tag: "Gerund",
        reason: "developing-a"
    },
    // world's leading manufacturer
    {
        match: "#Possessive [%Adj|Gerund%] #Noun",
        group: 0,
        tag: "Adjective",
        reason: "leading-manufacturer"
    },
    // meaning alluring
    {
        match: "%Noun|Gerund% %Adj|Gerund%",
        tag: "Gerund #Adjective",
        reason: "meaning-alluring"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j9vsI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    //the above is clear
    {
        match: "#Determiner [#Adjective] #Copula",
        group: 0,
        tag: "Noun",
        reason: "the-adj-is"
    },
    //real evil is
    {
        match: "#Adjective [#Adjective] #Copula",
        group: 0,
        tag: "Noun",
        reason: "adj-adj-is"
    },
    //his fine
    {
        match: "(his|its) [%Adj|Noun%]",
        group: 0,
        tag: "Noun",
        notIf: "#Hyphenated",
        reason: "his-fine"
    },
    //is all
    {
        match: "#Copula #Adverb? [all]",
        group: 0,
        tag: "Noun",
        reason: "is-all"
    },
    // have fun
    {
        match: `(have|had) [#Adjective] #Preposition .`,
        group: 0,
        tag: "Noun",
        reason: "have-fun"
    },
    // brewing giant
    {
        match: `#Gerund (giant|capital|center|zone|application)`,
        tag: "Noun",
        reason: "brewing-giant"
    },
    // in an instant
    {
        match: `#Preposition (a|an) [#Adjective]$`,
        group: 0,
        tag: "Noun",
        reason: "an-instant"
    },
    // no golden would
    {
        match: `no [#Adjective] #Modal`,
        group: 0,
        tag: "Noun",
        reason: "no-golden"
    },
    // brand new
    {
        match: `[brand #Gerund?] new`,
        group: 0,
        tag: "Adverb",
        reason: "brand-new"
    },
    // some kind
    {
        match: `(#Determiner|#Comparative|new|different) [kind]`,
        group: 0,
        tag: "Noun",
        reason: "some-kind"
    },
    // her favourite sport
    {
        match: `#Possessive [%Adj|Noun%] #Noun`,
        group: 0,
        tag: "Adjective",
        reason: "her-favourite"
    },
    // must-win
    {
        match: `must && #Hyphenated .`,
        tag: "Adjective",
        reason: "must-win"
    },
    // the present
    {
        match: `#Determiner [#Adjective]$`,
        tag: "Noun",
        notIf: "(this|that|#Comparative|#Superlative)",
        reason: "the-south"
    },
    // company-wide
    {
        match: `(#Noun && #Hyphenated) (#Adjective && #Hyphenated)`,
        tag: "Adjective",
        notIf: "(this|that|#Comparative|#Superlative)",
        reason: "company-wide"
    },
    // the poor were
    {
        match: `#Determiner [#Adjective] (#Copula|#Determiner)`,
        notIf: "(#Comparative|#Superlative)",
        group: 0,
        tag: "Noun",
        reason: "the-poor"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9rAhb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // amusing his aunt
    // { match: '[#Adjective] #Possessive #Noun', group: 0, tag: 'Verb', reason: 'gerund-his-noun' },
    // loving you
    // { match: '[#Adjective] (us|you)', group: 0, tag: 'Gerund', reason: 'loving-you' },
    // slowly stunning
    {
        match: "(slowly|quickly) [#Adjective]",
        group: 0,
        tag: "Verb",
        reason: "slowly-adj"
    },
    // does mean
    {
        match: "does (#Adverb|not)? [#Adjective]",
        group: 0,
        tag: "PresentTense",
        reason: "does-mean"
    },
    // okay by me
    {
        match: "[(fine|okay|cool|ok)] by me",
        group: 0,
        tag: "Adjective",
        reason: "okay-by-me"
    },
    // i mean
    {
        match: "i (#Adverb|do)? not? [mean]",
        group: 0,
        tag: "PresentTense",
        reason: "i-mean"
    },
    //will secure our
    {
        match: "will #Adjective",
        tag: "Auxiliary Infinitive",
        reason: "will-adj"
    },
    //he disguised the thing
    {
        match: "#Pronoun [#Adjective] #Determiner #Adjective? #Noun",
        group: 0,
        tag: "Verb",
        reason: "he-adj-the"
    },
    //is eager to go
    {
        match: "#Copula [%Adj|Present%] to #Verb",
        group: 0,
        tag: "Verb",
        reason: "adj-to"
    },
    //is done well
    {
        match: "#Copula [#Adjective] (well|badly|quickly|slowly)",
        group: 0,
        tag: "Verb",
        reason: "done-well"
    },
    // rude and insulting
    {
        match: "#Adjective and [#Gerund] !#Preposition?",
        group: 0,
        tag: "Adjective",
        reason: "rude-and-x"
    },
    // were over cooked
    {
        match: "#Copula #Adverb? (over|under) [#PastTense]",
        group: 0,
        tag: "Adjective",
        reason: "over-cooked"
    },
    // was bland and overcooked
    {
        match: "#Copula #Adjective+ (and|or) [#PastTense]$",
        group: 0,
        tag: "Adjective",
        reason: "bland-and-overcooked"
    },
    // got tired of
    {
        match: "got #Adverb? [#PastTense] of",
        group: 0,
        tag: "Adjective",
        reason: "got-tired-of"
    },
    //felt loved
    {
        match: "(seem|seems|seemed|appear|appeared|appears|feel|feels|felt|sound|sounds|sounded) (#Adverb|#Adjective)? [#PastTense]",
        group: 0,
        tag: "Adjective",
        reason: "felt-loved"
    },
    // seem confused
    {
        match: "(seem|feel|seemed|felt) [#PastTense #Particle?]",
        group: 0,
        tag: "Adjective",
        reason: "seem-confused"
    },
    // a bit confused
    {
        match: "a (bit|little|tad) [#PastTense #Particle?]",
        group: 0,
        tag: "Adjective",
        reason: "a-bit-confused"
    },
    // do not be embarrassed
    {
        match: "not be [%Adj|Past% #Particle?]",
        group: 0,
        tag: "Adjective",
        reason: "do-not-be-confused"
    },
    // is just right
    {
        match: "#Copula just [%Adj|Past% #Particle?]",
        group: 0,
        tag: "Adjective",
        reason: "is-just-right"
    },
    // as pale as
    {
        match: "as [#Infinitive] as",
        group: 0,
        tag: "Adjective",
        reason: "as-pale-as"
    },
    //failed and oppressive
    {
        match: "[%Adj|Past%] and #Adjective",
        group: 0,
        tag: "Adjective",
        reason: "faled-and-oppressive"
    },
    // or heightened emotion
    {
        match: "or [#PastTense] #Noun",
        group: 0,
        tag: "Adjective",
        notIf: "(#Copula|#Pronoun)",
        reason: "or-heightened-emotion"
    },
    // became involved
    {
        match: "(become|became|becoming|becomes) [#Verb]",
        group: 0,
        tag: "Adjective",
        reason: "become-verb"
    },
    // their declared intentions
    {
        match: "#Possessive [#PastTense] #Noun",
        group: 0,
        tag: "Adjective",
        reason: "declared-intentions"
    },
    // is he cool
    {
        match: "#Copula #Pronoun [%Adj|Present%]",
        group: 0,
        tag: "Adjective",
        reason: "is-he-cool"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gDed7":[function(require,module,exports) {
// const adverbAdj = '(dark|bright|flat|light|soft|pale|dead|dim|faux|little|wee|sheer|most|near|good|extra|all)'
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    //still good
    {
        match: "[still] #Adjective",
        group: 0,
        tag: "Adverb",
        reason: "still-advb"
    },
    //still make
    {
        match: "[still] #Verb",
        group: 0,
        tag: "Adverb",
        reason: "still-verb"
    },
    // so hot
    {
        match: "[so] #Adjective",
        group: 0,
        tag: "Adverb",
        reason: "so-adv"
    },
    // way hotter
    {
        match: "[way] #Comparative",
        group: 0,
        tag: "Adverb",
        reason: "way-adj"
    },
    // way too hot
    {
        match: "[way] #Adverb #Adjective",
        group: 0,
        tag: "Adverb",
        reason: "way-too-adj"
    },
    // all singing
    {
        match: "[all] #Verb",
        group: 0,
        tag: "Adverb",
        reason: "all-verb"
    },
    // sing like an angel
    {
        match: "#Verb  [like]",
        group: 0,
        notIf: "(#Modal|#PhrasalVerb)",
        tag: "Adverb",
        reason: "verb-like"
    },
    //barely even walk
    {
        match: "(barely|hardly) even",
        tag: "Adverb",
        reason: "barely-even"
    },
    //even held
    {
        match: "[even] #Verb",
        group: 0,
        tag: "Adverb",
        reason: "even-walk"
    },
    //even worse
    {
        match: "[even] #Comparative",
        group: 0,
        tag: "Adverb",
        reason: "even-worse"
    },
    // even the greatest
    {
        match: "[even] (#Determiner|#Possessive)",
        group: 0,
        tag: "#Adverb",
        reason: "even-the"
    },
    // even left
    {
        match: "even left",
        tag: "#Adverb #Verb",
        reason: "even-left"
    },
    // way over
    {
        match: "[way] #Adjective",
        group: 0,
        tag: "#Adverb",
        reason: "way-over"
    },
    //cheering hard - dropped -ly's
    {
        match: "#PresentTense [(hard|quick|bright|slow|fast|backwards|forwards)]",
        notIf: "#Copula",
        group: 0,
        tag: "Adverb",
        reason: "lazy-ly"
    },
    // much appreciated
    {
        match: "[much] #Adjective",
        group: 0,
        tag: "Adverb",
        reason: "bit-1"
    },
    // is well
    {
        match: "#Copula [#Adverb]$",
        group: 0,
        tag: "Adjective",
        reason: "is-well"
    },
    // a bit cold
    {
        match: "a [(little|bit|wee) bit?] #Adjective",
        group: 0,
        tag: "Adverb",
        reason: "a-bit-cold"
    },
    // super strong
    {
        match: `[(super|pretty)] #Adjective`,
        group: 0,
        tag: "Adverb",
        reason: "super-strong"
    },
    // become overly weakened
    {
        match: "(become|fall|grow) #Adverb? [#PastTense]",
        group: 0,
        tag: "Adjective",
        reason: "overly-weakened"
    },
    // a completely beaten man
    {
        match: "(a|an) #Adverb [#Participle] #Noun",
        group: 0,
        tag: "Adjective",
        reason: "completely-beaten"
    },
    //a close
    {
        match: "#Determiner #Adverb? [close]",
        group: 0,
        tag: "Adjective",
        reason: "a-close"
    },
    //walking close
    {
        match: "#Gerund #Adverb? [close]",
        group: 0,
        tag: "Adverb",
        notIf: "(getting|becoming|feeling)",
        reason: "being-close"
    },
    // a blown motor
    {
        match: "(the|those|these|a|an) [#Participle] #Noun",
        group: 0,
        tag: "Adjective",
        reason: "blown-motor"
    },
    // charged back
    {
        match: "(#PresentTense|#PastTense) [back]",
        group: 0,
        tag: "Adverb",
        notIf: "(#PhrasalVerb|#Copula)",
        reason: "charge-back"
    },
    // send around
    {
        match: "#Verb [around]",
        group: 0,
        tag: "Adverb",
        notIf: "#PhrasalVerb",
        reason: "send-around"
    },
    // later say
    {
        match: "[later] #PresentTense",
        group: 0,
        tag: "Adverb",
        reason: "later-say"
    },
    // the well
    {
        match: "#Determiner [well] !#PastTense?",
        group: 0,
        tag: "Noun",
        reason: "the-well"
    },
    // high enough
    {
        match: "#Adjective [enough]",
        group: 0,
        tag: "Adverb",
        reason: "high-enough"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iKMdO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // ==== Holiday ====
    {
        match: "#Holiday (day|eve)",
        tag: "Holiday",
        reason: "holiday-day"
    },
    //5th of March
    {
        match: "#Value of #Month",
        tag: "Date",
        reason: "value-of-month"
    },
    //5 March
    {
        match: "#Cardinal #Month",
        tag: "Date",
        reason: "cardinal-month"
    },
    //march 5 to 7
    {
        match: "#Month #Value to #Value",
        tag: "Date",
        reason: "value-to-value"
    },
    //march the 12th
    {
        match: "#Month the #Value",
        tag: "Date",
        reason: "month-the-value"
    },
    //june 7
    {
        match: "(#WeekDay|#Month) #Value",
        tag: "Date",
        reason: "date-value"
    },
    //7 june
    {
        match: "#Value (#WeekDay|#Month)",
        tag: "Date",
        reason: "value-date"
    },
    //may twenty five
    {
        match: "(#TextValue && #Date) #TextValue",
        tag: "Date",
        reason: "textvalue-date"
    },
    // 'aug 20-21'
    {
        match: `#Month #NumberRange`,
        tag: "Date",
        reason: "aug 20-21"
    },
    // wed march 5th
    {
        match: `#WeekDay #Month #Ordinal`,
        tag: "Date",
        reason: "week mm-dd"
    },
    // aug 5th 2021
    {
        match: `#Month #Ordinal #Cardinal`,
        tag: "Date",
        reason: "mm-dd-yyy"
    },
    // === timezones ===
    // china standard time
    {
        match: `(#Place|#Demonmym|#Time) (standard|daylight|central|mountain)? time`,
        tag: "Timezone",
        reason: "std-time"
    },
    // eastern time
    {
        match: `(eastern|mountain|pacific|central|atlantic) (standard|daylight|summer)? time`,
        tag: "Timezone",
        reason: "eastern-time"
    },
    // 5pm central
    {
        match: `#Time [(eastern|mountain|pacific|central|est|pst|gmt)]`,
        group: 0,
        tag: "Timezone",
        reason: "5pm-central"
    },
    // central european time
    {
        match: `(central|western|eastern) european time`,
        tag: "Timezone",
        reason: "cet"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1Fpkw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // ==== WeekDay ====
    // sun the 5th
    {
        match: "[sun] the #Ordinal",
        tag: "WeekDay",
        reason: "sun-the-5th"
    },
    //sun feb 2
    {
        match: "[sun] #Date",
        group: 0,
        tag: "WeekDay",
        reason: "sun-feb"
    },
    //1pm next sun
    {
        match: "#Date (on|this|next|last|during)? [sun]",
        group: 0,
        tag: "WeekDay",
        reason: "1pm-sun"
    },
    //this sat
    {
        match: `(in|by|before|during|on|until|after|of|within|all) [sat]`,
        group: 0,
        tag: "WeekDay",
        reason: "sat"
    },
    {
        match: `(in|by|before|during|on|until|after|of|within|all) [wed]`,
        group: 0,
        tag: "WeekDay",
        reason: "wed"
    },
    {
        match: `(in|by|before|during|on|until|after|of|within|all) [march]`,
        group: 0,
        tag: "Month",
        reason: "march"
    },
    //sat november
    {
        match: "[sat] #Date",
        group: 0,
        tag: "WeekDay",
        reason: "sat-feb"
    },
    // ==== Month ====
    //all march
    {
        match: `#Preposition [(march|may)]`,
        group: 0,
        tag: "Month",
        reason: "in-month"
    },
    //this march
    {
        match: `(this|next|last) (march|may) !#Infinitive?`,
        tag: "#Date #Month",
        reason: "this-month"
    },
    // march 5th
    {
        match: `(march|may) the? #Value`,
        tag: "#Month #Date #Date",
        reason: "march-5th"
    },
    // 5th of march
    {
        match: `#Value of? (march|may)`,
        tag: "#Date #Date #Month",
        reason: "5th-of-march"
    },
    // march and feb
    {
        match: `[(march|may)] .? #Date`,
        group: 0,
        tag: "Month",
        reason: "march-and-feb"
    },
    // feb to march
    {
        match: `#Date .? [(march|may)]`,
        group: 0,
        tag: "Month",
        reason: "feb-and-march"
    },
    //quickly march
    {
        match: `#Adverb [(march|may)]`,
        group: 0,
        tag: "Verb",
        reason: "quickly-march"
    },
    //march quickly
    {
        match: `[(march|may)] #Adverb`,
        group: 0,
        tag: "Verb",
        reason: "march-quickly"
    },
    //12 am
    {
        match: `#Value (am|pm)`,
        tag: "Time",
        reason: "2-am"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9dGTS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const infNouns = "(feel|sense|process|rush|side|bomb|bully|challenge|cover|crush|dump|exchange|flow|function|issue|lecture|limit|march|process)";
exports.default = [
    //'more' is not always an adverb
    // any more
    {
        match: "(the|any) [more]",
        group: 0,
        tag: "Singular",
        reason: "more-noun"
    },
    // more players
    {
        match: "[more] #Noun",
        group: 0,
        tag: "Adjective",
        reason: "more-noun"
    },
    // rights of man
    {
        match: "(right|rights) of .",
        tag: "Noun",
        reason: "right-of"
    },
    // a bit
    {
        match: "a [bit]",
        group: 0,
        tag: "Singular",
        reason: "bit-2"
    },
    // a must
    {
        match: "a [must]",
        group: 0,
        tag: "Singular",
        reason: "must-2"
    },
    // we all
    {
        match: "(we|us) [all]",
        group: 0,
        tag: "Noun",
        reason: "we all"
    },
    // due to weather
    {
        match: "due to [#Verb]",
        group: 0,
        tag: "Noun",
        reason: "due-to"
    },
    //some pressing issues
    {
        match: "some [#Verb] #Plural",
        group: 0,
        tag: "Noun",
        reason: "determiner6"
    },
    // my first thought
    {
        match: "#Possessive #Ordinal [#PastTense]",
        group: 0,
        tag: "Noun",
        reason: "first-thought"
    },
    //the nice swim
    {
        match: "(the|this|those|these) #Adjective [%Verb|Noun%]",
        group: 0,
        tag: "Noun",
        notIf: "#Copula",
        reason: "the-adj-verb"
    },
    // the truly nice swim
    {
        match: "(the|this|those|these) #Adverb #Adjective [#Verb]",
        group: 0,
        tag: "Noun",
        reason: "determiner4"
    },
    //the wait to vote
    {
        match: "the [#Verb] #Preposition .",
        group: 0,
        tag: "Noun",
        reason: "determiner1"
    },
    //a sense of
    {
        match: "(a|an|the) [#Verb] of",
        group: 0,
        tag: "Noun",
        reason: "the-verb-of"
    },
    //the threat of force
    {
        match: "#Determiner #Noun of [#Verb]",
        group: 0,
        tag: "Noun",
        notIf: "#Gerund",
        reason: "noun-of-noun"
    },
    // ended in ruins
    {
        match: "#PastTense #Preposition [#PresentTense]",
        group: 0,
        notIf: "#Gerund",
        tag: "Noun",
        reason: "ended-in-ruins"
    },
    //'u' as pronoun
    {
        match: "#Conjunction [u]",
        group: 0,
        tag: "Pronoun",
        reason: "u-pronoun-2"
    },
    {
        match: "[u] #Verb",
        group: 0,
        tag: "Pronoun",
        reason: "u-pronoun-1"
    },
    //the western line
    {
        match: "#Determiner [(western|eastern|northern|southern|central)] #Noun",
        group: 0,
        tag: "Noun",
        reason: "western-line"
    },
    //air-flow
    {
        match: "(#Singular && @hasHyphen) #PresentTense",
        tag: "Noun",
        reason: "hyphen-verb"
    },
    //is no walk
    {
        match: "is no [#Verb]",
        group: 0,
        tag: "Noun",
        reason: "is-no-verb"
    },
    //do so
    {
        match: "do [so]",
        group: 0,
        tag: "Noun",
        reason: "so-noun"
    },
    // what the hell
    {
        match: "#Determiner [(shit|damn|hell)]",
        group: 0,
        tag: "Noun",
        reason: "swears-noun"
    },
    // go to shit
    {
        match: "to [(shit|hell)]",
        group: 0,
        tag: "Noun",
        reason: "to-swears"
    },
    // the staff were
    {
        match: "(the|these) [#Singular] (were|are)",
        group: 0,
        tag: "Plural",
        reason: "singular-were"
    },
    // a comdominium, or simply condo
    {
        match: `a #Noun+ or #Adverb+? [#Verb]`,
        group: 0,
        tag: "Noun",
        reason: "noun-or-noun"
    },
    // walk the walk
    {
        match: "(the|those|these|a|an) #Adjective? [#PresentTense #Particle?]",
        group: 0,
        tag: "Noun",
        notIf: "(seem|appear|include|#Gerund|#Copula)",
        reason: "det-inf"
    },
    // { match: '(the|those|these|a|an) #Adjective? [#PresentTense #Particle?]', group: 0, tag: 'Noun', notIf: '(#Gerund|#Copula)', reason: 'det-pres' },
    // ==== Actor ====
    //Aircraft designer
    {
        match: "#Noun #Actor",
        tag: "Actor",
        notIf: "(#Person|#Pronoun)",
        reason: "thing-doer"
    },
    //lighting designer
    {
        match: "#Gerund #Actor",
        tag: "Actor",
        reason: "gerund-doer"
    },
    // captain sanders
    // { match: '[#Actor+] #ProperNoun', group: 0, tag: 'Honorific', reason: 'sgt-kelly' },
    // co-founder
    {
        match: `co #Singular`,
        tag: "Actor",
        reason: "co-noun"
    },
    // co-founder
    {
        match: `[#Noun+] #Actor`,
        group: 0,
        tag: "Actor",
        notIf: "(#Honorific|#Pronoun|#Possessive)",
        reason: "air-traffic-controller"
    },
    // fine-artist
    {
        match: `(urban|cardiac|cardiovascular|respiratory|medical|clinical|visual|graphic|creative|dental|exotic|fine|certified|registered|technical|virtual|professional|amateur|junior|senior|special|pharmaceutical|theoretical)+ #Noun? #Actor`,
        tag: "Actor",
        reason: "fine-artist"
    },
    // dance coach
    {
        match: `#Noun+ (coach|chef|king|engineer|fellow|personality|boy|girl|man|woman|master)`,
        tag: "Actor",
        reason: "dance-coach"
    },
    // chief design officer
    {
        match: `chief . officer`,
        tag: "Actor",
        reason: "chief-x-officer"
    },
    // chief of police
    {
        match: `chief of #Noun+`,
        tag: "Actor",
        reason: "chief-of-police"
    },
    // president of marketing
    {
        match: `senior? vice? president of #Noun+`,
        tag: "Actor",
        reason: "president-of"
    },
    // ==== Singular ====
    //the sun
    {
        match: "#Determiner [sun]",
        group: 0,
        tag: "Singular",
        reason: "the-sun"
    },
    //did a 900, paid a 20
    {
        match: "#Verb (a|an) [#Value]$",
        group: 0,
        tag: "Singular",
        reason: "did-a-value"
    },
    //'the can'
    {
        match: "the [(can|will|may)]",
        group: 0,
        tag: "Singular",
        reason: "the can"
    },
    // ==== Possessive ====
    //spencer kelly's
    {
        match: "#FirstName #Acronym? (#Possessive && #LastName)",
        tag: "Possessive",
        reason: "name-poss"
    },
    //Super Corp's fundraiser
    {
        match: "#Organization+ #Possessive",
        tag: "Possessive",
        reason: "org-possessive"
    },
    //Los Angeles's fundraiser
    {
        match: "#Place+ #Possessive",
        tag: "Possessive",
        reason: "place-possessive"
    },
    // Ptolemy's experiments
    {
        match: "#Possessive #PresentTense #Particle?",
        notIf: "(#Gerund|her)",
        tag: "Noun",
        reason: "possessive-verb"
    },
    // my presidents house
    {
        match: "(my|our|their|her|his|its) [(#Plural && #Actor)] #Noun",
        tag: "Possessive",
        reason: "my-dads"
    },
    // 10th of a second
    {
        match: "#Value of a [second]",
        group: 0,
        unTag: "Value",
        tag: "Singular",
        reason: "10th-of-a-second"
    },
    // 10 seconds
    {
        match: "#Value [seconds]",
        group: 0,
        unTag: "Value",
        tag: "Plural",
        reason: "10-seconds"
    },
    // in time
    {
        match: "in [#Infinitive]",
        group: 0,
        tag: "Singular",
        reason: "in-age"
    },
    // a minor in
    {
        match: "a [#Adjective] #Preposition",
        group: 0,
        tag: "Noun",
        reason: "a-minor-in"
    },
    //the repairer said
    {
        match: "#Determiner [#Singular] said",
        group: 0,
        tag: "Actor",
        reason: "the-actor-said"
    },
    //the euro sense
    {
        match: `#Determiner #Noun [${infNouns}] !(#Preposition|to|#Adverb)?`,
        group: 0,
        tag: "Noun",
        reason: "the-noun-sense"
    },
    // photographs of a computer are
    {
        match: "[#PresentTense] (of|by|for) (a|an|the) #Noun #Copula",
        group: 0,
        tag: "Plural",
        reason: "photographs-of"
    },
    // fight and win
    {
        match: "#Infinitive and [%Noun|Verb%]",
        group: 0,
        tag: "Infinitive",
        reason: "fight and win"
    },
    // peace and flowers and love
    {
        match: "#Noun and [#Verb] and #Noun",
        group: 0,
        tag: "Noun",
        reason: "peace-and-flowers"
    },
    // the 1992 classic
    {
        match: "the #Cardinal [%Adj|Noun%]",
        group: 0,
        tag: "Noun",
        reason: "the-1992-classic"
    },
    // the premier university
    {
        match: "#Copula the [%Adj|Noun%] #Noun",
        group: 0,
        tag: "Adjective",
        reason: "the-premier-university"
    },
    // scottish - i ate me sandwich
    {
        match: "i #Verb [me] #Noun",
        group: 0,
        tag: "Possessive",
        reason: "scottish-me"
    },
    // dance music
    {
        match: "[#PresentTense] (music|class|lesson|night|party|festival|league|ceremony)",
        group: 0,
        tag: "Noun",
        reason: "dance-music"
    },
    // wit it
    {
        match: "[wit] (me|it)",
        group: 0,
        tag: "Presposition",
        reason: "wit-me"
    },
    //left-her-boots, shoved her hand
    {
        match: "#PastTense #Possessive [#Verb]",
        group: 0,
        tag: "Noun",
        notIf: "(saw|made)",
        reason: "left-her-boots"
    },
    //35 signs
    {
        match: "#Value [%Plural|Verb%]",
        group: 0,
        tag: "Plural",
        notIf: "(one|1|a|an)",
        reason: "35-signs"
    },
    //had time
    {
        match: "had [#PresentTense]",
        group: 0,
        tag: "Noun",
        notIf: "(#Gerund|come|become)",
        reason: "had-time"
    },
    //instant access
    {
        match: "%Adj|Noun% %Noun|Verb%",
        tag: "#Adjective #Noun",
        notIf: "#ProperNoun #Noun",
        reason: "instant-access"
    },
    // a representative to 
    {
        match: "#Determiner [%Adj|Noun%] #Conjunction",
        group: 0,
        tag: "Noun",
        reason: "a-rep-to"
    },
    // near death experiences, ambitious sales targets
    {
        match: "#Adjective #Noun [%Plural|Verb%]$",
        group: 0,
        tag: "Plural",
        notIf: "#Pronoun",
        reason: "near-death-experiences"
    },
    // your guild colors
    {
        match: "#Possessive #Noun [%Plural|Verb%]$",
        group: 0,
        tag: "Plural",
        reason: "your-guild-colors"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4DT40":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // the planning processes
    {
        match: "(this|that|the|a|an) [#Gerund #Infinitive]",
        group: 0,
        tag: "Singular",
        reason: "the-planning-process"
    },
    // the paving stones
    {
        match: "(that|the) [#Gerund #PresentTense]",
        group: 0,
        ifNo: "#Copula",
        tag: "Plural",
        reason: "the-paving-stones"
    },
    // this swimming
    // { match: '(this|that|the) [#Gerund]', group: 0, tag: 'Noun', reason: 'this-gerund' },
    // the remaining claims
    {
        match: "#Determiner [#Gerund] #Noun",
        group: 0,
        tag: "Adjective",
        reason: "the-gerund-noun"
    },
    // i think tipping sucks
    {
        match: `#Pronoun #Infinitive [#Gerund] #PresentTense`,
        group: 0,
        tag: "Noun",
        reason: "tipping-sucks"
    },
    // early warning
    {
        match: "#Adjective [#Gerund]",
        group: 0,
        tag: "Noun",
        notIf: "(still|even|just)",
        reason: "early-warning"
    },
    //walking is cool
    {
        match: "[#Gerund] #Adverb? not? #Copula",
        group: 0,
        tag: "Activity",
        reason: "gerund-copula"
    },
    //are doing is
    {
        match: "#Copula [(#Gerund|#Activity)] #Copula",
        group: 0,
        tag: "Gerund",
        reason: "are-doing-is"
    },
    //walking should be fun
    {
        match: "[#Gerund] #Modal",
        group: 0,
        tag: "Activity",
        reason: "gerund-modal"
    },
    // finish listening
    // { match: '#Infinitive [#Gerund]', group: 0, tag: 'Activity', reason: 'finish-listening' },
    // the ruling party
    // responsibility for setting
    {
        match: "#Singular for [%Noun|Gerund%]",
        group: 0,
        tag: "Gerund",
        reason: "noun-for-gerund"
    },
    // better for training
    {
        match: "#Comparative (for|at) [%Noun|Gerund%]",
        group: 0,
        tag: "Gerund",
        reason: "better-for-gerund"
    },
    // keep the touching
    {
        match: "#PresentTense the [#Gerund]",
        group: 0,
        tag: "Noun",
        reason: "keep-the-touching"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lhx8B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // do the dance
    {
        match: "#Infinitive (this|that|the) [#Infinitive]",
        group: 0,
        tag: "Noun",
        reason: "do-this-dance"
    },
    //running-a-show
    {
        match: "#Gerund #Determiner [#Infinitive]",
        group: 0,
        tag: "Noun",
        reason: "running-a-show"
    },
    //the-only-reason
    {
        match: "#Determiner (only|further|just|more|backward) [#Infinitive]",
        group: 0,
        tag: "Noun",
        reason: "the-only-reason"
    },
    // a stream runs
    {
        match: "(the|this|a|an) [#Infinitive] #Adverb? #Verb",
        group: 0,
        tag: "Noun",
        reason: "determiner5"
    },
    //a nice deal
    {
        match: "#Determiner #Adjective #Adjective? [#Infinitive]",
        group: 0,
        tag: "Noun",
        reason: "a-nice-inf"
    },
    // the mexican train
    {
        match: "#Determiner #Demonym [#PresentTense]",
        group: 0,
        tag: "Noun",
        reason: "mexican-train"
    },
    //next career move
    {
        match: "#Adjective #Noun+ [#Infinitive] #Copula",
        group: 0,
        tag: "Noun",
        reason: "career-move"
    },
    // at some point
    {
        match: "at some [#Infinitive]",
        group: 0,
        tag: "Noun",
        reason: "at-some-inf"
    },
    // goes to sleep
    {
        match: "(go|goes|went) to [#Infinitive]",
        group: 0,
        tag: "Noun",
        reason: "goes-to-verb"
    },
    //a close watch on
    {
        match: "(a|an) #Adjective? #Noun [#Infinitive] (#Preposition|#Noun)",
        group: 0,
        notIf: "from",
        tag: "Noun",
        reason: "a-noun-inf"
    },
    //a tv show
    {
        match: "(a|an) #Noun [#Infinitive]$",
        group: 0,
        tag: "Noun",
        reason: "a-noun-inf2"
    },
    //is mark hughes
    // { match: '#Copula [#Infinitive] #Noun', group: 0, tag: 'Noun', reason: 'is-pres-noun' },
    // good wait staff
    // { match: '#Adjective [#Infinitive] #Noun', group: 0, tag: 'Noun', reason: 'good-wait-staff' },
    // running for congress
    {
        match: "#Gerund #Adjective? for [#Infinitive]",
        group: 0,
        tag: "Noun",
        reason: "running-for"
    },
    // running to work
    // { match: '#Gerund #Adjective to [#Infinitive]', group: 0, tag: 'Noun', reason: 'running-to' },
    // about love
    {
        match: "about [#Infinitive]",
        group: 0,
        tag: "Singular",
        reason: "about-love"
    },
    // singers on stage
    {
        match: "#Plural on [#Infinitive]",
        group: 0,
        tag: "Noun",
        reason: "on-stage"
    },
    // any charge
    {
        match: "any [#Infinitive]",
        group: 0,
        tag: "Noun",
        reason: "any-charge"
    },
    // no doubt
    {
        match: "no [#Infinitive]",
        group: 0,
        tag: "Noun",
        reason: "no-doubt"
    },
    // number of seats
    {
        match: "number of [#PresentTense]",
        group: 0,
        tag: "Noun",
        reason: "number-of-x"
    },
    // teaches/taught
    {
        match: "(taught|teaches|learns|learned) [#PresentTense]",
        group: 0,
        tag: "Noun",
        reason: "teaches-x"
    },
    // use reverse
    {
        match: "(try|use|attempt|build|make) [#Verb #Particle?]",
        notIf: "(#Copula|#Noun|sure|fun|up)",
        group: 0,
        tag: "Noun",
        reason: "do-verb"
    },
    // checkmate is
    {
        match: "^[#Infinitive] (is|was)",
        group: 0,
        tag: "Noun",
        reason: "checkmate-is"
    },
    // get much sleep
    {
        match: "#Infinitive much [#Infinitive]",
        group: 0,
        tag: "Noun",
        reason: "get-much"
    },
    // cause i gotta
    {
        match: "[cause] #Pronoun #Verb",
        group: 0,
        tag: "Conjunction",
        reason: "cause-cuz"
    },
    // the cardio dance party
    {
        match: "the #Singular [#Infinitive] #Noun",
        group: 0,
        tag: "Noun",
        notIf: "#Pronoun",
        reason: "cardio-dance"
    },
    // that should smoke
    {
        match: "#Determiner #Modal [#Noun]",
        group: 0,
        tag: "PresentTense",
        reason: "should-smoke"
    },
    //this rocks
    {
        match: "this [#Plural]",
        group: 0,
        tag: "PresentTense",
        notIf: "(#Preposition|#Date)",
        reason: "this-verbs"
    },
    //voice that rocks
    {
        match: "#Noun that [#Plural]",
        group: 0,
        tag: "PresentTense",
        notIf: "(#Preposition|#Pronoun|way)",
        reason: "voice-that-rocks"
    },
    //that leads to
    {
        match: "that [#Plural] to",
        group: 0,
        tag: "PresentTense",
        notIf: "#Preposition",
        reason: "that-leads-to"
    },
    //let him glue
    {
        match: "(let|make|made) (him|her|it|#Person|#Place|#Organization)+ [#Singular] (a|an|the|it)",
        group: 0,
        tag: "Infinitive",
        reason: "let-him-glue"
    },
    // assign all tasks
    {
        match: "#Verb (all|every|each|most|some|no) [#PresentTense]",
        notIf: "#Modal",
        group: 0,
        tag: "Noun",
        reason: "all-presentTense"
    },
    // big dreams, critical thinking
    // have big dreams
    {
        match: "(had|have|#PastTense) #Adjective [#PresentTense]",
        group: 0,
        tag: "Noun",
        notIf: "better",
        reason: "adj-presentTense"
    },
    // excellent answer spencer
    // { match: '^#Adjective [#PresentTense]', group: 0, tag: 'Noun', reason: 'start adj-presentTense' },
    // one big reason
    {
        match: "#Value #Adjective [#PresentTense]",
        group: 0,
        tag: "Noun",
        notIf: "#Copula",
        reason: "one-big-reason"
    },
    // won widespread support
    {
        match: "#PastTense #Adjective+ [#PresentTense]",
        group: 0,
        tag: "Noun",
        notIf: "(#Copula|better)",
        reason: "won-wide-support"
    },
    // many poses
    {
        match: "(many|few|several|couple) [#PresentTense]",
        group: 0,
        tag: "Noun",
        notIf: "#Copula",
        reason: "many-poses"
    },
    // very big dreams
    {
        match: "#Determiner #Adverb #Adjective [%Noun|Verb%]",
        group: 0,
        tag: "Noun",
        notIf: "#Copula",
        reason: "very-big-dream"
    },
    // from start to finish
    {
        match: "from #Noun to [%Noun|Verb%]",
        group: 0,
        tag: "Noun",
        reason: "start-to-finish"
    },
    // for comparison or contrast
    {
        match: "(for|with|of) #Noun (and|or|not) [%Noun|Verb%]",
        group: 0,
        tag: "Noun",
        notIf: "#Pronoun",
        reason: "for-food-and-gas"
    },
    // adorable little store
    {
        match: "#Adjective #Adjective [#PresentTense]",
        group: 0,
        tag: "Noun",
        notIf: "#Copula",
        reason: "adorable-little-store"
    },
    // of basic training
    // { match: '#Preposition #Adjective [#PresentTense]', group: 0, tag: 'Noun', reason: 'of-basic-training' },
    // justifiying higher costs
    {
        match: "#Gerund #Adverb? #Comparative [#PresentTense]",
        group: 0,
        tag: "Noun",
        notIf: "#Copula",
        reason: "higher-costs"
    },
    {
        match: "(#Noun && @hasComma) #Noun (and|or) [#PresentTense]",
        group: 0,
        tag: "Noun",
        notIf: "#Copula",
        reason: "noun-list"
    },
    // any questions for
    {
        match: "(many|any|some|several) [#PresentTense] for",
        group: 0,
        tag: "Noun",
        reason: "any-verbs-for"
    },
    // to facilitate gas exchange with
    {
        match: `to #PresentTense #Noun [#PresentTense] #Preposition`,
        group: 0,
        tag: "Noun",
        reason: "gas-exchange"
    },
    // waited until release
    {
        match: `#PastTense (until|as|through|without) [#PresentTense]`,
        group: 0,
        tag: "Noun",
        reason: "waited-until-release"
    },
    // selling like hot cakes
    {
        match: `#Gerund like #Adjective? [#PresentTense]`,
        group: 0,
        tag: "Plural",
        reason: "like-hot-cakes"
    },
    // some valid reason
    {
        match: `some #Adjective [#PresentTense]`,
        group: 0,
        tag: "Noun",
        reason: "some-reason"
    },
    // for some reason
    {
        match: `for some [#PresentTense]`,
        group: 0,
        tag: "Noun",
        reason: "for-some-reason"
    },
    // same kind of shouts
    {
        match: `(same|some|the|that|a) kind of [#PresentTense]`,
        group: 0,
        tag: "Noun",
        reason: "some-kind-of"
    },
    // a type of shout
    {
        match: `(same|some|the|that|a) type of [#PresentTense]`,
        group: 0,
        tag: "Noun",
        reason: "some-type-of"
    },
    // doing better for fights
    {
        match: `#Gerund #Adjective #Preposition [#PresentTense]`,
        group: 0,
        tag: "Noun",
        reason: "doing-better-for-x"
    },
    // get better aim
    {
        match: `(get|got|have) #Comparative [#PresentTense]`,
        group: 0,
        tag: "Noun",
        reason: "got-better-aim"
    },
    // whose name was
    {
        match: "whose [#PresentTense] #Copula",
        group: 0,
        tag: "Noun",
        reason: "whos-name-was"
    },
    // give up on reason
    {
        match: `#PhrasalVerb #Particle #Preposition [#PresentTense]`,
        group: 0,
        tag: "Noun",
        reason: "given-up-on-x"
    },
    //there are reasons
    {
        match: "there (are|were) #Adjective? [#PresentTense]",
        group: 0,
        tag: "Plural",
        reason: "there-are"
    },
    // 30 trains
    {
        match: "#Value [#PresentTense] of",
        group: 0,
        notIf: "(one|1|#Copula|#Infinitive)",
        tag: "Plural",
        reason: "2-trains"
    },
    // compromises are possible
    {
        match: "[#PresentTense] (are|were) #Adjective",
        group: 0,
        tag: "Plural",
        reason: "compromises-are-possible"
    },
    // hope i helped
    {
        match: "^[(hope|guess|thought|think)] #Pronoun #Verb",
        group: 0,
        tag: "Infinitive",
        reason: "suppose-i"
    },
    //pursue its dreams
    // { match: '#PresentTense #Possessive [#PresentTense]', notIf: '#Gerund', group: 0, tag: 'Plural', reason: 'pursue-its-dreams' },
    // our unyielding support
    {
        match: "#Possessive #Adjective [#Verb]",
        group: 0,
        tag: "Noun",
        notIf: "#Copula",
        reason: "our-full-support"
    },
    // tastes good
    {
        match: "[(tastes|smells)] #Adverb? #Adjective",
        group: 0,
        tag: "PresentTense",
        reason: "tastes-good"
    },
    // are you playing golf
    // { match: '^are #Pronoun [#Noun]', group: 0, notIf: '(here|there)', tag: 'Verb', reason: 'are-you-x' },
    // ignoring commute
    {
        match: "#Copula #Gerund [#PresentTense] !by?",
        group: 0,
        tag: "Noun",
        notIf: "going",
        reason: "ignoring-commute"
    },
    // noun-pastTense variables
    {
        match: "#Determiner #Adjective? [(shed|thought|rose|bid|saw|spelt)]",
        group: 0,
        tag: "Noun",
        reason: "noun-past"
    },
    // 'verb-to'
    // how to watch
    {
        match: "how to [%Noun|Verb%]",
        group: 0,
        tag: "Infinitive",
        reason: "how-to-noun"
    },
    // which boost it
    {
        match: "which [%Noun|Verb%] #Noun",
        group: 0,
        tag: "Infinitive",
        reason: "which-boost-it"
    },
    // asking questions
    {
        match: "#Gerund [%Plural|Verb%]",
        group: 0,
        tag: "Plural",
        reason: "asking-questions"
    },
    // ready to stream
    {
        match: "(ready|available|difficult|hard|easy|made|attempt|try) to [%Noun|Verb%]",
        group: 0,
        tag: "Infinitive",
        reason: "ready-to-noun"
    },
    // bring to market
    {
        match: "(bring|went|go|drive|run|bike) to [%Noun|Verb%]",
        group: 0,
        tag: "Noun",
        reason: "bring-to-noun"
    },
    // can i sleep, would you look
    {
        match: "#Modal #Noun [%Noun|Verb%]",
        group: 0,
        tag: "Infinitive",
        reason: "would-you-look"
    },
    // is just spam
    {
        match: "#Copula just [#Infinitive]",
        group: 0,
        tag: "Noun",
        reason: "is-just-spam"
    },
    // request copies
    {
        match: "^%Noun|Verb% %Plural|Verb%",
        tag: "Imperative #Plural",
        reason: "request-copies"
    },
    // homemade pickles and drinks
    {
        match: "#Adjective #Plural and [%Plural|Verb%]",
        group: 0,
        tag: "#Plural",
        reason: "pickles-and-drinks"
    },
    // the 1968 film
    {
        match: "#Determiner #Year [#Verb]",
        group: 0,
        tag: "Noun",
        reason: "the-1968-film"
    },
    // the break up
    {
        match: "#Determiner [#PhrasalVerb #Particle]",
        group: 0,
        tag: "Noun",
        reason: "the-break-up"
    },
    // the individual goals
    {
        match: "#Determiner [%Adj|Noun%] #Noun",
        group: 0,
        tag: "Adjective",
        notIf: "(#Pronoun|#Possessive|#ProperNoun)",
        reason: "the-individual-goals"
    },
    // work or prepare
    {
        match: "[%Noun|Verb%] or #Infinitive",
        group: 0,
        tag: "Infinitive",
        reason: "work-or-prepare"
    },
    // to give thanks
    {
        match: "to #Infinitive [#PresentTense]",
        group: 0,
        tag: "Noun",
        notIf: "(#Gerund|#Copula|help)",
        reason: "to-give-thanks"
    },
    // kills me
    {
        match: "[#Noun] me",
        group: 0,
        tag: "Verb",
        reason: "kills-me"
    },
    // removes wrinkles
    {
        match: "%Plural|Verb% %Plural|Verb%",
        tag: "#PresentTense #Plural",
        reason: "removes-wrinkles"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ldRTY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    {
        match: "#Money and #Money #Currency?",
        tag: "Money",
        reason: "money-and-money"
    },
    // 6 dollars and 5 cents
    {
        match: "#Value #Currency [and] #Value (cents|ore|centavos|sens)",
        group: 0,
        tag: "money",
        reason: "and-5-cents"
    },
    // maybe currencies
    {
        match: "#Value (mark|rand|won|rub|ore)",
        tag: "#Money #Currency",
        reason: "4-mark"
    },
    // 3 pounds
    {
        match: "a pound",
        tag: "#Money #Unit",
        reason: "a-pound"
    },
    {
        match: "#Value (pound|pounds)",
        tag: "#Money #Unit",
        reason: "4-pounds"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eZfrx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // half a penny
    {
        match: "[(half|quarter)] of? (a|an)",
        group: 0,
        tag: "Fraction",
        reason: "millionth"
    },
    // nearly half
    {
        match: "#Adverb [half]",
        group: 0,
        tag: "Fraction",
        reason: "nearly-half"
    },
    // half the
    {
        match: "[half] the",
        group: 0,
        tag: "Fraction",
        reason: "half-the"
    },
    // and a half
    {
        match: "#Cardinal and a half",
        tag: "Fraction",
        reason: "and-a-half"
    },
    // two-halves
    {
        match: "#Value (halves|halfs|quarters)",
        tag: "Fraction",
        reason: "two-halves"
    },
    // ---ordinals as fractions---
    // a fifth
    {
        match: "a #Ordinal",
        tag: "Fraction",
        reason: "a-quarter"
    },
    // seven fifths
    {
        match: "[#Cardinal+] (#Fraction && /s$/)",
        tag: "Fraction",
        reason: "seven-fifths"
    },
    // doc.match('(#Fraction && /s$/)').lookBefore('#Cardinal+$').tag('Fraction')
    // one third of ..
    {
        match: "[#Cardinal+ #Ordinal] of .",
        group: 0,
        tag: "Fraction",
        reason: "ordinal-of"
    },
    // 100th of
    {
        match: "[(#NumericValue && #Ordinal)] of .",
        group: 0,
        tag: "Fraction",
        reason: "num-ordinal-of"
    },
    // a twenty fifth
    {
        match: "(a|one) #Cardinal?+ #Ordinal",
        tag: "Fraction",
        reason: "a-ordinal"
    },
    // //  '3 out of 5'
    {
        match: "#Cardinal+ out? of every? #Cardinal",
        tag: "Fraction",
        reason: "out-of"
    }
] // {match:'', tag:'',reason:''},
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cRv8N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // ==== Ambiguous numbers ====
    // 'second'
    {
        match: `#Cardinal [second]`,
        tag: "Unit",
        reason: "one-second"
    },
    //'a/an' can mean 1 - "a hour"
    {
        match: "!once? [(a|an)] (#Duration|hundred|thousand|million|billion|trillion)",
        group: 0,
        tag: "Value",
        reason: "a-is-one"
    },
    // ==== PhoneNumber ====
    //1 800 ...
    {
        match: "1 #Value #PhoneNumber",
        tag: "PhoneNumber",
        reason: "1-800-Value"
    },
    //(454) 232-9873
    {
        match: "#NumericValue #PhoneNumber",
        tag: "PhoneNumber",
        reason: "(800) PhoneNumber"
    },
    // ==== Currency ====
    // chinese yuan
    {
        match: "#Demonym #Currency",
        tag: "Currency",
        reason: "demonym-currency"
    },
    // ten bucks
    {
        match: "#Value [(buck|bucks|grand)]",
        group: 0,
        tag: "Currency",
        reason: "value-bucks"
    },
    // ==== Money ====
    {
        match: "[#Value+] #Currency",
        group: 0,
        tag: "Money",
        reason: "15 usd"
    },
    // ==== Ordinal ====
    {
        match: "[second] #Noun",
        group: 0,
        tag: "Ordinal",
        reason: "second-noun"
    },
    // ==== Units ====
    //5 yan
    {
        match: "#Value+ [#Currency]",
        group: 0,
        tag: "Unit",
        reason: "5-yan"
    },
    {
        match: "#Value [(foot|feet)]",
        group: 0,
        tag: "Unit",
        reason: "foot-unit"
    },
    //5 kg.
    {
        match: "#Value [#Abbreviation]",
        group: 0,
        tag: "Unit",
        reason: "value-abbr"
    },
    {
        match: "#Value [k]",
        group: 0,
        tag: "Unit",
        reason: "value-k"
    },
    {
        match: "#Unit an hour",
        tag: "Unit",
        reason: "unit-an-hour"
    },
    // ==== Magnitudes ====
    //minus 7
    {
        match: "(minus|negative) #Value",
        tag: "Value",
        reason: "minus-value"
    },
    //seven point five
    {
        match: "#Value (point|decimal) #Value",
        tag: "Value",
        reason: "value-point-value"
    },
    //quarter million
    {
        match: "#Determiner [(half|quarter)] #Ordinal",
        group: 0,
        tag: "Value",
        reason: "half-ordinal"
    },
    // thousand and two
    {
        match: `#Multiple+ and #Value`,
        tag: "Value",
        reason: "magnitude-and-value"
    },
    // ambiguous units like 'gb'
    // { match: '#Value square? [(kb|mb|gb|tb|ml|pt|qt|tbl|tbsp|km|cm|mm|mi|ft|yd|kg|hg|mg|oz|lb|mph|pa|miles|yard|yards|pound|pounds)]', group: 0, tag: 'Unit', reason: '12-gb' },
    // 5 miles per hour
    {
        match: "#Value #Unit [(per|an) (hr|hour|sec|second|min|minute)]",
        group: 0,
        tag: "Unit",
        reason: "12-miles-per-second"
    },
    // 5 square miles
    {
        match: "#Value [(square|cubic)] #Unit",
        group: 0,
        tag: "Unit",
        reason: "square-miles"
    },
    // 5) The expenses
    {
        match: "^[#Value] (#Determiner|#Gerund)",
        group: 0,
        tag: "Expression",
        unTag: "Value",
        reason: "numbered-list"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ltTxJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // ==== FirstNames ====
    //is foo Smith
    {
        match: "#Copula [(#Noun|#PresentTense)] #LastName",
        group: 0,
        tag: "FirstName",
        reason: "copula-noun-lastname"
    },
    //pope francis
    {
        match: "(sister|pope|brother|father|aunt|uncle|grandpa|grandfather|grandma) #ProperNoun",
        tag: "Person",
        reason: "lady-titlecase",
        safe: true
    },
    // ==== Nickname ====
    // Dwayne 'the rock' Johnson
    {
        match: "#FirstName [#Determiner #Noun] #LastName",
        group: 0,
        tag: "Person",
        reason: "first-noun-last"
    },
    {
        match: "#ProperNoun (b|c|d|e|f|g|h|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z) #ProperNoun",
        tag: "Person",
        reason: "titlecase-acronym-titlecase",
        safe: true
    },
    {
        match: "#Acronym #LastName",
        tag: "Person",
        reason: "acronym-lastname",
        safe: true
    },
    {
        match: "#Person (jr|sr|md)",
        tag: "Person",
        reason: "person-honorific"
    },
    //remove single 'mr'
    {
        match: "#Honorific #Acronym",
        tag: "Person",
        reason: "Honorific-TitleCase"
    },
    {
        match: "#Person #Person the? #RomanNumeral",
        tag: "Person",
        reason: "roman-numeral"
    },
    {
        match: "#FirstName [/^[^aiurck]$/]",
        group: 0,
        tag: [
            "Acronym",
            "Person"
        ],
        reason: "john-e"
    },
    //j.k Rowling
    {
        match: "#Noun van der? #Noun",
        tag: "Person",
        reason: "van der noun",
        safe: true
    },
    //king of spain
    {
        match: "(king|queen|prince|saint|lady) of #Noun",
        tag: "Person",
        reason: "king-of-noun",
        safe: true
    },
    //lady Florence
    {
        match: "(prince|lady) #Place",
        tag: "Person",
        reason: "lady-place"
    },
    //saint Foo
    {
        match: "(king|queen|prince|saint) #ProperNoun",
        tag: "Person",
        notIf: "#Place",
        reason: "saint-foo"
    },
    // al sharpton
    {
        match: "al (#Person|#ProperNoun)",
        tag: "Person",
        reason: "al-borlen",
        safe: true
    },
    //ferdinand de almar
    {
        match: "#FirstName de #Noun",
        tag: "Person",
        reason: "bill-de-noun"
    },
    //Osama bin Laden
    {
        match: "#FirstName (bin|al) #Noun",
        tag: "Person",
        reason: "bill-al-noun"
    },
    //John L. Foo
    {
        match: "#FirstName #Acronym #ProperNoun",
        tag: "Person",
        reason: "bill-acronym-title"
    },
    //Andrew Lloyd Webber
    {
        match: "#FirstName #FirstName #ProperNoun",
        tag: "Person",
        reason: "bill-firstname-title"
    },
    //Mr Foo
    {
        match: "#Honorific #FirstName? #ProperNoun",
        tag: "Person",
        reason: "dr-john-Title"
    },
    //peter the great
    {
        match: "#FirstName the #Adjective",
        tag: "Person",
        reason: "name-the-great"
    },
    // dick van dyke
    {
        match: "#ProperNoun (van|al|bin) #ProperNoun",
        tag: "Person",
        reason: "title-van-title",
        safe: true
    },
    //jose de Sucre
    {
        match: "#ProperNoun (de|du) la? #ProperNoun",
        tag: "Person",
        notIf: "#Place",
        reason: "title-de-title"
    },
    //Jani K. Smith
    {
        match: "#Singular #Acronym #LastName",
        tag: "#FirstName #Person .",
        reason: "title-acro-noun",
        safe: true
    },
    //Foo Ford
    {
        match: "[#ProperNoun] #Person",
        group: 0,
        tag: "Person",
        reason: "proper-person",
        safe: true
    },
    // john keith jones
    {
        match: "#Person [#ProperNoun #ProperNoun]",
        group: 0,
        tag: "Person",
        notIf: "#Possessive",
        reason: "three-name-person",
        safe: true
    },
    //John Foo
    {
        match: "#FirstName #Acronym? [#ProperNoun]",
        group: 0,
        tag: "LastName",
        notIf: "#Possessive",
        reason: "firstname-titlecase"
    },
    // john stewart
    {
        match: "#FirstName [#FirstName]",
        group: 0,
        tag: "LastName",
        reason: "firstname-firstname"
    },
    //Joe K. Sombrero
    {
        match: "#FirstName #Acronym #Noun",
        tag: "Person",
        reason: "n-acro-noun",
        safe: true
    },
    //Anthony de Marco
    {
        match: "#FirstName [(de|di|du|van|von)] #Person",
        group: 0,
        tag: "LastName",
        reason: "de-firstname"
    },
    // baker jenna smith
    // { match: '[#Actor+] #Person', group: 0, tag: 'Person', reason: 'baker-sam-smith' },
    // sergeant major Harold
    {
        match: "[(lieutenant|corporal|sergeant|captain|qeen|king|admiral|major|colonel|marshal|president|queen|king)+] #ProperNoun",
        group: 0,
        tag: "Honorific",
        reason: "seargeant-john"
    },
    // ==== Honorics ====
    {
        match: "[(private|general|major|rear|prime|field|count|miss)] #Honorific? #Person",
        group: 0,
        tag: [
            "Honorific",
            "Person"
        ],
        reason: "ambg-honorifics"
    },
    // dr john foobar
    {
        match: "#Honorific #FirstName [#Singular]",
        group: 0,
        tag: "LastName",
        notIf: "#Possessive",
        reason: "dr-john-foo",
        safe: true
    },
    //his-excellency
    {
        match: "[(his|her) (majesty|honour|worship|excellency|honorable)] #Person",
        group: 0,
        tag: "Honorific",
        reason: "his-excellency"
    },
    // Lieutenant colonel
    {
        match: "#Honorific #Actor",
        tag: "Honorific",
        reason: "Lieutenant colonel"
    },
    // first lady, second admiral
    {
        match: "(first|second|third|1st|2nd|3rd) #Actor",
        tag: "Honorific",
        reason: "first lady"
    },
    // Louis IV
    {
        match: "#Person #RomanNumeral",
        tag: "Person",
        reason: "louis-IV"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8YJwh":[function(require,module,exports) {
// const personAdj = '(misty|rusty|dusty|rich|randy|sandy|young|earnest|frank|brown)'
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // ebenezer scrooge
    {
        match: "#FirstName #Noun$",
        tag: ". #LastName",
        notIf: "(#Possessive|#Organization|#Place|#Pronoun|@hasTitleCase)",
        reason: "firstname-noun"
    },
    // ===person-date===
    {
        match: "%Person|Date% #Acronym? #ProperNoun",
        tag: "Person",
        reason: "jan-thierson"
    },
    // ===person-noun===
    //Cliff Clavin
    {
        match: "%Person|Noun% #Acronym? #ProperNoun",
        tag: "Person",
        reason: "switch-person",
        safe: true
    },
    // olive garden
    {
        match: "%Person|Noun% #Organization",
        tag: "Organization",
        reason: "olive-garden"
    },
    // ===person-verb===
    // ollie faroo
    {
        match: "%Person|Verb% #Acronym? #ProperNoun",
        tag: "Person",
        reason: "verb-propernoun",
        ifNo: "#Actor"
    },
    // chuck will ...
    {
        match: `[%Person|Verb%] (will|had|has|said|says|told|did|learned|wants|wanted)`,
        group: 0,
        tag: "Person",
        reason: "person-said"
    },
    // ===person-place===
    //sydney harbour
    {
        match: `[%Person|Place%] (harbor|harbour|pier|town|city|place|dump|landfill)`,
        group: 0,
        tag: "Place",
        reason: "sydney-harbour"
    },
    // east sydney
    {
        match: `(west|east|north|south) [%Person|Place%]`,
        group: 0,
        tag: "Place",
        reason: "east-sydney"
    },
    // ===person-adjective===
    // rusty smith
    // { match: `${personAdj} #Person`, tag: 'Person', reason: 'randy-smith' },
    // rusty a. smith
    // { match: `${personAdj} #Acronym? #ProperNoun`, tag: 'Person', reason: 'rusty-smith' },
    // very rusty
    // { match: `#Adverb [${personAdj}]`, group: 0, tag: 'Adjective', reason: 'really-rich' },
    // ===person-verb===
    // would wade
    {
        match: `#Modal [%Person|Verb%]`,
        group: 0,
        tag: "Verb",
        reason: "would-mark"
    },
    // really wade
    {
        match: `#Adverb [%Person|Verb%]`,
        group: 0,
        tag: "Verb",
        reason: "really-mark"
    },
    // drew closer
    {
        match: `[%Person|Verb%] (#Adverb|#Comparative)`,
        group: 0,
        tag: "Verb",
        reason: "drew-closer"
    },
    // wade smith
    {
        match: `%Person|Verb% #Person`,
        tag: "Person",
        reason: "rob-smith"
    },
    // wade m. Cooper
    {
        match: `%Person|Verb% #Acronym #ProperNoun`,
        tag: "Person",
        reason: "rob-a-smith"
    },
    // will go
    {
        match: "[will] #Verb",
        group: 0,
        tag: "Modal",
        reason: "will-verb"
    },
    // will Pharell
    {
        match: "(will && @isTitleCase) #ProperNoun",
        tag: "Person",
        reason: "will-name"
    },
    // jack layton won
    {
        match: "(#FirstName && !#Possessive) [#Singular] #Verb",
        group: 0,
        safe: true,
        tag: "LastName",
        reason: "jack-layton"
    },
    // sherwood anderson told
    {
        match: "^[#Singular] #Person #Verb",
        group: 0,
        safe: true,
        tag: "Person",
        reason: "sherwood-anderson"
    },
    // bought a warhol
    {
        match: "(a|an) [#Person]$",
        group: 0,
        unTag: "Person",
        reason: "a-warhol"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kXYMe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    //sometimes adverbs - 'pretty good','well above'
    {
        match: "#Copula (pretty|dead|full|well|sure) (#Adjective|#Noun)",
        tag: "#Copula #Adverb #Adjective",
        reason: "sometimes-adverb"
    },
    //i better ..
    {
        match: "(#Pronoun|#Person) (had|#Adverb)? [better] #PresentTense",
        group: 0,
        tag: "Modal",
        reason: "i-better"
    },
    // adj -> gerund
    // like
    {
        match: "(#Modal|i|they|we|do) not? [like]",
        group: 0,
        tag: "PresentTense",
        reason: "modal-like"
    },
    // ==== Tense ====
    //he left
    {
        match: "#Noun #Adverb? [left]",
        group: 0,
        tag: "PastTense",
        reason: "left-verb"
    },
    // ==== Copula ====
    //will be running (not copula)
    {
        match: "will #Adverb? not? #Adverb? [be] #Gerund",
        group: 0,
        tag: "Copula",
        reason: "will-be-copula"
    },
    //for more complex forms, just tag 'be'
    {
        match: "will #Adverb? not? #Adverb? [be] #Adjective",
        group: 0,
        tag: "Copula",
        reason: "be-copula"
    },
    // ==== Infinitive ====
    //march to
    {
        match: "[march] (up|down|back|toward)",
        notIf: "#Date",
        group: 0,
        tag: "Infinitive",
        reason: "march-to"
    },
    //must march
    {
        match: "#Modal [march]",
        group: 0,
        tag: "Infinitive",
        reason: "must-march"
    },
    // may be
    {
        match: `[may] be`,
        group: 0,
        tag: "Verb",
        reason: "may-be"
    },
    // subject to
    {
        match: `[(subject|subjects|subjected)] to`,
        group: 0,
        tag: "Verb",
        reason: "subject to"
    },
    // subject to
    {
        match: `[home] to`,
        group: 0,
        tag: "PresentTense",
        reason: "home to"
    },
    // === misc==
    // side with
    // { match: '[(side|fool|monkey)] with', group: 0, tag: 'Infinitive', reason: 'fool-with' },
    // open the door
    {
        match: "[open] #Determiner",
        group: 0,
        tag: "Infinitive",
        reason: "open-the"
    },
    //were being run
    {
        match: `(were|was) being [#PresentTense]`,
        group: 0,
        tag: "PastTense",
        reason: "was-being"
    },
    //had been broken
    {
        match: `(had|has|have) [been /en$/]`,
        group: 0,
        tag: "Auxiliary Participle",
        reason: "had-been-broken"
    },
    //had been smoked
    {
        match: `(had|has|have) [been /ed$/]`,
        group: 0,
        tag: "Auxiliary PastTense",
        reason: "had-been-smoked"
    },
    //were being run
    {
        match: `(had|has) #Adverb? [been] #Adverb? #PastTense`,
        group: 0,
        tag: "Auxiliary",
        reason: "had-been-adj"
    },
    //had to walk
    {
        match: `(had|has) to [#Noun] (#Determiner|#Possessive)`,
        group: 0,
        tag: "Infinitive",
        reason: "had-to-noun"
    },
    // have read
    {
        match: `have [#PresentTense]`,
        group: 0,
        tag: "PastTense",
        notIf: "(come|gotten)",
        reason: "have-read"
    },
    // does that work
    {
        match: `(does|will|#Modal) that [work]`,
        group: 0,
        tag: "PastTense",
        reason: "does-that-work"
    },
    // sounds fun
    {
        match: `[(sound|sounds)] #Adjective`,
        group: 0,
        tag: "PresentTense",
        reason: "sounds-fun"
    },
    // look good
    {
        match: `[(look|looks)] #Adjective`,
        group: 0,
        tag: "PresentTense",
        reason: "looks-good"
    },
    // stops thinking
    {
        match: `[(start|starts|stop|stops|begin|begins)] #Gerund`,
        group: 0,
        tag: "Verb",
        reason: "starts-thinking"
    },
    // have read
    {
        match: `(have|had) read`,
        tag: "Modal #PastTense",
        reason: "read-read"
    },
    //were under cooked
    {
        match: `(is|was|were) [(under|over) #PastTense]`,
        group: 0,
        tag: "Adverb Adjective",
        reason: "was-under-cooked"
    },
    // damn them
    {
        match: "[shit] (#Determiner|#Possessive|them)",
        group: 0,
        tag: "Verb",
        reason: "swear1-verb"
    },
    {
        match: "[damn] (#Determiner|#Possessive|them)",
        group: 0,
        tag: "Verb",
        reason: "swear2-verb"
    },
    {
        match: "[fuck] (#Determiner|#Possessive|them)",
        group: 0,
        tag: "Verb",
        reason: "swear3-verb"
    },
    // jobs that fit
    {
        match: "#Plural that %Noun|Verb%",
        tag: ". #Preposition #Infinitive",
        reason: "jobs-that-work"
    },
    // works for me
    {
        match: "[works] for me",
        group: 0,
        tag: "PresentTense",
        reason: "works-for-me"
    },
    // as we please
    {
        match: "as #Pronoun [please]",
        group: 0,
        tag: "Infinitive",
        reason: "as-we-please"
    },
    // verb-prefixes - 'co write'
    {
        match: "[(co|mis|de|inter|intra|pre|re|un|out|under|over|counter)] #Verb",
        group: 0,
        tag: [
            "Verb",
            "Prefix"
        ],
        notIf: "(#Copula|#PhrasalVerb)",
        reason: "co-write"
    },
    // dressed and left
    {
        match: "#PastTense and [%Adj|Past%]",
        group: 0,
        tag: "PastTense",
        reason: "dressed-and-left"
    },
    // melted and fallen
    {
        match: "[%Adj|Past%] and #PastTense",
        group: 0,
        tag: "PastTense",
        reason: "dressed-and-left"
    },
    // is he stoked
    {
        match: "#Copula #Pronoun [%Adj|Past%]",
        group: 0,
        tag: "Adjective",
        reason: "is-he-stoked"
    },
    // to dream of
    {
        match: "to [%Noun|Verb%] #Preposition",
        group: 0,
        tag: "Infinitive",
        reason: "to-dream-of"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"404yk":[function(require,module,exports) {
// these are some of our heaviest-used matches
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // ==== Auxiliary ====
    // have been
    {
        match: `will (#Adverb|not)+? [have] (#Adverb|not)+? #Verb`,
        group: 0,
        tag: "Auxiliary",
        reason: "will-have-vb"
    },
    //was walking
    {
        match: `[#Copula] (#Adverb|not)+? (#Gerund|#PastTense)`,
        group: 0,
        tag: "Auxiliary",
        reason: "copula-walking"
    },
    //would walk
    {
        match: `[(#Modal|did)+] (#Adverb|not)+? #Verb`,
        group: 0,
        tag: "Auxiliary",
        reason: "modal-verb"
    },
    //would have had
    {
        match: `#Modal (#Adverb|not)+? [have] (#Adverb|not)+? [had] (#Adverb|not)+? #Verb`,
        group: 0,
        tag: "Auxiliary",
        reason: "would-have"
    },
    //support a splattering of auxillaries before a verb
    {
        match: `[(has|had)] (#Adverb|not)+? #PastTense`,
        group: 0,
        tag: "Auxiliary",
        reason: "had-walked"
    },
    // will walk
    {
        match: "[(do|does|did|will|have|had|has|got)] (not|#Adverb)+? #Verb",
        group: 0,
        tag: "Auxiliary",
        reason: "have-had"
    },
    // about to go
    {
        match: "[about to] #Adverb? #Verb",
        group: 0,
        tag: [
            "Auxiliary",
            "Verb"
        ],
        reason: "about-to"
    },
    //would be walking
    {
        match: `#Modal (#Adverb|not)+? [be] (#Adverb|not)+? #Verb`,
        group: 0,
        tag: "Auxiliary",
        reason: "would-be"
    },
    //had been walking
    {
        match: `[(#Modal|had|has)] (#Adverb|not)+? [been] (#Adverb|not)+? #Verb`,
        group: 0,
        tag: "Auxiliary",
        reason: "had-been"
    },
    // was being driven
    {
        match: "[(be|being|been)] #Participle",
        group: 0,
        tag: "Auxiliary",
        reason: "being-driven"
    },
    // may want
    {
        match: "[may] #Adverb? #Infinitive",
        group: 0,
        tag: "Auxiliary",
        reason: "may-want"
    },
    // was being walked
    {
        match: "#Copula (#Adverb|not)+? [(be|being|been)] #Adverb+? #PastTense",
        group: 0,
        tag: "Auxiliary",
        reason: "being-walked"
    },
    // will be walked
    {
        match: "will [be] #PastTense",
        group: 0,
        tag: "Auxiliary",
        reason: "will-be-x"
    },
    // been walking
    {
        match: "[(be|been)] (#Adverb|not)+? #Gerund",
        group: 0,
        tag: "Auxiliary",
        reason: "been-walking"
    },
    // used to walk
    {
        match: "[used to] #PresentTense",
        group: 0,
        tag: "Auxiliary",
        reason: "used-to-walk"
    },
    // was going to walk
    {
        match: "#Copula (#Adverb|not)+? [going to] #Adverb+? #PresentTense",
        group: 0,
        tag: "Auxiliary",
        reason: "going-to-walk"
    },
    // tell me
    {
        match: "#Imperative [(me|him|her)]",
        group: 0,
        tag: "Reflexive",
        reason: "tell-him"
    },
    // there is no x
    {
        match: "(is|was) #Adverb? [no]",
        group: 0,
        tag: "Negative",
        reason: "is-no"
    },
    // been told
    {
        match: "[(been|had|became|came)] #PastTense",
        group: 0,
        notIf: "#PhrasalVerb",
        tag: "Auxiliary",
        reason: "been-told"
    },
    // being born
    {
        match: "[(being|having|getting)] #Verb",
        group: 0,
        tag: "Auxiliary",
        reason: "being-born"
    },
    // be walking
    {
        match: "[be] #Gerund",
        group: 0,
        tag: "Auxiliary",
        reason: "be-walking"
    },
    // better go
    {
        match: "[better] #PresentTense",
        group: 0,
        tag: "Modal",
        notIf: "(#Copula|#Gerund)",
        reason: "better-go"
    },
    // even better
    {
        match: "even better",
        tag: "Adverb #Comparative",
        reason: "even-better"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3pcVs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // ==== Phrasal ====
    //'foo-up'
    {
        match: "(#Verb && @hasHyphen) up",
        tag: "PhrasalVerb",
        reason: "foo-up"
    },
    {
        match: "(#Verb && @hasHyphen) off",
        tag: "PhrasalVerb",
        reason: "foo-off"
    },
    {
        match: "(#Verb && @hasHyphen) over",
        tag: "PhrasalVerb",
        reason: "foo-over"
    },
    {
        match: "(#Verb && @hasHyphen) out",
        tag: "PhrasalVerb",
        reason: "foo-out"
    },
    // walk in on
    {
        match: "[#Verb (in|out|up|down|off|back)] (on|in)",
        notIf: "#Copula",
        tag: "PhrasalVerb Particle",
        reason: "walk-in-on"
    },
    // went on for
    {
        match: "(lived|went|crept|go) [on] for",
        group: 0,
        tag: "PhrasalVerb",
        reason: "went-on"
    },
    // the curtains come down
    {
        match: "#Verb (up|down|in|on|for)$",
        tag: "PhrasalVerb #Particle",
        notIf: "#PhrasalVerb",
        reason: "come-down$"
    },
    // got me thinking
    // { match: '(got|had) me [#Noun]', group: 0, tag: 'Verb', reason: 'got-me-gerund' },
    // help stop
    {
        match: "help [(stop|end|make|start)]",
        group: 0,
        tag: "Infinitive",
        reason: "help-stop"
    },
    // work in the office
    {
        match: "#PhrasalVerb (in && #Particle) #Determiner",
        tag: "#Verb #Preposition #Determiner",
        unTag: "PhrasalVerb",
        reason: "work-in-the"
    },
    // start listening
    {
        match: "[(stop|start|finish|help)] #Gerund",
        group: 0,
        tag: "Infinitive",
        reason: "start-listening"
    },
    // mis-fired
    // { match: '[(mis)] #Verb', group: 0, tag: 'Verb', reason: 'mis-firedsa' },
    //back it up
    {
        match: "#Verb (him|her|it|us|himself|herself|itself|everything|something) [(up|down)]",
        group: 0,
        tag: "Adverb",
        reason: "phrasal-pronoun-advb"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"77RD5":[function(require,module,exports) {
// this is really hard to do
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const notIf = "(i|we|they)" //we do not go
;
exports.default = [
    // do not go
    {
        match: "^do not? [#Infinitive #Particle?]",
        notIf,
        group: 0,
        tag: "Imperative",
        reason: "do-eat"
    },
    // please go
    {
        match: "^please do? not? [#Infinitive #Particle?]",
        group: 0,
        tag: "Imperative",
        reason: "please-go"
    },
    // just go
    {
        match: "^just do? not? [#Infinitive #Particle?]",
        group: 0,
        tag: "Imperative",
        reason: "just-go"
    },
    // do it better
    {
        match: "^[#Infinitive] it #Comparative",
        notIf,
        group: 0,
        tag: "Imperative",
        reason: "do-it-better"
    },
    // do it again
    {
        match: "^[#Infinitive] it (please|now|again|plz)",
        notIf,
        group: 0,
        tag: "Imperative",
        reason: "do-it-please"
    },
    // go quickly.
    {
        match: "^[#Infinitive] (#Adjective|#Adverb)$",
        group: 0,
        tag: "Imperative",
        notIf: "(so|such|rather|enough)",
        reason: "go-quickly"
    },
    // turn down the noise
    {
        match: "^[#Infinitive] (up|down|over) #Determiner",
        group: 0,
        tag: "Imperative",
        reason: "turn-down"
    },
    // eat my shorts
    {
        match: "^[#Infinitive] (your|my|the|a|an|any|each|every|some|more|with|on)",
        group: 0,
        notIf: "like",
        tag: "Imperative",
        reason: "eat-my-shorts"
    },
    // tell him the story
    {
        match: "^[#Infinitive] (him|her|it|us|me|there)",
        group: 0,
        tag: "Imperative",
        reason: "tell-him"
    },
    // avoid loud noises
    {
        match: "^[#Infinitive] #Adjective #Noun$",
        group: 0,
        tag: "Imperative",
        reason: "avoid-loud-noises"
    },
    // call and reserve
    {
        match: "^[#Infinitive] (#Adjective|#Adverb)? and #Infinitive",
        group: 0,
        tag: "Imperative",
        reason: "call-and-reserve"
    },
    // one-word imperatives
    {
        match: "^(go|stop|wait|hurry) please?$",
        tag: "Imperative",
        reason: "go"
    },
    // somebody call
    {
        match: "^(somebody|everybody) [#Infinitive]",
        group: 0,
        tag: "Imperative",
        reason: "somebody-call"
    },
    // let's leave
    {
        match: "^let (us|me) [#Infinitive]",
        group: 0,
        tag: "Imperative",
        reason: "lets-leave"
    },
    // shut the door
    {
        match: "^[(shut|close|open|start|stop|end|keep)] #Determiner #Noun",
        group: 0,
        tag: "Imperative",
        reason: "shut-the-door"
    },
    // turn off the light
    {
        match: "^[#PhrasalVerb #Particle] #Determiner #Noun",
        group: 0,
        tag: "Imperative",
        reason: "turn-off-the-light"
    },
    // go to toronto
    {
        match: "^[go] to .",
        group: 0,
        tag: "Imperative",
        reason: "go-to-toronto"
    },
    // would you recommend
    {
        match: "^#Modal you [#Infinitive]",
        group: 0,
        tag: "Imperative",
        reason: "would-you-"
    },
    // never say
    {
        match: "^never [#Infinitive]",
        group: 0,
        tag: "Imperative",
        reason: "never-stop"
    },
    // come have a drink
    {
        match: "^come #Infinitive",
        tag: "Imperative",
        notIf: "on",
        reason: "come-have"
    },
    // come and have a drink
    {
        match: "^come and? #Infinitive",
        tag: "Imperative . Imperative",
        notIf: "#PhrasalVerb",
        reason: "come-and-have"
    },
    // stay away
    {
        match: "^stay (out|away|back)",
        tag: "Imperative",
        reason: "stay-away"
    },
    // stay cool
    {
        match: "^[(stay|be|keep)] #Adjective",
        group: 0,
        tag: "Imperative",
        reason: "stay-cool"
    },
    // keep it silent
    {
        match: "^[keep it] #Adjective",
        group: 0,
        tag: "Imperative",
        reason: "keep-it-cool"
    },
    // don't be late
    {
        match: "^do not [#Infinitive]",
        group: 0,
        tag: "Imperative",
        reason: "do-not-be"
    },
    // allow yourself
    {
        match: "[#Infinitive] (yourself|yourselves)",
        group: 0,
        tag: "Imperative",
        reason: "allow-yourself"
    },
    // look what
    {
        match: "[#Infinitive] what .",
        group: 0,
        tag: "Imperative",
        reason: "look-what"
    },
    // continue playing
    {
        match: "^[#Infinitive] #Gerund",
        group: 0,
        tag: "Imperative",
        reason: "keep-playing"
    },
    // go to it
    {
        match: "^[#Infinitive] (to|for|into|toward|here|there)",
        group: 0,
        tag: "Imperative",
        reason: "go-to"
    },
    // relax and unwind
    {
        match: "^[#Infinitive] (and|or) #Infinitive",
        group: 0,
        tag: "Imperative",
        reason: "inf-and-inf"
    },
    // commit to
    {
        match: "^[%Noun|Verb%] to",
        group: 0,
        tag: "Imperative",
        reason: "commit-to"
    },
    // maintain eye contact
    {
        match: "^[#Infinitive] #Adjective? #Singular #Singular",
        group: 0,
        tag: "Imperative",
        reason: "maintain-eye-contact"
    },
    // don't forget to clean
    {
        match: "do not (forget|omit|neglect) to [#Infinitive]",
        group: 0,
        tag: "Imperative",
        reason: "do-not-forget"
    },
    // pay attention
    {
        match: "^[(ask|wear|pay|look|help|show|watch|act|fix|kill|stop|start|turn|try|win)] #Noun",
        group: 0,
        tag: "Imperative",
        reason: "pay-attention"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lGbvK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // that were growing
    {
        match: "(that|which) were [%Adj|Gerund%]",
        group: 0,
        tag: "Gerund",
        reason: "that-were-growing"
    },
    // repairing crubling roads
    {
        match: "#Gerund [#Gerund] #Plural",
        group: 0,
        tag: "Adjective",
        reason: "hard-working-fam"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lhq7x":[function(require,module,exports) {
// ==== Passive voice ===
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // got walked, was walked, were walked
    {
        match: "(got|were|was|is|are|am) (#PastTense|#Participle)",
        tag: "Passive",
        reason: "got-walked"
    },
    // was being walked
    {
        match: "(was|were|is|are|am) being (#PastTense|#Participle)",
        tag: "Passive",
        reason: "was-being"
    },
    // had been walked, have been eaten
    {
        match: "(had|have|has) been (#PastTense|#Participle)",
        tag: "Passive",
        reason: "had-been"
    },
    // will be cleaned
    {
        match: "will be being? (#PastTense|#Participle)",
        tag: "Passive",
        reason: "will-be-cleaned"
    },
    // suffered by the country
    {
        match: "#Noun [(#PastTense|#Participle)] by (the|a) #Noun",
        group: 0,
        tag: "Passive",
        reason: "suffered-by"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lCWzM":[function(require,module,exports) {
// order matters
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let matches = [
    // u r cool
    {
        match: "u r",
        tag: "#Pronoun #Copula",
        reason: "u r"
    },
    {
        match: "#Noun [(who|whom)]",
        group: 0,
        tag: "Determiner",
        reason: "captain-who"
    },
    // ==== Conditions ====
    // had he survived,
    {
        match: "[had] #Noun+ #PastTense",
        group: 0,
        tag: "Condition",
        reason: "had-he"
    },
    // were he to survive
    {
        match: "[were] #Noun+ to #Infinitive",
        group: 0,
        tag: "Condition",
        reason: "were-he"
    },
    // some sort of
    {
        match: "some sort of",
        tag: "Adjective Noun Conjunction",
        reason: "some-sort-of"
    },
    // some of
    // { match: 'some of', tag: 'Noun Conjunction', reason: 'some-of' },
    // of some sort
    {
        match: "of some sort",
        tag: "Conjunction Adjective Noun",
        reason: "of-some-sort"
    },
    // such skill
    {
        match: "[such] (a|an|is)? #Noun",
        group: 0,
        tag: "Determiner",
        reason: "such-skill"
    },
    // another one
    // { match: '[another] (#Noun|#Value)', group: 0, tag: 'Adjective', reason: 'another-one' },
    // right after
    {
        match: "[right] (before|after|in|into|to|toward)",
        group: 0,
        tag: "#Adverb",
        reason: "right-into"
    },
    // at about
    {
        match: "#Preposition [about]",
        group: 0,
        tag: "Adjective",
        reason: "at-about"
    },
    // are ya
    {
        match: "(are|#Modal|see|do|for) [ya]",
        group: 0,
        tag: "Pronoun",
        reason: "are-ya"
    },
    // long live
    {
        match: "[long live] .",
        group: 0,
        tag: "#Adjective #Infinitive",
        reason: "long-live"
    },
    // plenty of
    {
        match: "[plenty] of",
        group: 0,
        tag: "#Uncountable",
        reason: "plenty-of"
    },
    // 'there' as adjective
    {
        match: "(always|nearly|barely|practically) [there]",
        group: 0,
        tag: "Adjective",
        reason: "always-there"
    },
    // existential 'there'
    // there she is
    {
        match: "[there] (#Adverb|#Pronoun)? #Copula",
        group: 0,
        tag: "There",
        reason: "there-is"
    },
    // is there food
    {
        match: "#Copula [there] .",
        group: 0,
        tag: "There",
        reason: "is-there"
    },
    // should there
    {
        match: "#Modal #Adverb? [there]",
        group: 0,
        tag: "There",
        reason: "should-there"
    },
    // do you
    {
        match: "^[do] (you|we|they)",
        group: 0,
        tag: "QuestionWord",
        reason: "do-you"
    },
    // does he
    {
        match: "^[does] (he|she|it|#ProperNoun)",
        group: 0,
        tag: "QuestionWord",
        reason: "does-he"
    },
    // the person who
    {
        match: "#Determiner #Noun+ [who] #Verb",
        group: 0,
        tag: "Preposition",
        reason: "the-x-who"
    },
    // the person which
    {
        match: "#Determiner #Noun+ [which] #Verb",
        group: 0,
        tag: "Preposition",
        reason: "the-x-which"
    },
    // a while
    {
        match: "a [while]",
        group: 0,
        tag: "Noun",
        reason: "a-while"
    },
    // guess who
    {
        match: "guess who",
        tag: "#Infinitive #QuestionWord",
        reason: "guess-who"
    },
    // swear words
    {
        match: "[fucking] !#Verb",
        group: 0,
        tag: "#Gerund",
        reason: "f-as-gerund"
    }
];
exports.default = matches;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"farKF":[function(require,module,exports) {
// import orgWords from './_orgWords.js'
// let orgMap = `(${orgWords.join('|')})`
/*
const multi = [
  'building society',
  'central bank',
  'department store',
  'institute of technology',
  'liberation army',
  'people party',
  'social club',
  'state police',
  'state university',
]
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // Foo University
    // { match: `#Noun ${orgMap}`, tag: 'Organization', safe: true, reason: 'foo-university' },
    // // University of Toronto
    // { match: `${orgMap} of #Place`, tag: 'Organization', safe: true, reason: 'university-of-foo' },
    // // foo regional health authority
    // { match: `${orgMap} (health|local|regional)+ authority`, tag: 'Organization', reason: 'regional-health' },
    // // foo stock exchange
    // { match: `${orgMap} (stock|mergantile)+ exchange`, tag: 'Organization', reason: 'stock-exchange' },
    // // foo news service
    // { match: `${orgMap} (daily|evening|local)+ news service?`, tag: 'Organization', reason: 'foo-news' },
    //University of Foo
    {
        match: "university of #Place",
        tag: "Organization",
        reason: "university-of-Foo"
    },
    //John & Joe's
    {
        match: "#Noun (&|n) #Noun",
        tag: "Organization",
        reason: "Noun-&-Noun"
    },
    // teachers union of Ontario
    {
        match: "#Organization of the? #ProperNoun",
        tag: "Organization",
        reason: "org-of-place",
        safe: true
    },
    //walmart USA
    {
        match: "#Organization #Country",
        tag: "Organization",
        reason: "org-country"
    },
    //organization
    {
        match: "#ProperNoun #Organization",
        tag: "Organization",
        notIf: "#FirstName",
        reason: "titlecase-org"
    },
    //FitBit Inc
    {
        match: "#ProperNoun (ltd|co|inc|dept|assn|bros)",
        tag: "Organization",
        reason: "org-abbrv"
    },
    // the OCED
    {
        match: "the [#Acronym]",
        group: 0,
        tag: "Organization",
        reason: "the-acronym",
        safe: true
    },
    // government of india
    {
        match: "government of the? [#Place+]",
        tag: "Organization",
        reason: "government-of-x"
    },
    // school board
    {
        match: "(health|school|commerce) board",
        tag: "Organization",
        reason: "school-board"
    },
    // special comittee
    {
        match: "(nominating|special|conference|executive|steering|central|congressional) committee",
        tag: "Organization",
        reason: "special-comittee"
    },
    // global trade union
    {
        match: "(world|global|international|national|#Demonym) #Organization",
        tag: "Organization",
        reason: "global-org"
    },
    // schools
    {
        match: "#Noun+ (public|private) school",
        tag: "School",
        reason: "noun-public-school"
    },
    // new york yankees
    {
        match: "#Place+ #SportsTeam",
        tag: "SportsTeam",
        reason: "place-sportsteam"
    },
    // 'manchester united'
    {
        match: "(dc|atlanta|minnesota|manchester|newcastle|sheffield) united",
        tag: "SportsTeam",
        reason: "united-sportsteam"
    },
    // 'toronto fc'
    {
        match: "#Place+ fc",
        tag: "SportsTeam",
        reason: "fc-sportsteam"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"34MN7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // ==== Region ====
    // West Norforlk
    {
        match: "(west|north|south|east|western|northern|southern|eastern)+ #Place",
        tag: "Region",
        reason: "west-norfolk"
    },
    //some us-state acronyms (exlude: al, in, la, mo, hi, me, md, ok..)
    {
        match: "#City [(al|ak|az|ar|ca|ct|dc|fl|ga|id|il|nv|nh|nj|ny|oh|pa|sc|tn|tx|ut|vt|pr)]",
        group: 0,
        tag: "Region",
        reason: "us-state"
    },
    // portland oregon
    {
        match: "portland [or]",
        group: 0,
        tag: "Region",
        reason: "portland-or"
    },
    //words removed from preTagger/placeWords
    {
        match: "#ProperNoun+ (cliff|place|range|pit|place|point|room|grounds|ruins)",
        tag: "Place",
        reason: "foo-point"
    },
    // in Foo California
    {
        match: "in [#ProperNoun] #Place",
        group: 0,
        tag: "Place",
        reason: "propernoun-place"
    },
    // Address
    {
        match: "#Value #Noun (st|street|rd|road|crescent|cr|way|tr|terrace|avenue|ave)",
        tag: "Address",
        reason: "address-st"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"52isX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    // ==== Conjunctions ====
    {
        match: "[so] #Noun",
        group: 0,
        tag: "Conjunction",
        reason: "so-conj"
    },
    //how he is driving
    {
        match: "[(who|what|where|why|how|when)] #Noun #Copula #Adverb? (#Verb|#Adjective)",
        group: 0,
        tag: "Conjunction",
        reason: "how-he-is-x"
    },
    // when he
    {
        match: "#Copula [(who|what|where|why|how|when)] #Noun",
        group: 0,
        tag: "Conjunction",
        reason: "when-he"
    },
    // says that he..
    {
        match: "#Verb [that] #Pronoun",
        group: 0,
        tag: "Conjunction",
        reason: "said-that-he"
    },
    // things that are required
    {
        match: "#Noun [that] #Copula",
        group: 0,
        tag: "Conjunction",
        reason: "that-are"
    },
    // things that seem cool
    {
        match: "#Noun [that] #Verb #Adjective",
        group: 0,
        tag: "Conjunction",
        reason: "that-seem"
    },
    // wasn't that wide..
    {
        match: "#Noun #Copula not? [that] #Adjective",
        group: 0,
        tag: "Adverb",
        reason: "that-adj"
    },
    // ==== Prepositions ====
    //all students
    {
        match: "#Verb #Adverb? #Noun [(that|which)]",
        group: 0,
        tag: "Preposition",
        reason: "that-prep"
    },
    //work, which has been done.
    {
        match: "@hasComma [which] (#Pronoun|#Verb)",
        group: 0,
        tag: "Preposition",
        reason: "which-copula"
    },
    //folks like her
    {
        match: "#Noun [like] #Noun",
        group: 0,
        tag: "Preposition",
        reason: "noun-like"
    },
    //like the time
    {
        match: "^[like] #Determiner",
        group: 0,
        tag: "Preposition",
        reason: "like-the"
    },
    //a day like this
    {
        match: "a #Noun [like] (#Noun|#Determiner)",
        group: 0,
        tag: "Preposition",
        reason: "a-noun-like"
    },
    // really like
    {
        match: "#Adverb [like]",
        group: 0,
        tag: "Verb",
        reason: "really-like"
    },
    // nothing like
    {
        match: "(not|nothing|never) [like]",
        group: 0,
        tag: "Preposition",
        reason: "nothing-like"
    },
    // treat them like
    {
        match: "#Infinitive #Pronoun [like]",
        group: 0,
        tag: "Preposition",
        reason: "treat-them-like"
    },
    // ==== Questions ====
    // where
    // why
    // when
    // who
    // whom
    // whose
    // what
    // which
    //the word 'how many'
    // { match: '^(how|which)', tag: 'QuestionWord', reason: 'how-question' },
    // how-he, when the
    {
        match: "[#QuestionWord] (#Pronoun|#Determiner)",
        group: 0,
        tag: "Preposition",
        reason: "how-he"
    },
    // when stolen
    {
        match: "[#QuestionWord] #Participle",
        group: 0,
        tag: "Preposition",
        reason: "when-stolen"
    },
    // how is
    {
        match: "[how] (#Determiner|#Copula|#Modal|#PastTense)",
        group: 0,
        tag: "QuestionWord",
        reason: "how-is"
    },
    // children who dance
    {
        match: "#Plural [(who|which|when)] .",
        group: 0,
        tag: "Preposition",
        reason: "people-who"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7abZ7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = [
    //swear-words as non-expression POS
    {
        match: "holy (shit|fuck|hell)",
        tag: "Expression",
        reason: "swears-expression"
    },
    // well..
    {
        match: "^[(well|so|okay|now)] !#Adjective?",
        group: 0,
        tag: "Expression",
        reason: "well-"
    },
    // well..
    {
        match: "^come on",
        tag: "Expression",
        reason: "come-on"
    },
    // sorry
    {
        match: "(say|says|said) [sorry]",
        group: 0,
        tag: "Expression",
        reason: "say-sorry"
    },
    // ok,
    {
        match: "^(ok|alright|shoot|hell|anyways)",
        tag: "Expression",
        reason: "ok-"
    },
    // c'mon marge..
    // { match: '^[come on] #Noun', group: 0, tag: 'Expression', reason: 'come-on' },
    // say,
    {
        match: "^(say && @hasComma)",
        tag: "Expression",
        reason: "say-"
    },
    {
        match: "^(like && @hasComma)",
        tag: "Expression",
        reason: "like-"
    },
    // dude we should
    {
        match: "^[(dude|man|girl)] #Pronoun",
        group: 0,
        tag: "Expression",
        reason: "dude-i"
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2jLJz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
let net = null;
// runs all match/tag patterns in model.two.matches
const postTagger = function(view) {
    const { world } = view;
    const { model, methods } = world;
    net = net || methods.one.buildNet(model.two.matches, world);
    // perform these matches on a comma-seperated document
    let document = methods.two.quickSplit(view.document);
    let ptrs = document.map((terms)=>{
        let t = terms[0];
        return [
            t.index[0],
            t.index[1],
            t.index[1] + terms.length
        ];
    });
    let m = view.update(ptrs);
    m.cache();
    m.sweep(net);
    view.uncache();
    view.unfreeze();
    return view;
};
// helper function for compute('tagger')
const tagger = (view)=>view.compute([
        "lexicon",
        "preTagger",
        "postTagger"
    ]);
exports.default = {
    postTagger,
    tagger
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fXnP3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>function(View) {
        // average tagger score
        View.prototype.confidence = function() {
            let sum = 0;
            let count = 0;
            this.docs.forEach((terms)=>{
                terms.forEach((term)=>{
                    count += 1;
                    sum += term.confidence || 1;
                });
            });
            if (count === 0) return 1;
            return round(sum / count);
        };
        // (re-) run the POS-tagger
        View.prototype.tagger = function() {
            return this.compute([
                "tagger"
            ]);
        };
    });
const round = (n)=>Math.round(n * 100) / 100;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4qwqK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lazyParseJs = require("./lazyParse.js");
var _lazyParseJsDefault = parcelHelpers.interopDefault(_lazyParseJs);
exports.default = {
    lib: {
        lazy: (0, _lazyParseJsDefault.default)
    }
};

},{"./lazyParse.js":"6gnQY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6gnQY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _maybeMatchJs = require("./maybeMatch.js");
var _maybeMatchJsDefault = parcelHelpers.interopDefault(_maybeMatchJs);
// tokenize first, then only tag sentences required
const lazyParse = function(input, reg) {
    let net = reg;
    if (typeof reg === "string") net = this.buildNet([
        {
            match: reg
        }
    ]);
    let doc = this.tokenize(input);
    let m = (0, _maybeMatchJsDefault.default)(doc, net);
    if (m.found) {
        m.compute([
            "index",
            "tagger"
        ]);
        return m.match(reg);
    }
    return doc.none();
};
exports.default = lazyParse;

},{"./maybeMatch.js":"41VNl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"41VNl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const getWords = function(net) {
    return Object.keys(net.hooks).filter((w)=>!w.startsWith("#") && !w.startsWith("%"));
};
const maybeMatch = function(doc, net) {
    // must have *atleast* one of these words
    let words = getWords(net);
    if (words.length === 0) return doc;
    if (!doc._cache) doc.cache();
    let cache = doc._cache;
    // return sentences that have one of our needed words
    return doc.filter((_m, i)=>{
        return words.some((str)=>cache[i].has(str));
    });
};
exports.default = maybeMatch;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4m1UV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _swapJs = require("./api/swap.js");
var _swapJsDefault = parcelHelpers.interopDefault(_swapJs);
const api = function(View) {
    View.prototype.swap = (0, _swapJsDefault.default);
};
exports.default = {
    api
};

},{"./api/swap.js":"afOJj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"afOJj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _swapVerbJs = require("./swap-verb.js");
var _swapVerbJsDefault = parcelHelpers.interopDefault(_swapVerbJs);
const swapNoun = function(m, lemma) {
    let str = lemma;
    if (m.has("#Plural")) {
        const toPlural = m.methods.two.transform.noun.toPlural;
        str = toPlural(lemma, m.model);
    }
    m.replaceWith(str, {
        possessives: true
    });
};
const swapAdverb = function(m, lemma) {
    const { toAdverb } = m.methods.two.transform.adjective;
    let str = lemma;
    let adv = toAdverb(str);
    if (adv) m.replaceWith(adv);
};
const swapAdjective = function(m, lemma) {
    const { toComparative, toSuperlative } = m.methods.two.transform.adjective;
    let str = lemma;
    if (m.has("#Comparative")) str = toComparative(str, m.model);
    else if (m.has("#Superlative")) str = toSuperlative(str, m.model);
    if (str) m.replaceWith(str);
};
const swap = function(from, to, tag) {
    let reg = from.split(/ /g).map((str)=>str.toLowerCase().trim());
    reg = reg.filter((str)=>str);
    reg = reg.map((str)=>`{${str}}`).join(" ");
    let m = this.match(reg);
    // guard against some homonyms
    if (tag) m = m.if(tag);
    if (m.has("#Verb")) return (0, _swapVerbJsDefault.default)(m, to);
    if (m.has("#Noun")) return swapNoun(m, to);
    if (m.has("#Adverb")) return swapAdverb(m, to);
    if (m.has("#Adjective")) return swapAdjective(m, to);
    return this;
};
exports.default = swap;

},{"./swap-verb.js":"iwADa","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iwADa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const matchVerb = function(m, lemma) {
    const conjugate = m.methods.two.transform.verb.conjugate;
    let all = conjugate(lemma, m.model);
    if (m.has("#Gerund")) return all.Gerund;
    if (m.has("#PastTense")) return all.PastTense;
    if (m.has("#PresentTense")) return all.PresentTense;
    if (m.has("#Gerund")) return all.Gerund;
    return lemma;
};
const swapVerb = function(vb, lemma) {
    let str = lemma;
    vb.forEach((m)=>{
        if (!m.has("#Infinitive")) str = matchVerb(m, lemma);
        m.replaceWith(str);
    });
    return vb;
};
exports.default = swapVerb;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"74uG7":[function(require,module,exports) {
// guard against superlative+comparative forms
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const toRoot = function(adj) {
    const { fromComparative, fromSuperlative } = adj.methods.two.transform.adjective;
    let str = adj.text("normal");
    if (adj.has("#Comparative")) return fromComparative(str, adj.model);
    if (adj.has("#Superlative")) return fromSuperlative(str, adj.model);
    return str;
};
const api = function(View) {
    class Adjectives extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Adjectives";
        }
        json(opts = {}) {
            const { toAdverb, toNoun, toSuperlative, toComparative } = this.methods.two.transform.adjective;
            opts.normal = true;
            return this.map((m)=>{
                let json = m.toView().json(opts)[0] || {};
                let str = toRoot(m);
                json.adjective = {
                    adverb: toAdverb(str, this.model),
                    noun: toNoun(str, this.model),
                    superlative: toSuperlative(str, this.model),
                    comparative: toComparative(str, this.model)
                };
                return json;
            }, []);
        }
        adverbs() {
            return this.before("#Adverb+$").concat(this.after("^#Adverb+"));
        }
        conjugate(n) {
            const { toComparative, toSuperlative, toNoun, toAdverb } = this.methods.two.transform.adjective;
            return this.getNth(n).map((adj)=>{
                let root = toRoot(adj);
                return {
                    Adjective: root,
                    Comparative: toComparative(root, this.model),
                    Superlative: toSuperlative(root, this.model),
                    Noun: toNoun(root, this.model),
                    Adverb: toAdverb(root, this.model)
                };
            }, []);
        }
        toComparative(n) {
            const { toComparative } = this.methods.two.transform.adjective;
            return this.getNth(n).map((adj)=>{
                let root = toRoot(adj);
                let str = toComparative(root, this.model);
                return adj.replaceWith(str);
            });
        }
        toSuperlative(n) {
            const { toSuperlative } = this.methods.two.transform.adjective;
            return this.getNth(n).map((adj)=>{
                let root = toRoot(adj);
                let str = toSuperlative(root, this.model);
                return adj.replaceWith(str);
            });
        }
        toAdverb(n) {
            const { toAdverb } = this.methods.two.transform.adjective;
            return this.getNth(n).map((adj)=>{
                let root = toRoot(adj);
                let str = toAdverb(root, this.model);
                return adj.replaceWith(str);
            });
        }
        toNoun(n) {
            const { toNoun } = this.methods.two.transform.adjective;
            return this.getNth(n).map((adj)=>{
                let root = toRoot(adj);
                let str = toNoun(root, this.model);
                return adj.replaceWith(str);
            });
        }
    }
    View.prototype.adjectives = function(n) {
        let m = this.match("#Adjective");
        m = m.getNth(n);
        return new Adjectives(m.document, m.pointer);
    };
    View.prototype.superlatives = function(n) {
        let m = this.match("#Superlative");
        m = m.getNth(n);
        return new Adjectives(m.document, m.pointer);
    };
    View.prototype.comparatives = function(n) {
        let m = this.match("#Comparative");
        m = m.getNth(n);
        return new Adjectives(m.document, m.pointer);
    };
};
exports.default = {
    api
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8dS3E":[function(require,module,exports) {
// guard against superlative+comparative forms
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const toRoot = function(adj) {
    let str = adj.compute("root").text("root");
    return str;
};
// return the nth elem of a doc
const api = function(View) {
    class Adverbs extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Adverbs";
        }
        conjugate(n) {
            return this.getNth(n).map((adv)=>{
                let adj = toRoot(adv);
                return {
                    Adverb: adv.text("normal"),
                    Adjective: adj
                };
            }, []);
        }
        json(opts = {}) {
            const fromAdverb = this.methods.two.transform.adjective.fromAdverb;
            opts.normal = true;
            return this.map((m)=>{
                let json = m.toView().json(opts)[0] || {};
                json.adverb = {
                    adjective: fromAdverb(json.normal)
                };
                return json;
            }, []);
        }
    }
    View.prototype.adverbs = function(n) {
        let m = this.match("#Adverb");
        m = m.getNth(n);
        return new Adverbs(m.document, m.pointer);
    };
};
exports.default = {
    api
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hnmzV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _apiJs = require("./api/api.js");
var _apiJsDefault = parcelHelpers.interopDefault(_apiJs);
var _indexJs = require("./compute/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
exports.default = {
    compute: (0, _indexJsDefault.default),
    api: (0, _apiJsDefault.default),
    hooks: [
        "chunks"
    ]
};

},{"./api/api.js":"6uLHN","./compute/index.js":"kcR2M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6uLHN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _clausesJs = require("./clauses.js");
var _clausesJsDefault = parcelHelpers.interopDefault(_clausesJs);
var _chunksJs = require("./chunks.js");
var _chunksJsDefault = parcelHelpers.interopDefault(_chunksJs);
const api = function(View) {
    class Chunks extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Chunks";
        }
        isVerb() {
            return this.filter((c)=>c.has("<Verb>"));
        }
        isNoun() {
            return this.filter((c)=>c.has("<Noun>"));
        }
        isAdjective() {
            return this.filter((c)=>c.has("<Adjective>"));
        }
        isPivot() {
            return this.filter((c)=>c.has("<Pivot>"));
        }
        // chunk-friendly debug
        debug() {
            this.toView().debug("chunks");
            return this;
        }
        // overloaded - keep Sentences class
        update(pointer) {
            let m = new Chunks(this.document, pointer);
            m._cache = this._cache // share this full thing
            ;
            return m;
        }
    }
    View.prototype.chunks = function(n) {
        let m = (0, _chunksJsDefault.default)(this);
        m = m.getNth(n);
        return new Chunks(this.document, m.pointer);
    };
    View.prototype.clauses = (0, _clausesJsDefault.default);
};
exports.default = api;

},{"./clauses.js":"dHZL9","./chunks.js":"eWSQQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dHZL9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const byComma = function(doc) {
    let commas = doc.match("@hasComma");
    // remove any non-clause uses
    commas = commas.filter((m)=>{
        // don't split the first word
        if (m.growLeft(".").wordCount() === 1) return false;
        // don't split the last word
        if (m.growRight(". .").wordCount() === 1) return false;
        let more = m.grow(".") // grow by 1 word in either direction
        ;
        more = more.ifNo("@hasComma @hasComma") //fun, cool...
        ;
        more = more.ifNo("@hasComma (and|or) .") //cool, and fun
        ;
        more = more.ifNo("(#City && @hasComma) #Country") //'toronto, canada'
        ;
        more = more.ifNo("(#WeekDay && @hasComma) #Date") //'tuesday, march 2nd'
        ;
        more = more.ifNo("(#Date+ && @hasComma) #Value") //'july 6, 1992'
        ;
        more = more.ifNo("(#Adjective && @hasComma) #Adjective") //nice, pretty
        ;
        // more = more.ifNo('@hasComma (too|also)$') //at end of sentence
        return more.found;
    });
    return doc.splitAfter(commas);
};
// should we split-out a clause (in brackets)?
const splitParentheses = function(doc) {
    let matches = doc.parentheses();
    matches = matches.filter((m)=>{
        return m.wordCount() >= 3 && m.has("#Verb") && m.has("#Noun");
    });
    return doc.splitOn(matches);
};
// split-out a long quotion, but not 'inline quotes'.
const splitQuotes = function(doc) {
    let matches = doc.quotations();
    matches = matches.filter((m)=>{
        return m.wordCount() >= 3 && m.has("#Verb") && m.has("#Noun");
    });
    return doc.splitOn(matches);
};
const clauses = function(n) {
    let found = this;
    found = splitParentheses(found);
    found = splitQuotes(found);
    found = byComma(found);
    found = found.splitAfter("(@hasEllipses|@hasSemicolon|@hasDash|@hasColon)");
    // i said
    found = found.splitAfter("^#Pronoun (said|says)");
    // ... said John.
    found = found.splitBefore("(said|says) #ProperNoun$");
    // ... if it was
    found = found.splitBefore(". . if .{4}");
    // various conjunctions
    found = found.splitBefore("and while");
    found = found.splitBefore("now that");
    found = found.splitBefore("ever since");
    found = found.splitBefore("(supposing|although)");
    found = found.splitBefore("even (while|if|though)");
    found = found.splitBefore("(whereas|whose)");
    // found = found.splitBefore('as (far|long|much|soon) as')
    found = found.splitBefore("as (though|if)");
    found = found.splitBefore("(til|until)");
    // it is cool and it is ..
    // let conjunctions = found.if('#Copula #Adjective #Conjunction (#Pronoun|#Determiner) #Verb').match('#Conjunction')
    // found = found.splitBefore(conjunctions)
    // // if it is this then that
    // let condition = found.if('if .{2,9} then .').match('then')
    // found = found.splitBefore(condition)
    // // misc clause partitions
    // found = found.splitBefore('as well as .')
    // found = found.splitBefore('such as .')
    // found = found.splitBefore('in addition to .')
    // // semicolons, dashes
    // found = found.splitAfter('@hasSemicolon')
    // found = found.splitAfter('@hasDash')
    // // 
    // found = found.splitBefore('which (were|are|will)')
    // // he said [...]
    // found = found.splitAfter('#Noun (said|say|says)')
    // passive voice verb - '.. which was robbed is empty'
    // let passive = found.match('#Noun (which|that) (was|is) #Adverb? #PastTense #Adverb?')
    // if (passive.found) {
    //   found = found.splitAfter(passive)
    // }
    // //which the boy robbed
    // passive = found.match('#Noun (which|that) the? #Noun+ #Adverb? #PastTense #Adverb?')
    // if (passive.found) {
    //   found = found.splitAfter(passive)
    // }
    // does there appear to have relative/subordinate clause still?
    // let tooLong = found.filter(d => d.wordCount() > 5 && d.match('#Verb+').length >= 2)
    // if (tooLong.found) {
    //   // and after the ..
    //   found = found.splitBefore('#Conjunction #Preposition')
    //   // let m = tooLong.splitAfter('#Noun .* #Verb .* #Noun+')
    //   // found = found.splitOn(m.eq(0))
    // }
    if (typeof n === "number") found = found.get(n);
    return found;
};
exports.default = clauses;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eWSQQ":[function(require,module,exports) {
// split terms into Nounphrase, verbphrase, etc groups
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const chunks = function(doc) {
    let all = [];
    let lastOne = null;
    // first, split by comma, etc
    let m = doc.clauses();
    // loop through each clause
    m.docs.forEach((terms)=>{
        terms.forEach((term)=>{
            // new chunk
            if (!term.chunk || term.chunk !== lastOne) {
                lastOne = term.chunk;
                all.push([
                    term.index[0],
                    term.index[1],
                    term.index[1] + 1
                ]);
            } else // keep the chunk going
            all[all.length - 1][2] = term.index[1] + 1;
        });
        lastOne = null;
    });
    let parts = doc.update(all);
    return parts;
};
exports.default = chunks;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kcR2M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _01EasyJs = require("./01-easy.js");
var _01EasyJsDefault = parcelHelpers.interopDefault(_01EasyJs);
var _02NeighboursJs = require("./02-neighbours.js");
var _02NeighboursJsDefault = parcelHelpers.interopDefault(_02NeighboursJs);
var _03MatcherJs = require("./03-matcher.js");
var _03MatcherJsDefault = parcelHelpers.interopDefault(_03MatcherJs);
var _04FallbackJs = require("./04-fallback.js");
var _04FallbackJsDefault = parcelHelpers.interopDefault(_04FallbackJs);
var _05FixUpJs = require("./05-fixUp.js");
var _05FixUpJsDefault = parcelHelpers.interopDefault(_05FixUpJs);
/* Chunks:
    Noun
    Verb
    Adjective
    Pivot
*/ const findChunks = function(view) {
    const { document, world } = view;
    (0, _01EasyJsDefault.default)(document);
    (0, _02NeighboursJsDefault.default)(document);
    (0, _03MatcherJsDefault.default)(view, document, world);
    // matcher(view, document, world) //run it 2nd time
    (0, _04FallbackJsDefault.default)(document, world);
    (0, _05FixUpJsDefault.default)(document, world);
};
exports.default = {
    chunks: findChunks
};

},{"./01-easy.js":"8cukQ","./02-neighbours.js":"1kvTS","./03-matcher.js":"34sHo","./04-fallback.js":"gsmuJ","./05-fixUp.js":"7XW4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8cukQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const byWord = {
    this: "Noun",
    then: "Pivot"
};
// simply chunk Nouns as <Noun>
const easyMode = function(document) {
    for(let n = 0; n < document.length; n += 1)for(let t = 0; t < document[n].length; t += 1){
        let term = document[n][t];
        if (byWord.hasOwnProperty(term.normal) === true) {
            term.chunk = byWord[term.normal];
            continue;
        }
        if (term.tags.has("Verb")) {
            term.chunk = "Verb";
            continue;
        }
        if (term.tags.has("Noun") || term.tags.has("Determiner")) {
            term.chunk = "Noun";
            continue;
        }
        // 100 cats
        if (term.tags.has("Value")) {
            term.chunk = "Noun";
            continue;
        }
        //
        if (term.tags.has("QuestionWord")) {
            term.chunk = "Pivot";
            continue;
        }
    }
};
exports.default = easyMode;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1kvTS":[function(require,module,exports) {
// simply chunk Nouns as <Noun>
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const byNeighbour = function(document) {
    for(let n = 0; n < document.length; n += 1)for(let t = 0; t < document[n].length; t += 1){
        let term = document[n][t];
        if (term.chunk) continue;
        // based on next-term
        let onRight = document[n][t + 1];
        // based on last-term
        let onLeft = document[n][t - 1];
        //'is cool' vs 'the cool dog'
        if (term.tags.has("Adjective")) {
            // 'is cool'
            if (onLeft && onLeft.tags.has("Copula")) {
                term.chunk = "Adjective";
                continue;
            }
            // 'the cool'
            if (onLeft && onLeft.tags.has("Determiner")) {
                term.chunk = "Noun";
                continue;
            }
            // 'cool dog'
            if (onRight && onRight.tags.has("Noun")) {
                term.chunk = "Noun";
                continue;
            }
            continue;
        }
        // 'really swimming' vs 'really cool'
        if (term.tags.has("Adverb") || term.tags.has("Negative")) {
            if (onLeft && onLeft.tags.has("Adjective")) {
                term.chunk = "Adjective";
                continue;
            }
            if (onLeft && onLeft.tags.has("Verb")) {
                term.chunk = "Verb";
                continue;
            }
            if (onRight && onRight.tags.has("Adjective")) {
                term.chunk = "Adjective";
                continue;
            }
            if (onRight && onRight.tags.has("Verb")) {
                term.chunk = "Verb";
                continue;
            }
        }
    }
};
exports.default = byNeighbour;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"34sHo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const rules = [
    // === Conjunction ===
    // that the houses
    {
        match: "[that] #Determiner #Noun",
        group: 0,
        chunk: "Pivot"
    },
    // estimated that
    {
        match: "#PastTense [that]",
        group: 0,
        chunk: "Pivot"
    },
    // so the
    {
        match: "[so] #Determiner",
        group: 0,
        chunk: "Pivot"
    },
    // === Adjective ===
    // was really nice
    {
        match: "#Copula #Adverb+? [#Adjective]",
        group: 0,
        chunk: "Adjective"
    },
    // was nice
    // { match: '#Copula [#Adjective]', group: 0, chunk: 'Adjective' },
    // nice and cool
    {
        match: "#Adjective and #Adjective",
        chunk: "Adjective"
    },
    // really nice
    // { match: '#Adverb+ #Adjective', chunk: 'Adjective' },
    // === Verb ===
    // quickly and suddenly run
    {
        match: "#Adverb+ and #Adverb #Verb",
        chunk: "Verb"
    },
    // sitting near
    {
        match: "#Gerund #Adjective$",
        chunk: "Verb"
    },
    // going to walk
    {
        match: "#Gerund to #Verb",
        chunk: "Verb"
    },
    // come and have a drink
    {
        match: "#PresentTense and #PresentTense",
        chunk: "Verb"
    },
    // really not
    {
        match: "#Adverb #Negative",
        chunk: "Verb"
    },
    // want to see
    {
        match: "(want|wants|wanted) to #Infinitive",
        chunk: "Verb"
    },
    // walk ourselves
    {
        match: "#Verb #Reflexive",
        chunk: "Verb"
    },
    // tell him the story
    // { match: '#PresentTense [#Pronoun] #Determiner', group: 0, chunk: 'Verb' },
    // tries to walk
    {
        match: "#Verb [to] #Adverb? #Infinitive",
        group: 0,
        chunk: "Verb"
    },
    // upon seeing
    {
        match: "[#Preposition] #Gerund",
        group: 0,
        chunk: "Verb"
    },
    // ensure that
    {
        match: "#Infinitive [that] <Noun>",
        group: 0,
        chunk: "Verb"
    },
    // === Noun ===
    // the brown fox
    // { match: '#Determiner #Adjective+ #Noun', chunk: 'Noun' },
    // the fox
    // { match: '(the|this) <Noun>', chunk: 'Noun' },
    // brown fox
    // { match: '#Adjective+ <Noun>', chunk: 'Noun' },
    // --- of ---
    // son of a gun
    {
        match: "#Noun of #Determiner? #Noun",
        chunk: "Noun"
    },
    // 3 beautiful women
    {
        match: "#Value+ #Adverb? #Adjective",
        chunk: "Noun"
    },
    // the last russian tsar
    {
        match: "the [#Adjective] #Noun",
        chunk: "Noun"
    },
    // breakfast in bed
    {
        match: "#Singular in #Determiner? #Singular",
        chunk: "Noun"
    },
    // Some citizens in this Canadian capital
    {
        match: "#Plural [in] #Determiner? #Noun",
        group: 0,
        chunk: "Pivot"
    },
    // indoor and outdoor seating
    {
        match: "#Noun and #Determiner? #Noun",
        notIf: "(#Possessive|#Pronoun)",
        chunk: "Noun"
    }
];
let net = null;
const matcher = function(view, _, world) {
    const { methods } = world;
    net = net || methods.one.buildNet(rules, world);
    view.sweep(net);
};
exports.default = matcher;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gsmuJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var process = require("2c1ed042bcd9ae8e");
const setChunk = function(term, chunk) {
    const env = typeof process === "undefined" || !process.env ? self.env || {} : process.env;
    if (env.DEBUG_CHUNKS) {
        let str = (term.normal + "'").padEnd(8);
        console.log(`  | '${str}  \u{2192}  \x1b[34m${chunk.padEnd(12)}\x1b[0m \x1b[2m -fallback- \x1b[0m`) // eslint-disable-line
        ;
    }
    term.chunk = chunk;
};
// ensure everything has a chunk
const fallback = function(document) {
    for(let n = 0; n < document.length; n += 1)for(let t = 0; t < document[n].length; t += 1){
        let term = document[n][t];
        if (term.chunk === undefined) {
            // conjunctions stand alone
            if (term.tags.has("Conjunction")) setChunk(term, "Pivot");
            else if (term.tags.has("Preposition")) setChunk(term, "Pivot");
            else if (term.tags.has("Adverb")) setChunk(term, "Verb");
            else //  ¯\_(ツ)_/¯
            term.chunk = "Noun";
        }
    }
};
exports.default = fallback;

},{"2c1ed042bcd9ae8e":"d5jf4","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7XW4s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const fixUp = function(docs) {
    let byChunk = [];
    let current = null;
    docs.forEach((terms)=>{
        // ensure an adjective chunk is preceded by a copula
        for(let i = 0; i < terms.length; i += 1){
            let term = terms[i];
            if (current && term.chunk === current) byChunk[byChunk.length - 1].terms.push(term);
            else {
                byChunk.push({
                    chunk: term.chunk,
                    terms: [
                        term
                    ]
                });
                current = term.chunk;
            }
        }
    });
    // ensure every verb-phrase actually has a verb
    byChunk.forEach((c)=>{
        if (c.chunk === "Verb") {
            const hasVerb = c.terms.find((t)=>t.tags.has("Verb"));
            if (!hasVerb) c.terms.forEach((t)=>t.chunk = null);
        }
    });
};
exports.default = fixUp;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4VSwx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./acronyms/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./parentheses/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _indexJs2 = require("./possessives/index.js");
var _indexJsDefault2 = parcelHelpers.interopDefault(_indexJs2);
var _indexJs3 = require("./quotations/index.js");
var _indexJsDefault3 = parcelHelpers.interopDefault(_indexJs3);
var _indexJs4 = require("./selections/index.js");
var _indexJsDefault4 = parcelHelpers.interopDefault(_indexJs4);
exports.default = {
    api: function(View) {
        (0, _indexJsDefault.default)(View);
        (0, _indexJsDefault1.default)(View);
        (0, _indexJsDefault2.default)(View);
        (0, _indexJsDefault3.default)(View);
        (0, _indexJsDefault4.default)(View);
    }
};

},{"./acronyms/index.js":"k09Aj","./parentheses/index.js":"iwOmF","./possessives/index.js":"cghyb","./quotations/index.js":"4qJ31","./selections/index.js":"7YYuZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k09Aj":[function(require,module,exports) {
// return the nth elem of a doc
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const hasPeriod = /\./g;
const api = function(View) {
    class Acronyms extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Acronyms";
        }
        strip() {
            this.docs.forEach((terms)=>{
                terms.forEach((term)=>{
                    term.text = term.text.replace(hasPeriod, "");
                    term.normal = term.normal.replace(hasPeriod, "");
                });
            });
            return this;
        }
        addPeriods() {
            this.docs.forEach((terms)=>{
                terms.forEach((term)=>{
                    term.text = term.text.replace(hasPeriod, "");
                    term.normal = term.normal.replace(hasPeriod, "");
                    term.text = term.text.split("").join(".") + ".";
                    term.normal = term.normal.split("").join(".") + ".";
                });
            });
            return this;
        }
    }
    View.prototype.acronyms = function(n) {
        let m = this.match("#Acronym");
        m = m.getNth(n);
        return new Acronyms(m.document, m.pointer);
    };
};
exports.default = api;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iwOmF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fnsJs = require("./fns.js");
const api = function(View) {
    class Parentheses extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Possessives";
        }
        strip() {
            return (0, _fnsJs.strip)(this);
        }
    }
    View.prototype.parentheses = function(n) {
        let m = (0, _fnsJs.find)(this);
        m = m.getNth(n);
        return new Parentheses(m.document, m.pointer);
    };
};
exports.default = api;

},{"./fns.js":"lbeWl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lbeWl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "find", ()=>find);
parcelHelpers.export(exports, "strip", ()=>strip);
const hasOpen = /\(/;
const hasClosed = /\)/;
const findEnd = function(terms, i) {
    for(; i < terms.length; i += 1){
        if (terms[i].post && hasClosed.test(terms[i].post)) return i;
    }
    return null;
};
const find = function(doc) {
    let ptrs = [];
    doc.docs.forEach((terms)=>{
        let isOpen = false;
        for(let i = 0; i < terms.length; i += 1){
            let term = terms[i];
            if (!isOpen && term.pre && hasOpen.test(term.pre)) {
                let end = findEnd(terms, i);
                if (end !== null) {
                    let [n, start] = terms[i].index;
                    ptrs.push([
                        n,
                        start,
                        end + 1,
                        terms[i].id
                    ]);
                    i = end;
                }
            }
        }
    });
    return doc.update(ptrs);
};
const strip = function(m) {
    m.docs.forEach((terms)=>{
        terms[0].pre = terms[0].pre.replace(hasOpen, "");
        let last = terms[terms.length - 1];
        last.post = last.post.replace(hasClosed, "");
    });
    return m;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cghyb":[function(require,module,exports) {
// return the nth elem of a doc
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const apostropheS = /'s$/;
const find = function(doc) {
    let m = doc.match("#Possessive+");
    // expand it to include 'john smith's'
    if (m.has("#Person")) m = m.growLeft("#Person+");
    if (m.has("#Place")) m = m.growLeft("#Place+");
    if (m.has("#Organization")) m = m.growLeft("#Organization+");
    return m;
};
const api = function(View) {
    class Possessives extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Possessives";
        }
        strip() {
            this.docs.forEach((terms)=>{
                terms.forEach((term)=>{
                    term.text = term.text.replace(apostropheS, "");
                    term.normal = term.normal.replace(apostropheS, "");
                });
            });
            return this;
        }
    }
    View.prototype.possessives = function(n) {
        let m = find(this);
        m = m.getNth(n);
        return new Possessives(m.document, m.pointer);
    };
};
exports.default = api;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4qJ31":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _fnsJs = require("./fns.js");
const api = function(View) {
    class Quotations extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Possessives";
        }
        strip() {
            return (0, _fnsJs.strip)(this);
        }
    }
    View.prototype.quotations = function(n) {
        let m = (0, _fnsJs.find)(this);
        m = m.getNth(n);
        return new Quotations(m.document, m.pointer);
    };
};
exports.default = api;

},{"./fns.js":"1coCt","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1coCt":[function(require,module,exports) {
/* eslint-disable regexp/no-dupe-characters-character-class */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "find", ()=>find);
parcelHelpers.export(exports, "strip", ()=>strip);
const pairs = {
    '"': '"',
    "\uFF02": "\uFF02",
    "'": "'",
    "\u201C": "\u201D",
    "\u2018": "\u2019",
    "\u201F": "\u201D",
    "\u201B": "\u2019",
    "\u201E": "\u201D",
    "\u2E42": "\u201D",
    "\u201A": "\u2019",
    "\xab": "\xbb",
    "\u2039": "\u203A",
    // Prime 'non quotation'
    "\u2035": "\u2032",
    "\u2036": "\u2033",
    "\u2037": "\u2034",
    // Prime 'quotation' variation
    "\u301D": "\u301E",
    "`": "\xb4",
    "\u301F": "\u301E"
};
const hasOpen = RegExp("[" + Object.keys(pairs).join("") + "]");
const hasClosed = RegExp("[" + Object.values(pairs).join("") + "]");
const findEnd = function(terms, i) {
    const have = terms[i].pre.match(hasOpen)[0] || "";
    if (!have || !pairs[have]) return null;
    const want = pairs[have];
    for(; i < terms.length; i += 1){
        if (terms[i].post && terms[i].post.match(want)) return i;
    }
    return null;
};
const find = function(doc) {
    let ptrs = [];
    doc.docs.forEach((terms)=>{
        let isOpen = false;
        for(let i = 0; i < terms.length; i += 1){
            let term = terms[i];
            if (!isOpen && term.pre && hasOpen.test(term.pre)) {
                let end = findEnd(terms, i);
                if (end !== null) {
                    let [n, start] = terms[i].index;
                    ptrs.push([
                        n,
                        start,
                        end + 1,
                        terms[i].id
                    ]);
                    i = end;
                }
            }
        }
    });
    return doc.update(ptrs);
};
const strip = function(m) {
    m.docs.forEach((terms)=>{
        terms[0].pre = terms[0].pre.replace(hasOpen, "");
        let lastTerm = terms[terms.length - 1];
        lastTerm.post = lastTerm.post.replace(hasClosed, "");
    });
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7YYuZ":[function(require,module,exports) {
/** return anything tagged as a phone number */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const phoneNumbers = function(n) {
    let m = this.splitAfter("@hasComma");
    m = m.match("#PhoneNumber+");
    m = m.getNth(n);
    return m;
};
// setup easy helper methods
const selections = [
    [
        "hyphenated",
        "@hasHyphen ."
    ],
    [
        "hashTags",
        "#HashTag"
    ],
    [
        "emails",
        "#Email"
    ],
    [
        "emoji",
        "#Emoji"
    ],
    [
        "emoticons",
        "#Emoticon"
    ],
    [
        "atMentions",
        "#AtMention"
    ],
    [
        "urls",
        "#Url"
    ],
    // ['pronouns', '#Pronoun'],
    [
        "conjunctions",
        "#Conjunction"
    ],
    [
        "prepositions",
        "#Preposition"
    ],
    [
        "abbreviations",
        "#Abbreviation"
    ],
    [
        "honorifics",
        "#Honorific"
    ]
];
// aliases
let aliases = [
    [
        "emojis",
        "emoji"
    ],
    [
        "atmentions",
        "atMentions"
    ]
];
const addMethods = function(View) {
    // add a list of new helper methods
    selections.forEach((a)=>{
        View.prototype[a[0]] = function(n) {
            let m = this.match(a[1]);
            return typeof n === "number" ? m.get(n) : m;
        };
    });
    View.prototype.phoneNumbers = phoneNumbers;
    // add aliases
    aliases.forEach((a)=>{
        View.prototype[a[0]] = View.prototype[a[1]];
    });
};
exports.default = addMethods;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ibCzb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _apiJs = require("./api.js");
var _apiJsDefault = parcelHelpers.interopDefault(_apiJs);
exports.default = {
    api: (0, _apiJsDefault.default)
};

},{"./api.js":"gFKfP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gFKfP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>function(View) {
        View.prototype.normalize = function(opts = "light") {
            if (typeof opts === "string") opts = presets[opts];
            // run each method
            Object.keys(opts).forEach((fn)=>{
                if ((0, _methodsJsDefault.default).hasOwnProperty(fn)) (0, _methodsJsDefault.default)[fn](this, opts[fn]);
            });
            return this;
        };
    });
var _methodsJs = require("./methods.js");
var _methodsJsDefault = parcelHelpers.interopDefault(_methodsJs);
// turn presets into key-vals
const split = (str)=>{
    return str.split("|").reduce((h, k)=>{
        h[k] = true;
        return h;
    }, {});
};
const light = "unicode|punctuation|whitespace|acronyms";
const medium = "|case|contractions|parentheses|quotations|emoji|honorifics|debullet";
const heavy = "|possessives|adverbs|nouns|verbs";
const presets = {
    light: split(light),
    medium: split(light + medium),
    heavy: split(light + medium + heavy)
};

},{"./methods.js":"89OIK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"89OIK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const termLoop = function(view, cb) {
    view.docs.forEach((terms)=>{
        terms.forEach(cb);
    });
};
exports.default = {
    // remove titlecasing, uppercase
    "case": (doc)=>{
        termLoop(doc, (term)=>{
            term.text = term.text.toLowerCase();
        });
    },
    // visually romanize/anglicize 'Björk' into 'Bjork'.
    "unicode": (doc)=>{
        const world = doc.world;
        const killUnicode = world.methods.one.killUnicode;
        termLoop(doc, (term)=>term.text = killUnicode(term.text, world));
    },
    // remove hyphens, newlines, and force one space between words
    "whitespace": (doc)=>{
        termLoop(doc, (term)=>{
            // one space between words
            term.post = term.post.replace(/\s+/g, " ");
            term.post = term.post.replace(/\s([.,?!:;])/g, "$1") //no whitespace before a period, etc
            ;
            // no whitepace before a word
            term.pre = term.pre.replace(/\s+/g, "");
        });
    },
    // remove commas, semicolons - but keep sentence-ending punctuation
    "punctuation": (doc)=>{
        termLoop(doc, (term)=>{
            // turn dashes to spaces
            term.post = term.post.replace(/[–—-]/g, " ");
            // remove comma, etc 
            term.post = term.post.replace(/[,:;]/g, "");
            // remove elipses
            term.post = term.post.replace(/\.{2,}/g, "");
            // remove repeats
            term.post = term.post.replace(/\?{2,}/g, "?");
            term.post = term.post.replace(/!{2,}/g, "!");
            // replace ?!
            term.post = term.post.replace(/\?!+/g, "?");
        });
        // trim end
        let docs = doc.docs;
        let terms = docs[docs.length - 1];
        if (terms && terms.length > 0) {
            let lastTerm = terms[terms.length - 1];
            lastTerm.post = lastTerm.post.replace(/ /g, "");
        }
    },
    // ====== subsets ===
    // turn "isn't" to "is not"
    "contractions": (doc)=>{
        doc.contractions().expand();
    },
    //remove periods from acronyms, like 'F.B.I.'
    "acronyms": (doc)=>{
        doc.acronyms().strip();
    },
    //remove words inside brackets (like these)
    "parentheses": (doc)=>{
        doc.parentheses().strip();
    },
    // turn "Google's tax return" to "Google tax return"
    "possessives": (doc)=>{
        doc.possessives().strip();
    },
    // turn "tax return" to tax return
    "quotations": (doc)=>{
        doc.quotations().strip();
    },
    // remove them
    "emoji": (doc)=>{
        doc.emojis().remove();
    },
    //turn 'Vice Admiral John Smith' to 'John Smith'
    "honorifics": (doc)=>{
        doc.match("#Honorific+ #Person").honorifics().remove();
    },
    // remove needless adverbs
    "adverbs": (doc)=>{
        doc.adverbs().remove();
    },
    // turn "batmobiles" into "batmobile"
    "nouns": (doc)=>{
        doc.nouns().toSingular();
    },
    // turn all verbs into Infinitive form - "I walked" → "I walk"
    "verbs": (doc)=>{
        doc.verbs().toInfinitive();
    },
    // turn "fifty" into "50"
    "numbers": (doc)=>{
        doc.numbers().toNumber();
    },
    /** remove bullets from beginning of phrase */ "debullet": (doc)=>{
        const hasBullet = /^\s*([-–—*•])\s*$/;
        doc.docs.forEach((terms)=>{
            //remove bullet symbols
            if (hasBullet.test(terms[0].pre)) terms[0].pre = terms[0].pre.replace(hasBullet, "");
        });
        return doc;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cii9I":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _apiJs = require("./api/api.js");
var _apiJsDefault = parcelHelpers.interopDefault(_apiJs);
exports.default = {
    api: (0, _apiJsDefault.default)
};

},{"./api/api.js":"a2BY7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a2BY7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _findJs = require("../find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);
var _toJSONJs = require("./toJSON.js");
var _toJSONJsDefault = parcelHelpers.interopDefault(_toJSONJs);
var _toPluralJs = require("./toPlural.js");
var _toPluralJsDefault = parcelHelpers.interopDefault(_toPluralJs);
var _hasPluralJs = require("./hasPlural.js");
var _hasPluralJsDefault = parcelHelpers.interopDefault(_hasPluralJs);
var _toSingularJs = require("./toSingular.js");
var _toSingularJsDefault = parcelHelpers.interopDefault(_toSingularJs);
const api = function(View) {
    class Nouns extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Nouns";
        }
        parse(n) {
            return this.getNth(n).map((0, _parseJsDefault.default));
        }
        json(n) {
            let opts = typeof n === "object" ? n : {};
            return this.getNth(n).map((m)=>{
                let json = m.toView().json(opts)[0] || {};
                if (opts && opts.noun !== true) json.noun = (0, _toJSONJsDefault.default)(m);
                return json;
            }, []);
        }
        conjugate(n) {
            const methods = this.world.methods.two.transform.noun;
            return this.getNth(n).map((m)=>{
                let parsed = (0, _parseJsDefault.default)(m);
                let root = parsed.root.compute("root").text("root");
                let res = {
                    Singular: root
                };
                if ((0, _hasPluralJsDefault.default)(parsed.root)) res.Plural = methods.toPlural(root, this.model);
                // only show plural if one exists
                if (res.Singular === res.Plural) delete res.Plural;
                return res;
            }, []);
        }
        isPlural(n) {
            let res = this.filter((m)=>(0, _parseJsDefault.default)(m).isPlural);
            return res.getNth(n);
        }
        isSingular(n) {
            let res = this.filter((m)=>!(0, _parseJsDefault.default)(m).isPlural);
            return res.getNth(n);
        }
        adjectives(n) {
            let res = this.update([]);
            this.forEach((m)=>{
                let adj = (0, _parseJsDefault.default)(m).adjectives;
                if (adj.found) res = res.concat(adj);
            });
            return res.getNth(n);
        }
        toPlural(n) {
            return this.getNth(n).map((m)=>{
                return (0, _toPluralJsDefault.default)(m, (0, _parseJsDefault.default)(m));
            });
        // return new Nouns(all.document, all.pointer)
        }
        toSingular(n) {
            return this.getNth(n).map((m)=>{
                let res = (0, _parseJsDefault.default)(m);
                return (0, _toSingularJsDefault.default)(m, res);
            });
        }
        // create a new View, from this one
        update(pointer) {
            let m = new Nouns(this.document, pointer);
            m._cache = this._cache // share this full thing
            ;
            return m;
        }
    }
    View.prototype.nouns = function(n) {
        let m = (0, _findJsDefault.default)(this);
        m = m.getNth(n);
        return new Nouns(this.document, m.pointer);
    };
};
exports.default = api;

},{"../find.js":"jJmXS","./parse.js":"37sBc","./toJSON.js":"jqDkx","./toPlural.js":"b43lX","./hasPlural.js":"NZUMG","./toSingular.js":"34qJh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jJmXS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const findNouns = function(doc) {
    let m = doc.clauses().match("<Noun>");
    let commas = m.match("@hasComma");
    // allow toronto, ontario
    commas = commas.not("#Place");
    if (commas.found) m = m.splitAfter(commas);
    // yo there
    m = m.splitOn("#Expression");
    // these are individual nouns
    m = m.splitOn("(he|she|we|you|they|i)");
    // a client i saw
    m = m.splitOn("(#Noun|#Adjective) [(he|him|she|it)]", 0);
    // give him the best
    m = m.splitOn("[(he|him|she|it)] (#Determiner|#Value)", 0);
    // the noise the slide makes
    m = m.splitBefore("#Noun [(the|a|an)] #Adjective? #Noun", 0);
    // here spencer slept
    m = m.splitOn("[(here|there)] #Noun", 0);
    // put it there
    m = m.splitOn("[#Noun] (here|there)", 0);
    // its great purposes
    // give [parents] [our money]
    m = m.splitBefore("(our|my|their|your)");
    // tell my friend that he
    m = m.splitOn("#Noun [#Determiner]", 0);
    // his excuses
    // m = m.splitAfter('(his|hers|yours|ours|theirs)')
    // m = m.not('^#Determiner')
    //ensure there's actually a noun
    m = m.if("#Noun");
    return m;
};
exports.default = findNouns;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"37sBc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isSubordinateJs = require("./isSubordinate.js");
var _isSubordinateJsDefault = parcelHelpers.interopDefault(_isSubordinateJs);
var _isPluralJs = require("./isPlural.js");
var _isPluralJsDefault = parcelHelpers.interopDefault(_isPluralJs);
const getRoot = function(m) {
    let tmp = m.clone();
    tmp = tmp.match("#Noun+");
    tmp = tmp.remove("(#Adjective|#Preposition|#Determiner|#Value)");
    tmp = tmp.not("#Possessive");
    tmp = tmp.first();
    if (!tmp.found) return m;
    return tmp;
};
const parseNoun = function(m) {
    let root = getRoot(m);
    return {
        determiner: m.match("#Determiner").eq(0),
        adjectives: m.match("#Adjective"),
        number: m.values(),
        isPlural: (0, _isPluralJsDefault.default)(m, root),
        isSubordinate: (0, _isSubordinateJsDefault.default)(m),
        root: root
    };
};
exports.default = parseNoun;

},{"./isSubordinate.js":"4HxBo","./isPlural.js":"c5U7S","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4HxBo":[function(require,module,exports) {
// https://www.trentu.ca/history/subordinate-clause-and-complex-sentence
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const list = [
    "after",
    "although",
    "as if",
    "as long as",
    "as",
    "because",
    "before",
    "even if",
    "even though",
    "ever since",
    "if",
    "in order that",
    "provided that",
    "since",
    "so that",
    "than",
    "that",
    "though",
    "unless",
    "until",
    "what",
    "whatever",
    "when",
    "whenever",
    "where",
    "whereas",
    "wherever",
    "whether",
    "which",
    "whichever",
    "who",
    "whoever",
    "whom",
    "whomever",
    "whose"
];
const isSubordinate = function(m) {
    // athletes from toronto, days since december
    if (m.before("#Preposition$").found) return true;
    let leadIn = m.before();
    if (!leadIn.found) return false;
    for(let i = 0; i < list.length; i += 1){
        if (m.has(list[i])) return true;
    }
    return false;
};
exports.default = isSubordinate;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c5U7S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const notPlural = "(#Pronoun|#Place|#Value|#Person|#Uncountable|#Month|#WeekDay|#Holiday|#Possessive)";
const isPlural = function(m, root) {
    // const { looksPlural } = m.world.methods.two
    if (m.has("#Plural")) return true;
    // two singular nouns are plural noun phrase
    if (m.has("#Noun and #Noun")) return true;
    if (m.has("(we|they)")) return true;
    // these can't be plural
    if (root.has(notPlural) === true) return false;
    if (m.has("#Singular")) return false;
    // word-reg fallback
    let str = root.text("normal");
    // ends with a brutal s fallback
    return str.length > 3 && str.endsWith("s") && !str.endsWith("ss");
};
exports.default = isPlural;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jqDkx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);
const toText = (m)=>m.text();
const toArray = (m)=>m.json({
        terms: false,
        normal: true
    }).map((s)=>s.normal);
const getNum = function(m) {
    let num = null;
    if (!m.found) return num;
    let val = m.values(0);
    if (val.found) {
        let obj = val.parse()[0] || {};
        return obj.num;
    }
    return num;
};
const toJSON = function(m) {
    let res = (0, _parseJsDefault.default)(m);
    return {
        root: toText(res.root),
        number: getNum(res.number),
        determiner: toText(res.determiner),
        adjectives: toArray(res.adjectives),
        isPlural: res.isPlural,
        isSubordinate: res.isSubordinate
    };
};
exports.default = toJSON;

},{"./parse.js":"37sBc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b43lX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hasPluralJs = require("./hasPlural.js");
var _hasPluralJsDefault = parcelHelpers.interopDefault(_hasPluralJs);
const keep = {
    tags: true
};
const nounToPlural = function(m, parsed) {
    // already plural?
    if (parsed.isPlural === true) return m;
    // handle "steve's"
    if (parsed.root.has("#Possessive")) parsed.root = parsed.root.possessives().strip();
    // is a plural appropriate?
    if (!(0, _hasPluralJsDefault.default)(parsed.root)) return m;
    const { methods, model } = m.world;
    const { toPlural } = methods.two.transform.noun;
    // inflect the root noun
    let str = parsed.root.text({
        keepPunct: false
    });
    let plural = toPlural(str, model);
    m.match(parsed.root).replaceWith(plural, keep).tag("Plural", "toPlural");
    // should we change the determiner/article?
    if (parsed.determiner.has("(a|an)")) // 'a captain' -> 'the captains'
    // m.replace(parsed.determiner, 'the', keep)
    m.remove(parsed.determiner);
    // should we change the following copula?
    let copula = parsed.root.after("not? #Adverb+? [#Copula]", 0);
    if (copula.found) {
        if (copula.has("is")) m.replace(copula, "are");
        else if (copula.has("was")) m.replace(copula, "were");
    }
    return m;
};
exports.default = nounToPlural;

},{"./hasPlural.js":"NZUMG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"NZUMG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const hasPlural = function(root) {
    if (root.has("^(#Uncountable|#ProperNoun|#Place|#Pronoun|#Acronym)+$")) return false;
    return true;
};
exports.default = hasPlural;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"34qJh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const keep = {
    tags: true
};
const nounToSingular = function(m, parsed) {
    // already singular?
    if (parsed.isPlural === false) return m;
    const { methods, model } = m.world;
    const { toSingular } = methods.two.transform.noun;
    // inflect the root noun
    let str = parsed.root.text("normal");
    let single = toSingular(str, model);
    m.replace(parsed.root, single, keep).tag("Singular", "toPlural");
    // should we change the determiner/article?
    // m.debug()
    return m;
};
exports.default = nounToSingular;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7MUiZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _apiJs = require("./fractions/api.js");
var _apiJsDefault = parcelHelpers.interopDefault(_apiJs);
var _apiJs1 = require("./numbers/api.js");
var _apiJsDefault1 = parcelHelpers.interopDefault(_apiJs1);
const api = function(View) {
    (0, _apiJsDefault.default)(View);
    (0, _apiJsDefault1.default)(View);
};
exports.default = {
    api
};

},{"./fractions/api.js":"9a9mJ","./numbers/api.js":"iDrz6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9a9mJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _findJs = require("./find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);
var _toCardinalJs = require("./convert/toCardinal.js");
var _toCardinalJsDefault = parcelHelpers.interopDefault(_toCardinalJs);
var _toOrdinalJs = require("./convert/toOrdinal.js");
var _toOrdinalJsDefault = parcelHelpers.interopDefault(_toOrdinalJs);
const plugin = function(View) {
    /**
   */ class Fractions extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Fractions";
        }
        parse(n) {
            return this.getNth(n).map((0, _parseJsDefault.default));
        }
        get(n) {
            return this.getNth(n).map((0, _parseJsDefault.default));
        }
        json(n) {
            return this.getNth(n).map((p)=>{
                let json = p.toView().json(n)[0];
                let parsed = (0, _parseJsDefault.default)(p);
                json.fraction = parsed;
                return json;
            }, []);
        }
        // become 0.5
        toDecimal(n) {
            this.getNth(n).forEach((m)=>{
                let { decimal } = (0, _parseJsDefault.default)(m);
                m = m.replaceWith(String(decimal), true);
                m.tag("NumericValue");
                m.unTag("Fraction");
            });
            return this;
        }
        toFraction(n) {
            this.getNth(n).forEach((m)=>{
                let obj = (0, _parseJsDefault.default)(m);
                if (obj && typeof obj.numerator === "number" && typeof obj.denominator === "number") {
                    let str = `${obj.numerator}/${obj.denominator}`;
                    this.replace(m, str);
                }
            });
            return this;
        }
        toOrdinal(n) {
            this.getNth(n).forEach((m)=>{
                let obj = (0, _parseJsDefault.default)(m);
                let str = (0, _toOrdinalJsDefault.default)(obj);
                if (m.after("^#Noun").found) str += " of" // three fifths of dentists
                ;
                m.replaceWith(str);
            });
            return this;
        }
        toCardinal(n) {
            this.getNth(n).forEach((m)=>{
                let obj = (0, _parseJsDefault.default)(m);
                let str = (0, _toCardinalJsDefault.default)(obj);
                m.replaceWith(str);
            });
            return this;
        }
        toPercentage(n) {
            this.getNth(n).forEach((m)=>{
                let { decimal } = (0, _parseJsDefault.default)(m);
                let percent = decimal * 100;
                percent = Math.round(percent * 100) / 100 // round it
                ;
                m.replaceWith(`${percent}%`);
            });
            return this;
        }
    }
    View.prototype.fractions = function(n) {
        let m = (0, _findJsDefault.default)(this);
        m = m.getNth(n);
        return new Fractions(this.document, m.pointer);
    };
};
exports.default = plugin;

},{"./find.js":"kqtYs","./parse.js":"8xVL6","./convert/toCardinal.js":"lJEIA","./convert/toOrdinal.js":"3EQUi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kqtYs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const findFractions = function(doc, n) {
    // five eighths
    let m = doc.match("#Fraction+");
    // remove 'two and five eights'
    m = m.filter((r)=>{
        return !r.lookBehind("#Value and$").found;
    });
    // thirty seconds
    m = m.notIf("#Value seconds");
    if (typeof n === "number") m = m.eq(n);
    return m;
};
exports.default = findFractions;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8xVL6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../numbers/parse/toNumber/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
const endS = /s$/;
// just using .toNumber() again may risk an infinite-loop
const parseNumber = function(m) {
    let str = m.text("reduced");
    return (0, _indexJsDefault.default)(str);
};
let mapping = {
    half: 2,
    halve: 2,
    quarter: 4
};
const slashForm = function(m) {
    let str = m.text("reduced");
    let found = str.match(/^([-+]?[0-9]+)\/([-+]?[0-9]+)(st|nd|rd|th)?s?$/);
    if (found && found[1] && found[0]) return {
        numerator: Number(found[1]),
        denominator: Number(found[2])
    };
    return null;
};
// parse '4 out of 4'
const nOutOfN = function(m) {
    let found = m.match("[<num>#Value+] out of every? [<den>#Value+]");
    if (found.found !== true) return null;
    let { num, den } = found.groups();
    if (!num || !den) return null;
    num = parseNumber(num);
    den = parseNumber(den);
    if (!num || !den) return null;
    if (typeof num === "number" && typeof den === "number") return {
        numerator: num,
        denominator: den
    };
    return null;
};
// parse 'five thirds'
const nOrinalth = function(m) {
    let found = m.match("[<num>(#Cardinal|a)+] [<den>#Fraction+]");
    if (found.found !== true) return null;
    let { num, den } = found.groups();
    // -- parse numerator---
    // quick-support for 'a third'
    if (num.has("a")) num = 1;
    else // abuse the number-parser for 'thirty three'
    // let tmp = num.clone().unTag('Fraction')
    // num = tmp.numbers().get()[0]
    num = parseNumber(num);
    // -- parse denominator --
    // turn 'thirds' into third
    let str = den.text("reduced");
    if (endS.test(str)) {
        str = str.replace(endS, "");
        den = den.replaceWith(str);
    }
    // support 'one half' as '1/2'
    if (mapping.hasOwnProperty(str)) den = mapping[str];
    else // dem = dem.numbers().get()[0]
    den = parseNumber(den);
    if (typeof num === "number" && typeof den === "number") return {
        numerator: num,
        denominator: den
    };
    return null;
};
// implied 1 in '100th of a', 'fifth of a'
const oneNth = function(m) {
    let found = m.match("^#Ordinal$");
    if (found.found !== true) return null;
    // ensure it's '100th of a '
    if (m.lookAhead("^of .")) {
        // let num = found.numbers().get()[0]
        let num = parseNumber(found);
        return {
            numerator: 1,
            denominator: num
        };
    }
    return null;
};
// 'half'
const named = function(m) {
    let str = m.text("reduced");
    if (mapping.hasOwnProperty(str)) return {
        numerator: 1,
        denominator: mapping[str]
    };
    return null;
};
const round = (n)=>{
    let rounded = Math.round(n * 1000) / 1000;
    // don't round 1 millionth down into 0
    if (rounded === 0 && n !== 0) return n;
    return rounded;
};
const parseFraction = function(m) {
    m = m.clone();
    let res = named(m) || slashForm(m) || nOutOfN(m) || nOrinalth(m) || oneNth(m) || null;
    if (res !== null) // do the math
    {
        if (res.numerator && res.denominator) {
            res.decimal = res.numerator / res.denominator;
            res.decimal = round(res.decimal);
        }
    }
    return res;
};
exports.default = parseFraction;

},{"../numbers/parse/toNumber/index.js":"66hc6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"66hc6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _findModifiersJs = require("./findModifiers.js");
var _findModifiersJsDefault = parcelHelpers.interopDefault(_findModifiersJs);
var _dataJs = require("./data.js");
var _dataJsDefault = parcelHelpers.interopDefault(_dataJs);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
var _parseDecimalsJs = require("./parseDecimals.js");
var _parseDecimalsJsDefault = parcelHelpers.interopDefault(_parseDecimalsJs);
var _parseNumericJs = require("./parseNumeric.js");
var _parseNumericJsDefault = parcelHelpers.interopDefault(_parseNumericJs);
const improperFraction = /^([0-9,. ]+)\/([0-9,. ]+)$/;
//some numbers we know
const casualForms = {
    "a few": 3,
    "a couple": 2,
    "a dozen": 12,
    "two dozen": 24,
    zero: 0
};
// a 'section' is something like 'fifty-nine thousand'
// turn a section into something we can add to - like 59000
const section_sum = (obj)=>{
    return Object.keys(obj).reduce((sum, k)=>{
        sum += obj[k];
        return sum;
    }, 0);
};
//turn a string into a number
const parse = function(str) {
    //convert some known-numbers
    if (casualForms.hasOwnProperty(str) === true) return casualForms[str];
    //'a/an' is 1
    if (str === "a" || str === "an") return 1;
    const modifier = (0, _findModifiersJsDefault.default)(str);
    str = modifier.str;
    let last_mult = null;
    let has = {};
    let sum = 0;
    let isNegative = false;
    const terms = str.split(/[ -]/);
    // const isFraction = findFraction(terms)
    for(let i = 0; i < terms.length; i++){
        let w = terms[i];
        w = (0, _parseNumericJsDefault.default)(w);
        if (!w || w === "and") continue;
        if (w === "-" || w === "negative") {
            isNegative = true;
            continue;
        }
        if (w.charAt(0) === "-") {
            isNegative = true;
            w = w.substring(1);
        }
        //decimal mode
        if (w === "point") {
            sum += section_sum(has);
            sum += (0, _parseDecimalsJsDefault.default)(terms.slice(i + 1, terms.length));
            sum *= modifier.amount;
            return sum;
        }
        //improper fraction
        const fm = w.match(improperFraction);
        if (fm) {
            const num = parseFloat(fm[1].replace(/[, ]/g, ""));
            const denom = parseFloat(fm[2].replace(/[, ]/g, ""));
            if (denom) sum += num / denom || 0;
            continue;
        }
        // try to support 'two fifty'
        if ((0, _dataJsDefault.default).tens.hasOwnProperty(w)) {
            if (has.ones && Object.keys(has).length === 1) {
                sum = has.ones * 100;
                has = {};
            }
        }
        //prevent mismatched units, like 'seven eleven' if not a fraction
        if ((0, _validateJsDefault.default)(w, has) === false) return null;
        //buildOut section, collect 'has' values
        if (/^[0-9.]+$/.test(w)) has.ones = parseFloat(w) //not technically right
        ;
        else if ((0, _dataJsDefault.default).ones.hasOwnProperty(w) === true) has.ones = (0, _dataJsDefault.default).ones[w];
        else if ((0, _dataJsDefault.default).teens.hasOwnProperty(w) === true) has.teens = (0, _dataJsDefault.default).teens[w];
        else if ((0, _dataJsDefault.default).tens.hasOwnProperty(w) === true) has.tens = (0, _dataJsDefault.default).tens[w];
        else if ((0, _dataJsDefault.default).multiples.hasOwnProperty(w) === true) {
            let mult = (0, _dataJsDefault.default).multiples[w];
            //something has gone wrong : 'two hundred five hundred'
            //possibly because it's a fraction
            if (mult === last_mult) return null;
            //support 'hundred thousand'
            //this one is tricky..
            if (mult === 100 && terms[i + 1] !== undefined) {
                const w2 = terms[i + 1];
                if ((0, _dataJsDefault.default).multiples[w2]) {
                    mult *= (0, _dataJsDefault.default).multiples[w2] //hundredThousand/hundredMillion
                    ;
                    i += 1;
                }
            }
            //natural order of things
            //five thousand, one hundred..
            if (last_mult === null || mult < last_mult) {
                sum += (section_sum(has) || 1) * mult;
                last_mult = mult;
                has = {};
            } else {
                //maybe hundred .. thousand
                sum += section_sum(has);
                last_mult = mult;
                sum = (sum || 1) * mult;
                has = {};
            }
        }
    }
    //dump the remaining has values
    sum += section_sum(has);
    //post-process add modifier
    sum *= modifier.amount;
    sum *= isNegative ? -1 : 1;
    //dont return 0, if it went straight-through
    if (sum === 0 && Object.keys(has).length === 0) return null;
    return sum;
};
exports.default = parse;

},{"./findModifiers.js":"jF2gv","./data.js":"gaqxf","./validate.js":"aPt7R","./parseDecimals.js":"bZsEa","./parseNumeric.js":"aPJLV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jF2gv":[function(require,module,exports) {
//support global multipliers, like 'half-million' by doing 'million' then multiplying by 0.5
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const findModifiers = (str)=>{
    const mults = [
        {
            reg: /^(minus|negative)[\s-]/i,
            mult: -1
        },
        {
            reg: /^(a\s)?half[\s-](of\s)?/i,
            mult: 0.5
        }
    ];
    for(let i = 0; i < mults.length; i++){
        if (mults[i].reg.test(str) === true) return {
            amount: mults[i].mult,
            str: str.replace(mults[i].reg, "")
        };
    }
    return {
        amount: 1,
        str: str
    };
};
exports.default = findModifiers;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gaqxf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    ones: {
        zeroth: 0,
        first: 1,
        second: 2,
        third: 3,
        fourth: 4,
        fifth: 5,
        sixth: 6,
        seventh: 7,
        eighth: 8,
        ninth: 9,
        zero: 0,
        one: 1,
        two: 2,
        three: 3,
        four: 4,
        five: 5,
        six: 6,
        seven: 7,
        eight: 8,
        nine: 9
    },
    teens: {
        tenth: 10,
        eleventh: 11,
        twelfth: 12,
        thirteenth: 13,
        fourteenth: 14,
        fifteenth: 15,
        sixteenth: 16,
        seventeenth: 17,
        eighteenth: 18,
        nineteenth: 19,
        ten: 10,
        eleven: 11,
        twelve: 12,
        thirteen: 13,
        fourteen: 14,
        fifteen: 15,
        sixteen: 16,
        seventeen: 17,
        eighteen: 18,
        nineteen: 19
    },
    tens: {
        twentieth: 20,
        thirtieth: 30,
        fortieth: 40,
        fourtieth: 40,
        fiftieth: 50,
        sixtieth: 60,
        seventieth: 70,
        eightieth: 80,
        ninetieth: 90,
        twenty: 20,
        thirty: 30,
        forty: 40,
        fourty: 40,
        fifty: 50,
        sixty: 60,
        seventy: 70,
        eighty: 80,
        ninety: 90
    },
    multiples: {
        hundredth: 100,
        thousandth: 1000,
        millionth: 1e6,
        billionth: 1e9,
        trillionth: 1e12,
        quadrillionth: 1e15,
        quintillionth: 1e18,
        sextillionth: 1e21,
        septillionth: 1e24,
        hundred: 100,
        thousand: 1000,
        million: 1e6,
        billion: 1e9,
        trillion: 1e12,
        quadrillion: 1e15,
        quintillion: 1e18,
        sextillion: 1e21,
        septillion: 1e24,
        grand: 1000
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aPt7R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dataJs = require("./data.js");
var _dataJsDefault = parcelHelpers.interopDefault(_dataJs);
//prevent things like 'fifteen ten', and 'five sixty'
const isValid = (w, has)=>{
    if ((0, _dataJsDefault.default).ones.hasOwnProperty(w)) {
        if (has.ones || has.teens) return false;
    } else if ((0, _dataJsDefault.default).teens.hasOwnProperty(w)) {
        if (has.ones || has.teens || has.tens) return false;
    } else if ((0, _dataJsDefault.default).tens.hasOwnProperty(w)) {
        if (has.ones || has.teens || has.tens) return false;
    }
    return true;
};
exports.default = isValid;

},{"./data.js":"gaqxf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bZsEa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dataJs = require("./data.js");
var _dataJsDefault = parcelHelpers.interopDefault(_dataJs);
//concatenate into a string with leading '0.'
const parseDecimals = function(arr) {
    let str = "0.";
    for(let i = 0; i < arr.length; i++){
        let w = arr[i];
        if ((0, _dataJsDefault.default).ones.hasOwnProperty(w) === true) str += (0, _dataJsDefault.default).ones[w];
        else if ((0, _dataJsDefault.default).teens.hasOwnProperty(w) === true) str += (0, _dataJsDefault.default).teens[w];
        else if ((0, _dataJsDefault.default).tens.hasOwnProperty(w) === true) str += (0, _dataJsDefault.default).tens[w];
        else if (/^[0-9]$/.test(w) === true) str += w;
        else return 0;
    }
    return parseFloat(str);
};
exports.default = parseDecimals;

},{"./data.js":"gaqxf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aPJLV":[function(require,module,exports) {
//parse a string like "4,200.1" into Number 4200.1
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const parseNumeric = (str)=>{
    //remove ordinal - 'th/rd'
    str = str.replace(/1st$/, "1");
    str = str.replace(/2nd$/, "2");
    str = str.replace(/3rd$/, "3");
    str = str.replace(/([4567890])r?th$/, "$1");
    //remove prefixes
    str = str.replace(/^[$€¥£¢]/, "");
    //remove suffixes
    str = str.replace(/[%$€¥£¢]$/, "");
    //remove commas
    str = str.replace(/,/g, "");
    //split '5kg' from '5'
    str = str.replace(/([0-9])([a-z\u00C0-\u00FF]{1,2})$/, "$1");
    return str;
};
exports.default = parseNumeric;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lJEIA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../../numbers/format/toText/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
const toCardinal = function(obj) {
    if (!obj.numerator || !obj.denominator) return "";
    let a = (0, _indexJsDefault.default)({
        num: obj.numerator
    });
    let b = (0, _indexJsDefault.default)({
        num: obj.denominator
    });
    return `${a} out of ${b}`;
};
exports.default = toCardinal;

},{"../../numbers/format/toText/index.js":"eCZjn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eCZjn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toStringJs = require("../../_toString.js");
var _toStringJsDefault = parcelHelpers.interopDefault(_toStringJs);
var _dataJs = require("./data.js");
/**
 * turns an integer/float into.ber, like 'fifty-five'
 */ //turn number into an array of magnitudes, like [[5, million], [2, hundred]]
const breakdown_magnitudes = function(num) {
    let working = num;
    let have = [];
    (0, _dataJs.sequence).forEach((a)=>{
        if (num >= a[0]) {
            let howmany = Math.floor(working / a[0]);
            working -= howmany * a[0];
            if (howmany) have.push({
                unit: a[1],
                count: howmany
            });
        }
    });
    return have;
};
//turn numbers from 100-0 into their text
const breakdown_hundred = function(num) {
    let arr = [];
    if (num > 100) return arr //something bad happened..
    ;
    for(let i = 0; i < (0, _dataJs.tens_mapping).length; i++)if (num >= (0, _dataJs.tens_mapping)[i][1]) {
        num -= (0, _dataJs.tens_mapping)[i][1];
        arr.push((0, _dataJs.tens_mapping)[i][0]);
    }
    //(hopefully) we should only have 20-0 now
    if ((0, _dataJs.ones_mapping)[num]) arr.push((0, _dataJs.ones_mapping)[num]);
    return arr;
};
/** print-out 'point eight nine'*/ const handle_decimal = (num)=>{
    const names = [
        "zero",
        "one",
        "two",
        "three",
        "four",
        "five",
        "six",
        "seven",
        "eight",
        "nine"
    ];
    let arr = [];
    //parse it out like a string, because js math is such shit
    let str = (0, _toStringJsDefault.default)(num);
    let decimal = str.match(/\.([0-9]+)/);
    if (!decimal || !decimal[0]) return arr;
    arr.push("point");
    let decimals = decimal[0].split("");
    for(let i = 0; i < decimals.length; i++)arr.push(names[decimals[i]]);
    return arr;
};
/** turns an integer into a textual number */ const toText = function(obj) {
    let num = obj.num;
    // handle zero, quickly
    if (num === 0 || num === "0") return "zero" // no?
    ;
    //big numbers, north of sextillion, aren't gonna work well..
    //keep them small..
    if (num > 1e21) num = (0, _toStringJsDefault.default)(num);
    let arr = [];
    //handle negative numbers
    if (num < 0) {
        arr.push("minus");
        num = Math.abs(num);
    }
    //break-down into units, counts
    let units = breakdown_magnitudes(num);
    //build-up the string from its components
    for(let i = 0; i < units.length; i++){
        let unit_name = units[i].unit;
        if (unit_name === "one") {
            unit_name = "";
            //put an 'and' in here
            if (arr.length > 1) arr.push("and");
        }
        arr = arr.concat(breakdown_hundred(units[i].count));
        arr.push(unit_name);
    }
    //also support decimals - 'point eight'
    arr = arr.concat(handle_decimal(num));
    //remove empties
    arr = arr.filter((s)=>s);
    if (arr.length === 0) arr[0] = "";
    return arr.join(" ");
};
exports.default = toText // console.log(to_text(-1000.8));
;

},{"../../_toString.js":"bMKjA","./data.js":"3FDqw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bMKjA":[function(require,module,exports) {
/**
 * turn big numbers, like 2.3e+22, into a string with a ton of trailing 0's
 * */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const numToString = function(n) {
    if (n < 1000000) return String(n);
    let str;
    if (typeof n === "number") str = n.toFixed(0);
    else str = n;
    if (str.indexOf("e+") === -1) return str;
    return str.replace(".", "").split("e+").reduce(function(p, b) {
        return p + Array(b - p.length + 2).join(0);
    });
};
exports.default = numToString // console.log(numToString(2.5e+22));
;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3FDqw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sequence", ()=>sequence);
parcelHelpers.export(exports, "tens_mapping", ()=>tens_mapping);
parcelHelpers.export(exports, "ones_mapping", ()=>ones_mapping);
const tens_mapping = [
    [
        "ninety",
        90
    ],
    [
        "eighty",
        80
    ],
    [
        "seventy",
        70
    ],
    [
        "sixty",
        60
    ],
    [
        "fifty",
        50
    ],
    [
        "forty",
        40
    ],
    [
        "thirty",
        30
    ],
    [
        "twenty",
        20
    ]
];
const ones_mapping = [
    "",
    "one",
    "two",
    "three",
    "four",
    "five",
    "six",
    "seven",
    "eight",
    "nine",
    "ten",
    "eleven",
    "twelve",
    "thirteen",
    "fourteen",
    "fifteen",
    "sixteen",
    "seventeen",
    "eighteen",
    "nineteen"
];
const sequence = [
    [
        1e24,
        "septillion"
    ],
    [
        1e20,
        "hundred sextillion"
    ],
    [
        1e21,
        "sextillion"
    ],
    [
        1e20,
        "hundred quintillion"
    ],
    [
        1e18,
        "quintillion"
    ],
    [
        1e17,
        "hundred quadrillion"
    ],
    [
        1e15,
        "quadrillion"
    ],
    [
        1e14,
        "hundred trillion"
    ],
    [
        1e12,
        "trillion"
    ],
    [
        1e11,
        "hundred billion"
    ],
    [
        1e9,
        "billion"
    ],
    [
        1e8,
        "hundred million"
    ],
    [
        1e6,
        "million"
    ],
    [
        100000,
        "hundred thousand"
    ],
    [
        1000,
        "thousand"
    ],
    [
        100,
        "hundred"
    ],
    [
        1,
        "one"
    ]
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3EQUi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../../numbers/format/toText/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _textOrdinalJs = require("../../numbers/format/toOrdinal/textOrdinal.js");
var _textOrdinalJsDefault = parcelHelpers.interopDefault(_textOrdinalJs);
const toOrdinal = function(obj) {
    // don't divide by zero!
    if (!obj.numerator || !obj.denominator) return "";
    // create [two] [fifths]
    let start = (0, _indexJsDefault.default)({
        num: obj.numerator
    });
    let end = (0, _textOrdinalJsDefault.default)({
        num: obj.denominator
    });
    // 'one secondth' -> 'one half'
    if (obj.denominator === 2) end = "half";
    if (start && end) {
        if (obj.numerator !== 1) end += "s";
        return `${start} ${end}`;
    }
    return "";
};
exports.default = toOrdinal;

},{"../../numbers/format/toText/index.js":"eCZjn","../../numbers/format/toOrdinal/textOrdinal.js":"6Zl69","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Zl69":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("../toText/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
const irregulars = {
    one: "first",
    two: "second",
    three: "third",
    five: "fifth",
    eight: "eighth",
    nine: "ninth",
    twelve: "twelfth",
    twenty: "twentieth",
    thirty: "thirtieth",
    forty: "fortieth",
    fourty: "fourtieth",
    fifty: "fiftieth",
    sixty: "sixtieth",
    seventy: "seventieth",
    eighty: "eightieth",
    ninety: "ninetieth"
};
/**
 * convert a javascript number to 'twentieth' format
 * */ const textOrdinal = (obj)=>{
    let words = (0, _indexJsDefault.default)(obj).split(" ");
    //convert the last number to an ordinal
    let last = words[words.length - 1];
    if (irregulars.hasOwnProperty(last)) words[words.length - 1] = irregulars[last];
    else words[words.length - 1] = last.replace(/y$/, "i") + "th";
    return words.join(" ");
};
exports.default = textOrdinal;

},{"../toText/index.js":"eCZjn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iDrz6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _findJs = require("./find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _indexJs = require("./parse/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./format/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
const addMethod = function(View) {
    /**   */ class Numbers extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Numbers";
        }
        parse(n) {
            return this.getNth(n).map((0, _indexJsDefault.default));
        }
        get(n) {
            return this.getNth(n).map((0, _indexJsDefault.default)).map((o)=>o.num);
        }
        json(n) {
            let opts = typeof n === "object" ? n : {};
            return this.getNth(n).map((p)=>{
                let json = p.toView().json(opts)[0];
                let parsed = (0, _indexJsDefault.default)(p);
                json.number = {
                    prefix: parsed.prefix,
                    num: parsed.num,
                    suffix: parsed.suffix,
                    hasComma: parsed.hasComma,
                    unit: parsed.unit
                };
                return json;
            }, []);
        }
        /** any known measurement unit, for the number */ units() {
            return this.growRight("#Unit").match("#Unit$");
        }
        /** return only ordinal numbers */ isOrdinal() {
            return this.if("#Ordinal");
        }
        /** return only cardinal numbers*/ isCardinal() {
            return this.if("#Cardinal");
        }
        /** convert to numeric form like '8' or '8th' */ toNumber() {
            let m = this.if("#TextValue");
            m.forEach((val)=>{
                let obj = (0, _indexJsDefault.default)(val);
                if (obj.num === null) return;
                let fmt = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
                let str = (0, _indexJsDefault1.default)(obj, fmt);
                val.replaceWith(str, {
                    tags: true
                });
                val.tag("NumericValue");
            });
            return this;
        }
        /** add commas, or nicer formatting for numbers */ toLocaleString() {
            let m = this;
            m.forEach((val)=>{
                let obj = (0, _indexJsDefault.default)(val);
                if (obj.num === null) return;
                let num = obj.num.toLocaleString();
                // support ordinal ending, too
                if (val.has("#Ordinal")) {
                    let str = (0, _indexJsDefault1.default)(obj, "Ordinal");
                    let end = str.match(/[a-z]+$/);
                    if (end) num += end[0] || "";
                }
                val.replaceWith(num, {
                    tags: true
                });
            });
            return this;
        }
        /** convert to numeric form like 'eight' or 'eighth' */ toText() {
            let m = this;
            let res = m.map((val)=>{
                if (val.has("#TextValue")) return val;
                let obj = (0, _indexJsDefault.default)(val);
                if (obj.num === null) return val;
                let fmt = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
                let str = (0, _indexJsDefault1.default)(obj, fmt);
                val.replaceWith(str, {
                    tags: true
                });
                val.tag("TextValue");
                return val;
            });
            return new Numbers(res.document, res.pointer);
        }
        /** convert ordinal to cardinal form, like 'eight', or '8' */ toCardinal() {
            let m = this;
            let res = m.map((val)=>{
                if (!val.has("#Ordinal")) return val;
                let obj = (0, _indexJsDefault.default)(val);
                if (obj.num === null) return val;
                let fmt = val.has("#TextValue") ? "TextCardinal" : "Cardinal";
                let str = (0, _indexJsDefault1.default)(obj, fmt);
                val.replaceWith(str, {
                    tags: true
                });
                val.tag("Cardinal");
                return val;
            });
            return new Numbers(res.document, res.pointer);
        }
        /** convert cardinal to ordinal form, like 'eighth', or '8th' */ toOrdinal() {
            let m = this;
            let res = m.map((val)=>{
                if (val.has("#Ordinal")) return val;
                let obj = (0, _indexJsDefault.default)(val);
                if (obj.num === null) return val;
                let fmt = val.has("#TextValue") ? "TextOrdinal" : "Ordinal";
                let str = (0, _indexJsDefault1.default)(obj, fmt);
                val.replaceWith(str, {
                    tags: true
                });
                val.tag("Ordinal");
                return val;
            });
            return new Numbers(res.document, res.pointer);
        }
        /** return only numbers that are == n */ isEqual(n) {
            return this.filter((val)=>{
                let num = (0, _indexJsDefault.default)(val).num;
                return num === n;
            });
        }
        /** return only numbers that are > n*/ greaterThan(n) {
            return this.filter((val)=>{
                let num = (0, _indexJsDefault.default)(val).num;
                return num > n;
            });
        }
        /** return only numbers that are < n*/ lessThan(n) {
            return this.filter((val)=>{
                let num = (0, _indexJsDefault.default)(val).num;
                return num < n;
            });
        }
        /** return only numbers > min and < max */ between(min, max) {
            return this.filter((val)=>{
                let num = (0, _indexJsDefault.default)(val).num;
                return num > min && num < max;
            });
        }
        /** set these number to n */ set(n) {
            if (n === undefined) return this // don't bother
            ;
            if (typeof n === "string") n = (0, _indexJsDefault.default)(n).num;
            let m = this;
            let res = m.map((val)=>{
                let obj = (0, _indexJsDefault.default)(val);
                obj.num = n;
                if (obj.num === null) return val;
                let fmt = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
                if (val.has("#TextValue")) fmt = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
                let str = (0, _indexJsDefault1.default)(obj, fmt);
                // add commas to number
                if (obj.hasComma && fmt === "Cardinal") str = Number(str).toLocaleString();
                val = val.not("#Currency");
                val.replaceWith(str, {
                    tags: true
                });
                // handle plural/singular unit
                // agreeUnits(agree, val, obj)
                return val;
            });
            return new Numbers(res.document, res.pointer);
        }
        add(n) {
            if (!n) return this // don't bother
            ;
            if (typeof n === "string") n = (0, _indexJsDefault.default)(n).num;
            let m = this;
            let res = m.map((val)=>{
                let obj = (0, _indexJsDefault.default)(val);
                if (obj.num === null) return val;
                obj.num += n;
                let fmt = val.has("#Ordinal") ? "Ordinal" : "Cardinal";
                if (obj.isText) fmt = val.has("#Ordinal") ? "TextOrdinal" : "TextCardinal";
                let str = (0, _indexJsDefault1.default)(obj, fmt);
                val.replaceWith(str, {
                    tags: true
                });
                // handle plural/singular unit
                // agreeUnits(agree, val, obj)
                return val;
            });
            return new Numbers(res.document, res.pointer);
        }
        /** decrease each number by n*/ subtract(n, agree) {
            return this.add(n * -1, agree);
        }
        /** increase each number by 1 */ increment(agree) {
            return this.add(1, agree);
        }
        /** decrease each number by 1 */ decrement(agree) {
            return this.add(-1, agree);
        }
        // overloaded - keep Numbers class
        update(pointer) {
            let m = new Numbers(this.document, pointer);
            m._cache = this._cache // share this full thing
            ;
            return m;
        }
    }
    // aliases
    Numbers.prototype.toNice = Numbers.prototype.toLocaleString;
    Numbers.prototype.isBetween = Numbers.prototype.between;
    Numbers.prototype.minus = Numbers.prototype.subtract;
    Numbers.prototype.plus = Numbers.prototype.add;
    Numbers.prototype.equals = Numbers.prototype.isEqual;
    View.prototype.numbers = function(n) {
        let m = (0, _findJsDefault.default)(this);
        m = m.getNth(n);
        return new Numbers(this.document, m.pointer);
    };
    View.prototype.percentages = function(n) {
        let m = (0, _findJsDefault.default)(this);
        m = m.filter((v)=>v.has("#Percent") || v.after("^percent"));
        m = m.getNth(n);
        return new Numbers(this.document, m.pointer);
    };
    View.prototype.money = function(n) {
        let m = (0, _findJsDefault.default)(this);
        m = m.filter((v)=>v.has("#Money") || v.after("^#Currency"));
        m = m.getNth(n);
        return new Numbers(this.document, m.pointer);
    };
    // alias
    View.prototype.values = View.prototype.numbers;
};
exports.default = addMethod;

},{"./find.js":"aACCt","./parse/index.js":"5nNTW","./format/index.js":"gj4CK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aACCt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const ones = "one|two|three|four|five|six|seven|eight|nine";
const tens = "twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|fourty";
const teens = "eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen";
// this is a bit of a mess
// segment consecutive number-words into sensible chunks
const findNumbers = function(doc) {
    let m = doc.match("#Value+");
    //"50 83"
    if (m.has("#NumericValue #NumericValue")) {
        //a comma may mean two numbers
        if (m.has("#Value @hasComma #Value")) m.splitAfter("@hasComma");
        else if (m.has("#NumericValue #Fraction")) m.splitAfter("#NumericValue #Fraction");
        else m = m.splitAfter("#NumericValue");
    }
    //three-length
    if (m.has("#Value #Value #Value") && !m.has("#Multiple")) //twenty-five-twenty
    {
        if (m.has("(" + tens + ") #Cardinal #Cardinal")) m = m.splitAfter("(" + tens + ") #Cardinal");
    }
    //two-length ones
    if (m.has("#Value #Value")) {
        //june 21st 1992 is two seperate values
        if (m.has("#NumericValue #NumericValue")) m = m.splitOn("#Year");
        //sixty fifteen
        if (m.has("(" + tens + ") (" + teens + ")")) m = m.splitAfter("(" + tens + ")");
        //"72 82"
        let double = m.match("#Cardinal #Cardinal");
        if (double.found && !m.has("(point|decimal|#Fraction)")) //not 'two hundred'
        {
            if (!double.has("#Cardinal (#Multiple|point|decimal)")) {
                // two fifty five
                let noMultiple = m.has(`(${ones}) (${tens})`);
                // twenty one
                let tensVal = double.has("(" + tens + ") #Cardinal");
                // hundredOne
                let multVal = double.has("#Multiple #Value");
                //one proper way, 'twenty one', or 'hundred one'
                if (!noMultiple && !tensVal && !multVal) // double = double.firstTerm()
                double.terms().forEach((d)=>{
                    m = m.splitOn(d);
                });
            }
        }
        //seventh fifth
        if (m.match("#Ordinal #Ordinal").match("#TextValue").found && !m.has("#Multiple")) //the one proper way, 'twenty first'
        {
            if (!m.has("(" + tens + ") #Ordinal")) m = m.splitAfter("#Ordinal");
        }
        //fifth five
        m = m.splitBefore("#Ordinal [#Cardinal]", 0);
        //five 2017 (support '5 hundred', and 'twenty 5'
        if (m.has("#TextValue #NumericValue") && !m.has("(" + tens + "|#Multiple)")) m = m.splitBefore("#TextValue #NumericValue");
    }
    //5-8
    m = m.splitAfter("#NumberRange");
    // june 5th 1999
    m = m.splitBefore("#Year");
    return m;
};
exports.default = findNumbers;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5nNTW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./toNumber/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _parseJs = require("../../fractions/parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);
const parseNumeric = function(str, m) {
    str = str.replace(/,/g, "");
    //parse a numeric-number
    let arr = str.split(/([0-9.,]*)/);
    let [prefix, num] = arr;
    let suffix = arr.slice(2).join("");
    if (num !== "" && m.length < 2) {
        num = Number(num || str);
        //ensure that num is an actual number
        if (typeof num !== "number") num = null;
        // strip an ordinal off the suffix
        suffix = suffix || "";
        if (suffix === "st" || suffix === "nd" || suffix === "rd" || suffix === "th") suffix = "";
        // support M for million, k for thousand
        // if (suffix === 'm' || suffix === 'M') {
        //   num *= 1000000
        //   suffix = ''
        // }
        // if (suffix === 'k' || suffix === 'k') {
        //   num *= 1000
        //   suffix = ''
        // }
        return {
            prefix: prefix || "",
            num: num,
            suffix: suffix
        };
    }
    return null;
};
// get a numeric value from this phrase
const parseNumber = function(m) {
    if (typeof m === "string") return {
        num: (0, _indexJsDefault.default)(m)
    };
    let str = m.text("reduced");
    // reach for '12 litres'
    let unit = m.growRight("#Unit").match("#Unit$").text("machine");
    // is it in '3,123' format?
    let hasComma = /[0-9],[0-9]/.test(m.text("text"));
    // parse a numeric-number like '$4.00'
    if (m.terms().length === 1 && !m.has("#Multiple")) {
        let res = parseNumeric(str, m);
        if (res !== null) {
            res.hasComma = hasComma;
            res.unit = unit;
            return res;
        }
    }
    // -- parse text-formats --
    // Fractions: remove 'and a half' etc. from the end
    let frPart = m.match("#Fraction{2,}$");
    frPart = frPart.found === false ? m.match("^#Fraction$") : frPart;
    let fraction = null;
    if (frPart.found) {
        if (frPart.has("#Value and #Value #Fraction")) frPart = frPart.match("and #Value #Fraction");
        fraction = (0, _parseJsDefault.default)(frPart);
        // remove it from our string
        m = m.not(frPart);
        m = m.not("and$");
        str = m.text("reduced");
    }
    let num = 0;
    if (str) num = (0, _indexJsDefault.default)(str) || 0;
    // apply numeric fraction
    if (fraction && fraction.decimal) num += fraction.decimal;
    return {
        hasComma,
        prefix: "",
        num,
        suffix: "",
        isOrdinal: m.has("#Ordinal"),
        isText: m.has("#TextValue"),
        isFraction: m.has("#Fraction"),
        isMoney: m.has("#Money"),
        unit
    };
};
exports.default = parseNumber;

},{"./toNumber/index.js":"66hc6","../../fractions/parse.js":"8xVL6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gj4CK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _numOrdinalJs = require("./toOrdinal/numOrdinal.js");
var _numOrdinalJsDefault = parcelHelpers.interopDefault(_numOrdinalJs);
var _textOrdinalJs = require("./toOrdinal/textOrdinal.js");
var _textOrdinalJsDefault = parcelHelpers.interopDefault(_textOrdinalJs);
var _indexJs = require("./toText/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _suffixJs = require("./suffix.js");
var _suffixJsDefault = parcelHelpers.interopDefault(_suffixJs);
const format = function(obj, fmt) {
    if (fmt === "TextOrdinal") {
        let { prefix, suffix } = (0, _suffixJsDefault.default)(obj);
        return prefix + (0, _textOrdinalJsDefault.default)(obj) + suffix;
    }
    if (fmt === "Ordinal") return obj.prefix + (0, _numOrdinalJsDefault.default)(obj) + obj.suffix;
    if (fmt === "TextCardinal") {
        let { prefix, suffix } = (0, _suffixJsDefault.default)(obj);
        return prefix + (0, _indexJsDefault.default)(obj) + suffix;
    }
    // assume Cardinal
    let num = obj.num;
    if (obj.hasComma) num = num.toLocaleString();
    return obj.prefix + String(num) + obj.suffix;
};
exports.default = format;

},{"./toOrdinal/numOrdinal.js":"5g9Xh","./toOrdinal/textOrdinal.js":"6Zl69","./toText/index.js":"eCZjn","./suffix.js":"g9a5w","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5g9Xh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toStringJs = require("../../_toString.js");
var _toStringJsDefault = parcelHelpers.interopDefault(_toStringJs);
/**
 * turn a number like 5 into an ordinal like 5th
 */ const numOrdinal = function(obj) {
    let num = obj.num;
    if (!num && num !== 0) return null;
    //the teens are all 'th'
    let tens = num % 100;
    if (tens > 10 && tens < 20) return String(num) + "th";
    //the rest of 'em
    const mapping = {
        0: "th",
        1: "st",
        2: "nd",
        3: "rd"
    };
    let str = (0, _toStringJsDefault.default)(num);
    let last = str.slice(str.length - 1, str.length);
    if (mapping[last]) str += mapping[last];
    else str += "th";
    return str;
};
exports.default = numOrdinal;

},{"../../_toString.js":"bMKjA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g9a5w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const prefixes = {
    "\xa2": "cents",
    $: "dollars",
    "\xa3": "pounds",
    "\xa5": "yen",
    "\u20AC": "euros",
    "\u20A1": "col\xf3n",
    "\u0E3F": "baht",
    "\u20AD": "kip",
    "\u20A9": "won",
    "\u20B9": "rupees",
    "\u20BD": "ruble",
    "\u20BA": "liras"
};
const suffixes = {
    "%": "percent",
    // s: 'seconds',
    // cm: 'centimetres',
    // km: 'kilometres',
    // ft: 'feet',
    "\xb0": "degrees"
};
const addSuffix = function(obj) {
    let res = {
        suffix: "",
        prefix: obj.prefix
    };
    // $5 to 'five dollars'
    if (prefixes.hasOwnProperty(obj.prefix)) {
        res.suffix += " " + prefixes[obj.prefix];
        res.prefix = "";
    }
    // 5% to 'five percent'
    if (suffixes.hasOwnProperty(obj.suffix)) res.suffix += " " + suffixes[obj.suffix];
    if (res.suffix && obj.num === 1) res.suffix = res.suffix.replace(/s$/, "");
    // misc other suffixes
    if (!res.suffix && obj.suffix) res.suffix += " " + obj.suffix;
    return res;
};
exports.default = addSuffix;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4memP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const defaults = {
    people: true,
    emails: true,
    phoneNumbers: true,
    places: true
};
const redact = function(opts = {}) {
    opts = Object.assign({}, defaults, opts);
    if (opts.people !== false) this.people().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
    if (opts.emails !== false) this.emails().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
    if (opts.places !== false) this.places().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
    if (opts.phoneNumbers !== false) this.phoneNumbers().replaceWith("\u2588\u2588\u2588\u2588\u2588\u2588\u2588");
    return this;
};
const plugin = {
    api: function(View) {
        View.prototype.redact = redact;
    }
};
exports.default = plugin;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5hkub":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _apiJs = require("./api.js");
var _apiJsDefault = parcelHelpers.interopDefault(_apiJs);
exports.default = {
    api: (0, _apiJsDefault.default)
};

},{"./api.js":"bUhZv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bUhZv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _questionsJs = require("./questions.js");
var _questionsJsDefault = parcelHelpers.interopDefault(_questionsJs);
var _indexJs = require("./parse/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _toPastJs = require("./conjugate/toPast.js");
var _toPastJsDefault = parcelHelpers.interopDefault(_toPastJs);
var _toPresentJs = require("./conjugate/toPresent.js");
var _toPresentJsDefault = parcelHelpers.interopDefault(_toPresentJs);
var _toFutureJs = require("./conjugate/toFuture.js");
var _toFutureJsDefault = parcelHelpers.interopDefault(_toFutureJs);
var _toNegativeJs = require("./conjugate/toNegative.js");
var _toInfinitiveJs = require("./conjugate/toInfinitive.js");
var _toInfinitiveJsDefault = parcelHelpers.interopDefault(_toInfinitiveJs);
const api = function(View) {
    class Sentences extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Sentences";
        }
        json(opts = {}) {
            return this.map((m)=>{
                let json = m.toView().json(opts)[0] || {};
                let { subj, verb, pred, grammar } = (0, _indexJsDefault.default)(m);
                json.sentence = {
                    subject: subj.text("normal"),
                    verb: verb.text("normal"),
                    predicate: pred.text("normal"),
                    grammar
                };
                return json;
            }, []);
        }
        toPastTense(n) {
            return this.getNth(n).map((s)=>{
                let parsed = (0, _indexJsDefault.default)(s);
                return (0, _toPastJsDefault.default)(s, parsed);
            });
        }
        toPresentTense(n) {
            return this.getNth(n).map((s)=>{
                let parsed = (0, _indexJsDefault.default)(s);
                return (0, _toPresentJsDefault.default)(s, parsed);
            });
        }
        toFutureTense(n) {
            return this.getNth(n).map((s)=>{
                let parsed = (0, _indexJsDefault.default)(s);
                s = (0, _toFutureJsDefault.default)(s, parsed);
                return s;
            });
        }
        toInfinitive(n) {
            return this.getNth(n).map((s)=>{
                let parsed = (0, _indexJsDefault.default)(s);
                return (0, _toInfinitiveJsDefault.default)(s, parsed);
            });
        }
        toNegative(n) {
            return this.getNth(n).map((vb)=>{
                let parsed = (0, _indexJsDefault.default)(vb);
                return (0, _toNegativeJs.toNegative)(vb, parsed);
            });
        }
        toPositive(n) {
            return this.getNth(n).map((vb)=>{
                let parsed = (0, _indexJsDefault.default)(vb);
                return (0, _toNegativeJs.toPositive)(vb, parsed);
            });
        }
        isQuestion(n) {
            return this.questions(n);
        }
        isExclamation(n) {
            let res = this.filter((s)=>s.lastTerm().has("@hasExclamation"));
            return res.getNth(n);
        }
        isStatement(n) {
            let res = this.filter((s)=>!s.isExclamation().found && !s.isQuestion().found);
            return res.getNth(n);
        }
        // overloaded - keep Sentences class
        update(pointer) {
            let m = new Sentences(this.document, pointer);
            m._cache = this._cache // share this full thing
            ;
            return m;
        }
    }
    // aliases
    Sentences.prototype.toPresent = Sentences.prototype.toPresentTense;
    Sentences.prototype.toPast = Sentences.prototype.toPastTense;
    Sentences.prototype.toFuture = Sentences.prototype.toFutureTense;
    const methods = {
        sentences: function(n) {
            let m = this.map((s)=>s.fullSentence());
            m = m.getNth(n);
            return new Sentences(this.document, m.pointer);
        },
        questions: function(n) {
            let m = (0, _questionsJsDefault.default)(this);
            return m.getNth(n);
        }
    };
    Object.assign(View.prototype, methods);
};
exports.default = api;

},{"./questions.js":"kvLcx","./parse/index.js":"cK3BL","./conjugate/toPast.js":"12ZJj","./conjugate/toPresent.js":"kkpqs","./conjugate/toFuture.js":"aBc9q","./conjugate/toNegative.js":"cmhWk","./conjugate/toInfinitive.js":"jCcWZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kvLcx":[function(require,module,exports) {
//is this sentence asking a question?
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isQuestion = function(doc) {
    let clauses = doc.clauses();
    // Has ellipsis at the end means it's probably not a question
    // e.g., Is this just fantasy...
    if (/\.\.$/.test(doc.out("text"))) return false;
    // Starts with question word, but has a comma, so probably not a question
    // e.g., Why are we caught in a land slide, no escape from reality
    if (doc.has("^#QuestionWord") && doc.has("@hasComma")) return false;
    // do you see it or not
    if (doc.has("or not$")) return true;
    // Starts with a #QuestionWord
    // e.g., What open your eyes look up to the skies and see
    if (doc.has("^#QuestionWord")) return true;
    // Second word is a #QuestionWord
    // e.g., I'm what a poor boy
    // case ts.has('^\w+\s#QuestionWord'):
    // return true;
    // is it, do you - start of sentence
    // e.g., Do I need no sympathy
    if (doc.has("^(do|does|did|is|was|can|could|will|would|may) #Noun")) return true;
    // these are a little more loose..
    // e.g., Must I be come easy come easy go
    if (doc.has("^(have|must) you")) return true;
    // Clause starts with a question word
    // e.g., Anyway the wind blows, what doesn't really matter to me
    // if (clauses.has('^#QuestionWord')) {
    //   return true
    // }
    //is wayne gretskzy alive
    if (clauses.has("(do|does|is|was) #Noun+ #Adverb? (#Adjective|#Infinitive)$")) return true;
    // Probably not a question
    return false;
};
const findQuestions = function(view) {
    const hasQ = /\?/;
    const { document } = view;
    return view.filter((m)=>{
        let terms = m.docs[0] || [];
        let lastTerm = terms[terms.length - 1];
        // is it not a full sentence?
        if (!lastTerm || document[lastTerm.index[0]].length !== terms.length) return false;
        // does it end with a question mark?
        if (hasQ.test(lastTerm.post)) return true;
        // try to guess a sentence without a question-mark
        return isQuestion(m);
    });
};
exports.default = findQuestions;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cK3BL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mainClauseJs = require("./mainClause.js");
var _mainClauseJsDefault = parcelHelpers.interopDefault(_mainClauseJs);
const grammar = function(vb) {
    let tense = null;
    if (vb.has("#PastTense")) tense = "PastTense";
    else if (vb.has("#FutureTense")) tense = "FutureTense";
    else if (vb.has("#PresentTense")) tense = "PresentTense";
    return {
        tense
    };
};
const parse = function(s) {
    let clauses = s.clauses();
    let main = (0, _mainClauseJsDefault.default)(clauses);
    let chunks = main.chunks();
    let subj = s.none();
    let verb = s.none();
    let pred = s.none();
    chunks.forEach((ch, i)=>{
        if (i === 0 && !ch.has("<Verb>")) {
            subj = ch;
            return;
        }
        if (!verb.found && ch.has("<Verb>")) {
            verb = ch;
            return;
        }
        if (verb.found) pred = pred.concat(ch);
    });
    // cleanup a missed parse
    if (verb.found && !subj.found) subj = verb.before("<Noun>+").first();
    return {
        subj,
        verb,
        pred,
        grammar: grammar(verb)
    };
};
exports.default = parse;

},{"./mainClause.js":"2MBML","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2MBML":[function(require,module,exports) {
// if a clause starts with these, it's not a main clause
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const subordinate = `(after|although|as|because|before|if|since|than|that|though|when|whenever|where|whereas|wherever|whether|while|why|unless|until|once)`;
const relative = `(that|which|whichever|who|whoever|whom|whose|whomever)`;
//try to remove secondary clauses
const mainClause = function(s) {
    let m = s;
    if (m.length === 1) return m;
    // if there's no verb, it's dependent
    m = m.if("#Verb");
    if (m.length === 1) return m;
    // this is a signal for subordinate-clauses
    m = m.ifNo(subordinate);
    m = m.ifNo("^even (if|though)");
    m = m.ifNo("^so that");
    m = m.ifNo("^rather than");
    m = m.ifNo("^provided that");
    if (m.length === 1) return m;
    // relative clauses
    m = m.ifNo(relative);
    if (m.length === 1) return m;
    // check for subordinating conjunctions -- must be at the beginning of the clause
    m = m.ifNo("(^despite|^during|^before|^through|^throughout)");
    if (m.length === 1) return m;
    // check for clauses beginning with Gerund ("Taking ..., ...")
    m = m.ifNo("^#Gerund");
    if (m.length === 1) return m;
    // did we go too far?
    if (m.length === 0) m = s;
    // choose the first one?
    return m.eq(0);
};
exports.default = mainClause;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"12ZJj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const toPast = function(s) {
    let verbs = s.verbs();
    // translate the first verb, no-stress
    let first = verbs.eq(0);
    // already past
    if (first.has("#PastTense")) return s;
    first.toPastTense();
    // force agreement with any 2nd/3rd verbs:
    if (verbs.length > 1) {
        verbs = verbs.slice(1);
        // remove any sorta infinitive - 'to engage'
        verbs = verbs.filter((v)=>!v.lookBehind("to$").found);
        // keep -ing verbs
        verbs = verbs.if("#PresentTense");
        verbs = verbs.notIf("#Gerund");
        //run-on infinitive-list - 'to walk, sit and eat'
        let list = s.match("to #Verb+ #Conjunction #Verb").terms();
        verbs = verbs.not(list);
        // otherwise, I guess so?
        if (verbs.found) verbs.verbs().toPastTense();
    }
    // s.compute('chunks')
    return s;
};
exports.default = toPast;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kkpqs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const toPresent = function(s) {
    let verbs = s.verbs();
    // translate the first verb, no-stress
    let first = verbs.eq(0);
    // already present
    // if (first.has('#PresentTense')) {
    //   return s
    // }
    first.toPresentTense();
    // force agreement with any 2nd/3rd verbs:
    if (verbs.length > 1) {
        verbs = verbs.slice(1);
        // remove any sorta infinitive - 'to engage'
        verbs = verbs.filter((v)=>!v.lookBehind("to$").found);
        // keep -ing verbs
        // verbs = verbs.if('#PresentTense')
        verbs = verbs.notIf("#Gerund");
        //run-on infinitive-list - 'to walk, sit and eat'
        // let list = s.match('to #Verb+ #Conjunction #Verb').terms()
        // verbs = verbs.not(list)
        // otherwise, I guess so?
        if (verbs.found) verbs.verbs().toPresentTense();
    }
    // s.compute('chunks')
    return s;
};
exports.default = toPresent;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aBc9q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const toFuture = function(s) {
    let verbs = s.verbs();
    // translate the first verb, no-stress
    let first = verbs.eq(0);
    first.toFutureTense();
    s = s.fullSentence();
    verbs = s.verbs() //re-do it
    ;
    // verbs.debug()
    // force agreement with any 2nd/3rd verbs:
    if (verbs.length > 1) {
        verbs = verbs.slice(1);
        // which following-verbs should we also change?
        let toChange = verbs.filter((vb)=>{
            // remove any sorta infinitive - 'to engage'
            if (vb.lookBehind("to$").found) return false;
            // is watching
            if (vb.has("#Copula #Gerund")) return true;
            // keep -ing verbs
            if (vb.has("#Gerund")) return false;
            // he is green and he is friendly
            if (vb.has("#Copula")) return true;
            // 'he will see when he watches'
            if (vb.has("#PresentTense") && !vb.has("#Infinitive") && vb.lookBefore("(he|she|it|that|which)$").found) return false;
            return true;
        });
        // otherwise, change em too
        if (toChange.found) toChange.forEach((m)=>{
            //extra rules for 'is'
            if (m.has("#Copula")) {
                // when he was out..
                m.match("was").replaceWith("is");
                // when he is out
                m.match("is").replaceWith("will be");
                return;
            }
            // if (m.has('#PastTense')) {
            //   m.toPresentTense()
            //   return
            // }
            m.toInfinitive();
        });
    }
    return s;
};
exports.default = toFuture;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cmhWk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toNegative", ()=>toNegative);
parcelHelpers.export(exports, "toPositive", ()=>toPositive);
const toNegative = function(s) {
    s.verbs().first().toNegative().compute("chunks");
    return s;
};
const toPositive = function(s) {
    s.verbs().first().toPositive().compute("chunks");
    return s;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jCcWZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const toInfinitive = function(s) {
    s.verbs().toInfinitive();
    // s.compute('chunks')
    return s;
};
exports.default = toInfinitive;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b19hu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _apiJs = require("./people/api.js");
var _apiJsDefault = parcelHelpers.interopDefault(_apiJs);
var _apiJs1 = require("./places/api.js");
var _apiJsDefault1 = parcelHelpers.interopDefault(_apiJs1);
var _apiJs2 = require("./orgs/api.js");
var _apiJsDefault2 = parcelHelpers.interopDefault(_apiJs2);
var _topicsJs = require("./topics.js");
var _topicsJsDefault = parcelHelpers.interopDefault(_topicsJs);
const api = function(View) {
    (0, _apiJsDefault.default)(View);
    (0, _apiJsDefault1.default)(View);
    (0, _apiJsDefault2.default)(View);
    (0, _topicsJsDefault.default)(View);
};
exports.default = {
    api
};

},{"./people/api.js":"7cx9O","./places/api.js":"5G2Bv","./orgs/api.js":"jpQm3","./topics.js":"h7772","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7cx9O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _findJs = require("./find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);
var _genderJs = require("./gender.js");
var _genderJsDefault = parcelHelpers.interopDefault(_genderJs);
const addMethod = function(View) {
    /**
   *
   */ class People extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "People";
        }
        parse(n) {
            return this.getNth(n).map((0, _parseJsDefault.default));
        }
        json(n) {
            let opts = typeof n === "object" ? n : {};
            return this.getNth(n).map((p)=>{
                let json = p.toView().json(opts)[0];
                let parsed = (0, _parseJsDefault.default)(p);
                json.person = {
                    firstName: parsed.firstName.text("normal"),
                    lastName: parsed.lastName.text("normal"),
                    honorific: parsed.honorific.text("normal"),
                    presumed_gender: (0, _genderJsDefault.default)(parsed, p)
                };
                return json;
            }, []);
        }
        // used for co-reference resolution only
        presumedMale() {
            return this.filter((m)=>{
                return m.has("(#MaleName|mr|mister|sr|jr|king|pope|prince|sir)") //todo configure these in .world
                ;
            });
        }
        presumedFemale() {
            return this.filter((m)=>{
                return m.has("(#FemaleName|mrs|miss|queen|princess|madam)");
            });
        }
        // overloaded - keep People class
        update(pointer) {
            let m = new People(this.document, pointer);
            m._cache = this._cache // share this full thing
            ;
            return m;
        }
    }
    View.prototype.people = function(n) {
        let m = (0, _findJsDefault.default)(this);
        m = m.getNth(n);
        return new People(this.document, m.pointer);
    };
};
exports.default = addMethod;

},{"./find.js":"6qwya","./parse.js":"hAz2Z","./gender.js":"hnki1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6qwya":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const find = function(doc) {
    let m = doc.match("#Honorific+? #Person+");
    // Spencer's King
    let poss = m.match("#Possessive").notIf("(his|her)") //her majesty ...
    ;
    m = m.splitAfter(poss);
    return m;
};
exports.default = find;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hAz2Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const parse = function(m) {
    let res = {};
    res.firstName = m.match("#FirstName+");
    res.lastName = m.match("#LastName+");
    res.honorific = m.match("#Honorific+");
    let last = res.lastName;
    let first = res.firstName;
    if (!first.found || !last.found) // let p = m.clone()
    // assume 'Mr Springer' is a last-name
    {
        if (!first.found && !last.found && m.has("^#Honorific .$")) {
            res.lastName = m.match(".$");
            return res;
        }
    }
    return res;
};
exports.default = parse;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hnki1":[function(require,module,exports) {
/*
  Important notice - 
  this method makes many assumptions about gender-identity, in-order to assign grammatical gender.
  it should not be used for any other purposes, other than resolving pronouns in english
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const m = "male";
const f = "female";
// known gendered honorifics
const honorifics = {
    mr: m,
    mrs: f,
    miss: f,
    madam: f,
    // british stuff
    king: m,
    queen: f,
    duke: m,
    duchess: f,
    baron: m,
    baroness: f,
    count: m,
    countess: f,
    prince: m,
    princess: f,
    sire: m,
    dame: f,
    lady: f,
    ayatullah: m,
    congressman: m,
    congresswoman: f,
    "first lady": f,
    // marked as non-binary
    mx: null
};
const predictGender = function(parsed, person) {
    let { firstName, honorific } = parsed;
    // use first-name as signal-signal
    if (firstName.has("#FemaleName")) return f;
    if (firstName.has("#MaleName")) return m;
    // use honorics as gender-signal
    if (honorific.found) {
        let hon = honorific.text("normal");
        hon = hon.replace(/\./g, "") //clean it up a bit
        ;
        if (honorifics.hasOwnProperty(hon)) return honorifics[hon];
        // her excelency
        if (/^her /.test(hon)) return f;
        if (/^his /.test(hon)) return m;
    }
    // offer used-pronouns as a signal
    let after = person.after();
    if (!after.has("#Person") && after.has("#Pronoun")) {
        let pro = after.match("#Pronoun");
        // manual use of gender-neutral
        if (pro.has("(they|their)")) return null;
        let hasMasc = pro.has("(he|his)");
        let hasFem = pro.has("(she|her|hers)");
        if (hasMasc && !hasFem) return m;
        if (hasFem && !hasMasc) return f;
    }
    return null;
};
exports.default = predictGender;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5G2Bv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _findJs = require("./find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
const addMethod = function(View) {
    View.prototype.places = function(n) {
        let m = (0, _findJsDefault.default)(this);
        m = m.getNth(n);
        return new View(this.document, m.pointer);
    };
};
exports.default = addMethod;

},{"./find.js":"gWNRB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gWNRB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const find = function(doc) {
    let m = doc.match("(#Place|#Address)+");
    // split all commas except for 'paris, france'
    let splits = m.match("@hasComma");
    splits = splits.filter((c)=>{
        // split 'europe, china'
        if (c.has("(asia|africa|europe|america)$")) return true;
        // don't split 'paris, france'
        if (c.has("(#City|#Region|#ProperNoun)$") && c.after("^(#Country|#Region)").found) return false;
        return true;
    });
    m = m.splitAfter(splits);
    return m;
};
exports.default = find;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jpQm3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const api = function(View) {
    View.prototype.organizations = function(n) {
        let m = this.match("#Organization+");
        return m.getNth(n);
    };
};
exports.default = api;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h7772":[function(require,module,exports) {
//combine them with .topics() method
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const find = function(n) {
    let r = this.clauses();
    // Find people, places, and organizations
    let m = r.people();
    m = m.concat(r.places());
    m = m.concat(r.organizations());
    m = m.not("(someone|man|woman|mother|brother|sister|father)");
    //return them to normal ordering
    m = m.sort("seq");
    // m = m.unique()
    m = m.getNth(n);
    return m;
};
const api = function(View) {
    View.prototype.topics = find;
};
exports.default = api;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4nIaT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _apiJs = require("./api/api.js");
var _apiJsDefault = parcelHelpers.interopDefault(_apiJs);
exports.default = {
    api: (0, _apiJsDefault.default)
};

},{"./api/api.js":"eCaYQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eCaYQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _findJs = require("../find.js");
var _findJsDefault = parcelHelpers.interopDefault(_findJs);
var _toJSONJs = require("./toJSON.js");
var _toJSONJsDefault = parcelHelpers.interopDefault(_toJSONJs);
var _indexJs = require("./parse/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _toInfinitiveJs = require("./conjugate/toInfinitive.js");
var _toInfinitiveJsDefault = parcelHelpers.interopDefault(_toInfinitiveJs);
var _toPastJs = require("./conjugate/toPast.js");
var _toPastJsDefault = parcelHelpers.interopDefault(_toPastJs);
var _toParticipleJs = require("./conjugate/toParticiple.js");
var _toParticipleJsDefault = parcelHelpers.interopDefault(_toParticipleJs);
var _toPresentJs = require("./conjugate/toPresent.js");
var _toPresentJsDefault = parcelHelpers.interopDefault(_toPresentJs);
var _toFutureJs = require("./conjugate/toFuture.js");
var _toFutureJsDefault = parcelHelpers.interopDefault(_toFutureJs);
var _toGerundJs = require("./conjugate/toGerund.js");
var _toGerundJsDefault = parcelHelpers.interopDefault(_toGerundJs);
var _getSubjectJs = require("./parse/getSubject.js");
var _getSubjectJsDefault = parcelHelpers.interopDefault(_getSubjectJs);
var _indexJs1 = require("./parse/grammar/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _toNegativeJs = require("./conjugate/toNegative.js");
var _toNegativeJsDefault = parcelHelpers.interopDefault(_toNegativeJs);
var _libJs = require("./lib.js");
const api = function(View) {
    class Verbs extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Verbs";
        }
        parse(n) {
            return this.getNth(n).map((0, _indexJsDefault.default));
        }
        json(opts, n) {
            let m = this.getNth(n);
            let arr = m.map((vb)=>{
                let json = vb.toView().json(opts)[0] || {};
                json.verb = (0, _toJSONJsDefault.default)(vb);
                return json;
            }, []);
            return arr;
        }
        subjects(n) {
            return this.getNth(n).map((vb)=>{
                let parsed = (0, _indexJsDefault.default)(vb);
                return (0, _getSubjectJsDefault.default)(vb, parsed).subject;
            });
        }
        adverbs(n) {
            return this.getNth(n).map((vb)=>vb.match("#Adverb"));
        }
        isSingular(n) {
            return this.getNth(n).filter((vb)=>{
                return (0, _getSubjectJsDefault.default)(vb).plural !== true;
            });
        }
        isPlural(n) {
            return this.getNth(n).filter((vb)=>{
                return (0, _getSubjectJsDefault.default)(vb).plural === true;
            });
        }
        isImperative(n) {
            return this.getNth(n).filter((vb)=>vb.has("#Imperative"));
        }
        toInfinitive(n) {
            return this.getNth(n).map((vb)=>{
                let parsed = (0, _indexJsDefault.default)(vb);
                let info = (0, _indexJsDefault1.default)(vb, parsed);
                return (0, _toInfinitiveJsDefault.default)(vb, parsed, info.form);
            });
        }
        toPresentTense(n) {
            return this.getNth(n).map((vb)=>{
                let parsed = (0, _indexJsDefault.default)(vb);
                let info = (0, _indexJsDefault1.default)(vb, parsed);
                if (info.isInfinitive) return vb;
                return (0, _toPresentJsDefault.default)(vb, parsed, info.form);
            });
        }
        toPastTense(n) {
            return this.getNth(n).map((vb)=>{
                let parsed = (0, _indexJsDefault.default)(vb);
                let info = (0, _indexJsDefault1.default)(vb, parsed);
                if (info.isInfinitive) return vb;
                return (0, _toPastJsDefault.default)(vb, parsed, info.form);
            });
        }
        toFutureTense(n) {
            return this.getNth(n).map((vb)=>{
                let parsed = (0, _indexJsDefault.default)(vb);
                let info = (0, _indexJsDefault1.default)(vb, parsed);
                if (info.isInfinitive) return vb;
                return (0, _toFutureJsDefault.default)(vb, parsed, info.form);
            });
        }
        toGerund(n) {
            return this.getNth(n).map((vb)=>{
                let parsed = (0, _indexJsDefault.default)(vb);
                let info = (0, _indexJsDefault1.default)(vb, parsed);
                if (info.isInfinitive) return vb;
                return (0, _toGerundJsDefault.default)(vb, parsed, info.form);
            });
        }
        toPastParticiple(n) {
            return this.getNth(n).map((vb)=>{
                let parsed = (0, _indexJsDefault.default)(vb);
                let info = (0, _indexJsDefault1.default)(vb, parsed);
                if (info.isInfinitive) return vb;
                return (0, _toParticipleJsDefault.default)(vb, parsed, info.form);
            });
        }
        conjugate(n) {
            const { conjugate, toInfinitive } = this.world.methods.two.transform.verb;
            return this.getNth(n).map((vb)=>{
                let parsed = (0, _indexJsDefault.default)(vb);
                let info = (0, _indexJsDefault1.default)(vb, parsed);
                // allow imperatives like 'go!' to be conjugated here (only)
                if (info.form === "imperative") info.form = "simple-present";
                let inf = parsed.root.text("normal");
                if (!parsed.root.has("#Infinitive")) {
                    let tense = (0, _libJs.getTense)(parsed.root);
                    inf = toInfinitive(inf, vb.model, tense) || inf;
                }
                return conjugate(inf, vb.model);
            }, []);
        }
        /** return only verbs with 'not'*/ isNegative() {
            return this.if("#Negative");
        }
        /**  return only verbs without 'not'*/ isPositive() {
            return this.ifNo("#Negative");
        }
        /** remove 'not' from these verbs */ toPositive() {
            let m = this.match("do not #Verb");
            if (m.found) m.remove("do not");
            return this.remove("#Negative");
        }
        toNegative(n) {
            return this.getNth(n).map((vb)=>{
                let parsed = (0, _indexJsDefault.default)(vb);
                let info = (0, _indexJsDefault1.default)(vb, parsed);
                return (0, _toNegativeJsDefault.default)(vb, parsed, info.form);
            });
        }
        // overloaded - keep Verb class
        update(pointer) {
            let m = new Verbs(this.document, pointer);
            m._cache = this._cache // share this full thing
            ;
            return m;
        }
    }
    Verbs.prototype.toPast = Verbs.prototype.toPastTense;
    Verbs.prototype.toPresent = Verbs.prototype.toPresentTense;
    Verbs.prototype.toFuture = Verbs.prototype.toFutureTense;
    View.prototype.verbs = function(n) {
        let vb = (0, _findJsDefault.default)(this);
        vb = vb.getNth(n);
        return new Verbs(this.document, vb.pointer);
    };
};
exports.default = api;

},{"../find.js":"bMs75","./toJSON.js":"eNWN0","./parse/index.js":"4NR38","./conjugate/toInfinitive.js":"3NPQw","./conjugate/toPast.js":"9tWeU","./conjugate/toParticiple.js":"euTNx","./conjugate/toPresent.js":"eVZVi","./conjugate/toFuture.js":"cR2W3","./conjugate/toGerund.js":"jhSMy","./parse/getSubject.js":"aA8xx","./parse/grammar/index.js":"95Py8","./conjugate/toNegative.js":"4TTfd","./lib.js":"3lpDA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bMs75":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const findVerbs = function(doc) {
    let m = doc.match("<Verb>");
    // want to see
    m = m.not("#Conjunction");
    // by walking
    m = m.not("#Preposition");
    m = m.splitAfter("@hasComma");
    // the reason he will is ...
    // all i do is talk
    m = m.splitAfter("[(do|did|am|was|is|will)] (is|was)", 0);
    // m = m.splitAfter('[(do|did|am|was|is|will)] #PresentTense', 0)
    // cool
    // like being pampered
    m = m.splitBefore("(#Verb && !#Copula) [being] #Verb", 0);
    // like to be pampered
    m = m.splitBefore("#Verb [to be] #Verb", 0);
    // implicit conjugation - 'help fix'
    m = m.splitAfter("[help] #PresentTense", 0);
    // what i can sell is..
    m = m.splitBefore("(#PresentTense|#PastTense) [#Copula]$", 0);
    // what i can sell will be
    m = m.splitBefore("(#PresentTense|#PastTense) [will be]$", 0);
    // directing had
    m = m.splitBefore("(#PresentTense|#PastTense) [(had|has)]", 0);
    // 'allow yourself'
    m = m.not("#Reflexive$");
    // sitting near
    m = m.not("#Adjective");
    // pastTense-pastTense
    // Everyone he [met] [told] him
    m = m.splitAfter("[#PastTense] #PastTense", 0);
    // Everyone he [met] had [told] him
    m = m.splitAfter("[#PastTense] #Auxiliary+ #PastTense", 0);
    // fans that were blowing felt amazing
    m = m.splitAfter("#Copula [#Gerund] #PastTense", 0);
    // managed to see
    // m = m.splitOn('#PastTense [to] #Infinitive', 0)
    //ensure there's actually a verb
    m = m.if("#Verb");
    // the reason he will is ...
    // ensure it's not two verbs
    // held annually is called
    if (m.has("(#Verb && !#Auxiliary) #Adverb+? #Copula")) m = m.splitBefore("#Copula");
    return m;
};
exports.default = findVerbs;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eNWN0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./parse/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _indexJs1 = require("./parse/grammar/index.js");
var _indexJsDefault1 = parcelHelpers.interopDefault(_indexJs1);
var _libJs = require("./lib.js");
const toArray = function(m) {
    if (!m || !m.isView) return [];
    const opts = {
        normal: true,
        terms: false,
        text: false
    };
    return m.json(opts).map((s)=>s.normal);
};
const toText = function(m) {
    if (!m || !m.isView) return "";
    return m.text("normal");
};
const toInf = function(root) {
    const { toInfinitive } = root.methods.two.transform.verb;
    let str = root.text("normal");
    return toInfinitive(str, root.model, (0, _libJs.getTense)(root));
};
const toJSON = function(vb) {
    let parsed = (0, _indexJsDefault.default)(vb);
    vb = vb.clone().toView();
    const info = (0, _indexJsDefault1.default)(vb, parsed);
    return {
        root: parsed.root.text(),
        preAdverbs: toArray(parsed.adverbs.pre),
        postAdverbs: toArray(parsed.adverbs.post),
        auxiliary: toText(parsed.auxiliary),
        negative: parsed.negative.found,
        prefix: toText(parsed.prefix),
        infinitive: toInf(parsed.root),
        grammar: info
    };
};
exports.default = toJSON;

},{"./parse/index.js":"4NR38","./parse/grammar/index.js":"95Py8","./lib.js":"3lpDA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4NR38":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rootJs = require("./root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
var _adverbsJs = require("./adverbs.js");
var _adverbsJsDefault = parcelHelpers.interopDefault(_adverbsJs);
const getAuxiliary = function(vb, root) {
    let parts = vb.splitBefore(root);
    if (parts.length <= 1) return vb.none();
    let aux = parts.eq(0);
    aux = aux.not("(#Adverb|#Negative|#Prefix)");
    return aux;
};
const getNegative = function(vb) {
    return vb.match("#Negative");
};
// pull-apart phrasal-verb into verb-particle
const getPhrasal = function(root) {
    if (!root.has("(#Particle|#PhrasalVerb)")) return {
        verb: root.none(),
        particle: root.none()
    };
    let particle = root.match("#Particle$");
    return {
        verb: root.not(particle),
        particle: particle
    };
};
const parseVerb = function(view) {
    let vb = view.clone();
    vb.contractions().expand();
    const root = (0, _rootJsDefault.default)(vb);
    let res = {
        root: root,
        prefix: vb.match("#Prefix"),
        adverbs: (0, _adverbsJsDefault.default)(vb, root),
        auxiliary: getAuxiliary(vb, root),
        negative: getNegative(vb),
        phrasal: getPhrasal(root)
    };
    return res;
};
exports.default = parseVerb;

},{"./root.js":"MVAd9","./adverbs.js":"7gtQc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"MVAd9":[function(require,module,exports) {
// find the main verb, from a verb phrase
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const getMain = function(vb) {
    let root = vb;
    if (vb.wordCount() > 1) root = vb.not("(#Negative|#Auxiliary|#Modal|#Adverb|#Prefix)");
    // fallback to just the last word, sometimes
    if (root.length > 1 && !root.has("#Phrasal #Particle")) root = root.last();
    // look for more modals
    root = root.not("(want|wants|wanted) to");
    // fallback
    if (!root.found) {
        root = vb.not("#Negative");
        return root;
    }
    return root;
};
exports.default = getMain;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7gtQc":[function(require,module,exports) {
// split adverbs as before/after the root
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const getAdverbs = function(vb, root) {
    let res = {
        pre: vb.none(),
        post: vb.none()
    };
    if (!vb.has("#Adverb")) return res;
    // pivot on the main verb
    let parts = vb.splitOn(root);
    if (parts.length === 3) return {
        pre: parts.eq(0).adverbs(),
        post: parts.eq(2).adverbs()
    };
    // it must be the second one
    if (parts.eq(0).isDoc(root)) {
        res.post = parts.eq(1).adverbs();
        return res;
    }
    res.pre = parts.eq(0).adverbs();
    return res;
};
exports.default = getAdverbs;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"95Py8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _formsJs = require("./forms.js");
var _formsJsDefault = parcelHelpers.interopDefault(_formsJs);
const cleanUp = function(vb, res) {
    vb = vb.clone();
    // remove adverbs
    if (res.adverbs.post && res.adverbs.post.found) vb.remove(res.adverbs.post);
    if (res.adverbs.pre && res.adverbs.pre.found) vb.remove(res.adverbs.pre);
    // remove negatives
    if (vb.has("#Negative")) vb = vb.remove("#Negative");
    // remove prefixes like 'anti'
    if (vb.has("#Prefix")) vb = vb.remove("#Prefix");
    // cut-off phrasal-verb
    if (res.root.has("#PhrasalVerb #Particle")) vb.remove("#Particle$");
    // did we miss any of these?
    // vb = vb.remove('#Adverb')
    vb = vb.not("#Adverb");
    return vb;
};
// 'learned [to code]'
const isInfinitive = function(vb) {
    if (vb.has("#Infinitive")) {
        let m = vb.growLeft("to");
        if (m.has("^to #Infinitive")) return true;
    }
    return false;
};
const getGrammar = function(vb, res) {
    let grammar = {};
    // make it easy to classify, first
    vb = cleanUp(vb, res);
    for(let i = 0; i < (0, _formsJsDefault.default).length; i += 1){
        let todo = (0, _formsJsDefault.default)[i];
        if (vb.has(todo.match) === true) {
            grammar.form = todo.name;
            Object.assign(grammar, todo.data);
            break; //only match one
        }
    }
    // did we find nothing?
    if (!grammar.form) {
        if (vb.has("^#Verb$")) grammar.form = "infinitive";
    }
    // fallback to 'naiive' tense detection
    if (!grammar.tense) grammar.tense = res.root.has("#PastTense") ? "PastTense" : "PresentTense";
    grammar.copula = res.root.has("#Copula");
    // 'learn to code'
    grammar.isInfinitive = isInfinitive(vb);
    return grammar;
};
exports.default = getGrammar;

},{"./forms.js":"1WIMe","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1WIMe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const present = {
    tense: "PresentTense"
};
const conditional = {
    conditional: true
};
const future = {
    tense: "FutureTense"
};
const prog = {
    progressive: true
};
const past = {
    tense: "PastTense"
};
const complete = {
    complete: true,
    progressive: false
};
const passive = {
    passive: true
};
const plural = {
    plural: true
};
const singular = {
    plural: false
};
const getData = function(tags) {
    let data = {};
    tags.forEach((o)=>{
        Object.assign(data, o);
    });
    return data;
};
const verbForms = {
    // === Simple ===
    "imperative": [
        // walk!
        [
            "#Imperative",
            []
        ]
    ],
    "want-infinitive": [
        [
            "^(want|wants|wanted) to #Infinitive$",
            [
                present
            ]
        ],
        [
            "^wanted to #Infinitive$",
            [
                past
            ]
        ],
        [
            "^will want to #Infinitive$",
            [
                future
            ]
        ]
    ],
    "gerund-phrase": [
        // started looking
        [
            "^#PastTense #Gerund$",
            [
                past
            ]
        ],
        // starts looking
        [
            "^#PresentTense #Gerund$",
            [
                present
            ]
        ],
        // start looking
        [
            "^#Infinitive #Gerund$",
            [
                present
            ]
        ],
        // will start looking
        [
            "^will #Infinitive #Gerund$",
            [
                future
            ]
        ],
        // have started looking
        [
            "^have #PastTense #Gerund$",
            [
                past
            ]
        ],
        // will have started looking
        [
            "^will have #PastTense #Gerund$",
            [
                past
            ]
        ]
    ],
    "simple-present": [
        // he walks',
        [
            "^#PresentTense$",
            [
                present
            ]
        ],
        // we walk
        [
            "^#Infinitive$",
            [
                present
            ]
        ]
    ],
    "simple-past": [
        // he walked',
        [
            "^#PastTense$",
            [
                past
            ]
        ]
    ],
    "simple-future": [
        // he will walk
        [
            "^will #Adverb? #Infinitive",
            [
                future
            ]
        ]
    ],
    // === Progressive ===
    "present-progressive": [
        // he is walking
        [
            "^(is|are|am) #Gerund$",
            [
                present,
                prog
            ]
        ]
    ],
    "past-progressive": [
        // he was walking
        [
            "^(was|were) #Gerund$",
            [
                past,
                prog
            ]
        ]
    ],
    "future-progressive": [
        // he will be
        [
            "^will be #Gerund$",
            [
                future,
                prog
            ]
        ]
    ],
    // === Perfect ===
    "present-perfect": [
        // he has walked
        [
            "^(has|have) #PastTense$",
            [
                past,
                complete
            ]
        ]
    ],
    "past-perfect": [
        // he had walked
        [
            "^had #PastTense$",
            [
                past,
                complete
            ]
        ],
        // had been to see
        [
            "^had #PastTense to #Infinitive",
            [
                past,
                complete
            ]
        ]
    ],
    "future-perfect": [
        // he will have
        [
            "^will have #PastTense$",
            [
                future,
                complete
            ]
        ]
    ],
    // === Progressive-perfect ===
    "present-perfect-progressive": [
        // he has been walking
        [
            "^(has|have) been #Gerund$",
            [
                past,
                prog
            ]
        ]
    ],
    "past-perfect-progressive": [
        // he had been
        [
            "^had been #Gerund$",
            [
                past,
                prog
            ]
        ]
    ],
    "future-perfect-progressive": [
        // will have been
        [
            "^will have been #Gerund$",
            [
                future,
                prog
            ]
        ]
    ],
    // ==== Passive ===
    "passive-past": [
        // got walked, was walked, were walked
        [
            "(got|were|was) #Passive",
            [
                past,
                passive
            ]
        ],
        // was being walked
        [
            "^(was|were) being #Passive",
            [
                past,
                passive
            ]
        ],
        // had been walked, have been eaten
        [
            "^(had|have) been #Passive",
            [
                past,
                passive
            ]
        ]
    ],
    "passive-present": [
        // is walked, are stolen
        [
            "^(is|are|am) #Passive",
            [
                present,
                passive
            ]
        ],
        // is being walked
        [
            "^(is|are|am) being #Passive",
            [
                present,
                passive
            ]
        ],
        // has been cleaned
        [
            "^has been #Passive",
            [
                present,
                passive
            ]
        ]
    ],
    "passive-future": [
        // will have been walked
        [
            "will have been #Passive",
            [
                future,
                passive,
                conditional
            ]
        ],
        // will be cleaned
        [
            "will be being? #Passive",
            [
                future,
                passive,
                conditional
            ]
        ]
    ],
    // === Conditional ===
    "present-conditional": [
        // would be walked
        [
            "would be #PastTense",
            [
                present,
                conditional
            ]
        ]
    ],
    "past-conditional": [
        // would have been walked
        [
            "would have been #PastTense",
            [
                past,
                conditional
            ]
        ]
    ],
    // ==== Auxiliary ===
    "auxiliary-future": [
        // going to drink
        [
            "(is|are|am|was) going to (#Infinitive|#PresentTense)",
            [
                future
            ]
        ]
    ],
    "auxiliary-past": [
        // he did walk
        [
            "^did #Infinitive$",
            [
                past,
                singular
            ]
        ],
        // used to walk
        [
            "^used to #Infinitive$",
            [
                past,
                complete
            ]
        ]
    ],
    "auxiliary-present": [
        // we do walk
        [
            "^(does|do) #Infinitive$",
            [
                present,
                complete,
                plural
            ]
        ]
    ],
    // === modals ===
    "modal-past": [
        // he could have walked
        [
            "^(could|must|should|shall) have #PastTense$",
            [
                past
            ]
        ]
    ],
    "modal-infinitive": [
        // he can walk
        [
            "^#Modal #Infinitive$",
            []
        ]
    ],
    "infinitive": [
        // walk
        [
            "^#Infinitive$",
            []
        ]
    ]
};
let list = [];
Object.keys(verbForms).map((k)=>{
    verbForms[k].forEach((a)=>{
        list.push({
            name: k,
            match: a[0],
            data: getData(a[1])
        });
    });
});
exports.default = list;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3lpDA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "noop", ()=>noop);
parcelHelpers.export(exports, "isPlural", ()=>isPlural);
parcelHelpers.export(exports, "isAreAm", ()=>isAreAm);
parcelHelpers.export(exports, "doDoes", ()=>doDoes);
parcelHelpers.export(exports, "toInf", ()=>toInf);
parcelHelpers.export(exports, "getSubject", ()=>(0, _getSubjectJsDefault.default));
parcelHelpers.export(exports, "getTense", ()=>getTense);
parcelHelpers.export(exports, "wasWere", ()=>wasWere);
parcelHelpers.export(exports, "noWill", ()=>noWill);
var _getSubjectJs = require("./parse/getSubject.js");
var _getSubjectJsDefault = parcelHelpers.interopDefault(_getSubjectJs);
const noop = (vb)=>vb;
const isPlural = (vb, parsed)=>{
    let subj = (0, _getSubjectJsDefault.default)(vb, parsed);
    let m = subj.subject;
    if (m.has("i") || m.has("we")) return true;
    return subj.plural;
};
const wasWere = (vb, parsed)=>{
    let { subject, plural } = (0, _getSubjectJsDefault.default)(vb, parsed);
    if (plural || subject.has("we")) return "were";
    return "was";
};
// present-tense copula
const isAreAm = function(vb, parsed) {
    // 'people were' -> 'people are'
    if (vb.has("were")) return "are";
    // 'i was' -> i am
    let { subject, plural } = (0, _getSubjectJsDefault.default)(vb, parsed);
    if (subject.has("i")) return "am";
    if (subject.has("we") || plural) return "are";
    // 'he was' -> he is
    return "is";
};
const doDoes = function(vb, parsed) {
    let subj = (0, _getSubjectJsDefault.default)(vb, parsed);
    let m = subj.subject;
    if (m.has("i") || m.has("we")) return "do";
    if (subj.plural) return "do";
    return "does";
};
const getTense = function(m) {
    if (m.has("#Infinitive")) return "Infinitive";
    if (m.has("#Participle")) return "Participle";
    if (m.has("#PastTense")) return "PastTense";
    if (m.has("#Gerund")) return "Gerund";
    if (m.has("#PresentTense")) return "PresentTense";
    return undefined;
};
const toInf = function(vb, parsed) {
    const { toInfinitive } = vb.methods.two.transform.verb;
    let str = parsed.root.text({
        keepPunct: false
    });
    str = toInfinitive(str, vb.model, getTense(vb));
    if (str) vb.replace(parsed.root, str);
    return vb;
};
// i will start looking -> i started looking
// i will not start looking -> i did not start looking
const noWill = (vb)=>{
    if (vb.has("will not")) return vb.replace("will not", "have not");
    return vb.remove("will");
};

},{"./parse/getSubject.js":"aA8xx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aA8xx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const shouldSkip = function(last) {
    // is it our only choice?
    if (last.length <= 1) return false;
    let obj = last.parse()[0] || {};
    return obj.isSubordinate;
};
// try to chop-out any obvious conditional phrases
// he wore, [if it was raining], a raincoat.
const noSubClause = function(before) {
    let parts = before.clauses();
    parts = parts.filter((m, i)=>{
        // if it was raining..
        if (m.has("^(if|unless|while|but|for|per|at|by|that|which|who|from)")) return false;
        // bowed to her,
        if (i > 0 && m.has("^#Verb . #Noun+$")) return false;
        // the fog, suddenly increasing in..
        if (i > 0 && m.has("^#Adverb")) return false;
        return true;
    });
    // don't drop the whole thing.
    if (parts.length === 0) return before;
    return parts;
};
//
const lastNoun = function(vb) {
    let before = vb.before();
    // try to drop any mid-sentence clauses
    before = noSubClause(before);
    // parse-out our preceding nouns
    let nouns = before.nouns();
    // look for any dead-ringers
    let last = nouns.last();
    // i/she/he/they are very strong
    let pronoun = last.match("(i|he|she|we|you|they)");
    if (pronoun.found) return pronoun.nouns();
    // these are also good hints
    let det = nouns.if("^(that|this|those)");
    if (det.found) return det;
    if (nouns.found === false) {
        det = before.match("^(that|this|those)");
        if (det.found) return det;
    }
    // should we skip a subbordinate clause or two?
    last = nouns.last();
    if (shouldSkip(last)) {
        nouns.remove(last);
        last = nouns.last();
    }
    // i suppose we can skip two?
    if (shouldSkip(last)) {
        nouns.remove(last);
        last = nouns.last();
    }
    return last;
};
const isPlural = function(subj, vb) {
    // 'we are' vs 'he is'
    if (vb.has("(are|were|does)")) return true;
    if (subj.has("(those|they|we)")) return true;
    if (subj.found && subj.isPlural) return subj.isPlural().found;
    return false;
};
const getSubject = function(vb) {
    let subj = lastNoun(vb);
    return {
        subject: subj,
        plural: isPlural(subj, vb)
    };
};
exports.default = getSubject;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3NPQw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("../lib.js");
const keep = {
    tags: true
};
// all verb forms are the same
const toInf = function(vb, parsed) {
    const { toInfinitive } = vb.methods.two.transform.verb;
    const { root, auxiliary } = parsed;
    let aux = auxiliary.terms().harden();
    let str = root.text("normal");
    str = toInfinitive(str, vb.model, (0, _libJs.getTense)(root));
    if (str) vb.replace(root, str, keep).tag("Verb").firstTerm().tag("Infinitive");
    // remove any auxiliary terms
    if (aux.found) vb.remove(aux);
    // there is no real way to do this
    // 'i not walk'?  'i walk not'?
    if (parsed.negative.found) {
        if (!vb.has("not")) vb.prepend("not");
        let does = (0, _libJs.doDoes)(vb, parsed);
        vb.prepend(does);
    }
    vb.fullSentence().compute([
        "lexicon",
        "preTagger",
        "postTagger",
        "chunks"
    ]);
    return vb;
};
exports.default = toInf;

},{"../lib.js":"3lpDA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9tWeU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("../lib.js");
const keep = {
    tags: true
};
const fns = {
    noAux: (vb, parsed)=>{
        if (parsed.auxiliary.found) vb = vb.remove(parsed.auxiliary);
        return vb;
    },
    // walk->walked
    simple: (vb, parsed)=>{
        const { conjugate, toInfinitive } = vb.methods.two.transform.verb;
        const root = parsed.root;
        // 'i may'
        if (root.has("#Modal")) return vb;
        let str = root.text({
            keepPunct: false
        });
        str = toInfinitive(str, vb.model, (0, _libJs.getTense)(root));
        let all = conjugate(str, vb.model);
        // 'driven' || 'drove'
        str = all.PastTense;
        // all.Participle || all.PastTense
        // but skip the 'is' participle..
        str = str === "been" ? "was" : str;
        if (str === "was") str = (0, _libJs.wasWere)(vb, parsed);
        if (str) vb.replace(root, str, keep);
        return vb;
    },
    both: function(vb, parsed) {
        // 'he did not walk'
        if (parsed.negative.found) {
            vb.replace("will", "did");
            return vb;
        }
        // 'he walked'
        vb = fns.simple(vb, parsed);
        vb = fns.noAux(vb, parsed);
        return vb;
    },
    hasHad: (vb)=>{
        vb.replace("has", "had", keep);
        return vb;
    },
    // some verbs have this weird past-tense form
    // drive -> driven, (!drove)
    hasParticiple: (vb, parsed)=>{
        const { conjugate, toInfinitive } = vb.methods.two.transform.verb;
        const root = parsed.root;
        let str = root.text("normal");
        str = toInfinitive(str, vb.model, (0, _libJs.getTense)(root));
        return conjugate(str, vb.model).Participle;
    }
};
const forms = {
    // walk -> walked
    "infinitive": fns.simple,
    // he walks -> he walked
    "simple-present": fns.simple,
    // he walked
    "simple-past": (0, _libJs.noop),
    // he will walk -> he walked
    "simple-future": fns.both,
    // he is walking
    "present-progressive": (vb)=>{
        vb.replace("are", "were", keep);
        vb.replace("(is|are|am)", "was", keep);
        return vb;
    },
    // he was walking
    "past-progressive": (0, _libJs.noop),
    // he will be walking
    "future-progressive": (vb, parsed)=>{
        vb.match(parsed.root).insertBefore("was");
        vb.remove("(will|be)");
        return vb;
    },
    // has walked -> had walked (?)
    "present-perfect": fns.hasHad,
    // had walked
    "past-perfect": (0, _libJs.noop),
    // will have walked -> had walked
    "future-perfect": (vb, parsed)=>{
        vb.match(parsed.root).insertBefore("had");
        if (vb.has("will")) vb = (0, _libJs.noWill)(vb);
        vb.remove("have");
        return vb;
    },
    // has been walking -> had been
    "present-perfect-progressive": fns.hasHad,
    // had been walking
    "past-perfect-progressive": (0, _libJs.noop),
    // will have been -> had
    "future-perfect-progressive": (vb)=>{
        vb.remove("will");
        vb.replace("have", "had", keep);
        return vb;
    },
    // got walked
    "passive-past": (vb)=>{
        // 'have been walked' -> 'had been walked'
        vb.replace("have", "had", keep);
        return vb;
    },
    // is being walked  -> 'was being walked'
    "passive-present": (vb)=>{
        vb.replace("(is|are)", "was", keep);
        return vb;
    },
    // will be walked -> had been walked
    "passive-future": (vb, parsed)=>{
        if (parsed.auxiliary.has("will be")) {
            vb.match(parsed.root).insertBefore("had been");
            vb.remove("(will|be)");
        }
        // will have been walked -> had been walked
        if (parsed.auxiliary.has("will have been")) {
            vb.replace("have", "had", keep);
            vb.remove("will");
        }
        return vb;
    },
    // would be walked -> 'would have been walked'
    "present-conditional": (vb)=>{
        vb.replace("be", "have been");
        return vb;
    },
    // would have been walked
    "past-conditional": (0, _libJs.noop),
    // is going to drink -> was going to drink
    "auxiliary-future": (vb)=>{
        vb.replace("(is|are|am)", "was", keep);
        return vb;
    },
    // used to walk
    "auxiliary-past": (0, _libJs.noop),
    // we do walk -> we did walk
    "auxiliary-present": (vb)=>{
        vb.replace("(do|does)", "did", keep);
        return vb;
    },
    // must walk -> 'must have walked'
    "modal-infinitive": (vb, parsed)=>{
        // this modal has a clear tense
        if (vb.has("can")) // can drive -> could drive
        vb.replace("can", "could", keep);
        else {
            // otherwise, 
            //  walk -> have walked
            //  drive -> have driven
            fns.simple(vb, parsed);
            vb.match("#Modal").insertAfter("have").tag("Auxiliary");
        }
        return vb;
    },
    // must have walked
    "modal-past": (0, _libJs.noop),
    // wanted to walk
    "want-infinitive": (vb)=>{
        vb.replace("(want|wants)", "wanted", keep);
        vb.remove("will");
        return vb;
    },
    // started looking
    "gerund-phrase": (vb, parsed)=>{
        parsed.root = parsed.root.not("#Gerund$");
        fns.simple(vb, parsed);
        (0, _libJs.noWill)(vb);
        return vb;
    }
};
const toPast = function(vb, parsed, form) {
    // console.log(form)
    if (forms.hasOwnProperty(form)) {
        vb = forms[form](vb, parsed);
        vb.fullSentence().compute([
            "tagger",
            "chunks"
        ]);
        return vb;
    }
    // do nothing i guess?
    return vb;
};
exports.default = toPast;

},{"../lib.js":"3lpDA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"euTNx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("../lib.js");
const haveHas = function(vb, parsed) {
    let subj = (0, _libJs.getSubject)(vb, parsed);
    let m = subj.subject;
    if (m.has("(i|we|you)")) return "have";
    // the dog has
    if (subj.plural === false) return "has";
    // spencer has
    if (m.has("he") || m.has("she") || m.has("#Person")) return "has";
    return "have";
};
// walk-> has walked
const simple = (vb, parsed)=>{
    const { conjugate, toInfinitive } = vb.methods.two.transform.verb;
    const { root, auxiliary } = parsed;
    // 'i may'
    if (root.has("#Modal")) return vb;
    let str = root.text({
        keepPunct: false
    });
    str = toInfinitive(str, vb.model, (0, _libJs.getTense)(root));
    let all = conjugate(str, vb.model);
    // 'driven' || 'drove'
    str = all.Participle || all.PastTense;
    if (str) {
        vb = vb.replace(root, str);
        // 'have/had/has eaten'
        let have = haveHas(vb, parsed);
        vb.prepend(have).match(have).tag("Auxiliary");
        vb.remove(auxiliary);
    }
    return vb;
};
const forms = {
    // walk -> walked
    "infinitive": simple,
    // he walks -> he walked
    "simple-present": simple,
    // he walked
    // 'simple-past': noop,
    // he will walk -> he walked
    "simple-future": (vb, parsed)=>vb.replace("will", haveHas(vb, parsed)),
    // he is walking
    // 'present-progressive': noop,
    // he was walking
    // 'past-progressive': noop,
    // he will be walking
    // 'future-progressive': noop,
    // has walked -> had walked (?)
    "present-perfect": (0, _libJs.noop),
    // had walked
    "past-perfect": (0, _libJs.noop),
    // will have walked -> had walked
    "future-perfect": (vb, parsed)=>vb.replace("will have", haveHas(vb, parsed)),
    // has been walking -> had been
    "present-perfect-progressive": (0, _libJs.noop),
    // had been walking
    "past-perfect-progressive": (0, _libJs.noop),
    // will have been -> had
    "future-perfect-progressive": (0, _libJs.noop)
};
const toPast = function(vb, parsed, form) {
    // console.log(form)
    if (forms.hasOwnProperty(form)) {
        vb = forms[form](vb, parsed);
        vb.fullSentence().compute([
            "tagger",
            "chunks"
        ]);
        return vb;
    }
    // do the simple form
    vb = simple(vb, parsed, form);
    vb.fullSentence().compute([
        "tagger",
        "chunks"
    ]);
    // do nothing, then
    return vb;
};
exports.default = toPast;

},{"../lib.js":"3lpDA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eVZVi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("../lib.js");
const keep = {
    tags: true
};
// walk->walked
const simple = (vb, parsed)=>{
    const { conjugate, toInfinitive } = vb.methods.two.transform.verb;
    const root = parsed.root;
    let str = root.text("normal");
    str = toInfinitive(str, vb.model, (0, _libJs.getTense)(root));
    // 'i walk' vs 'he walks'
    if ((0, _libJs.isPlural)(vb, parsed) === false) str = conjugate(str, vb.model).PresentTense;
    // handle copula
    if (root.has("#Copula")) str = (0, _libJs.isAreAm)(vb, parsed);
    if (str) {
        vb = vb.replace(root, str, keep);
        vb.not("#Particle").tag("PresentTense");
    }
    // vb.replace('not ' + str, str + ' not')
    return vb;
};
const toGerund = (vb, parsed)=>{
    const { conjugate, toInfinitive } = vb.methods.two.transform.verb;
    const root = parsed.root;
    let str = root.text("normal");
    str = toInfinitive(str, vb.model, (0, _libJs.getTense)(root));
    // 'i walk' vs 'he walks'
    if ((0, _libJs.isPlural)(vb, parsed) === false) str = conjugate(str, vb.model).Gerund;
    if (str) {
        vb = vb.replace(root, str, keep);
        vb.not("#Particle").tag("Gerund");
    }
    return vb;
};
const vbToInf = (vb, parsed)=>{
    const { toInfinitive } = vb.methods.two.transform.verb;
    const root = parsed.root;
    let str = parsed.root.text("normal");
    str = toInfinitive(str, vb.model, (0, _libJs.getTense)(root));
    if (str) vb = vb.replace(parsed.root, str, keep);
    return vb;
};
const forms = {
    // walk
    "infinitive": simple,
    // he walks -> he walked
    "simple-present": (vb, parsed)=>{
        const { conjugate } = vb.methods.two.transform.verb;
        let { root } = parsed;
        // is it *only* a infinitive? - 'we buy' etc
        if (root.has("#Infinitive")) {
            let subj = (0, _libJs.getSubject)(vb, parsed);
            let m = subj.subject;
            if ((0, _libJs.isPlural)(vb, parsed) || m.has("i")) // keep it infinitive
            return vb;
            let str = root.text("normal");
            let pres = conjugate(str, vb.model).PresentTense;
            if (str !== pres) vb.replace(root, pres, keep);
        } else return simple(vb, parsed);
        return vb;
    },
    // he walked
    "simple-past": simple,
    // he will walk -> he walked
    "simple-future": (vb, parsed)=>{
        const { root, auxiliary } = parsed;
        // handle 'will be'
        if (auxiliary.has("will") && root.has("be")) {
            let str = (0, _libJs.isAreAm)(vb, parsed);
            vb.replace(root, str);
            vb = vb.remove("will");
            vb.replace("not " + str, str + " not");
        } else {
            simple(vb, parsed);
            vb = vb.remove("will");
        }
        return vb;
    },
    // is walking ->
    "present-progressive": (0, _libJs.noop),
    // was walking -> is walking
    "past-progressive": (vb, parsed)=>{
        let str = (0, _libJs.isAreAm)(vb, parsed);
        return vb.replace("(were|was)", str, keep);
    },
    // will be walking -> is walking
    "future-progressive": (vb)=>{
        vb.match("will").insertBefore("is");
        vb.remove("be");
        return vb.remove("will");
    },
    // has walked ->  (?)
    "present-perfect": (vb, parsed)=>{
        simple(vb, parsed);
        vb = vb.remove("(have|had|has)");
        return vb;
    },
    // had walked -> has walked
    "past-perfect": (vb, parsed)=>{
        // not 'we has walked'
        let subj = (0, _libJs.getSubject)(vb, parsed);
        let m = subj.subject;
        if ((0, _libJs.isPlural)(vb, parsed) || m.has("i")) {
            vb = (0, _libJs.toInf)(vb, parsed) // we walk
            ;
            vb.remove("had");
            return vb;
        }
        vb.replace("had", "has", keep);
        return vb;
    },
    // will have walked -> has walked
    "future-perfect": (vb)=>{
        vb.match("will").insertBefore("has");
        return vb.remove("have").remove("will");
    },
    // has been walking
    "present-perfect-progressive": (0, _libJs.noop),
    // had been walking
    "past-perfect-progressive": (vb)=>vb.replace("had", "has", keep),
    // will have been -> has been
    "future-perfect-progressive": (vb)=>{
        vb.match("will").insertBefore("has");
        return vb.remove("have").remove("will");
    },
    // got walked -> is walked
    // was walked -> is walked
    // had been walked -> is walked
    "passive-past": (vb, parsed)=>{
        let str = (0, _libJs.isAreAm)(vb, parsed);
        if (vb.has("(had|have|has)") && vb.has("been")) {
            vb.replace("(had|have|has)", str, keep);
            vb.replace("been", "being");
            return vb;
        }
        return vb.replace("(got|was|were)", str);
    },
    // is being walked  ->
    "passive-present": (0, _libJs.noop),
    // will be walked -> is being walked
    "passive-future": (vb)=>{
        vb.replace("will", "is");
        return vb.replace("be", "being");
    },
    // would be walked ->
    "present-conditional": (0, _libJs.noop),
    // would have been walked ->
    "past-conditional": (vb)=>{
        vb.replace("been", "be");
        return vb.remove("have");
    },
    // is going to drink -> is drinking
    "auxiliary-future": (vb, parsed)=>{
        toGerund(vb, parsed);
        vb.remove("(going|to)");
        return vb;
    },
    // used to walk -> is walking
    // did walk -> is walking
    "auxiliary-past": (vb, parsed)=>{
        // 'did provide' -> 'does provide'
        if (parsed.auxiliary.has("did")) {
            let str = (0, _libJs.doDoes)(vb, parsed);
            vb.replace(parsed.auxiliary, str);
            return vb;
        }
        toGerund(vb, parsed);
        vb.replace(parsed.auxiliary, "is");
        return vb;
    },
    // we do walk ->
    "auxiliary-present": (0, _libJs.noop),
    // must walk -> 'must have walked'
    "modal-infinitive": (0, _libJs.noop),
    // must have walked
    "modal-past": (vb, parsed)=>{
        vbToInf(vb, parsed);
        return vb.remove("have");
    },
    // started looking
    "gerund-phrase": (vb, parsed)=>{
        parsed.root = parsed.root.not("#Gerund$");
        simple(vb, parsed);
        return vb.remove("(will|have)");
    },
    // wanted to walk
    "want-infinitive": (vb, parsed)=>{
        let str = "wants";
        if ((0, _libJs.isPlural)(vb, parsed)) str = "want" //we want
        ;
        vb.replace("(want|wanted|wants)", str, keep);
        vb.remove("will");
        return vb;
    }
};
const toPresent = function(vb, parsed, form) {
    // console.log(form)
    if (forms.hasOwnProperty(form)) {
        vb = forms[form](vb, parsed);
        vb.fullSentence().compute([
            "tagger",
            "chunks"
        ]);
        return vb;
    }
    return vb;
};
exports.default = toPresent;

},{"../lib.js":"3lpDA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cR2W3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("../lib.js");
const keep = {
    tags: true
};
const simple = (vb, parsed)=>{
    const { toInfinitive } = vb.methods.two.transform.verb;
    const { root, auxiliary } = parsed;
    // 'i may'
    if (root.has("#Modal")) return vb;
    let str = root.text("normal");
    str = toInfinitive(str, vb.model, (0, _libJs.getTense)(root));
    if (str) {
        vb = vb.replace(root, str, keep);
        vb.not("#Particle").tag("Verb");
    }
    vb.prepend("will").match("will").tag("Auxiliary");
    vb.remove(auxiliary);
    return vb;
};
// 'will be walking'
const progressive = (vb, parsed)=>{
    const { conjugate, toInfinitive } = vb.methods.two.transform.verb;
    const { root, auxiliary } = parsed;
    let str = root.text("normal");
    str = toInfinitive(str, vb.model, (0, _libJs.getTense)(root));
    if (str) {
        str = conjugate(str, vb.model).Gerund;
        vb.replace(root, str, keep);
        vb.not("#Particle").tag("PresentTense");
    }
    vb.remove(auxiliary);
    vb.prepend("will be").match("will be").tag("Auxiliary");
    return vb;
};
const forms = {
    // walk ->
    "infinitive": simple,
    // he walks ->
    "simple-present": simple,
    // he walked
    "simple-past": simple,
    // he will walk ->
    "simple-future": (0, _libJs.noop),
    // is walking ->
    "present-progressive": progressive,
    // was walking ->
    "past-progressive": progressive,
    // will be walking ->
    "future-progressive": (0, _libJs.noop),
    // has walked ->
    "present-perfect": (vb)=>{
        vb.match("(have|has)").replaceWith("will have");
        return vb;
    },
    // had walked ->
    "past-perfect": (vb)=>vb.replace("(had|has)", "will have"),
    // will have walked ->
    "future-perfect": (0, _libJs.noop),
    // has been walking
    "present-perfect-progressive": (vb)=>vb.replace("has", "will have"),
    // had been walking
    "past-perfect-progressive": (vb)=>vb.replace("had", "will have"),
    // will have been ->
    "future-perfect-progressive": (0, _libJs.noop),
    // got walked ->
    // was walked ->
    // was being walked ->
    // had been walked ->
    "passive-past": (vb)=>{
        if (vb.has("got")) return vb.replace("got", "will get");
        if (vb.has("(was|were)")) {
            vb.replace("(was|were)", "will be");
            return vb.remove("being");
        }
        if (vb.has("(have|has|had) been")) return vb.replace("(have|has|had) been", "will be");
        return vb;
    },
    // is being walked  ->
    "passive-present": (vb)=>{
        vb.replace("being", "will be");
        vb.remove("(is|are|am)");
        return vb;
    },
    // will be walked ->
    "passive-future": (0, _libJs.noop),
    // would be walked ->
    "present-conditional": (vb)=>vb.replace("would", "will"),
    // would have been walked ->
    "past-conditional": (vb)=>vb.replace("would", "will"),
    // is going to drink ->
    "auxiliary-future": (0, _libJs.noop),
    // used to walk -> is walking
    // did walk -> is walking
    "auxiliary-past": (vb)=>{
        if (vb.has("used") && vb.has("to")) {
            vb.replace("used", "will");
            return vb.remove("to");
        }
        vb.replace("did", "will");
        return vb;
    },
    // we do walk ->
    // he does walk ->
    "auxiliary-present": (vb)=>{
        return vb.replace("(do|does)", "will");
    },
    // must walk ->
    "modal-infinitive": (0, _libJs.noop),
    // must have walked
    "modal-past": (0, _libJs.noop),
    // started looking
    "gerund-phrase": (vb, parsed)=>{
        parsed.root = parsed.root.not("#Gerund$");
        simple(vb, parsed);
        return vb.remove("(had|have)");
    },
    // wanted to walk
    "want-infinitive": (vb)=>{
        vb.replace("(want|wants|wanted)", "will want");
        return vb;
    }
};
const toFuture = function(vb, parsed, form) {
    // console.log(form)
    // is it already future-tense?
    if (vb.has("will") || vb.has("going to")) return vb;
    if (forms.hasOwnProperty(form)) {
        vb = forms[form](vb, parsed);
        vb.fullSentence().compute([
            "tagger",
            "chunks"
        ]);
        return vb;
    }
    return vb;
};
exports.default = toFuture;

},{"../lib.js":"3lpDA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jhSMy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("../lib.js");
const keep = {
    tags: true
};
// all verb forms are the same
const toGerund = function(vb, parsed) {
    // console.log(form)
    const { toInfinitive, conjugate } = vb.methods.two.transform.verb;
    const { root, auxiliary } = parsed;
    if (vb.has("#Gerund")) return vb;
    // conjugate '-ing' verb
    let str = root.text("normal");
    str = toInfinitive(str, vb.model, (0, _libJs.getTense)(root));
    let gerund = conjugate(str, vb.model).Gerund;
    // 'are walking', 'is walking'
    if (gerund) {
        let aux = (0, _libJs.isAreAm)(vb, parsed);
        vb.replace(root, gerund, keep);
        vb.remove(auxiliary);
        vb.prepend(aux) //.match(aux)
        ;
    }
    // remove any existing auxiliary
    // if (auxiliary.found) {
    // vb.match(auxiliary).debug()
    // vb.remove(auxiliary)
    // }
    vb.replace("not is", "is not");
    vb.replace("not are", "are not");
    vb.fullSentence().compute([
        "tagger",
        "chunks"
    ]);
    return vb;
};
exports.default = toGerund;

},{"../lib.js":"3lpDA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4TTfd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("../lib.js");
const keep = {
    tags: true
};
// do/does not walk 
const doesNot = function(vb, parsed) {
    let does = (0, _libJs.doDoes)(vb, parsed);
    vb.prepend(does + " not");
    return vb;
};
const isWas = function(vb) {
    // not be
    let m = vb.match("be");
    if (m.found) {
        m.prepend("not");
        return vb;
    }
    // will not
    m = vb.match("(is|was|am|are|will|were)");
    if (m.found) {
        m.append("not");
        return vb;
    }
    return vb;
};
const hasCopula = (vb)=>vb.has("(is|was|am|are|will|were|be)");
//vaguely, turn 'he is cool' into 'he is not cool'
const forms = {
    // he walks' -> 'he does not walk'
    "simple-present": (vb, parsed)=>{
        // is/was
        if (hasCopula(vb) === true) return isWas(vb, parsed);
        // he walk
        vb = (0, _libJs.toInf)(vb, parsed);
        // does not 
        vb = doesNot(vb, parsed);
        return vb;
    },
    // 'he walked' -> 'he did not walk'
    "simple-past": (vb, parsed)=>{
        // is/was
        if (hasCopula(vb) === true) return isWas(vb, parsed);
        // he walk
        vb = (0, _libJs.toInf)(vb, parsed);
        // vb.debug()
        // did not walk
        vb.prepend("did not");
        return vb;
    },
    // walk! -> 'do not walk'
    "imperative": (vb)=>{
        vb.prepend("do not");
        return vb;
    },
    // walk -> does not walk
    "infinitive": (vb, parsed)=>{
        if (hasCopula(vb) === true) return isWas(vb, parsed);
        return doesNot(vb, parsed);
    },
    "passive-past": (vb)=>{
        // got walked -> did not get walked
        if (vb.has("got")) {
            vb.replace("got", "get", keep);
            vb.prepend("did not");
            return vb;
        }
        // was walked, were walked
        // was being walked
        // had been walked, have been eaten
        let m = vb.match("(was|were|had|have)");
        if (m.found) m.append("not");
        return vb;
    },
    "auxiliary-past": (vb)=>{
        // used to walk
        if (vb.has("used")) {
            vb.prepend("did not");
            return vb;
        }
        // he did walk
        let m = vb.match("(did|does|do)");
        if (m.found) m.append("not");
        return vb;
    },
    // wants to walk
    "want-infinitive": (vb, parsed)=>{
        // does not 
        vb = doesNot(vb, parsed);
        // want
        vb = vb.replace("wants", "want", keep);
        return vb;
    }
};
const toNegative = function(vb, parsed, form) {
    // console.log(form)
    if (vb.has("#Negative")) return vb;
    if (forms.hasOwnProperty(form)) {
        vb = forms[form](vb, parsed);
        return vb;
    }
    // 'not be'
    let m = vb.matchOne("be");
    if (m.found) {
        m.prepend("not");
        return vb;
    }
    // is/was not
    if (hasCopula(vb) === true) return isWas(vb, parsed);
    // 'would not'
    m = vb.matchOne("(will|had|have|has|did|does|do|#Modal)");
    if (m.found) {
        m.append("not");
        return vb;
    }
    // do nothing i guess?
    return vb;
};
exports.default = toNegative;

},{"../lib.js":"3lpDA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jOABE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./compute/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _pronounsJs = require("./api/pronouns.js");
var _pronounsJsDefault = parcelHelpers.interopDefault(_pronounsJs);
exports.default = {
    compute: {
        coreference: (0, _indexJsDefault.default)
    },
    api: (0, _pronounsJsDefault.default)
};

},{"./compute/index.js":"gQjnx","./api/pronouns.js":"2PVaN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gQjnx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _findPersonJs = require("./findPerson.js");
var _findPersonJsDefault = parcelHelpers.interopDefault(_findPersonJs);
var _findTheyJs = require("./findThey.js");
var _findTheyJsDefault = parcelHelpers.interopDefault(_findTheyJs);
// import getIt from './findIt.js'
var _libJs = require("./lib.js");
const addReference = function(pron, m) {
    if (m && m.found) {
        // add reference on the pronoun
        let term = pron.docs[0][0] //pronouns are 1 word only
        ;
        term.reference = m.ptrs[0];
    }
};
const stepBack = function(m, cb) {
    // 1st - in same sentence
    let s = m.before();
    let res = cb(s);
    if (res.found) return res;
    // 2nd - previous sentence
    s = (0, _libJs.prevSentence)(m);
    res = cb(s);
    if (res.found) return res;
    // 3rd - two sentences back
    s = (0, _libJs.prevSentence)(s);
    res = cb(s);
    if (res.found) return res;
    return m.none();
};
const coreference = function(view) {
    let pronouns = view.pronouns().if("(he|him|his|she|her|hers|they|their|theirs|it|its)");
    pronouns.forEach((pron)=>{
        let res = null;
        // connect pronoun to its reference
        if (pron.has("(he|him|his)")) res = stepBack(pron, (m)=>(0, _findPersonJsDefault.default)(m, "m"));
        else if (pron.has("(she|her|hers)")) res = stepBack(pron, (m)=>(0, _findPersonJsDefault.default)(m, "f"));
        else if (pron.has("(they|their|theirs)")) res = stepBack(pron, (0, _findTheyJsDefault.default));
        if (res && res.found) addReference(pron, res);
    });
};
exports.default = coreference;

},{"./findPerson.js":"7WBHD","./findThey.js":"iDaKN","./lib.js":"7P0db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7WBHD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("./lib.js");
// only filter if we know a gender
// ambiguous names like 'jamie smith' will refer to either he or she
const byGender = function(ppl, gender) {
    if (gender === "m") return ppl.filter((m)=>!m.presumedFemale().found);
    else if (gender === "f") return ppl.filter((m)=>!m.presumedMale().found);
    return ppl;
};
const getPerson = function(s, gender) {
    // look at current sentence
    let people = s.people();
    people = byGender(people, gender);
    if (people.found) return people.last();
    // non-named people, like 'the cowboy'
    people = s.nouns("#Actor");
    if (people.found) return people.last();
    // existing pronouns
    if (gender === "f") return (0, _libJs.findChained)("(she|her|hers)", s);
    if (gender === "m") return (0, _libJs.findChained)("(he|him|his)", s);
    return s.none();
};
exports.default = getPerson;

},{"./lib.js":"7P0db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7P0db":[function(require,module,exports) {
// borrow a reference from another pronoun
// 'mike is tall, [he] climbs and [he] swims'
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "prevSentence", ()=>prevSentence);
parcelHelpers.export(exports, "findChained", ()=>findChained);
const findChained = function(want, s) {
    let m = s.match(want);
    if (m.found) {
        let ref = m.pronouns().refersTo();
        if (ref.found) return ref;
    }
    return s.none();
};
const prevSentence = function(m) {
    if (!m.found) return m;
    let [n] = m.fullPointer[0];
    if (n && n > 0) return m.update([
        [
            n - 1
        ]
    ]);
    return m.none();
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iDaKN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _libJs = require("./lib.js");
// find best reference for 'they' & 'their'
const getThey = function(s) {
    let nouns = s.nouns();
    // 'the bananas'
    let things = nouns.isPlural().notIf("#Pronoun");
    if (things.found) return things.last();
    // re-use existing pronoun reference
    let chain = (0, _libJs.findChained)("(they|their|theirs)", s);
    if (chain.found) return chain;
    // they can also refer to a singular noun
    // "the restaurant sold their food"
    // "a choir sang their song"
    // somebody shaved their head
    things = nouns.match("(somebody|nobody|everybody|anybody|someone|noone|everyone|anyone)");
    if (things.found) return things.last();
    return s.none();
};
exports.default = getThey;

},{"./lib.js":"7P0db","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2PVaN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const api = function(View) {
    class Pronouns extends View {
        constructor(document, pointer, groups){
            super(document, pointer, groups);
            this.viewType = "Pronouns";
        }
        hasReference() {
            this.compute("coreference");
            return this.filter((m)=>{
                let term = m.docs[0][0];
                return term.reference;
            });
        }
        // get the noun-phrase this pronoun refers to
        refersTo() {
            //calculate links
            this.compute("coreference");
            // return them
            return this.map((m)=>{
                if (!m.found) return m.none();
                let term = m.docs[0][0];
                if (term.reference) return m.update([
                    term.reference
                ]);
                return m.none();
            });
        }
        // overloaded - keep Numbers class
        update(pointer) {
            let m = new Pronouns(this.document, pointer);
            m._cache = this._cache // share this full thing
            ;
            return m;
        }
    }
    View.prototype.pronouns = function(n) {
        let m = this.match("#Pronoun");
        m = m.getNth(n);
        return new Pronouns(m.document, m.pointer);
    };
};
exports.default = api;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["4FFYD","dV6cC"], "dV6cC", "parcelRequirebbde")

//# sourceMappingURL=index.e82f28a0.js.map
